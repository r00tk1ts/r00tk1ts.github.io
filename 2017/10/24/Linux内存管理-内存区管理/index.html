

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="r00tk1t">
  <meta name="keywords" content="">
  
    <meta name="description" content="阅读内存区管理之前，需要先掌握页框管理机制。优先阅读《Linux内核学习——内存管理之页框管理》。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核学习——内存管理之内存区管理">
<meta property="og:url" content="https://r00tk1ts.github.io/2017/10/24/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="玉涵的技能书">
<meta property="og:description" content="阅读内存区管理之前，需要先掌握页框管理机制。优先阅读《Linux内核学习——内存管理之页框管理》。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/10/24/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/20171024_1.jpg">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/10/24/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/20171024_2.jpg">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/10/24/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/20171024_3.jpg">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/10/24/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/20171024_4.jpg">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/10/24/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/20171024_5.jpg">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/10/24/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/20171024_6.jpg">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/10/24/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/20171024_5.jpg">
<meta property="article:published_time" content="2017-10-24T11:37:11.000Z">
<meta property="article:modified_time" content="2024-04-22T03:34:00.155Z">
<meta property="article:author" content="r00tk1t">
<meta property="article:tag" content="linux-kernel">
<meta property="article:tag" content="ulk">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://r00tk1ts.github.io/2017/10/24/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/20171024_1.jpg">
  
  
  
  <title>Linux内核学习——内存管理之内存区管理 - 玉涵的技能书</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"r00tk1ts.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>玉涵的技能书</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/doc/">
                <i class="iconfont icon-books"></i>
                <span>藏经阁</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Linux内核学习——内存管理之内存区管理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2017-10-24 19:37" pubdate>
          2017年10月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          45k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          375 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Linux内核学习——内存管理之内存区管理</h1>
            
            
              <div class="markdown-body">
                
                <p>阅读内存区管理之前，需要先掌握页框管理机制。优先阅读《Linux内核学习——内存管理之页框管理》。</p>
<span id="more"></span>
<h1 id="linux内存管理内存区管理">Linux内存管理——内存区管理</h1>
<p>buddy system以page
frame作为单位，这适合大块内存的请求，对于小请求来说，如果每次对几十字节的请求都分配一个page
frame显然是极大的浪费。Linux当然需要一套机制来管理每个页框的详细内存分配。</p>
<h2 id="slab-allocator-design">Slab Allocator Design</h2>
<p>源于Solaris
2.4的一种设计，ULK给的定义非常晕，实际上只需要一张图即可搞清楚设计的架构。详细的情况需要看源码。</p>
<p><img src="20171024_1.jpg" srcset="/img/loading.gif" lazyload /></p>
<p>cache和slab的关系： <img src="20171024_2.jpg" srcset="/img/loading.gif" lazyload /></p>
<p>每个cache都包含三个slabs列表，这是一段连续的内存块。存在3种slab：
full：完全分配的slab partial：部分分配的slab
free:空slab，对象没被分配</p>
<p>slab列表中的每个slab都是一个连续的内存块，它们被划分成一个个分类的对象。slab是slab分配器操作的最小分配单位，通常情况，一个slab被分配成多个对象。</p>
<p>深入探索三个列表的工作机理前，先看看它们的描述符结构定义。</p>
<h3 id="cache描述符">Cache描述符</h3>
<p><code>kmem_cache_s</code>就是cache的描述符结构： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 高速缓存描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">kmem_cache_s</span> &#123;<br><span class="hljs-comment">/* 1) per-cpu data, touched during every alloc/free */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 每CPU指针数组，指向包含空闲对象的本地高速缓存。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span>	*array[NR_CPUS];<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 要转移进本地高速缓存或从本地高速缓存中转移出的大批对象的数量。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		batchcount;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 本地高速缓存中空闲对象的最大数目。这个参数可调。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		limit;<br><span class="hljs-comment">/* 2) touched by every alloc &amp; free from the backend */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 包含三个链表，为什么要单独放到一个描述符中呢?</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">kmem_list3</span>	lists;<br>	<span class="hljs-comment">/* NUMA: kmem_3list_t	*nodelists[MAX_NUMNODES] */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 高速缓存中包含的对象的大小。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		objsize;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 描述高速缓存永久属性的一组标志。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>	 	flags;	<span class="hljs-comment">/* constant flags */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 在一个单独slab中的对象的个数。高速缓存中的所有slab具有相同的大小。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		num;	<span class="hljs-comment">/* # of objs per slab */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 整个slab高速缓存中空闲对象的上限。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		free_limit; <span class="hljs-comment">/* upper limit of objects in the lists */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 高速缓存自旋锁。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">spinlock_t</span>		spinlock;<br><br><span class="hljs-comment">/* 3) cache_grow/shrink */</span><br>	<span class="hljs-comment">/* order of pgs per slab (2^n) */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 一个单独slab中包含的连续页框数目的对数。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		gfporder;<br><br>	<span class="hljs-comment">/* force GFP flags, e.g. GFP_DMA */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 分配页框时传递给伙伴系统函数的一组标志。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		gfpflags;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * slab使用的颜色个数。用于slab着色。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">size_t</span>			colour;		<span class="hljs-comment">/* cache colouring range */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * slab中的基本对齐偏移。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		colour_off;	<span class="hljs-comment">/* colour offset */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 下一个被分配的slab使用的颜色。就是对齐因子。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		colour_next;	<span class="hljs-comment">/* cache colouring */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 指向包含slab描述符的普通slab高速缓存。如果使用了内部slab描述符，则这个字段为NULL。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">kmem_cache_t</span>		*slabp_cache;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 单个slab的大小。</span><br><span class="hljs-comment">	 * slab_size = slab描述符大小 + 所有对象描述符大小 + pading</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		slab_size;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 高速缓存动态属性标志。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		dflags;		<span class="hljs-comment">/* dynamic flags */</span><br><br>	<span class="hljs-comment">/* constructor func */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 高速缓存相关的构造方法的指针。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">void</span> (*ctor)(<span class="hljs-type">void</span> *, <span class="hljs-type">kmem_cache_t</span> *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><br>	<span class="hljs-comment">/* de-constructor func */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 高速缓存相关的析构方法的指针。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">void</span> (*dtor)(<span class="hljs-type">void</span> *, <span class="hljs-type">kmem_cache_t</span> *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><br><span class="hljs-comment">/* 4) cache creation/removal */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 高速缓存名称。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>		*name;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 高速缓存链表。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>	next;<br><br><span class="hljs-comment">/* 5) statistics */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> STATS</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 统计信息</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		num_active;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		num_allocations;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		high_mark;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		grown;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		reaped;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> 		errors;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		max_freeable;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		node_allocs;<br>	<span class="hljs-type">atomic_t</span>		allochit;<br>	<span class="hljs-type">atomic_t</span>		allocmiss;<br>	<span class="hljs-type">atomic_t</span>		freehit;<br>	<span class="hljs-type">atomic_t</span>		freemiss;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 调试信息</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span>			dbghead;<br>	<span class="hljs-type">int</span>			reallen;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>
通过next成员组成kmem_cache链，链的作用是配合查找best-fit大小的缓存。
高速缓存描述符指针数组array展开： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 空闲对象的本地高速缓存描述符（注意：是描述符而不是本地高速缓存本身，本地高速缓存在描述符后面）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> &#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 指向本地高速缓存中可使用对象的指针的个数。</span><br><span class="hljs-comment">	 * 它同时也作为高速缓存中第一个空槽的下标。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> avail;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 本地高速缓存的大小，也就是本地高速缓存中指针的最大个数</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> limit;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 本地高速缓存重新填充或者腾空时使用的块大小</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> batchcount;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果最近被使用过，则置为1</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> touched;<br>&#125;;<br></code></pre></td></tr></table></figure>
lists就是三个slab链表，分别是不包含空闲对象的slab描述符链，只包含空闲对象的slab描述符链和包含空闲和费空闲对象的slab描述符链：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * slab高速缓存描述符内嵌结构</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">kmem_list3</span> &#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 空闲和非空闲对象的slab描述符双向循环链表。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>	slabs_partial;	<span class="hljs-comment">/* partial list first, better asm code */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 不包含空闲对象的slab描述符双向循环链表。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>	slabs_full;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 只包含空闲对象的slab描述符双向循环链表。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>	slabs_free;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	free_objects;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * slab分配器的页回收算法使用。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span>		free_touched;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * slab分配器的页回收算法使用。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	next_reap;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 所有CPU共享的一个本地高速缓存的指针。它使得将空闲对象从一个本地高速缓存移动到另外一个高速缓存的任务更容易。</span><br><span class="hljs-comment">	 * 它的初始大小是batchcount字段的8倍。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span>	*shared;<br>&#125;;<br></code></pre></td></tr></table></figure>
free链的slab是进行回收的主要备选对象。通过此过程，slab使用的内存被返回给OS。</p>
<p>对象都是在slab中进行分配释放的，单个slab可以在slab列表之间移动。比如当一个slab中所有对象都被用完时，就从partial链移动到full链；当一个slab完全被分配并且有对象被释放后，就从full链移动到partial链。在看完slab描述符后，会有一张图用于梳理工作逻辑与结构关系。</p>
<h3 id="slab描述符">slab描述符</h3>
<p>高速缓存中的每个slab都由自己的类型为slab的描述符： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * slab描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span> &#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * slab高速缓存描述符的三个双向循环链表中的一个。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>	list;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * slab中第一个对象的偏移。</span><br><span class="hljs-comment">	 * 同一个高速缓存的不同slab有不同的coloroff值。这样可以避免硬件缓存行的不利影响。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		colouroff;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * slab中第一个对象的地址。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span>			*s_mem;		<span class="hljs-comment">/* including colour offset */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 当前正在使用的slab中的对象个数。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		inuse;		<span class="hljs-comment">/* num of objs active in slab */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * slab中下一个空闲对象的下标。如果没有剩下空闲对象则为BUFCT_END</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">kmem_bufctl_t</span>		free;<br>&#125;;<br></code></pre></td></tr></table></figure>
slab描述符可以放在两个地方： -
放在slab外部，位于cache_sizes指向的一个不适合ISA
DMA的普通高速缓存中。此时高速缓存描述符的flags字段中<code>CFLGS_OFF_SLAB</code>置1。
-
放在slab内部，位于分配给slab的第一个页框的起始位置。当对象小于512MB，或者当内部碎片为slab描述符和对象描述符在slab中留下足够空间时，slab描述符放在内部。</p>
<p>ULK上cache描述符与slab描述符的关联： <img src="20171024_3.jpg" srcset="/img/loading.gif" lazyload /></p>
<p>三种slab链的工作机理： <img src="20171024_4.jpg" srcset="/img/loading.gif" lazyload /></p>
<p>slab的内部结构平坦视图： <img src="20171024_5.jpg" srcset="/img/loading.gif" lazyload /></p>
<p>关于着色相关，后面再详述。</p>
<h3 id="普通和专用高速缓存">普通和专用高速缓存</h3>
<p>高速缓存的两种类型。普通只由slab分配器用于自己的目的，专用则由内核其余部分使用。</p>
<p>普通高速缓存： 1.
第一个高速缓存是kmem_cache，包含由内核使用的其余高速缓存的高速缓存描述符。cache_cache变量包含第一个高速缓存的描述符。
2.
另外一些高速缓存包含用作普通用途的内存区。内存区大小的范围一般包括13个几何分布的内存区。一个叫做malloc_sizes的表分别指向26个高速缓存描述符，相关的内存区大小为32，64，128，256，512，1024，2048，4096，8192，16384，32768，65536，131072字节。对每种大小，都有两个高速缓存：一个适用于ISA
DMA分配，一个用于常规分配。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第一个普通高速缓存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">kmem_cache_t</span> cache_cache = &#123;<br>	.lists		= <span class="hljs-built_in">LIST3_INIT</span>(cache_cache.lists),<br>	.batchcount	= <span class="hljs-number">1</span>,<br>	.limit		= BOOT_CPUCACHE_ENTRIES,<br>	.objsize	= <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_cache_t</span>),<br>	.flags		= SLAB_NO_REAP,<br>	.spinlock	= SPIN_LOCK_UNLOCKED,<br>	.name		= <span class="hljs-string">&quot;kmem_cache&quot;</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>	.reallen	= <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_cache_t</span>),<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向26个高速缓存描述符的表。</span><br><span class="hljs-comment"> * 与其相关的内存区大小为32,64,128,256,512,1024,4096,8192,32768,131072个字节。</span><br><span class="hljs-comment"> * 对于每种大小，都有两个高速缓存：一个适用于ISA DMA分配，一个适用于常规分配。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cache_sizes</span> malloc_sizes[] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CACHE(x) &#123; .cs_size = (x) &#125;,</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kmalloc_sizes.h&gt;</span></span><br>	&#123; <span class="hljs-number">0</span>, &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> CACHE</span><br>&#125;;<br><br><span class="hljs-comment">/* Size description struct for general caches. */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cache_sizes</span> &#123;<br>	<span class="hljs-type">size_t</span>		 cs_size;<br>	<span class="hljs-type">kmem_cache_t</span>	*cs_cachep;<br>	<span class="hljs-type">kmem_cache_t</span>	*cs_dmacachep;<br>&#125;;<br></code></pre></td></tr></table></figure></p>
<p>普通高速缓存的初始化建立： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 建立普通高速缓存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> __init <span class="hljs-title">kmem_cache_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">size_t</span> left_over;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">cache_sizes</span> *sizes;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">cache_names</span> *names;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Fragmentation resistance on low memory - only use bigger</span><br><span class="hljs-comment">	 * page orders on machines with more than 32MB of memory.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (num_physpages &gt; (<span class="hljs-number">32</span> &lt;&lt; <span class="hljs-number">20</span>) &gt;&gt; PAGE_SHIFT)<br>		slab_break_gfp_order = BREAK_GFP_ORDER_HI;<br><br>	<br>	<span class="hljs-comment">/* Bootstrap is tricky, because several objects are allocated</span><br><span class="hljs-comment">	 * from caches that do not exist yet:</span><br><span class="hljs-comment">	 * 1) initialize the cache_cache cache: it contains the kmem_cache_t</span><br><span class="hljs-comment">	 *    structures of all caches, except cache_cache itself: cache_cache</span><br><span class="hljs-comment">	 *    is statically allocated.</span><br><span class="hljs-comment">	 *    Initially an __init data area is used for the head array, it&#x27;s</span><br><span class="hljs-comment">	 *    replaced with a kmalloc allocated array at the end of the bootstrap.</span><br><span class="hljs-comment">	 * 2) Create the first kmalloc cache.</span><br><span class="hljs-comment">	 *    The kmem_cache_t for the new cache is allocated normally. An __init</span><br><span class="hljs-comment">	 *    data area is used for the head array.</span><br><span class="hljs-comment">	 * 3) Create the remaining kmalloc caches, with minimally sized head arrays.</span><br><span class="hljs-comment">	 * 4) Replace the __init data head arrays for cache_cache and the first</span><br><span class="hljs-comment">	 *    kmalloc cache with kmalloc allocated arrays.</span><br><span class="hljs-comment">	 * 5) Resize the head arrays of the kmalloc caches to their final sizes.</span><br><span class="hljs-comment">	 */</span><br><br>	<span class="hljs-comment">/* 1) create the cache_cache */</span><br>	<span class="hljs-built_in">init_MUTEX</span>(&amp;cache_chain_sem);<br>	<span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;cache_chain);<br>	<span class="hljs-built_in">list_add</span>(&amp;cache_cache.next, &amp;cache_chain);<br>	cache_cache.colour_off = <span class="hljs-built_in">cache_line_size</span>();<br>	cache_cache.array[<span class="hljs-built_in">smp_processor_id</span>()] = &amp;initarray_cache.cache;<br><br>	cache_cache.objsize = <span class="hljs-built_in">ALIGN</span>(cache_cache.objsize, <span class="hljs-built_in">cache_line_size</span>());<br><br>	<span class="hljs-built_in">cache_estimate</span>(<span class="hljs-number">0</span>, cache_cache.objsize, <span class="hljs-built_in">cache_line_size</span>(), <span class="hljs-number">0</span>,<br>				&amp;left_over, &amp;cache_cache.num);<br>	<span class="hljs-keyword">if</span> (!cache_cache.num)<br>		<span class="hljs-built_in">BUG</span>();<br><br>	cache_cache.colour = left_over/cache_cache.colour_off;<br>	cache_cache.colour_next = <span class="hljs-number">0</span>;<br>	cache_cache.slab_size = <span class="hljs-built_in">ALIGN</span>(cache_cache.num*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_bufctl_t</span>) +<br>				<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> slab), <span class="hljs-built_in">cache_line_size</span>());<br><br>	<span class="hljs-comment">/* 2+3) create the kmalloc caches */</span><br>	sizes = malloc_sizes;<br>	names = cache_names;<br><br>	<span class="hljs-keyword">while</span> (sizes-&gt;cs_size) &#123;<br>		<span class="hljs-comment">/* For performance, all the general caches are L1 aligned.</span><br><span class="hljs-comment">		 * This should be particularly beneficial on SMP boxes, as it</span><br><span class="hljs-comment">		 * eliminates &quot;false sharing&quot;.</span><br><span class="hljs-comment">		 * Note for systems short on memory removing the alignment will</span><br><span class="hljs-comment">		 * allow tighter packing of the smaller caches. */</span><br>		sizes-&gt;cs_cachep = <span class="hljs-built_in">kmem_cache_create</span>(names-&gt;name,<br>			sizes-&gt;cs_size, ARCH_KMALLOC_MINALIGN,<br>			(ARCH_KMALLOC_FLAGS | SLAB_PANIC), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>		<span class="hljs-comment">/* Inc off-slab bufctl limit until the ceiling is hit. */</span><br>		<span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">OFF_SLAB</span>(sizes-&gt;cs_cachep))) &#123;<br>			offslab_limit = sizes-&gt;cs_size-<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> slab);<br>			offslab_limit /= <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_bufctl_t</span>);<br>		&#125;<br><br>		sizes-&gt;cs_dmacachep = <span class="hljs-built_in">kmem_cache_create</span>(names-&gt;name_dma,<br>			sizes-&gt;cs_size, ARCH_KMALLOC_MINALIGN,<br>			(ARCH_KMALLOC_FLAGS | SLAB_CACHE_DMA | SLAB_PANIC),<br>			<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>		sizes++;<br>		names++;<br>	&#125;<br>	<span class="hljs-comment">/* 4) Replace the bootstrap head arrays */</span><br>	&#123;<br>		<span class="hljs-type">void</span> * ptr;<br>		<br>		ptr = <span class="hljs-built_in">kmalloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> arraycache_init), GFP_KERNEL);<br>		<span class="hljs-built_in">local_irq_disable</span>();<br>		<span class="hljs-built_in">BUG_ON</span>(<span class="hljs-built_in">ac_data</span>(&amp;cache_cache) != &amp;initarray_cache.cache);<br>		<span class="hljs-built_in">memcpy</span>(ptr, <span class="hljs-built_in">ac_data</span>(&amp;cache_cache), <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> arraycache_init));<br>		cache_cache.array[<span class="hljs-built_in">smp_processor_id</span>()] = ptr;<br>		<span class="hljs-built_in">local_irq_enable</span>();<br>	<br>		ptr = <span class="hljs-built_in">kmalloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> arraycache_init), GFP_KERNEL);<br>		<span class="hljs-built_in">local_irq_disable</span>();<br>		<span class="hljs-built_in">BUG_ON</span>(<span class="hljs-built_in">ac_data</span>(malloc_sizes[<span class="hljs-number">0</span>].cs_cachep) != &amp;initarray_generic.cache);<br>		<span class="hljs-built_in">memcpy</span>(ptr, <span class="hljs-built_in">ac_data</span>(malloc_sizes[<span class="hljs-number">0</span>].cs_cachep),<br>				<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> arraycache_init));<br>		malloc_sizes[<span class="hljs-number">0</span>].cs_cachep-&gt;array[<span class="hljs-built_in">smp_processor_id</span>()] = ptr;<br>		<span class="hljs-built_in">local_irq_enable</span>();<br>	&#125;<br><br>	<span class="hljs-comment">/* 5) resize the head arrays to their final sizes */</span><br>	&#123;<br>		<span class="hljs-type">kmem_cache_t</span> *cachep;<br>		<span class="hljs-built_in">down</span>(&amp;cache_chain_sem);<br>		<span class="hljs-built_in">list_for_each_entry</span>(cachep, &amp;cache_chain, next)<br>			<span class="hljs-built_in">enable_cpucache</span>(cachep);<br>		<span class="hljs-built_in">up</span>(&amp;cache_chain_sem);<br>	&#125;<br><br>	<span class="hljs-comment">/* Done! */</span><br>	g_cpucache_up = FULL;<br><br>	<span class="hljs-comment">/* Register a cpu startup notifier callback</span><br><span class="hljs-comment">	 * that initializes ac_data for all new cpus</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">register_cpu_notifier</span>(&amp;cpucache_notifier);<br>	<br><br>	<span class="hljs-comment">/* The reap timers are started later, with a module init call:</span><br><span class="hljs-comment">	 * That part of the kernel is not yet operational.</span><br><span class="hljs-comment">	 */</span><br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>专用高速缓存创建： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 建立专用高速缓存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">kmem_cache_t</span> *</span><br><span class="hljs-function"><span class="hljs-title">kmem_cache_create</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> align,</span></span><br><span class="hljs-params"><span class="hljs-function">	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span>*, <span class="hljs-type">kmem_cache_t</span> *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">	<span class="hljs-type">void</span> (*dtor)(<span class="hljs-type">void</span>*, <span class="hljs-type">kmem_cache_t</span> *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>))</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">size_t</span> left_over, slab_size, ralign;<br>	<span class="hljs-type">kmem_cache_t</span> *cachep = <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Sanity checks... these are all serious usage bugs.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> ((!name) ||<br>		<span class="hljs-built_in">in_interrupt</span>() ||<br>		(size &lt; BYTES_PER_WORD) ||<br>		(size &gt; (<span class="hljs-number">1</span>&lt;&lt;MAX_OBJ_ORDER)*PAGE_SIZE) ||<br>		(dtor &amp;&amp; !ctor)) &#123;<br>			<span class="hljs-built_in">printk</span>(KERN_ERR <span class="hljs-string">&quot;%s: Early error in slab %s\n&quot;</span>,<br>					__FUNCTION__, name);<br>			<span class="hljs-built_in">BUG</span>();<br>		&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>	<span class="hljs-built_in">WARN_ON</span>(<span class="hljs-built_in">strchr</span>(name, <span class="hljs-string">&#x27; &#x27;</span>));	<span class="hljs-comment">/* It confuses parsers */</span><br>	<span class="hljs-keyword">if</span> ((flags &amp; SLAB_DEBUG_INITIAL) &amp;&amp; !ctor) &#123;<br>		<span class="hljs-comment">/* No constructor, but inital state check requested */</span><br>		<span class="hljs-built_in">printk</span>(KERN_ERR <span class="hljs-string">&quot;%s: No con, but init state check &quot;</span><br>				<span class="hljs-string">&quot;requested - %s\n&quot;</span>, __FUNCTION__, name);<br>		flags &amp;= ~SLAB_DEBUG_INITIAL;<br>	&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FORCED_DEBUG</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Enable redzoning and last user accounting, except for caches with</span><br><span class="hljs-comment">	 * large objects, if the increased size would increase the object size</span><br><span class="hljs-comment">	 * above the next power of two: caches with object sizes just above a</span><br><span class="hljs-comment">	 * power of two have a significant amount of internal fragmentation.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 根据参数确定高速缓存的最佳方法(是内部还是外部slab描述符。)</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> ((size &lt; <span class="hljs-number">4096</span> || <span class="hljs-built_in">fls</span>(size<span class="hljs-number">-1</span>) == <span class="hljs-built_in">fls</span>(size<span class="hljs-number">-1</span>+<span class="hljs-number">3</span>*BYTES_PER_WORD)))<br>		flags |= SLAB_RED_ZONE|SLAB_STORE_USER;<br>	<span class="hljs-keyword">if</span> (!(flags &amp; SLAB_DESTROY_BY_RCU))<br>		flags |= SLAB_POISON;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-keyword">if</span> (flags &amp; SLAB_DESTROY_BY_RCU)<br>		<span class="hljs-built_in">BUG_ON</span>(flags &amp; SLAB_POISON);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-keyword">if</span> (flags &amp; SLAB_DESTROY_BY_RCU)<br>		<span class="hljs-built_in">BUG_ON</span>(dtor);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Always checks flags, a caller might be expecting debug</span><br><span class="hljs-comment">	 * support which isn&#x27;t available.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (flags &amp; ~CREATE_MASK)<br>		<span class="hljs-built_in">BUG</span>();<br><br>	<span class="hljs-comment">/* Check that size is in terms of words.  This is needed to avoid</span><br><span class="hljs-comment">	 * unaligned accesses for some archs when redzoning is used, and makes</span><br><span class="hljs-comment">	 * sure any on-slab bufctl&#x27;s are also correctly aligned.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (size &amp; (BYTES_PER_WORD<span class="hljs-number">-1</span>)) &#123;<br>		size += (BYTES_PER_WORD<span class="hljs-number">-1</span>);<br>		size &amp;= ~(BYTES_PER_WORD<span class="hljs-number">-1</span>);<br>	&#125;<br><br>	<span class="hljs-comment">/* calculate out the final buffer alignment: */</span><br>	<span class="hljs-comment">/* 1) arch recommendation: can be overridden for debug */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 需要考虑硬件缓存行。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (flags &amp; SLAB_HWCACHE_ALIGN) &#123;<br>		<span class="hljs-comment">/* Default alignment: as specified by the arch code.</span><br><span class="hljs-comment">		 * Except if an object is really small, then squeeze multiple</span><br><span class="hljs-comment">		 * objects into one cacheline.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 如果高速缓存对象的大小大于高速缓存行ralign的一半，</span><br><span class="hljs-comment">		 * 就在RAM中根据L1_CACHE_BYTES的倍数对齐对象。</span><br><span class="hljs-comment">		 *</span><br><span class="hljs-comment">		 * lf: 很好理解，大于cacheline，一半，就按照整个cacheline对其; 小于一半，一个cacheline至少可以放两个，以cacheline的一半对其</span><br><span class="hljs-comment">		 */</span><br>		ralign = <span class="hljs-built_in">cache_line_size</span>();<br>		<span class="hljs-keyword">while</span> (size &lt;= ralign/<span class="hljs-number">2</span>)<br>			ralign /= <span class="hljs-number">2</span>;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		ralign = BYTES_PER_WORD;<br>	&#125;<br>	<span class="hljs-comment">/* 2) arch mandated alignment: disables debug if necessary */</span><br>	<span class="hljs-keyword">if</span> (ralign &lt; ARCH_SLAB_MINALIGN) &#123;<br>		ralign = ARCH_SLAB_MINALIGN;<br>		<span class="hljs-keyword">if</span> (ralign &gt; BYTES_PER_WORD)<br>			flags &amp;= ~(SLAB_RED_ZONE|SLAB_STORE_USER);<br>	&#125;<br>	<span class="hljs-comment">/* 3) caller mandated alignment: disables debug if necessary */</span><br>	<span class="hljs-keyword">if</span> (ralign &lt; align) &#123;<br>		ralign = align;<br>		<span class="hljs-keyword">if</span> (ralign &gt; BYTES_PER_WORD)<br>			flags &amp;= ~(SLAB_RED_ZONE|SLAB_STORE_USER);<br>	&#125;<br>	<span class="hljs-comment">/* 4) Store it. Note that the debug code below can reduce</span><br><span class="hljs-comment">	 *    the alignment to BYTES_PER_WORD.</span><br><span class="hljs-comment">	 */</span><br>	align = ralign;<br><br>	<span class="hljs-comment">/* Get cache&#x27;s description obj. */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 从cache_cache普通高速缓存中为新的高速缓存分配一个高速缓存描述符。</span><br><span class="hljs-comment">	 * 并把这个描述符插入到高速缓存描述符的cache_chain链表中。</span><br><span class="hljs-comment">	 */</span><br>	cachep = (<span class="hljs-type">kmem_cache_t</span> *) <span class="hljs-built_in">kmem_cache_alloc</span>(&amp;cache_cache, SLAB_KERNEL);<br>	<span class="hljs-keyword">if</span> (!cachep)<br>		<span class="hljs-keyword">goto</span> opps;<br>	<span class="hljs-built_in">memset</span>(cachep, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_cache_t</span>));<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>	cachep-&gt;reallen = size;<br><br>	<span class="hljs-keyword">if</span> (flags &amp; SLAB_RED_ZONE) &#123;<br>		<span class="hljs-comment">/* redzoning only works with word aligned caches */</span><br>		align = BYTES_PER_WORD;<br><br>		<span class="hljs-comment">/* add space for red zone words */</span><br>		cachep-&gt;dbghead += BYTES_PER_WORD;<br>		size += <span class="hljs-number">2</span>*BYTES_PER_WORD;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (flags &amp; SLAB_STORE_USER) &#123;<br>		<span class="hljs-comment">/* user store requires word alignment and</span><br><span class="hljs-comment">		 * one word storage behind the end of the real</span><br><span class="hljs-comment">		 * object.</span><br><span class="hljs-comment">		 */</span><br>		align = BYTES_PER_WORD;<br>		size += BYTES_PER_WORD;<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FORCED_DEBUG &amp;&amp; defined(CONFIG_DEBUG_PAGEALLOC)</span><br>	<span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">128</span> &amp;&amp; cachep-&gt;reallen &gt; <span class="hljs-built_in">cache_line_size</span>() &amp;&amp; size &lt; PAGE_SIZE) &#123;<br>		cachep-&gt;dbghead += PAGE_SIZE - size;<br>		size = PAGE_SIZE;<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	<span class="hljs-comment">/* Determine if the slab management is &#x27;on&#x27; or &#x27;off&#x27; slab. */</span><br>	<span class="hljs-keyword">if</span> (size &gt;= (PAGE_SIZE&gt;&gt;<span class="hljs-number">3</span>))<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Size is large, assume best to place the slab management obj</span><br><span class="hljs-comment">		 * off-slab (should allow better packing of objs).</span><br><span class="hljs-comment">		 */</span><br>		flags |= CFLGS_OFF_SLAB;<br><br>	size = <span class="hljs-built_in">ALIGN</span>(size, align);<br><br>	<span class="hljs-keyword">if</span> ((flags &amp; SLAB_RECLAIM_ACCOUNT) &amp;&amp; size &lt;= PAGE_SIZE) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * A VFS-reclaimable slab tends to have most allocations</span><br><span class="hljs-comment">		 * as GFP_NOFS and we really don&#x27;t want to have to be allocating</span><br><span class="hljs-comment">		 * higher-order pages when we are unable to shrink dcache.</span><br><span class="hljs-comment">		 */</span><br>		cachep-&gt;gfporder = <span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">cache_estimate</span>(cachep-&gt;gfporder, size, align, flags,<br>					&amp;left_over, &amp;cachep-&gt;num);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Calculate size (in pages) of slabs, and the num of objs per</span><br><span class="hljs-comment">		 * slab.  This could be made much more intelligent.  For now,</span><br><span class="hljs-comment">		 * try to avoid using high page-orders for slabs.  When the</span><br><span class="hljs-comment">		 * gfp() funcs are more friendly towards high-order requests,</span><br><span class="hljs-comment">		 * this should be changed.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">do</span> &#123;<br>			<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> break_flag = <span class="hljs-number">0</span>;<br>cal_wastage:<br>			<span class="hljs-built_in">cache_estimate</span>(cachep-&gt;gfporder, size, align, flags,<br>						&amp;left_over, &amp;cachep-&gt;num);<br>			<span class="hljs-keyword">if</span> (break_flag)<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">if</span> (cachep-&gt;gfporder &gt;= MAX_GFP_ORDER)<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">if</span> (!cachep-&gt;num)<br>				<span class="hljs-keyword">goto</span> next;<br>			<span class="hljs-keyword">if</span> (flags &amp; CFLGS_OFF_SLAB &amp;&amp;<br>					cachep-&gt;num &gt; offslab_limit) &#123;<br>				<span class="hljs-comment">/* This num of objs will cause problems. */</span><br>				cachep-&gt;gfporder--;<br>				break_flag++;<br>				<span class="hljs-keyword">goto</span> cal_wastage;<br>			&#125;<br><br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * Large num of objs is good, but v. large slabs are</span><br><span class="hljs-comment">			 * currently bad for the gfp()s.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-keyword">if</span> (cachep-&gt;gfporder &gt;= slab_break_gfp_order)<br>				<span class="hljs-keyword">break</span>;<br><br>			<span class="hljs-keyword">if</span> ((left_over*<span class="hljs-number">8</span>) &lt;= (PAGE_SIZE&lt;&lt;cachep-&gt;gfporder))<br>				<span class="hljs-keyword">break</span>;	<span class="hljs-comment">/* Acceptable internal fragmentation. */</span><br>next:<br>			cachep-&gt;gfporder++;<br>		&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (!cachep-&gt;num) &#123;<br>		<span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;kmem_cache_create: couldn&#x27;t create cache %s.\n&quot;</span>, name);<br>		<span class="hljs-built_in">kmem_cache_free</span>(&amp;cache_cache, cachep);<br>		cachep = <span class="hljs-literal">NULL</span>;<br>		<span class="hljs-keyword">goto</span> opps;<br>	&#125;<br>	slab_size = <span class="hljs-built_in">ALIGN</span>(cachep-&gt;num*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_bufctl_t</span>)<br>				+ <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> slab), align);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * If the slab has been placed off-slab, and we have enough space then</span><br><span class="hljs-comment">	 * move it on-slab. This is at the expense of any extra colouring.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (flags &amp; CFLGS_OFF_SLAB &amp;&amp; left_over &gt;= slab_size) &#123;<br>		flags &amp;= ~CFLGS_OFF_SLAB;<br>		left_over -= slab_size;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (flags &amp; CFLGS_OFF_SLAB) &#123;<br>		<span class="hljs-comment">/* really off slab. No need for manual alignment */</span><br>		slab_size = cachep-&gt;num*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_bufctl_t</span>)+<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> slab);<br>	&#125;<br><br>    <span class="hljs-comment">/*colour_off中记录的aln*/</span><br>	cachep-&gt;colour_off = <span class="hljs-built_in">cache_line_size</span>();<br>	<span class="hljs-comment">/* Offset must be a multiple of the alignment. */</span><br>	<span class="hljs-keyword">if</span> (cachep-&gt;colour_off &lt; align)<br>		cachep-&gt;colour_off = align;<br>    <span class="hljs-comment">/*可用颜色的个数是free/aln*/</span><br>	cachep-&gt;colour = left_over/cachep-&gt;colour_off;<br>	cachep-&gt;slab_size = slab_size;<br>	cachep-&gt;flags = flags;<br>	cachep-&gt;gfpflags = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span> (flags &amp; SLAB_CACHE_DMA)<br>		cachep-&gt;gfpflags |= GFP_DMA;<br>	<span class="hljs-built_in">spin_lock_init</span>(&amp;cachep-&gt;spinlock);<br>	cachep-&gt;objsize = size;<br>	<span class="hljs-comment">/* NUMA */</span><br>	<span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;cachep-&gt;lists.slabs_full);<br>	<span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;cachep-&gt;lists.slabs_partial);<br>	<span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;cachep-&gt;lists.slabs_free);<br><br>	<span class="hljs-keyword">if</span> (flags &amp; CFLGS_OFF_SLAB)<br>		cachep-&gt;slabp_cache = <span class="hljs-built_in">kmem_find_general_cachep</span>(slab_size,<span class="hljs-number">0</span>);<br>	cachep-&gt;ctor = ctor;<br>	cachep-&gt;dtor = dtor;<br>	cachep-&gt;name = name;<br><br>	<span class="hljs-comment">/* Don&#x27;t let CPUs to come and go */</span><br>	<span class="hljs-built_in">lock_cpu_hotplug</span>();<br><br>	<span class="hljs-keyword">if</span> (g_cpucache_up == FULL) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 初始化每CPU本地高速缓存</span><br><span class="hljs-comment">         */</span><br>		<span class="hljs-built_in">enable_cpucache</span>(cachep);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">if</span> (g_cpucache_up == NONE) &#123;<br>			<span class="hljs-comment">/* Note: the first kmem_cache_create must create</span><br><span class="hljs-comment">			 * the cache that&#x27;s used by kmalloc(24), otherwise</span><br><span class="hljs-comment">			 * the creation of further caches will BUG().</span><br><span class="hljs-comment">			 */</span><br>			cachep-&gt;array[<span class="hljs-built_in">smp_processor_id</span>()] = &amp;initarray_generic.cache;<br>			g_cpucache_up = PARTIAL;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			cachep-&gt;array[<span class="hljs-built_in">smp_processor_id</span>()] = <span class="hljs-built_in">kmalloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> arraycache_init),GFP_KERNEL);<br>		&#125;<br>		<span class="hljs-built_in">BUG_ON</span>(!<span class="hljs-built_in">ac_data</span>(cachep));<br>		<span class="hljs-built_in">ac_data</span>(cachep)-&gt;avail = <span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">ac_data</span>(cachep)-&gt;limit = BOOT_CPUCACHE_ENTRIES;<br>		<span class="hljs-built_in">ac_data</span>(cachep)-&gt;batchcount = <span class="hljs-number">1</span>;<br>		<span class="hljs-built_in">ac_data</span>(cachep)-&gt;touched = <span class="hljs-number">0</span>;<br>		cachep-&gt;batchcount = <span class="hljs-number">1</span>;<br>		cachep-&gt;limit = BOOT_CPUCACHE_ENTRIES;<br>		cachep-&gt;free_limit = (<span class="hljs-number">1</span>+<span class="hljs-built_in">num_online_cpus</span>())*cachep-&gt;batchcount<br>					+ cachep-&gt;num;<br>	&#125; <br><br>	cachep-&gt;lists.next_reap = jiffies + REAPTIMEOUT_LIST3 +<br>					((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)cachep)%REAPTIMEOUT_LIST3;<br><br>	<span class="hljs-comment">/* Need the semaphore to access the chain. */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 将新分配的高速缓存描述符挂接到cache_chain中</span><br><span class="hljs-comment">     */</span><br>	<span class="hljs-built_in">down</span>(&amp;cache_chain_sem);<br>	&#123;<br>		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> *p;<br>		<span class="hljs-type">mm_segment_t</span> old_fs;<br><br>		old_fs = <span class="hljs-built_in">get_fs</span>();<br>		<span class="hljs-built_in">set_fs</span>(KERNEL_DS);<br>		<span class="hljs-built_in">list_for_each</span>(p, &amp;cache_chain) &#123;<br>			<span class="hljs-type">kmem_cache_t</span> *pc = <span class="hljs-built_in">list_entry</span>(p, <span class="hljs-type">kmem_cache_t</span>, next);<br>			<span class="hljs-type">char</span> tmp;<br>			<span class="hljs-comment">/* This happens when the module gets unloaded and doesn&#x27;t</span><br><span class="hljs-comment">			   destroy its slab cache and noone else reuses the vmalloc</span><br><span class="hljs-comment">			   area of the module. Print a warning. */</span><br>			<span class="hljs-keyword">if</span> (__get_user(tmp,pc-&gt;name)) &#123; <br>				<span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;SLAB: cache with size %d has lost its name\n&quot;</span>, <br>					pc-&gt;objsize); <br>				<span class="hljs-keyword">continue</span>; <br>			&#125; 	<br>			<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(pc-&gt;name,name)) &#123; <br>				<span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;kmem_cache_create: duplicate cache %s\n&quot;</span>,name); <br>				<span class="hljs-built_in">up</span>(&amp;cache_chain_sem); <br>				<span class="hljs-built_in">unlock_cpu_hotplug</span>();<br>				<span class="hljs-built_in">BUG</span>(); <br>			&#125;	<br>		&#125;<br>		<span class="hljs-built_in">set_fs</span>(old_fs);<br>	&#125;<br><br>	<span class="hljs-comment">/* cache setup completed, link it into the list */</span><br>	<span class="hljs-built_in">list_add</span>(&amp;cachep-&gt;next, &amp;cache_chain);<br>	<span class="hljs-built_in">up</span>(&amp;cache_chain_sem);<br>	<span class="hljs-built_in">unlock_cpu_hotplug</span>();<br>opps:<br>	<span class="hljs-keyword">if</span> (!cachep &amp;&amp; (flags &amp; SLAB_PANIC))<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;kmem_cache_create(): failed to create slab `%s&#x27;\n&quot;</span>,<br>			name);<br>	<span class="hljs-keyword">return</span> cachep;<br>&#125;<br></code></pre></td></tr></table></figure>
根据参数确定处理新高速缓存的最佳方法，然后从普通高速缓存cache_cache中分配一个新的高速缓存描述符。然后入链到cache_chain。</p>
<p>撤销高速缓存： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 撤销一个高速缓存并将它从cache_chain链表上删除</span><br><span class="hljs-comment"> * 主要用于模块中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kmem_cache_destroy</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> * cachep)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> i;<br><br>	<span class="hljs-keyword">if</span> (!cachep || <span class="hljs-built_in">in_interrupt</span>())<br>		<span class="hljs-built_in">BUG</span>();<br><br>	<span class="hljs-comment">/* Don&#x27;t let CPUs to come and go */</span><br>	<span class="hljs-built_in">lock_cpu_hotplug</span>();<br><br>	<span class="hljs-comment">/* Find the cache in the chain of caches. */</span><br>	<span class="hljs-built_in">down</span>(&amp;cache_chain_sem);<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * the chain is never empty, cache_cache is never destroyed</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">list_del</span>(&amp;cachep-&gt;next);<br>	<span class="hljs-built_in">up</span>(&amp;cache_chain_sem);<br><br>	<span class="hljs-keyword">if</span> (__cache_shrink(cachep)) &#123;<br>		<span class="hljs-built_in">slab_error</span>(cachep, <span class="hljs-string">&quot;Can&#x27;t free all objects&quot;</span>);<br>		<span class="hljs-built_in">down</span>(&amp;cache_chain_sem);<br>		<span class="hljs-built_in">list_add</span>(&amp;cachep-&gt;next,&amp;cache_chain);<br>		<span class="hljs-built_in">up</span>(&amp;cache_chain_sem);<br>		<span class="hljs-built_in">unlock_cpu_hotplug</span>();<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(cachep-&gt;flags &amp; SLAB_DESTROY_BY_RCU))<br>		<span class="hljs-built_in">synchronize_kernel</span>();<br><br>	<span class="hljs-comment">/* no cpu_online check required here since we clear the percpu</span><br><span class="hljs-comment">	 * array on cpu offline and set this to NULL.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NR_CPUS; i++)<br>		<span class="hljs-built_in">kfree</span>(cachep-&gt;array[i]);<br><br>	<span class="hljs-comment">/* NUMA: free the list3 structures */</span><br>	<span class="hljs-built_in">kfree</span>(cachep-&gt;lists.shared);<br>	cachep-&gt;lists.shared = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-built_in">kmem_cache_free</span>(&amp;cache_cache, cachep);<br><br>	<span class="hljs-built_in">unlock_cpu_hotplug</span>();<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
撤销kmem_cache时，要确保先撤销掉其上所有的slab。<code>__cache_shrink()</code>负责这一工作，实际上就是反复的<code>slab_destroy()</code>:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __cache_shrink(<span class="hljs-type">kmem_cache_t</span> *cachep)<br>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span> *slabp;<br>	<span class="hljs-type">int</span> ret;<br><br>	<span class="hljs-built_in">drain_cpu_caches</span>(cachep);<br><br>	<span class="hljs-built_in">check_irq_on</span>();<br>	<span class="hljs-built_in">spin_lock_irq</span>(&amp;cachep-&gt;spinlock);<br><br>	<span class="hljs-keyword">for</span>(;;) &#123;<br>		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> *p;<br><br>		p = cachep-&gt;lists.slabs_free.prev;<br>		<span class="hljs-keyword">if</span> (p == &amp;cachep-&gt;lists.slabs_free)<br>			<span class="hljs-keyword">break</span>;<br><br>		slabp = <span class="hljs-built_in">list_entry</span>(cachep-&gt;lists.slabs_free.prev, <span class="hljs-keyword">struct</span> slab, list);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>		<span class="hljs-keyword">if</span> (slabp-&gt;inuse)<br>			<span class="hljs-built_in">BUG</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-built_in">list_del</span>(&amp;slabp-&gt;list);<br><br>		cachep-&gt;lists.free_objects -= cachep-&gt;num;<br>		<span class="hljs-built_in">spin_unlock_irq</span>(&amp;cachep-&gt;spinlock);<br>		<span class="hljs-built_in">slab_destroy</span>(cachep, slabp);<br>		<span class="hljs-built_in">spin_lock_irq</span>(&amp;cachep-&gt;spinlock);<br>	&#125;<br>	ret = !<span class="hljs-built_in">list_empty</span>(&amp;cachep-&gt;lists.slabs_full) ||<br>		!<span class="hljs-built_in">list_empty</span>(&amp;cachep-&gt;lists.slabs_partial);<br>	<span class="hljs-built_in">spin_unlock_irq</span>(&amp;cachep-&gt;spinlock);<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id="slab分配器与zoned-page-frame分配器的接口">slab分配器与zoned page
frame分配器的接口</h2>
<p>slab分配器创建新slab时，它依赖zoned page
frame分配器以获得一组空闲连续页框。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * slab分配器调用此接口从页框分配器中获得一组连续的空闲页框。</span><br><span class="hljs-comment"> * cachep-需要额外页框的高速缓存的高速缓存描述符。请求页框的个数由cachep-&gt;gfporder中的order决定。</span><br><span class="hljs-comment"> * flags-说明如何请求页框。这组标志与存放在高速缓存描述符的gfpflags字段中专用高速缓存分配标志相结合。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">kmem_getpages</span><span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> nodeid)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page;<br>	<span class="hljs-type">void</span> *addr;<br>	<span class="hljs-type">int</span> i;<br><br>	flags |= cachep-&gt;gfpflags;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(nodeid == <span class="hljs-number">-1</span>)) &#123;<br>		page = <span class="hljs-built_in">alloc_pages</span>(flags, cachep-&gt;gfporder);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		page = <span class="hljs-built_in">alloc_pages_node</span>(nodeid, flags, cachep-&gt;gfporder);<br>	&#125;<br>	<span class="hljs-keyword">if</span> (!page)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	addr = <span class="hljs-built_in">page_address</span>(page);<br><br>	i = (<span class="hljs-number">1</span> &lt;&lt; cachep-&gt;gfporder);<br>	<span class="hljs-keyword">if</span> (cachep-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)<br>		<span class="hljs-built_in">atomic_add</span>(i, &amp;slab_reclaim_pages);<br>	<span class="hljs-built_in">add_page_state</span>(nr_slab, i);<br>	<span class="hljs-keyword">while</span> (i--) &#123;<br>		<span class="hljs-built_in">SetPageSlab</span>(page);<br>		page++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure>
熟悉的<code>alloc_pages_node</code>，再看释放操作： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放分配给slab的页框。</span><br><span class="hljs-comment"> * addr-从该地址开始释放页框。</span><br><span class="hljs-comment"> * cachep-slab是由cachep标识的高速缓存中的slab.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">kmem_freepages</span><span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">void</span> *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> i = (<span class="hljs-number">1</span>&lt;&lt;cachep-&gt;gfporder);<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page = <span class="hljs-built_in">virt_to_page</span>(addr);<br>	<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_freed = i;<br><br>	<span class="hljs-keyword">while</span> (i--) &#123;<br>		<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">TestClearPageSlab</span>(page))<br>			<span class="hljs-built_in">BUG</span>();<br>		page++;<br>	&#125;<br>	<span class="hljs-built_in">sub_page_state</span>(nr_slab, nr_freed);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果当前进程正在执行回存回收。就适当增加reclaimed_slab字段。</span><br><span class="hljs-comment">	 * 于是刚被释放的页就能通过回收算法被记录下来。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (current-&gt;reclaim_state)<br>		current-&gt;reclaim_state-&gt;reclaimed_slab += nr_freed;<br>	<span class="hljs-built_in">free_pages</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)addr, cachep-&gt;gfporder);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果SLAB_RECLAIM_ACCOUNT被置位，slab_reclaim_pages则被适当的减少。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (cachep-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT) <br>		<span class="hljs-built_in">atomic_sub</span>(<span class="hljs-number">1</span>&lt;&lt;cachep-&gt;gfporder, &amp;slab_reclaim_pages);<br>&#125;<br></code></pre></td></tr></table></figure>
依然是熟悉的<code>free_pages</code>。</p>
<h2 id="slab分配与释放">slab分配与释放</h2>
<h3 id="分配">分配</h3>
<p>kmem_cache一开始没有任何slab，三条链都是空的。只有当收到分配新对象的请求或者当前不包含任何空闲对象时才会分配slab。</p>
<p>slab分配器通过<code>cache_grow()</code>给kmem_cache分配新的slab：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 给高速缓存分配一个新的slab。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">cache_grow</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> * cachep, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> nodeid)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span>	*slabp;<br>	<span class="hljs-type">void</span>		*objp;<br>	<span class="hljs-type">size_t</span>		 offset;<br>	<span class="hljs-type">int</span>		 local_flags;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	 ctor_flags;<br><br>	<span class="hljs-comment">/* Be lazy and only check for valid flags here,</span><br><span class="hljs-comment"> 	 * keeping it out of the critical path in kmem_cache_alloc().</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (flags &amp; ~(SLAB_DMA|SLAB_LEVEL_MASK|SLAB_NO_GROW))<br>		<span class="hljs-built_in">BUG</span>();<br>	<span class="hljs-keyword">if</span> (flags &amp; SLAB_NO_GROW)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>	ctor_flags = SLAB_CTOR_CONSTRUCTOR;<br>	local_flags = (flags &amp; SLAB_LEVEL_MASK);<br>	<span class="hljs-keyword">if</span> (!(local_flags &amp; __GFP_WAIT))<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Not allowed to sleep.  Need to tell a constructor about</span><br><span class="hljs-comment">		 * this - it might need to know...</span><br><span class="hljs-comment">		 */</span><br>		ctor_flags |= SLAB_CTOR_ATOMIC;<br><br>	<span class="hljs-comment">/* About to mess with non-constant members - lock. */</span><br>	<span class="hljs-built_in">check_irq_off</span>();<br>	<span class="hljs-built_in">spin_lock</span>(&amp;cachep-&gt;spinlock);<br><br>	<span class="hljs-comment">/* Get colour for the slab, and cal the next value. */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 更新高速缓存描述符的当前颜色值。并根据当前颜色值计算数据区的偏移。</span><br><span class="hljs-comment">	 * 这样可以平等的在slab间分布颜色值。</span><br><span class="hljs-comment">	 * offset就是 aln * col,  colour_off字段记录的aln，colour_next记录的col</span><br><span class="hljs-comment">	 */</span><br>	offset = cachep-&gt;colour_next;<br>	cachep-&gt;colour_next++;<br>	<span class="hljs-keyword">if</span> (cachep-&gt;colour_next &gt;= cachep-&gt;colour)<br>		cachep-&gt;colour_next = <span class="hljs-number">0</span>;<br>	offset *= cachep-&gt;colour_off;<br><br>	<span class="hljs-built_in">spin_unlock</span>(&amp;cachep-&gt;spinlock);<br><br>	<span class="hljs-keyword">if</span> (local_flags &amp; __GFP_WAIT)<br>		<span class="hljs-built_in">local_irq_enable</span>();<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * The test for missing atomic flag is performed here, rather than</span><br><span class="hljs-comment">	 * the more obvious place, simply to reduce the critical path length</span><br><span class="hljs-comment">	 * in kmem_cache_alloc(). If a caller is seriously mis-behaving they</span><br><span class="hljs-comment">	 * will eventually be caught here (where it matters).</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">kmem_flagcheck</span>(cachep, flags);<br><br><br>	<span class="hljs-comment">/* Get mem for the objs. */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 调用kmem_getpages从分区页框分配器获得一组页框来存放一个单独的slab</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (!(objp = <span class="hljs-built_in">kmem_getpages</span>(cachep, flags, nodeid)))<br>		<span class="hljs-keyword">goto</span> failed;<br><br>	<span class="hljs-comment">/* Get slab management. */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 获得一个新的slab描述符</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (!(slabp = <span class="hljs-built_in">alloc_slabmgmt</span>(cachep, objp, offset, local_flags)))<br>		<span class="hljs-keyword">goto</span> opps1;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * set_slab_attr扫描分配给新slab的页框的所有页描述符</span><br><span class="hljs-comment">	 * 并将高速缓存描述符和slab描述符的地址分别赋给页描述符中lru字段的next和prev字段</span><br><span class="hljs-comment">	 * 这是不会出错的，因为只有当页框空闲时，伙伴系统的函数才会使用lru字段，而只要涉及伙伴系统，slab分配器函数处理的页框就不空闲。</span><br><span class="hljs-comment">	 * 注意：这个字段因为也会被页框回收算法使用，所以包含了这些隐含的约定，总会让人困惑，也许会带来一些意外的后果。</span><br><span class="hljs-comment">	 * 总之，从这里可以看出linux不好、甚至是坏的一面。除了linus，还有多少人能够改linux??</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">set_slab_attr</span>(cachep, slabp, objp);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * cache_init_objs将构造方法（如果有）应用到新的slab包含的所有对象上。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">cache_init_objs</span>(cachep, slabp, ctor_flags);<br><br>	<span class="hljs-keyword">if</span> (local_flags &amp; __GFP_WAIT)<br>		<span class="hljs-built_in">local_irq_disable</span>();<br>	<span class="hljs-built_in">check_irq_off</span>();<br>	<span class="hljs-built_in">spin_lock</span>(&amp;cachep-&gt;spinlock);<br><br>	<span class="hljs-comment">/* Make slab active. */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 将新得到的slab描述符slabp添加到高速缓存描述符cachep的全空slab链表的末端。并更新空闲对象计数器</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">list_add_tail</span>(&amp;slabp-&gt;list, &amp;(<span class="hljs-built_in">list3_data</span>(cachep)-&gt;slabs_free));<br>	<span class="hljs-built_in">STATS_INC_GROWN</span>(cachep);<br>	<span class="hljs-built_in">list3_data</span>(cachep)-&gt;free_objects += cachep-&gt;num;<br>	<span class="hljs-built_in">spin_unlock</span>(&amp;cachep-&gt;spinlock);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>opps1:<br>	<span class="hljs-built_in">kmem_freepages</span>(cachep, objp);<br>failed:<br>	<span class="hljs-keyword">if</span> (local_flags &amp; __GFP_WAIT)<br>		<span class="hljs-built_in">local_irq_disable</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
暂时不关心着色，显示通过<code>kmem_getpages</code>拿到一组页框。然后通过<code>alloc_slabmgmt</code>获得新的slab描述符：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得一个新的slab描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span>* <span class="hljs-built_in">alloc_slabmgmt</span> (<span class="hljs-type">kmem_cache_t</span> *cachep,<br>			<span class="hljs-type">void</span> *objp, <span class="hljs-type">int</span> colour_off, <span class="hljs-type">int</span> local_flags)<br>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span> *slabp;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果CFLGS_OFF_SLAB标志被置位，那么样从高速缓存描述符的slabp_cache字段指向的普通高速缓存中分配这个新的描述符。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">OFF_SLAB</span>(cachep)) &#123;<br>		<span class="hljs-comment">/* Slab management obj is off-slab. */</span><br>		slabp = <span class="hljs-built_in">kmem_cache_alloc</span>(cachep-&gt;slabp_cache, local_flags);<br>		<span class="hljs-keyword">if</span> (!slabp)<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 否则，从slab的第一个页框中分配这个slab描述符</span><br><span class="hljs-comment">		 */</span><br>		slabp = objp+colour_off;<br>		colour_off += cachep-&gt;slab_size; <span class="hljs-comment">/*slab_size字段记录的就是dsize*/</span><br>	&#125;<br>	slabp-&gt;inuse = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/*将col*aln + dsize存放到colouroff中，aln就是高速缓存描述符的colour_off字段*/</span><br>	slabp-&gt;colouroff = colour_off;<br>	slabp-&gt;s_mem = objp+colour_off;<br><br>	<span class="hljs-keyword">return</span> slabp;<br>&#125;<br></code></pre></td></tr></table></figure>
CFLGS_OFF_SLAB表示从内部还是外部存放slab描述符。内部对应else分支，在第一个页框中分配slab描述符，外部则对应if分支，在cachep-&gt;slabp_cache指向的普通高速缓存中分配slab描述符。</p>
<p>分配新slab描述符后，扫描分配给新slab的页框的所有页描述符，将kmem_cache和slab描述符的地址赋给页描述符的lru字段的next和prev。lru在buddy
system和slab系统中都有用到，实际上这种设计虽然省了空间，但却称为逻辑的困扰项。</p>
<p>此后的<code>cache_init_objs</code>对新slab的所有对象应用构造方法，然后把新的slab描述符链到free链的尾端，更新对应的字段。</p>
<h3 id="释放">释放</h3>
<p>当slab高速缓存中空闲对象太多或周期性调用的定时器函数确定有可以被释放的slab时，才会进行slab的撤销：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当以下两个条件满足时:</span><br><span class="hljs-comment"> *     Slab高速缓存中有太多的空闲对象。</span><br><span class="hljs-comment"> *     被定时器周期性的检测到，有完全未使用的slab能够被释放。</span><br><span class="hljs-comment"> * 撤销一个slab。并释放相应的页框到分区页框分配器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">slab_destroy</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-keyword">struct</span> slab *slabp)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">void</span> *addr = slabp-&gt;s_mem - slabp-&gt;colouroff;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cachep-&gt;num; i++) &#123;<br>		<span class="hljs-type">void</span> *objp = slabp-&gt;s_mem + cachep-&gt;objsize * i;<br><br>		<span class="hljs-keyword">if</span> (cachep-&gt;flags &amp; SLAB_POISON) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_PAGEALLOC</span><br>			<span class="hljs-keyword">if</span> ((cachep-&gt;objsize%PAGE_SIZE)==<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">OFF_SLAB</span>(cachep))<br>				<span class="hljs-built_in">kernel_map_pages</span>(<span class="hljs-built_in">virt_to_page</span>(objp), cachep-&gt;objsize/PAGE_SIZE,<span class="hljs-number">1</span>);<br>			<span class="hljs-keyword">else</span><br>				<span class="hljs-built_in">check_poison_obj</span>(cachep, objp);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>			<span class="hljs-built_in">check_poison_obj</span>(cachep, objp);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		&#125;<br>		<span class="hljs-keyword">if</span> (cachep-&gt;flags &amp; SLAB_RED_ZONE) &#123;<br>			<span class="hljs-keyword">if</span> (*<span class="hljs-built_in">dbg_redzone1</span>(cachep, objp) != RED_INACTIVE)<br>				<span class="hljs-built_in">slab_error</span>(cachep, <span class="hljs-string">&quot;start of a freed object &quot;</span><br>							<span class="hljs-string">&quot;was overwritten&quot;</span>);<br>			<span class="hljs-keyword">if</span> (*<span class="hljs-built_in">dbg_redzone2</span>(cachep, objp) != RED_INACTIVE)<br>				<span class="hljs-built_in">slab_error</span>(cachep, <span class="hljs-string">&quot;end of a freed object &quot;</span><br>							<span class="hljs-string">&quot;was overwritten&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">if</span> (cachep-&gt;dtor &amp;&amp; !(cachep-&gt;flags &amp; SLAB_POISON))<br>			(cachep-&gt;dtor)(objp+<span class="hljs-built_in">obj_dbghead</span>(cachep), cachep, <span class="hljs-number">0</span>);<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果高速缓存为它的对象定义了析构方法，就遍历slab中的所有对象。</span><br><span class="hljs-comment">	 * 使用析构函数释放slab中的所有对象。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (cachep-&gt;dtor) &#123;<br>		<span class="hljs-type">int</span> i;<br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cachep-&gt;num; i++) &#123;<br>			<span class="hljs-type">void</span>* objp = slabp-&gt;s_mem+cachep-&gt;objsize*i;<br>			(cachep-&gt;dtor)(objp, cachep, <span class="hljs-number">0</span>);<br>		&#125;<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果使用了SLAB_DESTROY_BY_RCU标志来创建slab高速缓存，就应该使用call_rcu</span><br><span class="hljs-comment">	 * 来注册一个回调，以延期释放slab。回调函数会调用kmem_freepages和kmem_cache_free</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(cachep-&gt;flags &amp; SLAB_DESTROY_BY_RCU)) &#123;<br>		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab_rcu</span> *slab_rcu;<br><br>		slab_rcu = (<span class="hljs-keyword">struct</span> slab_rcu *) slabp;<br>		slab_rcu-&gt;cachep = cachep;<br>		slab_rcu-&gt;addr = addr;<br>		<span class="hljs-built_in">call_rcu</span>(&amp;slab_rcu-&gt;head, kmem_rcu_free);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 调用kmem_freepages，将slab使用的所有连续页框返回给伙伴系统。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">kmem_freepages</span>(cachep, addr);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 如果slab描述符存放在slab的外面，那么就从slab描述符的高速缓存释放slab描述符。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">OFF_SLAB</span>(cachep))<br>			<span class="hljs-built_in">kmem_cache_free</span>(cachep-&gt;slabp_cache, slabp);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure> 先进行析构dtor，然后释放slab给buddy system。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放分配给slab的页框。</span><br><span class="hljs-comment"> * addr-从该地址开始释放页框。</span><br><span class="hljs-comment"> * cachep-slab是由cachep标识的高速缓存中的slab.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">kmem_freepages</span><span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">void</span> *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> i = (<span class="hljs-number">1</span>&lt;&lt;cachep-&gt;gfporder);<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page = <span class="hljs-built_in">virt_to_page</span>(addr);<br>	<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_freed = i;<br><br>	<span class="hljs-keyword">while</span> (i--) &#123;<br>		<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">TestClearPageSlab</span>(page))<br>			<span class="hljs-built_in">BUG</span>();<br>		page++;<br>	&#125;<br>	<span class="hljs-built_in">sub_page_state</span>(nr_slab, nr_freed);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果当前进程正在执行回存回收。就适当增加reclaimed_slab字段。</span><br><span class="hljs-comment">	 * 于是刚被释放的页就能通过回收算法被记录下来。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (current-&gt;reclaim_state)<br>		current-&gt;reclaim_state-&gt;reclaimed_slab += nr_freed;<br>	<span class="hljs-built_in">free_pages</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)addr, cachep-&gt;gfporder);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果SLAB_RECLAIM_ACCOUNT被置位，slab_reclaim_pages则被适当的减少。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (cachep-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT) <br>		<span class="hljs-built_in">atomic_sub</span>(<span class="hljs-number">1</span>&lt;&lt;cachep-&gt;gfporder, &amp;slab_reclaim_pages);<br>&#125;<br></code></pre></td></tr></table></figure> 最终通过<code>free_pages()</code>释放。</p>
<p>且另一方面，如果slab描述符存放在slab外部，也需要从专门放slab描述符的高速缓存中释放该slab描述符：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放一个曾经由slab分配器分配给某个内核函数的对象</span><br><span class="hljs-comment"> * cachep-高速缓存描述符的地址。</span><br><span class="hljs-comment"> * objp-要释放的对象的地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmem_cache_free</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">void</span> *objp)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>	<span class="hljs-built_in">local_irq_save</span>(flags);<br>	__cache_free(cachep, objp);<br>	<span class="hljs-built_in">local_irq_restore</span>(flags);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __cache_free (<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">void</span>* objp)<br>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *ac = <span class="hljs-built_in">ac_data</span>(cachep);<br><br>	<span class="hljs-built_in">check_irq_off</span>();<br>	objp = <span class="hljs-built_in">cache_free_debugcheck</span>(cachep, objp, __builtin_return_address(<span class="hljs-number">0</span>));<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 首先检查本地高速缓存是否有空间给指向一个空闲对象的额外指针。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(ac-&gt;avail &lt; ac-&gt;limit)) &#123;<br>		<span class="hljs-built_in">STATS_INC_FREEHIT</span>(cachep);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 本地高速缓存有空闲指针，则该指针被加到本地高速缓存后返回。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">ac_entry</span>(ac)[ac-&gt;avail++] = objp;<br>		<span class="hljs-keyword">return</span>;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-built_in">STATS_INC_FREEMISS</span>(cachep);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 调用cache_flusharray，清空本地高速缓存</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">cache_flusharray</span>(cachep, ac);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 然后将指针加到本地高速缓存。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">ac_entry</span>(ac)[ac-&gt;avail++] = objp;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清空本地高速缓存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">cache_flusharray</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span>* cachep, <span class="hljs-keyword">struct</span> array_cache *ac)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> batchcount;<br><br>	batchcount = ac-&gt;batchcount;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>	<span class="hljs-built_in">BUG_ON</span>(!batchcount || batchcount &gt; ac-&gt;avail);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-built_in">check_irq_off</span>();<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 获得自旋锁</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">spin_lock</span>(&amp;cachep-&gt;spinlock);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果包含一个共享本地高速缓存</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (cachep-&gt;lists.shared) &#123;<br>		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *shared_array = cachep-&gt;lists.shared;<br>		<span class="hljs-type">int</span> max = shared_array-&gt;limit-shared_array-&gt;avail;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 该共享缓存还没有满</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (max) &#123;<br>			<span class="hljs-keyword">if</span> (batchcount &gt; max)<br>				batchcount = max;<br>			<span class="hljs-comment">/**</span><br><span class="hljs-comment">			 * 将batchcount个指针放到共享高速缓存中。</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-built_in">memcpy</span>(&amp;<span class="hljs-built_in">ac_entry</span>(shared_array)[shared_array-&gt;avail],<br>					&amp;<span class="hljs-built_in">ac_entry</span>(ac)[<span class="hljs-number">0</span>],<br>					<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*)*batchcount);<br>			<span class="hljs-comment">/**</span><br><span class="hljs-comment">			 * 上移batchcount个指针来重新填充共享本地高速缓存</span><br><span class="hljs-comment">			 */</span><br>			shared_array-&gt;avail += batchcount;<br>			<span class="hljs-keyword">goto</span> free_done;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 将当前包含在本地高速缓存中的ac-&gt;batchcount个对象归还给slab分配器。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">free_block</span>(cachep, &amp;<span class="hljs-built_in">ac_entry</span>(ac)[<span class="hljs-number">0</span>], batchcount);<br>free_done:<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> STATS</span><br>	&#123;<br>		<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> *p;<br><br>		p = <span class="hljs-built_in">list3_data</span>(cachep)-&gt;slabs_free.next;<br>		<span class="hljs-keyword">while</span> (p != &amp;(<span class="hljs-built_in">list3_data</span>(cachep)-&gt;slabs_free)) &#123;<br>			<span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span> *slabp;<br><br>			slabp = <span class="hljs-built_in">list_entry</span>(p, <span class="hljs-keyword">struct</span> slab, list);<br>			<span class="hljs-built_in">BUG_ON</span>(slabp-&gt;inuse);<br><br>			i++;<br>			p = p-&gt;next;<br>		&#125;<br>		<span class="hljs-built_in">STATS_SET_FREEABLE</span>(cachep, i);<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 释放锁</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">spin_unlock</span>(&amp;cachep-&gt;spinlock);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 通过减去被移到共享本地高速缓存或被释放到slab分配器的对象的个数来更新本地高速缓存描述的avail字段</span><br><span class="hljs-comment">	 */</span><br>	ac-&gt;avail -= batchcount;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 移动本地高速缓存数组起始处的那个本地高速缓存中的所有指针。</span><br><span class="hljs-comment">	 * 因为已经把第一个对象指针从本地高速缓存上删除，因此剩余的指针必须上移。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">memmove</span>(&amp;<span class="hljs-built_in">ac_entry</span>(ac)[<span class="hljs-number">0</span>], &amp;<span class="hljs-built_in">ac_entry</span>(ac)[batchcount],<br>			<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*)*ac-&gt;avail);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>如果cachep-&gt;flags中指定了<code>SLAB_DESTROY_BY_RCU</code>，就注册<code>kmem_rcu_free</code>回调，延期释放slab
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * rcu原语中，写者调用call_rcu来释放数据结构的旧副本。</span><br><span class="hljs-comment"> * 当所有CPU都经过静止状态(quiescent state)后，</span><br><span class="hljs-comment"> * call_rcu接受rcu_head描述符（通常嵌在要释放在数据结构中）和将要调用的回调函数的地址作为参数。</span><br><span class="hljs-comment"> * 一旦回调函数被执行，它通常释放数据结构的旧副本。</span><br><span class="hljs-comment"> * call_rcu把回调函数和其参数的地址存放在rcu_head，然后把描述符插入到回调函数的每CPU链表中。</span><br><span class="hljs-comment"> * 内核每经过一个时钟滴答，就周期性的检查本地CPU是否经过了一个静止状态。</span><br><span class="hljs-comment"> * 如果经过了，本地tasklet(rcu_tasklet)就执行链表中的回调函数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> fastcall <span class="hljs-title">call_rcu</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rcu_head *head,</span></span><br><span class="hljs-params"><span class="hljs-function">				<span class="hljs-type">void</span> (*func)(<span class="hljs-keyword">struct</span> rcu_head *rcu))</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rcu_data</span> *rdp;<br><br>	head-&gt;func = func;<br>	head-&gt;next = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-built_in">local_irq_save</span>(flags);<br>	rdp = &amp;__get_cpu_var(rcu_data);<br>	*rdp-&gt;nxttail = head;<br>	rdp-&gt;nxttail = &amp;head-&gt;next;<br>	<span class="hljs-built_in">local_irq_restore</span>(flags);<br>&#125;<br><br><span class="hljs-comment">//注册的回调函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">kmem_rcu_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rcu_head *head)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab_rcu</span> *slab_rcu = (<span class="hljs-keyword">struct</span> slab_rcu *) head;<br>	<span class="hljs-type">kmem_cache_t</span> *cachep = slab_rcu-&gt;cachep;<br><br>	<span class="hljs-built_in">kmem_freepages</span>(cachep, slab_rcu-&gt;addr);<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">OFF_SLAB</span>(cachep))<br>		<span class="hljs-built_in">kmem_cache_free</span>(cachep-&gt;slabp_cache, slab_rcu);<br>&#125;<br></code></pre></td></tr></table></figure>
rcu的机制暂时不关心，但延迟的<code>kmem_rcu_free</code>函数依然调用的是<code>kmem_freepages</code>挂<code>kmem_cache_free</code>。一样的套路。</p>
<h2 id="object">Object</h2>
<h3 id="对象描述符">对象描述符</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 高速缓存对象描述符。将slab中的空闲对象链接起来。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">kmem_bufctl_t</span>;<br></code></pre></td></tr></table></figure>
<p>kmem_bufctl_t实际上就是个uint16，只有当object空闲时才有意义，表示下一个空闲对象在slab中的下标。通过这一描述符形成了隐式链表，最后一个空闲对象用BUFCTL_END(0xffff)标记<code>#define BUFCTL_END   (((kmem_bufctl_t)(~0U))-0)</code>。</p>
<p>因为slab描述符有内部或外部之分，而object描述符跟着slab描述符走（注意这里说的是描述符，而不是object或是slab，object始终在slab内），所以object描述符也有内外之分。
-
外部的object描述符由外部的slab描述符所在的普通高速缓存中的slabp_cache字段指向，它是一个数组。
- 内部的object描述符就位于所有对象之前。</p>
<p><img src="20171024_6.jpg" srcset="/img/loading.gif" lazyload /></p>
<h3 id="对象对齐">对象对齐</h3>
<p>object在内存中是对齐的，起始物理地址是一个给定常量的倍数，通常是2的倍数。该常量称为对齐因子。</p>
<p>slab分配器允许的最大对齐因子为4096，即页框大小。</p>
<p>80x86指定32位大小来对齐对象，因为当内存单元的物理地址对齐尺寸和内存总线宽度一致时，内存的读写会非常快。slab分配器为了对齐，难免会产生额外的内存碎片，但瑕不掩瑜，这代价是值得的。</p>
<h3 id="slab着色">slab着色</h3>
<p>回看这张图： <img src="20171024_5.jpg" srcset="/img/loading.gif" lazyload /></p>
<p>每个slab的首部都有一个着色区，不为对象使用。着色区的大小使slab中每个对象的起始地址都按高速缓存中缓存行(cache
line)大小进行对齐。slab是一组页框，因此slab肯定是按高速缓存行对齐的，但是slab的object大小是不确定的，设置着色区的目的就是将lab中第一个对象的起始地址往后推到与缓冲行对齐的位置。因为一个缓冲区中有多个slab，因此应该把每个缓冲区中的各个slab着色区的大小尽量安排成不同的大小，这就可以使得在不同slab中，出于同一相对位置的对象，让它们在高速缓存中的起始地址相互错开，以改善高速缓存的存取效率（如果不错开，可能同缓存区的两个slab上，同相对位置的两个对象会来来回回在高速缓存行与RAM之间传送，高速缓存行无法发挥效率）。</p>
<p>每个slab上最后也有一片废料区，是对着色区大小的补偿，大小取决于着色区的大小，以及slab与其每个对象的相对大小。该区域和着色区的综合对于同一个对象的各个slab来说是个constant。</p>
<p>每个对象的大小基本上是所需数据结构的大小，只有当数据结构大小不与高速缓存中的缓冲行对齐时，才增加若干字节使其对齐。所以，一个slab上的所有对象的起始地址都必然是按高速缓冲中的缓冲行对齐的。</p>
<p>也就是说，着色区保证了第一个对象的对齐，而对象大小的对齐保证了后续所有对象的对齐。</p>
<h3 id="空闲slab对象的本地缓存">空闲slab对象的本地缓存</h3>
<p>多处理的slab分配器实现不同于原始的Solaris
2.4。为了减少处理器之间对自旋锁的竞争并更好的利用硬件缓存，slab分配器的每个高速缓存都包含一个每CPU数据结构。该结构由一个指向被释放对象的小指针数组组成。slab对象的大多数分配和释放只影响本地数组，只有在本地数组下溢或上溢时才涉及slab数据结构。</p>
<p>这就是kmem_cache的array_cache，前面已经展开看到过。这一设计非常类似“每CPU页框高速缓存”。</p>
<h3 id="分配slab对象">分配slab对象</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得新的slab对象</span><br><span class="hljs-comment"> * cachep-指向高速缓存描述符。新空闲对象必须从该高速缓存描述符获得。</span><br><span class="hljs-comment"> * flag-表示传递给分区页框分配器函数的标志。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">kmem_cache_alloc</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> __cache_alloc(cachep, flags);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> * __cache_alloc (<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">int</span> flags)<br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> save_flags;<br>	<span class="hljs-type">void</span>* objp;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *ac;<br><br>	<span class="hljs-built_in">cache_alloc_debugcheck_before</span>(cachep, flags);<br><br>	<span class="hljs-built_in">local_irq_save</span>(save_flags);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 首先试图从本地高速缓存获得一个空闲对象。</span><br><span class="hljs-comment">	 */</span><br>	ac = <span class="hljs-built_in">ac_data</span>(cachep);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果本地高速缓存有空闲对象，那么avail字段就包含最后被释放的对象的项在本地高速缓存中的下标。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(ac-&gt;avail)) &#123;<br>		<span class="hljs-built_in">STATS_INC_ALLOCHIT</span>(cachep);<br>		ac-&gt;touched = <span class="hljs-number">1</span>;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 因为本地高速缓存数组正好存放在ac描述符的后面。</span><br><span class="hljs-comment">		 * 所以(void**)(ac+1)[--ac-&gt;avail]获得空闲对象的地址，并递减ac-&gt;avail的值。</span><br><span class="hljs-comment">		 */</span><br>		objp = <span class="hljs-built_in">ac_entry</span>(ac)[--ac-&gt;avail];<br>	&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* 本地高速缓存中没有空闲对象。 */</span>  <span class="hljs-comment">/*ac-&gt;avail == 0*/</span><br>		<span class="hljs-built_in">STATS_INC_ALLOCMISS</span>(cachep);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * cache_alloc_refill重新填充本地高速缓存并获得一个空闲对象。</span><br><span class="hljs-comment">		 */</span><br>		objp = <span class="hljs-built_in">cache_alloc_refill</span>(cachep, flags);<br>	&#125;<br>	<span class="hljs-built_in">local_irq_restore</span>(save_flags);<br>	objp = <span class="hljs-built_in">cache_alloc_debugcheck_after</span>(cachep, flags, objp, __builtin_return_address(<span class="hljs-number">0</span>));<br>	<span class="hljs-keyword">return</span> objp;<br>&#125;<br><br><span class="hljs-comment">//本地高速缓存派上了用场</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *<span class="hljs-built_in">ac_data</span>(<span class="hljs-type">kmem_cache_t</span> *cachep)<br>&#123;<br>	<span class="hljs-keyword">return</span> cachep-&gt;array[<span class="hljs-built_in">smp_processor_id</span>()];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果本地高速缓存有空闲对象，则递减ac-&gt;avail值即可，avail包含指向最后被释放的对象的项在本地高速缓存中的下标。if分支的逻辑很简单。</p>
<p>如果没有的话，进入else，就需要通过cache_alloc_refill：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重新填充本地高速缓存并获得一个空闲对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">cache_alloc_refill</span><span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span>* cachep, <span class="hljs-type">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> batchcount;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">kmem_list3</span> *l3;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *ac;<br><br>	<span class="hljs-built_in">check_irq_off</span>();<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * ac = cachep-&gt;array[smp_processor_id()];</span><br><span class="hljs-comment">	 * 将本地高速缓存描述符的地址存放在ac局部变量中。</span><br><span class="hljs-comment">	 */</span><br>	ac = <span class="hljs-built_in">ac_data</span>(cachep);<br>retry:<br>	batchcount = ac-&gt;batchcount;<br>	<span class="hljs-keyword">if</span> (!ac-&gt;touched &amp;&amp; batchcount &gt; BATCHREFILL_LIMIT) &#123;<br>		<span class="hljs-comment">/* if there was little recent activity on this</span><br><span class="hljs-comment">		 * cache, then perform only a partial refill.</span><br><span class="hljs-comment">		 * Otherwise we could generate refill bouncing.</span><br><span class="hljs-comment">		 */</span><br>		batchcount = BATCHREFILL_LIMIT;<br>	&#125;<br>	l3 = <span class="hljs-built_in">list3_data</span>(cachep);<br><br>	<span class="hljs-built_in">BUG_ON</span>(ac-&gt;avail &gt; <span class="hljs-number">0</span>);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 获取spinlock</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">spin_lock</span>(&amp;cachep-&gt;spinlock);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果slab高速缓存包含共享本地高速缓存</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (l3-&gt;shared) &#123;<br>		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *shared_array = l3-&gt;shared;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 并且该共享本地高速缓存包含一些空闲对象</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (shared_array-&gt;avail) &#123;<br>			<span class="hljs-keyword">if</span> (batchcount &gt; shared_array-&gt;avail)<br>				batchcount = shared_array-&gt;avail;<br>			<span class="hljs-comment">/**</span><br><span class="hljs-comment">			 * 从共享本地高速缓存中上移batchcount个指针来重新填充CPU的本地高速缓存</span><br><span class="hljs-comment">			 */</span><br>			shared_array-&gt;avail -= batchcount;<br>			ac-&gt;avail = batchcount;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 共享本地高速缓存，从后向前使用，avail指向最后面</span><br><span class="hljs-comment">             * 这里shared_array-&gt;avail在前面经过&quot;shared_array-&gt;avail -= batchcount;&quot;的处理指向了前面，</span><br><span class="hljs-comment">             * 所以这里直接用memcpy进行从前向后的拷贝</span><br><span class="hljs-comment">             */</span><br>			<span class="hljs-built_in">memcpy</span>(<span class="hljs-built_in">ac_entry</span>(ac), &amp;<span class="hljs-built_in">ac_entry</span>(shared_array)[shared_array-&gt;avail],<br>					<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*)*batchcount);<br>			shared_array-&gt;touched = <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">goto</span> alloc_done;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 函数试图填充本地高速缓存，填充值为高速缓存的slab中包含的多达ac-&gt;batchcount个空闲对象的指针</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">while</span> (batchcount &gt; <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> *entry;<br>		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span> *slabp;<br>		<span class="hljs-comment">/* Get slab alloc is to come from. */</span><br>		entry = l3-&gt;slabs_partial.next;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 查看高速缓存描述符的slabs_partial和slabs_free链表</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (entry == &amp;l3-&gt;slabs_partial) &#123; <span class="hljs-comment">/*partial用完了*/</span><br>			l3-&gt;free_touched = <span class="hljs-number">1</span>;<br>			entry = l3-&gt;slabs_free.next;<br>			<span class="hljs-keyword">if</span> (entry == &amp;l3-&gt;slabs_free) <span class="hljs-comment">/*free用完了*/</span><br>				<span class="hljs-keyword">goto</span> must_grow;<br>		&#125;<br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 获得slab描述符的地址slabp，该slab描述符的相应slab或者部分被填充或者为空。</span><br><span class="hljs-comment">		 */</span><br>		slabp = <span class="hljs-built_in">list_entry</span>(entry, <span class="hljs-keyword">struct</span> slab, list);<br>		<span class="hljs-built_in">check_slabp</span>(cachep, slabp);<br>		<span class="hljs-built_in">check_spinlock_acquired</span>(cachep);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 对于slab中的每个空闲对象</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">while</span> (slabp-&gt;inuse &lt; cachep-&gt;num &amp;&amp; batchcount--) &#123;<br>			<span class="hljs-type">kmem_bufctl_t</span> next;<br>			<span class="hljs-built_in">STATS_INC_ALLOCED</span>(cachep);<br>			<span class="hljs-built_in">STATS_INC_ACTIVE</span>(cachep);<br>			<span class="hljs-built_in">STATS_SET_HIGH</span>(cachep);<br><br>			<span class="hljs-comment">/* get obj pointer */</span><br>			<span class="hljs-comment">/**</span><br><span class="hljs-comment">			 * 将对象地址插入本地高速缓存。</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-built_in">ac_entry</span>(ac)[ac-&gt;avail++] = slabp-&gt;s_mem + slabp-&gt;free*cachep-&gt;objsize;<br><br>			<span class="hljs-comment">/**</span><br><span class="hljs-comment">			 * 函数增加slab描述符的inuse字段</span><br><span class="hljs-comment">			 */</span><br>			slabp-&gt;inuse++;<br>			next = <span class="hljs-built_in">slab_bufctl</span>(slabp)[slabp-&gt;free];<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>			<span class="hljs-built_in">slab_bufctl</span>(slabp)[slabp-&gt;free] = BUFCTL_FREE;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>				<span class="hljs-comment">/**</span><br><span class="hljs-comment">				 * 更新free字段，使得它指向slab中下一个空闲对象的下标。</span><br><span class="hljs-comment">				 */</span><br>		       	slabp-&gt;free = next;<br>		&#125;<br>		<span class="hljs-built_in">check_slabp</span>(cachep, slabp);<br><br>		<span class="hljs-comment">/* move slabp to correct slabp list: */</span><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 如果有必要，将清空的slab插入到适当的链表上，可以是slabs_full链表，也可以是slabs_partial链表</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">list_del</span>(&amp;slabp-&gt;list);<br>		<span class="hljs-keyword">if</span> (slabp-&gt;free == BUFCTL_END)<br>			<span class="hljs-built_in">list_add</span>(&amp;slabp-&gt;list, &amp;l3-&gt;slabs_full);<br>		<span class="hljs-keyword">else</span><br>			<span class="hljs-built_in">list_add</span>(&amp;slabp-&gt;list, &amp;l3-&gt;slabs_partial);<br>	&#125;<br><br>must_grow:<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 被加到本地高速缓存的指针个数被存放在ac-&gt;avail字段。</span><br><span class="hljs-comment">	 * 函数递减同样数量的free_objects来说明这些对象不再空闲</span><br><span class="hljs-comment">	 */</span><br>	l3-&gt;free_objects -= ac-&gt;avail;<br>alloc_done:<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 释放spinlock</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">spin_unlock</span>(&amp;cachep-&gt;spinlock);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 没有发生任何高速缓存再填充的情况</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!ac-&gt;avail)) &#123;<br>		<span class="hljs-type">int</span> x;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 调用cache_grow获得一个新的slab，从而获得了新的空闲对象</span><br><span class="hljs-comment">		 */</span><br>		x = <span class="hljs-built_in">cache_grow</span>(cachep, flags, <span class="hljs-number">-1</span>);<br>		<br>		<span class="hljs-comment">// cache_grow can reenable interrupts, then ac could change.</span><br>		ac = <span class="hljs-built_in">ac_data</span>(cachep);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * cache_grow失败了，返回NULL</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (!x &amp;&amp; ac-&gt;avail == <span class="hljs-number">0</span>)	<span class="hljs-comment">// no objects in sight? abort</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * cache_grow成功了，返回再试。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (!ac-&gt;avail)		<span class="hljs-comment">// objects refilled by interrupt?</span><br>			<span class="hljs-keyword">goto</span> retry;<br>	&#125;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果ac-&gt;avail&gt;0(一些高速缓存再填充的情况发生了)</span><br><span class="hljs-comment">	 */</span><br>	ac-&gt;touched = <span class="hljs-number">1</span>;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 返回最后插入到本地高速缓存的空闲对象指针</span><br><span class="hljs-comment">	 * 本地高速缓存(非共享)，从后像前使用，avail指向最后面</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">ac_entry</span>(ac)[--ac-&gt;avail];<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="释放slab对象">释放slab对象</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放一个曾经由slab分配器分配给某个内核函数的对象</span><br><span class="hljs-comment"> * cachep-高速缓存描述符的地址。</span><br><span class="hljs-comment"> * objp-要释放的对象的地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmem_cache_free</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">void</span> *objp)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>	<span class="hljs-built_in">local_irq_save</span>(flags);<br>	__cache_free(cachep, objp);<br>	<span class="hljs-built_in">local_irq_restore</span>(flags);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __cache_free (<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">void</span>* objp)<br>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *ac = <span class="hljs-built_in">ac_data</span>(cachep);<br><br>	<span class="hljs-built_in">check_irq_off</span>();<br>	objp = <span class="hljs-built_in">cache_free_debugcheck</span>(cachep, objp, __builtin_return_address(<span class="hljs-number">0</span>));<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 首先检查本地高速缓存是否有空间给指向一个空闲对象的额外指针。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(ac-&gt;avail &lt; ac-&gt;limit)) &#123;<br>		<span class="hljs-built_in">STATS_INC_FREEHIT</span>(cachep);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 本地高速缓存有空闲指针，则该指针被加到本地高速缓存后返回。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">ac_entry</span>(ac)[ac-&gt;avail++] = objp;<br>		<span class="hljs-keyword">return</span>;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-built_in">STATS_INC_FREEMISS</span>(cachep);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 调用cache_flusharray，清空本地高速缓存</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">cache_flusharray</span>(cachep, ac);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 然后将指针加到本地高速缓存。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">ac_entry</span>(ac)[ac-&gt;avail++] = objp;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>较之alloc简单一些，同样的道理，alloc是多对一，而free是一对一。free时当发现本地高速缓存已满，就先清一波，再将本次的对象放进去。</p>
<h3 id="通用对象">通用对象</h3>
<p>如果对存储区的请求不频繁，就可以用一组普通高速缓存来处理，普通高速缓存中的对象具有几何分布的大小，范围是32-131072字节。</p>
<p><code>kmalloc</code>用于获取这种对象： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得普通高速缓存中的对象。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title">kmalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (__builtin_constant_p(size)) &#123;<br>		<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 找size对应的几何分布大小值。</span><br><span class="hljs-comment">		 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CACHE(x) \</span><br><span class="hljs-meta">		<span class="hljs-keyword">if</span> (size &lt;= x) \</span><br><span class="hljs-meta">			goto found; \</span><br><span class="hljs-meta">		<span class="hljs-keyword">else</span> \</span><br><span class="hljs-meta">			i++;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kmalloc_sizes.h&quot;</span></span><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 运行到此，说明要分配的对象太大，不能分配这么大的对象。</span><br><span class="hljs-comment">		 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> CACHE</span><br>		&#123;<br>			<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> __you_cannot_kmalloc_that_much(<span class="hljs-type">void</span>);<br>			__you_cannot_kmalloc_that_much();<br>		&#125;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 请求分配的size对应的高速缓存描述符索引号为i</span><br><span class="hljs-comment">		 * 根据GFP_DMA，在不同的高速缓存描述符中分配对象。</span><br><span class="hljs-comment">		 */</span><br>found:<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">kmem_cache_alloc</span>((flags &amp; GFP_DMA) ?<br>			malloc_sizes[i].cs_dmacachep :<br>			malloc_sizes[i].cs_cachep, flags);<br>	&#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 主要走这里，只有内置的常量分配才会走上面</span><br><span class="hljs-comment">     */</span><br>	<span class="hljs-keyword">return</span> __kmalloc(size, flags);<br>&#125;<br><br><span class="hljs-type">void</span> * __kmalloc (<span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> flags)<br>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">cache_sizes</span> *csizep = malloc_sizes;<br>	<br>	<span class="hljs-comment">/* 在malloc_sizes表中为size匹配最近的2的幂数大小的内存 */</span><br>	<span class="hljs-keyword">for</span> (; csizep-&gt;cs_size; csizep++) &#123;<br>		<span class="hljs-keyword">if</span> (size &gt; csizep-&gt;cs_size)<br>			<span class="hljs-keyword">continue</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>		<span class="hljs-comment">/* This happens if someone tries to call</span><br><span class="hljs-comment">		 * kmem_cache_create(), or kmalloc(), before</span><br><span class="hljs-comment">		 * the generic caches are initialized.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">BUG_ON</span>(csizep-&gt;cs_cachep == <span class="hljs-literal">NULL</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-comment">/* 最终落实到__cache_alloc，GFP_DMA标志在这里处理，决定用csizep对应的dmacache还是级常规cache */</span><br>		<span class="hljs-keyword">return</span> __cache_alloc(flags &amp; GFP_DMA ?<br>			 csizep-&gt;cs_dmacachep : csizep-&gt;cs_cachep, flags);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 对应kfree:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放由kmalloc接口分配的内存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kfree</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *objp)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">kmem_cache_t</span> *c;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>	<span class="hljs-keyword">if</span> (!objp)<br>		<span class="hljs-keyword">return</span>;<br>	<span class="hljs-built_in">local_irq_save</span>(flags);<br>	<span class="hljs-built_in">kfree_debugcheck</span>(objp);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 通过((kmem_cache_t *)(pg)-&gt;lru.next)，可确定合适的高速缓存描述符。</span><br><span class="hljs-comment">	 */</span><br>	c = <span class="hljs-built_in">GET_PAGE_CACHE</span>(<span class="hljs-built_in">virt_to_page</span>(objp));<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * __cache_free释放高速缓存中的对象。</span><br><span class="hljs-comment">	 */</span><br>	__cache_free(c, (<span class="hljs-type">void</span>*)objp);<br>	<span class="hljs-built_in">local_irq_restore</span>(flags);<br>&#125;<br></code></pre></td></tr></table></figure>
这个就很简单了，拿到内存区所在的第一个页框描述符的<code>lru.next</code>字段，就可以确定合适的高速缓存描述符。最终落实到<code>__cache_free</code>释放。</p>
<h2 id="内存池-mempool_t">内存池 mempool_t</h2>
<p>动态内存最后的储备，内核手头保留的应急罐头。它和保留页框池显然是两回事。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存池描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mempool_s</span> &#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 用来保护对象字段的自旋锁。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">spinlock_t</span> lock;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 内存池中元素的最大个数。内存池元素的初始个数</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> min_nr;		<span class="hljs-comment">/* nr of elements at *elements */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 当前内存池中元素的个数。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> curr_nr;		<span class="hljs-comment">/* Current nr of elements at *elements */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 指向一个数组的指针，该数组由指向保留元素的指针组成。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span> **elements;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 池的拥有者可获得的私有数据。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span> *pool_data;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 分配一个元素的方法。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">mempool_alloc_t</span> *alloc;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 释放一个元素的方法。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">mempool_free_t</span> *free;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 当内存池为空时使用的等待队列。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">wait_queue_head_t</span> wait;<br>&#125; <span class="hljs-type">mempool_t</span>;<br></code></pre></td></tr></table></figure> ### 创建内存池 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建一个新内存池</span><br><span class="hljs-comment"> * min_nr-内存元素的个数。</span><br><span class="hljs-comment"> * alloc_fn,free_fn-分配和释放内存的方法地址。</span><br><span class="hljs-comment"> * pool_data-私有数据。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">mempool_t</span> * <span class="hljs-title">mempool_create</span><span class="hljs-params">(<span class="hljs-type">int</span> min_nr, <span class="hljs-type">mempool_alloc_t</span> *alloc_fn,</span></span><br><span class="hljs-params"><span class="hljs-function">				<span class="hljs-type">mempool_free_t</span> *free_fn, <span class="hljs-type">void</span> *pool_data)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">mempool_t</span> *pool;<br><br>	pool = <span class="hljs-built_in">kmalloc</span>(<span class="hljs-built_in">sizeof</span>(*pool), GFP_KERNEL);<br>	<span class="hljs-keyword">if</span> (!pool)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-built_in">memset</span>(pool, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(*pool));<br>	pool-&gt;elements = <span class="hljs-built_in">kmalloc</span>(min_nr * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *), GFP_KERNEL);<br>	<span class="hljs-keyword">if</span> (!pool-&gt;elements) &#123;<br>		<span class="hljs-built_in">kfree</span>(pool);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	<span class="hljs-built_in">spin_lock_init</span>(&amp;pool-&gt;lock);<br>	pool-&gt;min_nr = min_nr;<br>	pool-&gt;pool_data = pool_data;<br>	<span class="hljs-built_in">init_waitqueue_head</span>(&amp;pool-&gt;wait);<br>	pool-&gt;alloc = alloc_fn;<br>	pool-&gt;free = free_fn;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * First pre-allocate the guaranteed number of buffers.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">while</span> (pool-&gt;curr_nr &lt; pool-&gt;min_nr) &#123;<br>		<span class="hljs-type">void</span> *element;<br><br>		element = pool-&gt;<span class="hljs-built_in">alloc</span>(GFP_KERNEL, pool-&gt;pool_data);<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!element)) &#123;<br>			<span class="hljs-built_in">free_pool</span>(pool);<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>		&#125;<br>		<span class="hljs-built_in">add_element</span>(pool, element);<br>	&#125;<br>	<span class="hljs-keyword">return</span> pool;<br>&#125;<br></code></pre></td></tr></table></figure> ### 分配元素
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从内存池中分配一个元素</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">mempool_alloc</span><span class="hljs-params">(<span class="hljs-type">mempool_t</span> *pool, <span class="hljs-type">int</span> gfp_mask)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">void</span> *element;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>	<span class="hljs-built_in">DEFINE_WAIT</span>(wait);<br>	<span class="hljs-type">int</span> gfp_nowait = gfp_mask &amp; ~(__GFP_WAIT | __GFP_IO);<br><br>	<span class="hljs-built_in">might_sleep_if</span>(gfp_mask &amp; __GFP_WAIT);<br>repeat_alloc:<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 首先试图通过调用alloc函数从基本内存分配器分配一个内存元素。</span><br><span class="hljs-comment">	 */</span><br>	element = pool-&gt;<span class="hljs-built_in">alloc</span>(gfp_nowait|__GFP_NOWARN, pool-&gt;pool_data);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果从基本内存分配器中分配成功，就返回获得的内存元素而不涉及到内存池。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(element != <span class="hljs-literal">NULL</span>))<br>		<span class="hljs-keyword">return</span> element;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * If the pool is less than 50% full and we can perform effective</span><br><span class="hljs-comment">	 * page reclaim then try harder to allocate an element.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">mb</span>();<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 从基本内存池中分配元素失败，从内存池中分配。</span><br><span class="hljs-comment">	 */</span><br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果内存池中的对象太少，并且允许阻塞，就试图从基本内存分配器分配。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> ((gfp_mask &amp; __GFP_FS) &amp;&amp; (gfp_mask != gfp_nowait) &amp;&amp;<br>				(pool-&gt;curr_nr &lt;= pool-&gt;min_nr/<span class="hljs-number">2</span>)) &#123;<br>		element = pool-&gt;<span class="hljs-built_in">alloc</span>(gfp_mask, pool-&gt;pool_data);<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(element != <span class="hljs-literal">NULL</span>))<br>			<span class="hljs-keyword">return</span> element;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Kick the VM at this point.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">wakeup_bdflush</span>(<span class="hljs-number">0</span>);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 运行到此，就真的需要从内存池中取得元素了。</span><br><span class="hljs-comment">	 * 要么是从基本内存池中分配失败，要么是内存池中的元素还比较多。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">spin_lock_irqsave</span>(&amp;pool-&gt;lock, flags);<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(pool-&gt;curr_nr)) &#123;<br>		element = <span class="hljs-built_in">remove_element</span>(pool);<br>		<span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;pool-&gt;lock, flags);<br>		<span class="hljs-keyword">return</span> element;<br>	&#125;<br>	<span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;pool-&gt;lock, flags);<br><br>	<span class="hljs-comment">/* We must not sleep in the GFP_ATOMIC case */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 内存池中的对象也用完了。又不允许等待，那就返回NULL吧。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (!(gfp_mask &amp; __GFP_WAIT))<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 内存池中的元素用完了，但是允许等待，由于前面已经唤醒了守护进程。</span><br><span class="hljs-comment">	 * 现在需要的是让守护线程运行起来，调度一次。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">prepare_to_wait</span>(&amp;pool-&gt;wait, &amp;wait, TASK_UNINTERRUPTIBLE);<br>	<span class="hljs-built_in">mb</span>();<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 在真正调度出去前，再次判断一下curr_nr，是否有其他进程在开中断后释放了元素。</span><br><span class="hljs-comment">	 * 注意前面调用了mb()</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (!pool-&gt;curr_nr)<br>		<span class="hljs-built_in">io_schedule</span>();<br>	<span class="hljs-built_in">finish_wait</span>(&amp;pool-&gt;wait, &amp;wait);<br><br>	<span class="hljs-keyword">goto</span> repeat_alloc;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="释放元素">释放元素：</h3>
<p>mempool回收元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放一个元素到内存池。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mempool_free</span><span class="hljs-params">(<span class="hljs-type">void</span> *element, <span class="hljs-type">mempool_t</span> *pool)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>	<span class="hljs-built_in">mb</span>();<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果内存池未满，就将元素加入到内存池。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (pool-&gt;curr_nr &lt; pool-&gt;min_nr) &#123;<br>		<span class="hljs-built_in">spin_lock_irqsave</span>(&amp;pool-&gt;lock, flags);<br>		<span class="hljs-keyword">if</span> (pool-&gt;curr_nr &lt; pool-&gt;min_nr) &#123;<br>			<span class="hljs-built_in">add_element</span>(pool, element);<br>			<span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;pool-&gt;lock, flags);<br>			<span class="hljs-built_in">wake_up</span>(&amp;pool-&gt;wait);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;pool-&gt;lock, flags);<br>	&#125;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 否则释放到基本内存分配器中。</span><br><span class="hljs-comment">	 */</span><br>	pool-&gt;<span class="hljs-built_in">free</span>(element, pool-&gt;pool_data);<br>&#125;<br></code></pre></td></tr></table></figure></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux/" class="category-chain-item">Linux</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/linux-kernel/" class="print-no-link">#linux-kernel</a>
      
        <a href="/tags/ulk/" class="print-no-link">#ulk</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Linux内核学习——内存管理之内存区管理</div>
      <div>https://r00tk1ts.github.io/2017/10/24/Linux内存管理-内存区管理/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>r00tk1t</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2017年10月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2017/10/25/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/" title="Linux内核学习——内存管理之非连续内存区管理">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux内核学习——内存管理之非连续内存区管理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/10/20/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%A1%B5%E6%A1%86%E7%AE%A1%E7%90%86/" title="Linux内核学习——内存管理之页框管理">
                        <span class="hidden-mobile">Linux内核学习——内存管理之页框管理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/diy/yinghua.js"></script>
<script src="/js/diy/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
