

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="r00tk1t">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux内存管理非常复杂，从物理内存的分门别类，到内核用户态进程的索取，可以说是包罗万象。这一篇学习页框管理机制的设计以及透过源码了解一些技术细节。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核学习——内存管理之页框管理">
<meta property="og:url" content="https://r00tk1ts.github.io/2017/10/20/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%A1%B5%E6%A1%86%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="玉涵的技能书">
<meta property="og:description" content="Linux内存管理非常复杂，从物理内存的分门别类，到内核用户态进程的索取，可以说是包罗万象。这一篇学习页框管理机制的设计以及透过源码了解一些技术细节。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/10/20/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%A1%B5%E6%A1%86%E7%AE%A1%E7%90%86/20171020_1.jpg">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/10/20/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%A1%B5%E6%A1%86%E7%AE%A1%E7%90%86/20171020_2.jpg">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/10/20/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%A1%B5%E6%A1%86%E7%AE%A1%E7%90%86/20171020_4.jpg">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/10/20/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%A1%B5%E6%A1%86%E7%AE%A1%E7%90%86/20171020_3.jpg">
<meta property="article:published_time" content="2017-10-20T12:10:11.000Z">
<meta property="article:modified_time" content="2024-04-22T03:34:00.159Z">
<meta property="article:author" content="r00tk1t">
<meta property="article:tag" content="linux-kernel">
<meta property="article:tag" content="ulk">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://r00tk1ts.github.io/2017/10/20/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%A1%B5%E6%A1%86%E7%AE%A1%E7%90%86/20171020_1.jpg">
  
  
  
  <title>Linux内核学习——内存管理之页框管理 - 玉涵的技能书</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"r00tk1ts.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>玉涵的技能书</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/doc/">
                <i class="iconfont icon-books"></i>
                <span>藏经阁</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Linux内核学习——内存管理之页框管理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2017-10-20 20:10" pubdate>
          2017年10月20日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          53k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          442 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Linux内核学习——内存管理之页框管理</h1>
            
            
              <div class="markdown-body">
                
                <p>Linux内存管理非常复杂，从物理内存的分门别类，到内核用户态进程的索取，可以说是包罗万象。这一篇学习页框管理机制的设计以及透过源码了解一些技术细节。</p>
<span id="more"></span>
<h1 id="linux内存管理页框管理">Linux内存管理——页框管理</h1>
<p>在“内存寻址”一节中，我们知道了描述一个物理页的单位叫页框(page
frame)。页框的尺寸大小和硬件和Linux系统配置有关。对Intel来说，Linux采用4KB页框尺寸作为标准内存分配单元。</p>
<blockquote>
<ol type="1">
<li>开启PAE的情况下，为2MB。</li>
<li>如果开启了大页，那么页框尺寸为4MB。</li>
</ol>
</blockquote>
<p>页框之所以选择4KB大小，ULK给出了两方面原因：</p>
<ol type="1">
<li>分页系统造成的缺页异常很好解释，要么是页存在但process不被允许访问，要么是页不存在。如果不存在，内存分配器需要找一个free
4KB页框给process。（这样一来管理虚拟地址空间的分页系统的4KB单位与页框大小一致，处理起来也就省事。此外，关于缺页异常实际上也没这里描摹的那么简单，ULK这里的说法是高度抽象的。）</li>
<li>尽管4K和4M都是磁盘块尺寸的倍数，但内存和磁盘间往往传递小块更为的高效。（这是考虑到页的换入换出机制，磁盘IO比内存寻址慢的多，页越大那么单次执行换页操作就越耗时，这不难理解。）</li>
</ol>
<p>物理内存可以分成静态+动态两部分，其中静态部分永久保留，用于硬件和Linux内核代码/静态数据结构。动态内存部分则是Linux系统RT所使用和管理。</p>
<p>物理内存的动静态布局大致如此：</p>
<p><img src="20171020_1.jpg" srcset="/img/loading.gif" lazyload /></p>
<h2 id="内存模型">内存模型</h2>
<p>动态内存是如何管理的呢？这将牵扯到各个层面的管理模块，每个模块都足够复杂。在探索之前，我们先来搞清楚Linux在设计上如何抽象动态内存。</p>
<h3 id="平坦模式">平坦模式</h3>
<p>所谓平坦模式，是指物理地址空间连续没有空洞。这是最为理想化的模型，管理也简单。虚拟地址空间位于线性映射区域的页与物理地址空间的页帧一一对应，利用内核的某种映射机制来相互转换。</p>
<h3 id="非连续模式">非连续模式</h3>
<p>cpu访问物理内存，地址空间往往有着空洞。这种模式本质上是平坦模式的扩展，它相当于用空洞做间隔，把物理内存拆分成多个平坦空间，而虚拟地址空间就多了一个索引转换层，每个内存页需要去索引属于哪一块物理内存区。</p>
<blockquote>
<p>为什么设计上要自找麻烦呢？用平坦模式不好吗？当然是因为外因造成的，比如NUMA架构（详见下文）。</p>
</blockquote>
<h3 id="稀疏模式">稀疏模式</h3>
<p>这种模式就比较新潮了，是内核发展到现代所演变出来的一种模式。平坦模式是把物理页全部抽象成一片连续的地址空间，所有页page都在<code>mem_maps[]</code>中，而因为NUMA架构，物理内存空间不再连续，原本的单一<code>mem_maps[]</code>变成了<code>mem_maps[][]</code>，多了一个维度来索引某一块物理连续内存空间。而稀疏模式则在此基础上，引入了section的概念，每个section内部内存连续，而mem_map的page数组依附于section而不再依附于node(<code>struct pglist_data</code>)。</p>
<p>由于我们分析2.6.x内核，所以只会涉及到平坦和非连续模式，着重探索平坦模式，NUMA架构只是做一些介绍。</p>
<h2 id="物理内存的三个层次">物理内存的三个层次</h2>
<p>宏观上的设计大抵如此，但如果不了解微观上的各相关结构意义与耦合关系，读内核代码势必云里雾里。物理内存的管理上，有三个最为基础的数据结构：<code>struct page</code>,
<code>struct pg_data_t</code>和<code>struct zone</code> 。</p>
<h3 id="page">page</h3>
<p>内核记录了每个页框的状态：属于哪个进程；属于内核代码或数据结构；空闲等等。页框的状态保存在页描述符，其类型为<code>struct page</code>。内核把所有的页描述符都存在全局<code>mem_map</code>数组（通常存放在ZONE_NORMAL首部）。page是最为基本的存储单元，可以看成是字节数组，标准大小为4KB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Each physical page in the system has a struct page associated with</span><br><span class="hljs-comment"> * it to keep track of whatever it is we are using the page for at the</span><br><span class="hljs-comment"> * moment. Note that we have no way to track which tasks are using</span><br><span class="hljs-comment"> * a page.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> &#123;</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 一组标志，也对页框所在的管理区进行编号</span><br><span class="hljs-comment">	 * 在不支持NUMA的机器上，flags中字段中管理索引占两位，节点索引占一位。</span><br><span class="hljs-comment">	 * 在支持NUMA的32位机器上，flags中管理索引占用两位。节点数目占6位。</span><br><span class="hljs-comment">	 * 在支持NUMA的64位机器上，64位的flags字段中，管理区索引占用两位，节点数目占用10位。</span><br><span class="hljs-comment">	 * page_flags_t实际上是个无符号整型数</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">page_flags_t</span> flags;		<span class="hljs-comment">/* Atomic flags, some possibly</span><br><span class="hljs-comment">					 * updated asynchronously */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 页框的引用计数。当小于0表示没有人使用。</span><br><span class="hljs-comment">	 * Page_count返回_count+1表示正在使用的人数。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">atomic_t</span> _count;		<span class="hljs-comment">/* Usage count, see below. */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 页框中的页表项数目（没有则为-1）</span><br><span class="hljs-comment">	 *		-1:		表示没有页表项引用该页框。</span><br><span class="hljs-comment">	 *		0:		表明页是非共享的。</span><br><span class="hljs-comment">	 *		&gt;0:		表示而是共享的。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">atomic_t</span> _mapcount;		<span class="hljs-comment">/* Count of ptes mapped in mms,</span><br><span class="hljs-comment">					 * to show when page is mapped</span><br><span class="hljs-comment">					 * &amp; limit reverse map searches.</span><br><span class="hljs-comment">					 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 可用于正在使用页的内核成分（如在缓冲页的情况下，它是一个缓冲器头指针。）</span><br><span class="hljs-comment">	 * 如果页是空闲的，则该字段由伙伴系统使用。</span><br><span class="hljs-comment">	 * 当用于伙伴系统时，如果该页是一个2^k的空闲页块的第一个页，那么它的值就是k.</span><br><span class="hljs-comment">	 * 这样，伙伴系统可以查找相邻的伙伴，以确定是否可以将空闲块合并成2^(k+1)大小的空闲块。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;		<span class="hljs-comment">/* Mapping-private opaque data:</span><br><span class="hljs-comment">					 * usually used for buffer_heads</span><br><span class="hljs-comment">					 * if PagePrivate set; used for</span><br><span class="hljs-comment">					 * swp_entry_t if PageSwapCache</span><br><span class="hljs-comment">					 * When page is free, this indicates</span><br><span class="hljs-comment">					 * order in the buddy system.</span><br><span class="hljs-comment">					 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 当页被插入页高速缓存时使用或者当页属于匿名页时使用）。</span><br><span class="hljs-comment">	 * 		如果mapping字段为空，则该页属于交换高速缓存(swap cache)。</span><br><span class="hljs-comment">	 *		如果mapping字段不为空，且最低位为1，表示该页为匿名页。同时该字段中存放的是指向anon_vma描述符的指针。</span><br><span class="hljs-comment">	 *		如果mapping字段不为空，且最低位为0，表示该页为映射页。同时该字段指向对应文件的address_space对象。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *<span class="hljs-title">mapping</span>;</span>	<span class="hljs-comment">/* If low bit clear, points to</span><br><span class="hljs-comment">					 * inode address_space, or NULL.</span><br><span class="hljs-comment">					 * If page mapped as anonymous</span><br><span class="hljs-comment">					 * memory, low bit is set, and</span><br><span class="hljs-comment">					 * it points to anon_vma object:</span><br><span class="hljs-comment">					 * see PAGE_MAPPING_ANON below.</span><br><span class="hljs-comment">					 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 作为不同的含义被几种内核成分使用。</span><br><span class="hljs-comment">	 * 在页磁盘映象或匿名区中表示存放在页框中的数据的位置。</span><br><span class="hljs-comment">	 * 或者它存放在一个换出页标志符。</span><br><span class="hljs-comment">	 * 表示所有者的地址空间中以页大小为单位的偏移量，</span><br><span class="hljs-comment">	 * 也就是磁盘映像中页中数据的位置</span><br><span class="hljs-comment">	 * page-&gt;index是区域内的页索引或是页的线性地址除以PAGE_SIZE</span><br><span class="hljs-comment">	 * </span><br><span class="hljs-comment">	 * liufeng: </span><br><span class="hljs-comment">	 * 不是页内偏移量，而是该页面相对于文件起始位置，以页面为大小的偏移量</span><br><span class="hljs-comment">	 * 如果减去vma-&gt;vm_pgoff，就表示该页面的虚拟地址相对于vma起始地址，以页面为大小的偏移量</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">pgoff_t</span> index;			<span class="hljs-comment">/* Our offset within mapping. */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 包含页的最近最少使用的双向链表的指针。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">lru</span>;</span>		<span class="hljs-comment">/* Pageout list, eg. active_list</span><br><span class="hljs-comment">					 * protected by zone-&gt;lru_lock !</span><br><span class="hljs-comment">					 */</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * On machines where all RAM is mapped into kernel address space,</span><br><span class="hljs-comment">	 * we can simply calculate the virtual address. On machines with</span><br><span class="hljs-comment">	 * highmem some memory is mapped into kernel virtual memory</span><br><span class="hljs-comment">	 * dynamically, so we need a place to store that address.</span><br><span class="hljs-comment">	 * Note that this field could be 16 bits on x86 ... ;)</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * Architectures with slow multiplication can define</span><br><span class="hljs-comment">	 * WANT_PAGE_VIRTUAL in asm/page.h</span><br><span class="hljs-comment">	 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果进行了内存映射，就是内核虚拟地址。对存在高端内存的系统来说有意义。</span><br><span class="hljs-comment">	 * 否则是NULL</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span> *virtual;			<span class="hljs-comment">/* Kernel virtual address (NULL if</span><br><span class="hljs-comment">					   not kmapped, ie. highmem) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* WANT_PAGE_VIRTUAL */</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>每个页框都有一个page描述符，内部的各个字段与耦合的各个模块有关，比如buddy
system，lru
pageout链等。另外也可以看出内核设计上对空间的取用近乎苛刻，虽然不似WRK中充斥着大量的union语法（较新的内核4.x版本已经用union重写了，为了增强可读性），但同一个成员在不同的场景下其代表意义不同，并非单一职责。</p>
<p>此外，在Linux内核中，有个非常重要的全局指针变量<code>mem_map</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存映射数组。管理区描述符的zone_mem_map指向它的一个元素。</span><br><span class="hljs-comment"> * 用于伙伴系统。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">mem_map</span>;</span><br></code></pre></td></tr></table></figure>
<p>实际上是个flexible数组。</p>
<p>flags字段非常重要，取值非常多且意义深远：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">page_buf_flags_e</span> &#123;</span>		<span class="hljs-comment">/* pb_flags values */</span><br>	PBF_READ = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>),	<span class="hljs-comment">/* buffer intended for reading from device */</span><br>	PBF_WRITE = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>),	<span class="hljs-comment">/* buffer intended for writing to device   */</span><br>	PBF_MAPPED = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>),  <span class="hljs-comment">/* buffer mapped (pb_addr valid)           */</span><br>	PBF_PARTIAL = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>), <span class="hljs-comment">/* buffer partially read                   */</span><br>	PBF_ASYNC = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>),   <span class="hljs-comment">/* initiator will not wait for completion  */</span><br>	PBF_NONE = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>),    <span class="hljs-comment">/* buffer not read at all                  */</span><br>	PBF_DELWRI = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>),  <span class="hljs-comment">/* buffer has dirty pages                  */</span><br>	PBF_STALE = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>),	<span class="hljs-comment">/* buffer has been staled, do not find it  */</span><br>	PBF_FS_MANAGED = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>),  <span class="hljs-comment">/* filesystem controls freeing memory  */</span><br>	PBF_FS_DATAIOD = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">9</span>),  <span class="hljs-comment">/* schedule IO completion on fs datad  */</span><br>	PBF_FORCEIO = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>),    <span class="hljs-comment">/* ignore any cache state		   */</span><br>	PBF_FLUSH = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">11</span>),	    <span class="hljs-comment">/* flush disk write cache		   */</span><br>	PBF_READ_AHEAD = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">12</span>), <span class="hljs-comment">/* asynchronous read-ahead		   */</span><br><br>	<span class="hljs-comment">/* flags used only as arguments to access routines */</span><br>	PBF_LOCK = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>),       <span class="hljs-comment">/* lock requested			   */</span><br>	PBF_TRYLOCK = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">15</span>),    <span class="hljs-comment">/* lock requested, but do not wait	   */</span><br>	PBF_DONT_BLOCK = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>), <span class="hljs-comment">/* do not block in current thread	   */</span><br><br>	<span class="hljs-comment">/* flags used only internally */</span><br>	_PBF_PAGE_CACHE = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">17</span>),<span class="hljs-comment">/* backed by pagecache		   */</span><br>	_PBF_KMEM_ALLOC = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">18</span>),<span class="hljs-comment">/* backed by kmem_alloc()		   */</span><br>	_PBF_RUN_QUEUES = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">19</span>),<span class="hljs-comment">/* run block device task queue	   */</span><br>&#125; <span class="hljs-type">page_buf_flags_t</span>;<br></code></pre></td></tr></table></figure>
<p>参考ULK的释义： <img src="20171020_2.jpg" srcset="/img/loading.gif" lazyload /></p>
<p>flags包含了各个耦合模块上相对的意义，设计上也可以看得出来其枚举值是可以叠加而不交叉的。关于它们的意义，具体读到相关代码时再做阐述。</p>
<h3 id="node">node</h3>
<p>如果所有内存都是均质的，那么物理地址整个都是平坦的，一气呵成也就不需要进行分类，但现实中往往不是所有的内存都是均质的，不同架构寻址内存的不同空间速度是不同的（Alpha,mips,etc.）。所以内存的使用布局就很有讲究，2.6支持NUMA，物理内存被瓜分成多个nodes。不同的node中的page同一CPU访问速度是相同的。所以一个node就表示一种物理内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The pg_data_t structure is used in machines with CONFIG_DISCONTIGMEM</span><br><span class="hljs-comment"> * (mostly NUMA machines?) to denote a higher-level memory zone than the</span><br><span class="hljs-comment"> * zone denotes.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * On NUMA machines, each NUMA node would have a pg_data_t to describe</span><br><span class="hljs-comment"> * it&#x27;s memory layout.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Memory statistics and page replacement data structures are maintained on a</span><br><span class="hljs-comment"> * per-zone basis.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bootmem_data</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存管理结点描述符。每个描述符中的物理内存，对CPU来说，访问是一致的。</span><br><span class="hljs-comment"> * 但是每个管理结点又包含了不同的管理区。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pglist_data</span> &#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 节点管理区描述符数组</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">zone</span> node_zones[MAX_NR_ZONES];<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 页分配器使用的zonelist数据结构的数组。</span><br><span class="hljs-comment">	 * 实际上这个东西对NUMA来说意义非凡，它可以承载备用节点，在当前节点没有空间时使用备用</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">zonelist</span> node_zonelists[GFP_ZONETYPES];<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 节点中管理区的个数</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> nr_zones;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 节点中页描述符的数组</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *node_mem_map;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 用在内核初始化阶段</span><br><span class="hljs-comment">	 * 内存管理子系统初始化前，内核页需要使用内存</span><br><span class="hljs-comment">	 * 此结构用于这个阶段的内存管理，内核使用自举内存分配器</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">bootmem_data</span> *bdata;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 节点中第一个页框的下标。</span><br><span class="hljs-comment">	 * 系统中所有的页帧是依次编号的，每个页帧的号码都是全局唯一的</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_start_pfn;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 内存结点的大小，不包含空洞（以页为单位）</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_present_pages; <span class="hljs-comment">/* total number of physical pages */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 节点的大小，包括空洞</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_spanned_pages; <span class="hljs-comment">/* total size of physical page</span><br><span class="hljs-comment">					     range, including holes */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 节点标识符</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> node_id;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 内存节点链表的下一项。该字段构成node单链表。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">pglist_data</span> *pgdat_next;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * Kswapd页换出守护进程使用的等待队列</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">wait_queue_head_t</span> kswapd_wait;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 指针指向kswapd内核线程的进程描述符。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> *kswapd;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * Kswapd将要创建的空闲块大小取对数的值。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> kswapd_max_order;<br>&#125; <span class="hljs-type">pg_data_t</span>;<br></code></pre></td></tr></table></figure>
<p>每个node又可以分成多个zones，每个node有个类型为<code>pg_data_t</code>的描述符，所有node描述符都存储在单一链，第一个元素由<code>pgdat_list</code>变量所指向。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内核将物理内存分为几个结点。</span><br><span class="hljs-comment"> * 每个结点上的内存，对当前CPU来说，其访问时间是相等的。</span><br><span class="hljs-comment"> * pgdat_list是这些结点的单向列表。</span><br><span class="hljs-comment"> * 对x86来说，不支持NUMA，所以这个链表只有一个结点。这个结点保存在contig_page_data中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> *<span class="hljs-title">pgdat_list</span>;</span><br></code></pre></td></tr></table></figure>
<p>对于x86这种不支持NUMA的架构，node实际上只有一个，它在全局数组变量<code>contig_page_data</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 支持NUMA。</span><br><span class="hljs-comment"> * 对IBM来说，虽然并不真正需要NUMA支持，但是：即使NUMA的支持没有编译进内核，LINUX还是使用结点管理NUMA。</span><br><span class="hljs-comment"> * 不过，这是一个单独的结点。它包含了系统中所有的物理内存。</span><br><span class="hljs-comment"> * 这个元素由contig_page_data表示。它包含在一个只有一个结点的链表中，这个链表被pgdat_list指向。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> <span class="hljs-title">contig_page_data</span> =</span> &#123; .bdata = &amp;contig_bootmem_data &#125;;<br></code></pre></td></tr></table></figure>
<p>此外，<code>mem_map</code>在<code>node_alloc_mem_map</code>中被赋值，指向了<code>contig_page_data.node_mem_map</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __init <span class="hljs-title function_">node_alloc_mem_map</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pglist_data *pgdat)</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br><br>	size = (pgdat-&gt;node_spanned_pages + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> page);<br>	pgdat-&gt;node_mem_map = alloc_bootmem_node(pgdat, size);<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_DISCONTIGMEM</span><br>	mem_map = contig_page_data.node_mem_map;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>NUMA架构比UMA架构复杂得多，整个系统的内存由<code>node_data</code>这个<code>pg_data_t</code>数组管理，而UMA只有一个简单的<code>contig_page_data</code>。</p>
<p>可以用<code>NODE_DATA(node_id)</code>来查找编号为<code>node_id</code>的节点，对于UMA架构，node只有一个，所以该宏总是返回全局的<code>contig_page_data</code>。</p>
<p>本文只讨论UMA架构，在UMA系统中,
内存就相当于一个只使用一个NUMA节点来管理整个系统的内存。而内存管理的其他地方则认为他们就是在处理一个(伪)NUMA系统。</p>
<h3 id="zone">zone</h3>
<p>理想架构中，页框作为内存存储单元可以存储内核和用户数据，磁盘数据缓存等等。任何页数据都可以存在任何页框中，没有任何限制。然而真实的架构有着硬件限制。</p>
<p>Linux内核必须处理80x86架构的两个硬件限制： 1.
旧ISA总线的DMA处理器有一个严格的限制：它们只能寻址RAM的前16MB空间。 2.
现代32位计算机有很多RAM，CPU不能直接访问所有的物理内存，因为线性地址空间太小了。(内核线性地址只有3G到4G这1GB，而RAM当前比这大得多，设计成一对一肯定是不行的，所以映射机制是个复杂的大杂烩。)</p>
<p>为了应付这两个限制，Linux在80x86
UMA架构中分割物理内存node成3个zones。 - ZONE_DMA -
包含低16MB的内存页框，用于兼容旧ISA总线DMA处理器 - ZONE_NORMAL -
包含16MB到896MB的内存页框 - ZONE_HIGHMEM - 包含高于896MB的内存页框</p>
<p>ZONE_DMA给旧ISA总线设备用。ZONE_DMA和ZONE_NORMAL包含内存的常规页框，通过线性映射到4GB的线性地址空间，它们可以被内核直接使用。ZONE_HIGHMEM包含不能够直接访问的内存页框。此外，因为x64虚拟地址空间的膨胀，ZONE_HIGHMEN
zone在64bit机器上总是空的（没有存在的必要）。</p>
<p>不同的硬件架构node分成的zone类别也有所不同，但大体上来讲都有两个非常重要的zone，一个是直接线性映射的NORMAL区，比如x86上的16M到896M这一部分偏移量的物理内存可以直接映射到3G+16M到3G+896M的虚拟线性地址上。而HIGHMEM则比较复杂，它被各种机制安排到剩余的128MB（1024MB-896MB）（不同架构可能不一样）线性空间上（也就是靠近4G的最后128MB），这些机制我们过后再探索。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存管理区描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">zone</span> &#123;<br>	<span class="hljs-comment">/* Fields commonly accessed by the page allocator */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 管理区中空闲页的数目</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		free_pages;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * Pages_min-管理区中保留页的数目</span><br><span class="hljs-comment">	 * Page_low-回收页框使用的下界。同时也被管理区分配器为作为阈值使用。</span><br><span class="hljs-comment">	 * pages_high-回收页框使用的上界，同时也被管理区分配器作为阈值使用。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		pages_min, pages_low, pages_high;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * We don&#x27;t know if the memory that we&#x27;re going to allocate will be freeable</span><br><span class="hljs-comment">	 * or/and it will be released eventually, so to avoid totally wasting several</span><br><span class="hljs-comment">	 * GB of ram we must reserve some of the lower zone memory (otherwise we risk</span><br><span class="hljs-comment">	 * to run OOM on the lower zones despite there&#x27;s tons of freeable ram</span><br><span class="hljs-comment">	 * on the higher zones). This array is recalculated at runtime if the</span><br><span class="hljs-comment">	 * sysctl_lowmem_reserve_ratio sysctl changes.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 为内存不足保留的页框，分别为各种内存域指定了若干页</span><br><span class="hljs-comment">	 * 用于一些无论如何都不能失败的关键性内存分配</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		lowmem_reserve[MAX_NR_ZONES];<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 用于实现单一页框的特殊高速缓存。</span><br><span class="hljs-comment">	 * 每内存管理区对每CPU都有一个。包含热高速缓存和冷高速缓存。</span><br><span class="hljs-comment">	 * 内核使用这些列表来保存可用于满足实现的“新鲜”页。</span><br><span class="hljs-comment">	 * 有些页帧很可能在CPU高速缓存中，因此可以快速访问，称之为热。</span><br><span class="hljs-comment">	 * 未缓存的页帧称之为冷的。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pageset</span>	pageset[NR_CPUS];<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * free areas of different sizes</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 保护该描述符的自旋锁</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">spinlock_t</span>		lock;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 标识出管理区中的空闲页框块。</span><br><span class="hljs-comment">	 * 包含11个元素，被伙伴系统使用。分别对应大小的1,2,4,8,16,32,128,256,512,1024连续空闲块的链表。</span><br><span class="hljs-comment">	 * 第k个元素标识所有大小为2^k的空闲块。free_list字段指向双向循环链表的头。</span><br><span class="hljs-comment">	 * free_list是free_area的内部结构，是个双向环回链表节点。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">free_area</span>	free_area[MAX_ORDER];<br><br>	<span class="hljs-comment">/* </span><br><span class="hljs-comment">	 * 为了cache line对齐加的pad</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">ZONE_PADDING</span>(_pad1_)<br><br>	<span class="hljs-comment">/* Fields commonly accessed by the page reclaim scanner */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 活动以及非活动链表使用的自旋锁。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">spinlock_t</span>		lru_lock;	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 管理区中的活动页链表</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>	active_list;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 管理区中的非活动页链表。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>	inactive_list;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 回收内存时需要扫描的活动页数。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		nr_scan_active;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 回收内存时需要扫描的非活动页数目</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		nr_scan_inactive;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 管理区的活动链表上的页数目。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		nr_active;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 管理区的非活动链表上的页数目。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		nr_inactive;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 管理区内回收页框时使用的计数器。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		pages_scanned;	   <span class="hljs-comment">/* since last reclaim */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 在管理区中填满不可回收页时此标志被置位</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span>			all_unreclaimable; <span class="hljs-comment">/* All pages pinned */</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * prev_priority holds the scanning priority for this zone.  It is</span><br><span class="hljs-comment">	 * defined as the scanning priority at which we achieved our reclaim</span><br><span class="hljs-comment">	 * target at the previous try_to_free_pages() or balance_pgdat()</span><br><span class="hljs-comment">	 * invokation.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * We use prev_priority as a measure of how much stress page reclaim is</span><br><span class="hljs-comment">	 * under - it drives the swappiness decision: whether to unmap mapped</span><br><span class="hljs-comment">	 * pages.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * temp_priority is used to remember the scanning priority at which</span><br><span class="hljs-comment">	 * this zone was successfully refilled to free_pages == pages_high.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * Access to both these fields is quite racy even on uniprocessor.  But</span><br><span class="hljs-comment">	 * it is expected to average out OK.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 临时管理区的优先级。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> temp_priority;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 管理区优先级，范围在12和0之间。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> prev_priority;<br><br><br>	<span class="hljs-built_in">ZONE_PADDING</span>(_pad2_)<br>	<span class="hljs-comment">/* Rarely used or read-mostly fields */</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * wait_table		-- the array holding the hash table</span><br><span class="hljs-comment">	 * wait_table_size	-- the size of the hash table array</span><br><span class="hljs-comment">	 * wait_table_bits	-- wait_table_size == (1 &lt;&lt; wait_table_bits)</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * The purpose of all these is to keep track of the people</span><br><span class="hljs-comment">	 * waiting for a page to become available and make them</span><br><span class="hljs-comment">	 * runnable again when possible. The trouble is that this</span><br><span class="hljs-comment">	 * consumes a lot of space, especially when so few things</span><br><span class="hljs-comment">	 * wait on pages at a given time. So instead of using</span><br><span class="hljs-comment">	 * per-page waitqueues, we use a waitqueue hash table.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * The bucket discipline is to sleep on the same queue when</span><br><span class="hljs-comment">	 * colliding and wake all in that wait queue when removing.</span><br><span class="hljs-comment">	 * When something wakes, it must check to be sure its page is</span><br><span class="hljs-comment">	 * truly available, a la thundering herd. The cost of a</span><br><span class="hljs-comment">	 * collision is great, but given the expected load of the</span><br><span class="hljs-comment">	 * table, they should be so rare as to be outweighed by the</span><br><span class="hljs-comment">	 * benefits from the saved space.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * __wait_on_page_locked() and unlock_page() in mm/filemap.c, are the</span><br><span class="hljs-comment">	 * primary users of these fields, and in mm/page_alloc.c</span><br><span class="hljs-comment">	 * free_area_init_core() performs the initialization of them.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 进程等待队列的散列表。这些进程正在等待管理区中的某页。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">wait_queue_head_t</span>	* wait_table;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 等待队列散列表的大小。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		wait_table_size;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 等待队列散列表数组的大小。值为2^order</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		wait_table_bits;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Discontig memory support fields.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 内存节点。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">pglist_data</span>	*zone_pgdat;<br>	<span class="hljs-comment">/** </span><br><span class="hljs-comment">	 * 指向管理区的第一个页描述符的指针。这个指针是数组mem_map的一个元素。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span>		*zone_mem_map;<br>	<span class="hljs-comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 管理区的第一个页框的下标。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		zone_start_pfn;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 以页为单位的管理区的总大小，包含空洞。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		spanned_pages;	<span class="hljs-comment">/* total size, including holes */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 以页为单位的管理区的总大小，不包含空洞。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		present_pages;	<span class="hljs-comment">/* amount of memory (excluding holes) */</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * rarely used fields:</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 指针指向管理区的传统名称：DMA、NORMAL、HighMem</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">char</span>			*name;<br>&#125; ____cacheline_maxaligned_in_smp;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>由于 <code>struct zone</code> 结构经常被访问到,
因此这个数据结构要求以 <code>L1 Cache</code> 对齐. 另外, 这里的
<code>ZONE_PADDING( )</code> 让 <code>zone-&gt;lock</code> 和
<code>zone_lru_lock</code> 这两个很热门的锁可以分布在不同的
<code>Cahe Line</code> 中. 一个内存 <code>node</code> 节点最多也就几个
<code>zone</code>, 因此 <code>zone</code> 数据结构不需要像
<code>struct page</code> 一样关心数据结构的大小, 因此这里的
<code>ZONE_PADDING( )</code> 可以理解为用空间换取时间(性能).
在内存管理开发过程中, 内核开发者逐渐发现有一些自选锁竞争会非常厉害,
很难获取. 像 <code>zone-&gt;lock</code> 和
<code>zone-&gt;lru_lock</code> 这两个锁有时需要同时获取锁.
因此保证他们使用不同的 <code>Cache Line</code>
是内核常用的一种优化技巧.</p>
</blockquote>
<p>回过头看page，page中有到node和zone的链接，为了省空间，并没有设定单独的指针指向，而是编码成索引放在flags字段的高位(2.4.18前，page是有个指向zone的指针的，但page那么多，每个都浪费一个指针大小，浪费的内存还是相当可观的，对于linux这种性能癖，当然优化掉了)。源码中可以看到flags的标志数目是有限的，flags字段的高位可以用于编码特定node和zone号（对32位非NUMA，zone索引2位，node索引1位。（因为zone有3个而node只有1个））。</p>
<p>page_zone()接收一个page地址作为参数，读取flags中的最高位，通过查看zone_table来确定zone的地址：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收一个页描述符的地址作为它的参数，它读取页描述符的flags字段的高位，并通过zone_table数组来确定相应管理区描述符的地址</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zone</span> *<span class="hljs-built_in">page_zone</span>(<span class="hljs-keyword">struct</span> page *page)<br>&#123;<br>	<span class="hljs-keyword">return</span> zone_table[page-&gt;flags &gt;&gt; NODEZONE_SHIFT];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODEZONE_SHIFT (sizeof(page_flags_t)*8 - MAX_NODES_SHIFT - MAX_ZONES_SHIFT)</span><br><br><span class="hljs-comment">/* There are currently 3 zones: DMA, Normal &amp; Highmem, thus we need 2 bits */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ZONES_SHIFT		2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_DISCONTIGMEM</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pglist_data</span> contig_page_data;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_DATA(nid)		(&amp;contig_page_data)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_MEM_MAP(nid)	mem_map</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NODES_SHIFT		1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pfn_to_nid(pfn)		(0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* CONFIG_DISCONTIGMEM */</span></span><br><span class="hljs-comment">//只关心non-NUMA</span><br></code></pre></td></tr></table></figure>
内核调用内存分配函数时，必须指明请求page所在的zone。内核一般指明它想用的zone。内核使用<code>zonelist</code>数组指明首选的zone：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * One allocation request operates on a zonelist. A zonelist</span><br><span class="hljs-comment"> * is a list of zones, the first one is the &#x27;goal&#x27; of the</span><br><span class="hljs-comment"> * allocation, the other zones are fallback zones, in decreasing</span><br><span class="hljs-comment"> * priority.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Right now a zonelist takes up less than a cacheline. We never</span><br><span class="hljs-comment"> * modify it apart from boot-up, and only a few indices are used,</span><br><span class="hljs-comment"> * so despite the zonelist table being relatively big, the cache</span><br><span class="hljs-comment"> * footprint of this construct is very small.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">zonelist</span> &#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">zone</span> *zones[MAX_NUMNODES * MAX_NR_ZONES + <span class="hljs-number">1</span>]; <span class="hljs-comment">// NULL delimited</span><br>&#125;;<br></code></pre></td></tr></table></figure></p>
<p>可以看到<code>zonelist</code>不过是zone的一个集成，聚合了所有node的所有zone，它的内部究竟如何布局，具体分配时又如何使用等到阅读内存分配代码时再一探究竟。</p>
<h2 id="保留的页框池">保留的页框池</h2>
<p>一方面内存有时会不够用，一些操作会被阻塞到有其他内存free。另一方面内核的某些操作是非常不想阻塞的，所以折中的办法就是留一个保留区。保留内存的数量由<code>min_free_kbytes</code>决定，单位为KB。这个值可以动态修改，通过sysctl系统调用或者直接写/proc文件系统下的内核变量。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内核保留内存池大小。</span><br><span class="hljs-comment"> * 一般等于sqrt(16*内核直接映射内存大小)</span><br><span class="hljs-comment"> * 但是不能小于128也不能大于65536</span><br><span class="hljs-comment"> * 管理员可以通过写入/proc/sys/vm/min_free_kbytes来改变这个值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> min_free_kbytes = <span class="hljs-number">1024</span>;<br></code></pre></td></tr></table></figure></p>
<p>zone的<code>pages_min</code>存储管理区内保留页框的数目。连同<code>pages_low</code>，<code>pages_high</code>在页框回收算法中会用到。</p>
<h2 id="zoned-page-frame分配器">Zoned Page Frame分配器</h2>
<p>zoned page
frame分配器是一个内核子系统，处理一组连续的页框分配请求。</p>
<p><strong>概要：</strong>
分配器接收分配和释放请求。分配时，组件搜索包含连续page
frames的zone来满足请求。在每个zone内，page frames由组件"buddy
system"控制。为了得到更高的性能，少量的page
frames放在缓存中以满足多次对单个页面的分配请求。</p>
<h3 id="分配接口">分配接口</h3>
<p>分配页框可以使用6个不同的函数和宏，直接对照源码最易理解。</p>
<p>note：以下源码取非NUMA配置。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分配2^order个连续的页框。它返回第一个所分配页框描述符的地址或者返回NULL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> alloc_pages(gfp_mask, order) \</span><br><span class="hljs-meta">		alloc_pages_node(numa_node_id(), gfp_mask, order)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于获得一个单独页框的宏</span><br><span class="hljs-comment"> * 它返回所分配页框描述符的地址，如果失败，则返回NULL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)</span><br><br><span class="hljs-comment">/* 可以看出alloc_page就是alloc_pages的特例 */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 类似于alloc_pages，但是它返回第一个所分配页的线性地址。</span><br><span class="hljs-comment"> */</span><br>fastcall <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __get_free_pages(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gfp_mask, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> * page;<br>	page = <span class="hljs-built_in">alloc_pages</span>(gfp_mask, order);<br>	<span class="hljs-keyword">if</span> (!page)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  	<span class="hljs-comment">// 实际上是page-&gt;virtual</span><br>	<span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) <span class="hljs-built_in">page_address</span>(page);<br>&#125;<br><br><span class="hljs-comment">/* 可以看到__get_free_pages内部也是调用了alloc_pages，只是返回的page由page_address转成了线性地址 */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于获得一个单独页框的宏。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __get_free_page(gfp_mask) \</span><br><span class="hljs-meta">		__get_free_pages((gfp_mask),0)</span><br><span class="hljs-comment">/* __get_free_page亦是__get_free_pages的特例 */</span><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于获取填满0的页框。</span><br><span class="hljs-comment"> * 返回的是页框对应的虚拟地址VA</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">fastcall <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">get_zeroed_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gfp_mask)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> * page;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * get_zeroed_page() returns a 32-bit address, which cannot represent</span><br><span class="hljs-comment">	 * a highmem page</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">BUG_ON</span>(gfp_mask &amp; __GFP_HIGHMEM);<br><br>	page = <span class="hljs-built_in">alloc_pages</span>(gfp_mask | __GFP_ZERO, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">if</span> (page)<br>		<span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) <span class="hljs-built_in">page_address</span>(page);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 显然也是alloc_pages的特例，给定了__GFP_ZERO标志 */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于获得适用于dma的页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __get_dma_pages(gfp_mask, order) \</span><br><span class="hljs-meta">		__get_free_pages((gfp_mask) | GFP_DMA,(order))</span><br><br><span class="hljs-comment">/* 又是个特例，给定了GFP_DMA标志 */</span><br></code></pre></td></tr></table></figure></p>
<p>可以看出这一族alloc函数都是对<code>alloc_pages</code>的包装，做了些善后工作，传递了不同的参数。</p>
<p>所以最后的谜底就在于<code>alloc_pages</code>中的<code>alloc_pages_node</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *<span class="hljs-built_in">alloc_pages_node</span>(<span class="hljs-type">int</span> nid, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gfp_mask,<br>						<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(order &gt;= MAX_ORDER))<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-keyword">return</span> __alloc_pages(gfp_mask, order,<br>		<span class="hljs-built_in">NODE_DATA</span>(nid)-&gt;node_zonelists + (gfp_mask &amp; GFP_ZONEMASK));<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>alloc_pages_node</code>只是做心智健全检查，实际工作交给了<code>__alloc_pages</code>，注意参数中<code>zonelist</code>是通过<code>NODE_DATA(nid)</code>取出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> *<span class="hljs-title">node_data</span>[];</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_DATA(nid)		(node_data[nid])</span><br></code></pre></td></tr></table></figure>
<p>转去看看<code>__alloc_pages</code>这个内存区PF分配器的总入口函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 请求分配一组连续页框，它是管理区分配器的核心</span><br><span class="hljs-comment"> * gfp_mask：在内存分配请求中指定的标志</span><br><span class="hljs-comment"> * order：   连续分配的页框数量的对数(实际分配的是2^order个连续的页框)</span><br><span class="hljs-comment"> * zonelist: zonelist数据结构的指针。该结构按优先次序描述了适于内存分配的内存管理区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> * <span class="hljs-title">fastcall</span></span><br><span class="hljs-class">__<span class="hljs-title">alloc_pages</span>(<span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">gfp_mask</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>,</span><br><span class="hljs-class">		<span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> *<span class="hljs-title">zonelist</span>)</span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> wait = gfp_mask &amp; __GFP_WAIT;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> **<span class="hljs-title">zones</span>, *<span class="hljs-title">z</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reclaim_state</span> <span class="hljs-title">reclaim_state</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">p</span> =</span> current;<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-type">int</span> classzone_idx;<br>	<span class="hljs-type">int</span> do_retry;<br>	<span class="hljs-type">int</span> can_try_harder;<br>	<span class="hljs-type">int</span> did_some_progress;<br><br>	might_sleep_if(wait);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * The caller may dip into page reserves a bit more if the caller</span><br><span class="hljs-comment">	 * cannot run direct reclaim, or is the caller has realtime scheduling</span><br><span class="hljs-comment">	 * policy</span><br><span class="hljs-comment">	 */</span><br>	can_try_harder = (unlikely(rt_task(p)) &amp;&amp; !in_interrupt()) || !wait;<br><br>	zones = zonelist-&gt;zones;  <span class="hljs-comment">/* the list of zones suitable for gfp_mask */</span><br><br>	<span class="hljs-keyword">if</span> (unlikely(zones[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>)) &#123;<br>		<span class="hljs-comment">/* Should this ever happen?? */</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	classzone_idx = zone_idx(zones[<span class="hljs-number">0</span>]);<br><br> restart:<br>	<span class="hljs-comment">/* Go through the zonelist once, looking for a zone with enough free */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment"> 	 * 扫描包含在zonelist数据结构中的每个内存管理区</span><br><span class="hljs-comment">	 */</span><br>  	<span class="hljs-comment">/*</span><br><span class="hljs-comment">  	 * 这里可以看到对zonelist的扫描顺序，是按索引从前向后的。</span><br><span class="hljs-comment">  	 * 那么zonelist是如何布局的呢？如何为不同zone区分高低贵贱呢？</span><br><span class="hljs-comment">  	 * 对于UMA架构比较简单，因为只有单一node，在build_zonelists中可以一探究竟</span><br><span class="hljs-comment">  	 * 简单归纳来说，HIGHMEM最廉价、NORMAL次之，DMA最昂贵。</span><br><span class="hljs-comment">  	 */</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (z = zones[i]) != <span class="hljs-literal">NULL</span>; i++) &#123;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 对于每个内存管理区，该函数将空闲页框的个数与一个阀值进行比较</span><br><span class="hljs-comment">		 * 该值取决于内存分配标志、当前进程的类型及管理区被函数检查的次数。</span><br><span class="hljs-comment">		 * 实际上，如果空闲内存不足，那么每个内存管理区一般会被检查几次。</span><br><span class="hljs-comment">		 * 每一次在所请求的空闲内存最低量的基础上使用更低的值进行扫描。</span><br><span class="hljs-comment">		 * 因此，这段循环代码会被复制几次，而变化很小。</span><br><span class="hljs-comment">		 */</span><br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * zone_watermark_ok辅助函数接收几个参数，它们决定内存管理区中空闲页框个数的阀值min。</span><br><span class="hljs-comment">		 * 这是对内存管理区的第一次扫描，在第一次扫描中，阀值设置为z-&gt;pages_low</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (!zone_watermark_ok(z, order, z-&gt;pages_low,<br>				       classzone_idx, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 这个函数就是关键的分配函数，它杂糅了伙伴系统分配策略 + 本地CPU高速缓存</span><br><span class="hljs-comment">		 */</span><br>		page = buffered_rmqueue(z, order, gfp_mask);<br>		<span class="hljs-keyword">if</span> (page)<br>			<span class="hljs-keyword">goto</span> got_pg;<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 一般来说，应当在上一次扫描时得到内存。</span><br><span class="hljs-comment">	 * 运行到此，表示内存已经紧张了（xie.baoyou注：没有连续的页框可供分配了）</span><br><span class="hljs-comment">	 * 就唤醒kswapd内核线程来异步的开始回收页框。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (z = zones[i]) != <span class="hljs-literal">NULL</span>; i++)<br>		wakeup_kswapd(z, order);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Go through the zonelist again. Let __GFP_HIGH and allocations</span><br><span class="hljs-comment">	 * coming from realtime tasks to go deeper into reserves</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 执行对内存管理区的第二次扫描，将值z-&gt;pages_min作为阀值传入。这个值已经在上一步的基础上降低了（pages_low一般是pages_min的5/4，pages_high一般是pages_min的3/2）。</span><br><span class="hljs-comment">	 * 当然，实际的min值还是要由can_try_harder和gfp_high确定。z-&gt;pages_min仅仅是一个参考值而已。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (z = zones[i]) != <span class="hljs-literal">NULL</span>; i++) &#123;<br>		<span class="hljs-keyword">if</span> (!zone_watermark_ok(z, order, z-&gt;pages_min,<br>				       classzone_idx, can_try_harder,<br>				       gfp_mask &amp; __GFP_HIGH))<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 第二次扫描后，可能因为阈值的降低也可能因为异步的kswapd内核线程回收了页框</span><br><span class="hljs-comment">		 * 此时已经可以满足分配需求了</span><br><span class="hljs-comment">		 */</span><br>		page = buffered_rmqueue(z, order, gfp_mask);<br>		<span class="hljs-keyword">if</span> (page)<br>			<span class="hljs-keyword">goto</span> got_pg;<br>	&#125;<br><br>	<span class="hljs-comment">/* This allocation should allow future memory freeing. */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 上一步都还没有获得内存，系统内存肯定是不足了。</span><br><span class="hljs-comment">	 */</span><br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果产生内存分配的内核控制路径不是一个中断处理程序或者可延迟函数，</span><br><span class="hljs-comment">	 * 并且它试图回收页框（PF_MEMALLOC，TIF_MEMDIE标志被置位）,那么才对内存管理区进行第三次扫描。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (((p-&gt;flags &amp; PF_MEMALLOC) || unlikely(test_thread_flag(TIF_MEMDIE))) &amp;&amp; !in_interrupt()) &#123;<br>		<span class="hljs-comment">/* go through the zonelist yet again, ignoring mins */</span><br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (z = zones[i]) != <span class="hljs-literal">NULL</span>; i++) &#123;<br>			<span class="hljs-comment">/**</span><br><span class="hljs-comment">			 * 本次扫描就不调用zone_watermark_ok，它忽略阀值，这样才能从预留的页中分配页。</span><br><span class="hljs-comment">			 * 允许这样做，因为是这个进程想要归还页框，那就暂借一点给它吧（呵呵，舍不得孩子套不到狼）。</span><br><span class="hljs-comment">			 */</span><br>			page = buffered_rmqueue(z, order, gfp_mask);<br>			<span class="hljs-keyword">if</span> (page)<br>				<span class="hljs-keyword">goto</span> got_pg;<br>		&#125;<br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 老天保佑，不要运行到这里来，实在是没有内存了。</span><br><span class="hljs-comment">		 * 不论是高端内存区还是普通内存区、还是DMA内存区，甚至这些管理区中保留的内存都没有了。</span><br><span class="hljs-comment">		 * 意味着我们的家底都完了。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">goto</span> nopage;<br>	&#125;<br><br>	<span class="hljs-comment">/* Atomic allocations - we can&#x27;t balance anything */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果gfp_mask的__GFP_WAIT标志没有被置位，函数就返回NULL。你又不能等，实在没辙。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (!wait)<br>		<span class="hljs-keyword">goto</span> nopage;<br><br>rebalance:<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果当前进程能够被阻塞，调用cond_resched检查是否有其他进程需要CPU</span><br><span class="hljs-comment">	 */</span><br>	cond_resched();<br><br>	<span class="hljs-comment">/* We now go into synchronous reclaim */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 设置PF_MEMALLOC标志来表示进程已经准备好执行内存回收。</span><br><span class="hljs-comment">	 */</span><br>	p-&gt;flags |= PF_MEMALLOC;<br>	reclaim_state.reclaimed_slab = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 将reclaim_state数据结构指针存入reclaim_state。这个结构只包含一个字段reclaimed_slab，初始值为0</span><br><span class="hljs-comment">	 */</span><br>	p-&gt;reclaim_state = &amp;reclaim_state;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 调用try_to_free_pages寻找一些页框来回收。</span><br><span class="hljs-comment">	 * 这个函数可能会阻塞当前进程。一旦返回，就重设PF_MEMALLOC，并再次调用cond_resched</span><br><span class="hljs-comment">	 */</span><br>	did_some_progress = try_to_free_pages(zones, gfp_mask, order);<br><br>	p-&gt;reclaim_state = <span class="hljs-literal">NULL</span>;<br>	p-&gt;flags &amp;= ~PF_MEMALLOC;<br><br>	cond_resched();<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果已经回收了一些页框，那么执行第二遍扫描类似的操作。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (likely(did_some_progress)) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Go through the zonelist yet one more time, keep</span><br><span class="hljs-comment">		 * very high watermark here, this is only to catch</span><br><span class="hljs-comment">		 * a parallel oom killing, we must fail if we&#x27;re still</span><br><span class="hljs-comment">		 * under heavy pressure.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (z = zones[i]) != <span class="hljs-literal">NULL</span>; i++) &#123;<br>			<span class="hljs-keyword">if</span> (!zone_watermark_ok(z, order, z-&gt;pages_min,<br>					       classzone_idx, can_try_harder,<br>					       gfp_mask &amp; __GFP_HIGH))<br>				<span class="hljs-keyword">continue</span>;<br><br>			page = buffered_rmqueue(z, order, gfp_mask);<br>			<span class="hljs-keyword">if</span> (page)<br>				<span class="hljs-keyword">goto</span> got_pg;<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((gfp_mask &amp; __GFP_FS) &amp;&amp; !(gfp_mask &amp; __GFP_NORETRY)) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Go through the zonelist yet one more time, keep</span><br><span class="hljs-comment">		 * very high watermark here, this is only to catch</span><br><span class="hljs-comment">		 * a parallel oom killing, we must fail if we&#x27;re still</span><br><span class="hljs-comment">		 * under heavy pressure.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 没有释放任何页框，说明内核遇到很大麻烦了。因为内存少又不能释放页框。</span><br><span class="hljs-comment">		 * 如果允许杀死进程：__GFP_FS被置位并且__GFP_NORETRY标志为0。</span><br><span class="hljs-comment">		 * 那就开始准备杀死进程吧。</span><br><span class="hljs-comment">		 */</span><br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 再扫描一次内存管理区。</span><br><span class="hljs-comment">		 * 这样做有点莫名其妙，既然申请少一点的内存都不行，为什么还要传入z-&gt;pages_high？？它看起来更不会成功。</span><br><span class="hljs-comment">		 * 其实这样做还是有道理的：实际上，只有另一个内核控制路径已经杀死一个进程来回收它的内存后，这步才会成功。</span><br><span class="hljs-comment">		 * 因此，这步避免了两个（而不是一个）无辜的进程被杀死。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (z = zones[i]) != <span class="hljs-literal">NULL</span>; i++) &#123;<br>			<span class="hljs-keyword">if</span> (!zone_watermark_ok(z, order, z-&gt;pages_high,<br>					       classzone_idx, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>				<span class="hljs-keyword">continue</span>;<br><br>			page = buffered_rmqueue(z, order, gfp_mask);<br>			<span class="hljs-keyword">if</span> (page)<br>				<span class="hljs-keyword">goto</span> got_pg;<br>		&#125;<br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 还是不行，就杀死一些进程再试吧。</span><br><span class="hljs-comment">		 */</span><br>		out_of_memory(gfp_mask);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * let&#x27;s go on</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">goto</span> restart;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Don&#x27;t let big-order allocations loop unless the caller explicitly</span><br><span class="hljs-comment">	 * requests that.  Wait for some write requests to complete then retry.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * In this implementation, __GFP_REPEAT means __GFP_NOFAIL for order</span><br><span class="hljs-comment">	 * &lt;= 3, but that may not be true in other implementations.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果内存分配请求不能被满足，那么函数决定是否应当继续扫描内存管理区。</span><br><span class="hljs-comment">	 * 如果__GFP_NORETRY被清除，并且内存分配请求跨越了多达8个页框或者__GFP_REPEAT被置位，或者__GFP_NOFAIL被置位。</span><br><span class="hljs-comment">	 */</span><br>	do_retry = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span> (!(gfp_mask &amp; __GFP_NORETRY)) &#123;<br>		<span class="hljs-keyword">if</span> ((order &lt;= <span class="hljs-number">3</span>) || (gfp_mask &amp; __GFP_REPEAT))<br>			do_retry = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span> (gfp_mask &amp; __GFP_NOFAIL)<br>			do_retry = <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 要重试，就调用blk_congestion_wait 使进程休眠一会。再跳到rebalance 重试。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (do_retry) &#123;<br>		blk_congestion_wait(WRITE, HZ/<span class="hljs-number">50</span>);<br>		<span class="hljs-keyword">goto</span> rebalance;<br>	&#125;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 既然不用重试，那就执行到nopage 返回NULL 了。</span><br><span class="hljs-comment">	 */</span><br>nopage:<br>	<span class="hljs-keyword">if</span> (!(gfp_mask &amp; __GFP_NOWARN) &amp;&amp; printk_ratelimit()) &#123;<br>		printk(KERN_WARNING <span class="hljs-string">&quot;%s: page allocation failure.&quot;</span><br>			<span class="hljs-string">&quot; order:%d, mode:0x%x\n&quot;</span>,<br>			p-&gt;comm, order, gfp_mask);<br>		dump_stack();<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>got_pg:<br>	zone_statistics(zonelist, z);<br>	<span class="hljs-keyword">return</span> page;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Return 1 if free pages are above &#x27;mark&#x27;. This takes into account the order</span><br><span class="hljs-comment"> * of the allocation.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * zone_watermark_ok辅助函数接收几个参数，它们决定内存管理区中空闲页框个数的阀值min。</span><br><span class="hljs-comment"> * 特别的，如果满足下列两个条件，则该函数返回1：</span><br><span class="hljs-comment"> *     1、除了被分配的页框外，在内存管理区中至少还有min个空闲页框，不包括为内存不足保留的页框（zone的lowmem_reserve字段）。</span><br><span class="hljs-comment"> *     2、除了被分配的页框外，这里在order至少为k的块中，起码还有min/2^k个空闲页框。其中对每个k，取值在1和order之间。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 作为参数传递的基本值可以是内存管理区界值pages_min,pages_low,pages_high中的任意一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">zone_watermark_ok</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *z, <span class="hljs-type">int</span> order, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mark,</span><br><span class="hljs-params">		      <span class="hljs-type">int</span> classzone_idx, <span class="hljs-type">int</span> can_try_harder, <span class="hljs-type">int</span> gfp_high)</span><br>&#123;<br>	<span class="hljs-comment">/* free_pages my go negative - that&#x27;s OK */</span><br>	<span class="hljs-type">long</span> min = mark, free_pages = z-&gt;free_pages - (<span class="hljs-number">1</span> &lt;&lt; order) + <span class="hljs-number">1</span>; <span class="hljs-comment">/*free_pages是除了要分配的页框(1&lt;&lt;order)后剩余的空闲页面*/</span><br>	<span class="hljs-type">int</span> o;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果gfp_high标志被置位。则base除2。</span><br><span class="hljs-comment">	 * 注意这里不是：min /= 2;</span><br><span class="hljs-comment">	 * 一般来说，如果gfp_mask的__GFP_HIGH标志被置位，那么这个标志就会为1</span><br><span class="hljs-comment">	 * 换句话说，就是指从高端内存中分配。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (gfp_high)<br>		min -= min / <span class="hljs-number">2</span>;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果作为参数传递的can_try_harder标志被置位，这个值再减少1/4</span><br><span class="hljs-comment">	 * can_try_harder=1一般是当：gfp_mask中的__GFP_WAIT标志被置位，或者当前进程是一个实时进程并且在进程上下文中已经完成了内存分配。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (can_try_harder)<br>		min -= min / <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 除了被分配的页框外，在内存管理区中至少还有min个空闲页框，不包括为内存不足保留的页框（zone的lowmem_reserve字段）。</span><br><span class="hljs-comment">     */</span><br>	<span class="hljs-keyword">if</span> (free_pages &lt;= min + z-&gt;lowmem_reserve[classzone_idx])<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 除了被分配的页框外，这里在order至少为k的块中，起码还有min/2^k个空闲页框。其中对每个k，取值在1和order之间。</span><br><span class="hljs-comment">     */</span><br>	<span class="hljs-keyword">for</span> (o = <span class="hljs-number">0</span>; o &lt; order; o++) &#123;<br>		<span class="hljs-comment">/* At the next order, this order&#x27;s pages become unavailable */</span><br>		free_pages -= z-&gt;free_area[o].nr_free &lt;&lt; o;<br><br>		<span class="hljs-comment">/* Require fewer higher order pages to be free */</span><br>		min &gt;&gt;= <span class="hljs-number">1</span>;<br><br>		<span class="hljs-keyword">if</span> (free_pages &lt;= min)<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到整个zone的扫描策略非常复杂，但无论哪种情形，一旦满足了分配水位需求，就会调用</p>
<p><code>buffered_rmqueue</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回第一个被分配的页框的页描述符。如果内存管理区没有所请求大小的一组连续页框，则返回NULL。</span><br><span class="hljs-comment"> * 在指定的内存管理区中分配页框。它使用每CPU页框高速缓存来处理单一页框请求。</span><br><span class="hljs-comment"> * zone:内存管理区描述符的地址。</span><br><span class="hljs-comment"> * order：请求分配的内存大小的对数,0表示分配一个页框。</span><br><span class="hljs-comment"> * gfp_flags:分配标志，如果gfp_flags中的__GFP_COLD标志被置位，那么页框应当从冷高速缓存中获取，否则应当从热高速缓存中获取（只对单一页框请求有意义。）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<br><span class="hljs-title function_">buffered_rmqueue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">int</span> order, <span class="hljs-type">int</span> gfp_flags)</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-type">int</span> cold = !!(gfp_flags &amp; __GFP_COLD);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果order!=0，则每CPU页框高速缓存就不能被使用。</span><br><span class="hljs-comment">	 * 因为高速缓存仅限于单页分配，这是固有的设计，就是为了加速单页请求分配的效率。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (order == <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pages</span> *<span class="hljs-title">pcp</span>;</span><br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 检查由__GFP_COLD标志所标识的内存管理区本地CPU高速缓存是否需要被补充。</span><br><span class="hljs-comment">		 * 其count字段小于或者等于low</span><br><span class="hljs-comment">		 */</span><br>		pcp = &amp;zone-&gt;pageset[get_cpu()].pcp[cold];<br>		local_irq_save(flags);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 当前缓存中的页框数低于low，需要从伙伴系统中补充页框。</span><br><span class="hljs-comment">		 * 调用rmqueue_bulk函数从伙伴系统中分配batch个单一页框</span><br><span class="hljs-comment">		 * rmqueue_bulk反复调用__rmqueue，直到缓存的页框达到low。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (pcp-&gt;count &lt;= pcp-&gt;low)<br>			pcp-&gt;count += rmqueue_bulk(zone, <span class="hljs-number">0</span>,<br>						pcp-&gt;batch, &amp;pcp-&gt;<span class="hljs-built_in">list</span>);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 如果count为正，函数从高速缓存链表中获得一个页框。</span><br><span class="hljs-comment">		 * count减1</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (pcp-&gt;count) &#123;<br>			page = list_entry(pcp-&gt;<span class="hljs-built_in">list</span>.next, <span class="hljs-keyword">struct</span> page, lru);<br>			list_del(&amp;page-&gt;lru);<br>			pcp-&gt;count--;<br>		&#125;<br>		local_irq_restore(flags);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 没有和get_cpu配对使用呢？</span><br><span class="hljs-comment">		 * 这就是内核，外层一定调用了get_cpu。这种代码看起来头疼。</span><br><span class="hljs-comment">		 */</span><br>		put_cpu();<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 内存请求没有得到满足，或者是因为请求跨越了几个连续页框，或者是因为被选中的页框高速缓存为空。</span><br><span class="hljs-comment">	 * 调用__rmqueue函数(因为已经保护了，直接调用__rmqueue即可)从伙伴系统中分配所请求的页框。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (page == <span class="hljs-literal">NULL</span>) &#123;<br>		spin_lock_irqsave(&amp;zone-&gt;lock, flags);<br>		page = __rmqueue(zone, order);<br>		spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果内存请求得到满足，函数就初始化（第一个）页框的页描述符</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (page != <span class="hljs-literal">NULL</span>) &#123;<br>		BUG_ON(bad_range(zone, page));<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 将第一个页清除一些标志，将private字段置0，并将页框引用计数器置1。</span><br><span class="hljs-comment">		 */</span><br>		mod_page_state_zone(zone, pgalloc, <span class="hljs-number">1</span> &lt;&lt; order);<br>		prep_new_page(page, order);<br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 如果__GFP_ZERO标志被置位，则将被分配的区域填充0。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (gfp_flags &amp; __GFP_ZERO)<br>			prep_zero_page(page, order, gfp_flags);<br><br>		<span class="hljs-keyword">if</span> (order &amp;&amp; (gfp_flags &amp; __GFP_COMP))<br>			prep_compound_page(page, order);<br>	&#125;<br>	<span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>除了每CPU页框高速缓存的分配以外，重点就是<code>__rmqueue</code>这个函数，该函数实际上就是通往伙伴系统的分配接口。另一方面，每CPU页框高速缓存在分配时也会检查当前预存量的水位，如果不足也会调用相应的到伙伴系统的接口去批量申请页框。</p>
<p>关于伙伴系统的<code>__rmqueue</code>，我们过后再深入分析。</p>
<p>####Appendix</p>
<p><code>gfp_mask</code>flags:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * GFP bitmasks..</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Zone modifiers in GFP_ZONEMASK (see linux/mmzone.h - low two bits) */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所请求的页框必须处于ZONE_DMA管理区。等价于GFP_DMA</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_DMA	0x01</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所请求的页框处于ZONE_HIGHMEM管理区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_HIGHMEM	0x02</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Action modifiers - doesn&#x27;t change the zoning</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * __GFP_REPEAT: Try hard to allocate the memory, but the allocation attempt</span><br><span class="hljs-comment"> * _might_ fail.  This depends upon the particular VM implementation.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * __GFP_NOFAIL: The VM implementation _must_ retry infinitely: the caller</span><br><span class="hljs-comment"> * cannot handle allocation failures.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * __GFP_NORETRY: The VM implementation must not retry indefinitely.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 允许内核对等待空闲页框的当前进程进行阻塞</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_WAIT	0x10	<span class="hljs-comment">/* Can wait and reschedule? */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 允许内核访问保留的页框池</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_HIGH	0x20	<span class="hljs-comment">/* Should access emergency pools? */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 允许内核在低端内存上执行IO传输以释放页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_IO	0x40	<span class="hljs-comment">/* Can start physical IO? */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果清0,则不允许内核执行依赖于文件系统的操作。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_FS	0x80	<span class="hljs-comment">/* Can call down to low-level FS? */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所请求的页可能为&quot;冷&quot;的。即不在高速缓存中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_COLD	0x100	<span class="hljs-comment">/* Cache-cold page required */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一次内存分配失败将不会产生警告信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_NOWARN	0x200	<span class="hljs-comment">/* Suppress page allocation failure warning */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内核重试内存分配直到成功。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_REPEAT	0x400	<span class="hljs-comment">/* Retry the allocation.  Might fail */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 与__GFP_REPEAT相同</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_NOFAIL	0x800	<span class="hljs-comment">/* Retry for ever.  Cannot fail */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一次内存分配失败后不再重试。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_NORETRY	0x1000	<span class="hljs-comment">/* Do not retry.  Might fail */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Slab分配器不允许增大slab高速缓存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_NO_GROW	0x2000	<span class="hljs-comment">/* Slab internal usage */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 属于扩展页的页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_COMP	0x4000	<span class="hljs-comment">/* Add compound page metadata */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 任何返回的页框必须被填满0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_ZERO	0x8000	<span class="hljs-comment">/* Return zeroed page on success */</span></span><br></code></pre></td></tr></table></figure>
<p>###释放接口</p>
<p>再看释放：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先检查page指向的页描述符。</span><br><span class="hljs-comment"> * 如果该页框未被保留，就把描述符的count字段减1</span><br><span class="hljs-comment"> * 如果count变为0,就假定从与page对应的页框开始的2^order个连续页框不再被使用。</span><br><span class="hljs-comment"> * 这种情况下，该函数释放页框。</span><br><span class="hljs-comment"> */</span><br>fastcall <span class="hljs-type">void</span> __free_pages(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br>  	<span class="hljs-comment">/*</span><br><span class="hljs-comment">  	 * 如果是保留的页框或者引用计数-1不为0，则不用释放页框。</span><br><span class="hljs-comment">  	 * 前者是因为保留页框本来就不用释放（通过flags的PG_reserved位标识），</span><br><span class="hljs-comment">  	 * 后者是因为当前尚有进程引用该页框（比如经典的父子进程）</span><br><span class="hljs-comment">  	 */</span><br>	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PageReserved</span>(page) &amp;&amp; <span class="hljs-built_in">put_page_testzero</span>(page)) &#123;<br>		<span class="hljs-keyword">if</span> (order == <span class="hljs-number">0</span>)<br>			<span class="hljs-built_in">free_hot_page</span>(page);<br>		<span class="hljs-keyword">else</span><br>			__free_pages_ok(page, order);<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 类似于__free_pages，但是它接收的参数为要释放的第一个页框的线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">fastcall <span class="hljs-type">void</span> <span class="hljs-title">free_pages</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (addr != <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-built_in">BUG_ON</span>(!<span class="hljs-built_in">virt_addr_valid</span>((<span class="hljs-type">void</span> *)addr));<br>		__free_pages(<span class="hljs-built_in">virt_to_page</span>((<span class="hljs-type">void</span> *)addr), order);<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/* 和alloc相反，此时用virt_to_page来从线性地址到page进行转换，本质上调用依然是__free_pages */</span><br><br><span class="hljs-comment">/* 衍生出的另两个order为0的特例 */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放page指向的页框</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __free_page(page) __free_pages((page), 0)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放线性地址addr对应的页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> free_page(addr) free_pages((addr),0)</span><br></code></pre></td></tr></table></figure>
<p>所以还是看__free_pages，对于order为0的情况，最终cold参数为0进入free_hot_cold_page中：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> fastcall <span class="hljs-title">free_hot_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br>  	<span class="hljs-comment">// cold为0，表示是热高速缓存</span><br>	<span class="hljs-built_in">free_hot_cold_page</span>(page, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放单个页框到页框高速缓存。</span><br><span class="hljs-comment"> * page-要释放的页框描述符地址。</span><br><span class="hljs-comment"> * cold-释放到热高速缓存还是冷高速缓存中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> fastcall <span class="hljs-title">free_hot_cold_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">int</span> cold)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * page_zone从page-&gt;flag中，获得page所在的内存管理区描述符。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">zone</span> *zone = <span class="hljs-built_in">page_zone</span>(page);<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pages</span> *pcp;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>	<span class="hljs-built_in">arch_free_page</span>(page, <span class="hljs-number">0</span>);<br><br>	<span class="hljs-built_in">kernel_map_pages</span>(page, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-built_in">inc_page_state</span>(pgfree);<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">PageAnon</span>(page))<br>		page-&gt;mapping = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-built_in">free_pages_check</span>(__FUNCTION__, page);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 冷高速缓存还是热高速缓存??</span><br><span class="hljs-comment">	 */</span><br>	pcp = &amp;zone-&gt;pageset[<span class="hljs-built_in">get_cpu</span>()].pcp[cold];<br>	<span class="hljs-built_in">local_irq_save</span>(flags);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果缓存的页框太多，就清除一些。</span><br><span class="hljs-comment">	 * 调用free_pages_bulk将这些页框释放给伙伴系统。</span><br><span class="hljs-comment">	 * 当然，需要更新一下count计数。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (pcp-&gt;count &gt;= pcp-&gt;high)<br>		pcp-&gt;count -= <span class="hljs-built_in">free_pages_bulk</span>(zone, pcp-&gt;batch, &amp;pcp-&gt;list, <span class="hljs-number">0</span>);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 将释放的页框加到高速缓存链表上。并增加count字段。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">list_add</span>(&amp;page-&gt;lru, &amp;pcp-&gt;list);<br>	pcp-&gt;count++;<br>	<span class="hljs-built_in">local_irq_restore</span>(flags);<br>	<span class="hljs-built_in">put_cpu</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
对order为0也就是单页释放的情况，和分配时策略相同，都是最终释放到每CPU页框高速缓存。此外，释放时也会做相反的判断，如果当前预留量过多了，就还给伙伴系统一些。而释放给伙伴系统的核心在于<code>free_pages_bulk</code>，这涉及到伙伴系统的策略，过后再研究。</p>
<blockquote>
<p>到这里，透过代码也就不难看出，每CPU页框高速缓存的管理类似zone，也有自己的阈值，判断水位高低的策略，这与zone分配器的扫描策略十分相似。</p>
<p>更多详细可以展开每CPU页框高速缓存的结构体与内部函数，这里限于篇幅不展开了。</p>
</blockquote>
<p>对于order不为0的，核心也是<code>free_page_bulk</code>，说白了还是释放给伙伴系统：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> __free_pages_ok(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br>	<span class="hljs-built_in">LIST_HEAD</span>(list);<br>	<span class="hljs-type">int</span> i;<br><br>	<span class="hljs-built_in">arch_free_page</span>(page, order);<br><br>	<span class="hljs-built_in">mod_page_state</span>(pgfree, <span class="hljs-number">1</span> &lt;&lt; order);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><br>	<span class="hljs-keyword">if</span> (order &gt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span> ; i &lt; (<span class="hljs-number">1</span> &lt;&lt; order) ; ++i)<br>			__put_page(page + i);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> ; i &lt; (<span class="hljs-number">1</span> &lt;&lt; order) ; ++i)<br>		<span class="hljs-built_in">free_pages_check</span>(__FUNCTION__, page + i);<br>	<span class="hljs-built_in">list_add</span>(&amp;page-&gt;lru, &amp;list);<br>	<span class="hljs-built_in">kernel_map_pages</span>(page, <span class="hljs-number">1</span>&lt;&lt;order, <span class="hljs-number">0</span>);<br>	<span class="hljs-built_in">free_pages_bulk</span>(<span class="hljs-built_in">page_zone</span>(page), <span class="hljs-number">1</span>, &amp;list, order);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="appendix">Appendix</h4>
<p><code>virt_to_page</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将内核逻辑地址转换为相应的page结构指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) &gt;&gt; PAGE_SHIFT)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __pa(x)			((unsigned long)(x)-PAGE_OFFSET)		<span class="hljs-comment">//PAGE_OFFSET = 0xC0000000</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pfn_to_page(pfn)	(mem_map + (pfn))	<span class="hljs-comment">//由页框号+mem_map得到描述符page， mem_map就是存放page的数组，根据number索引</span></span><br></code></pre></td></tr></table></figure>
<h2 id="zone_highmem内核映射">ZONE_HIGHMEM内核映射</h2>
<p>high_memory变量存放HIGHMEM起始地址，设置为896M。896MB边界以上的page
frame无法直接映射在内核线性地址空间，因此内核无法直接访问。因此，<code>__get_free_pages</code>等函数对此情形并不适用（32位的系统中，因为<code>__get_free_pages()</code>无法返回一个不存在的线性地址（会溢出0xFFFFFFFF）转而返回NULL，会造成page
frame的丢失）。</p>
<p>为了32位系统内核可以使用HIGHMEM，做了一种映射的机制。约定如下： 1.
只用<code>alloc_pages</code>,<code>alloc_page</code>分配HIGHMEM的内存页框，虽然线性地址不存在，但是页描述符page的线性地址存在，这个东西在一开始就分配到NON-HIGHMEM区了。
2.
内核线性地址空间的最后128MB的一部分用于映射HIGHMEM的页框。线性地址对页框是一对多的，映射是暂时性的（如果都是永久的，那肯定不够用）。</p>
<p>当内核想访问高于896M的物理地址内存时，会从0xF8000000~0xFFFFFFFF空间范围内找一段相应大小空闲的地址空间，暂借一会儿，用毕归还。这就相当于坑位就那么多，大家轮着用。</p>
<p>内核有3种机制映射高端内存的页框：永久内核映射、临时内核映射和非连续内存分配。目前只关心前两种。</p>
<blockquote>
<p>实际上896M只是个上限值，不一定真的会分配这么多给NORMAL，毕竟有时候物理内存没有这么大，这个值会根据真实物理内存大小动态计算出来。</p>
</blockquote>
<p>内核1GB线性地址空间划分如图：</p>
<p><img src="20171020_4.jpg" srcset="/img/loading.gif" lazyload /></p>
<ul>
<li>PAGE_OFFSET ~ high_memory: 16~896MB直接映射</li>
<li>VMALLOC_START ~ VMALLOC_END: 非连续内存分配</li>
<li>KMAP_BASE ~ FIXADDR_START: 永久内核映射</li>
<li>FIXADDR_START ~
4GB:固定映射线性地址空间（FIX_KMAP区域为临时内核映射）</li>
</ul>
<h3 id="永久内核映射">永久内核映射</h3>
<p>在2.6内核上, 这个地址范围是4G-8M到4G-4M之间.
这个空间起叫”内核永久映射空间”或者”永久内核映射空间”,
这个空间和其它空间使用同样的页目录表，对于内核来说，就是
<code>swapper_pg_dir</code>，对普通进程来说，通过 CR3
寄存器指向。通常情况下，这个空间是 4M
大小，因此仅仅需要一个页表即可，内核通过来 <code>pkmap_page_table</code>
寻找这个页表。通过 <code>kmap()</code>，可以把一个 page
映射到这个空间来。由于这个空间是 4M 大小，最多能同时映射1024 个
page。因此，对于不使用的的
page，及应该时从这个空间释放掉（也就是解除映射关系），通过<code>kunmap()</code>，可以把一个
page 对应的线性地址从这个空间释放出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于建立永久内核映射的页表。</span><br><span class="hljs-comment"> * 这样，内核可以长期映射高端内存到内核地址空间中。</span><br><span class="hljs-comment"> * 页表中的表项数由LAST_PKMAP宏产生，取决于是否打开PAE，它的值可能是512或者1024，</span><br><span class="hljs-comment"> * 这样可能映射2MB或4MB的永久内核映射。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">pte_t</span> * pkmap_page_table;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Pkmap_count数组包含LAST_PKMAP个计数器，pkmap_page_table页表中每一项都有一个。</span><br><span class="hljs-comment"> * 它记录了永久内核映射使用了哪些页表项。</span><br><span class="hljs-comment"> * 它的值可能为：</span><br><span class="hljs-comment"> *	0：对应的页表项没有映射任何高端内存页框，并且是可用的。</span><br><span class="hljs-comment"> *	1：对应页表项没有映射任何高端内存，但是它仍然不可用。因为自从它最后一次使用以来，相应的TLB表还没有被刷新。</span><br><span class="hljs-comment"> *	&gt;1：相应的页表项映射了一个高端内存页框。并且正好有n-1个内核正在使用这个页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> pkmap_count[LAST_PKMAP];<br></code></pre></td></tr></table></figure>
<p>映射起始地址从PKMAP_BASE开始: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 永久内核映射的线性地址起始处。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PKMAP_BASE ( (FIXADDR_BOOT_START - PAGE_SIZE*(LAST_PKMAP + 1)) &amp; PMD_MASK )</span><br></code></pre></td></tr></table></figure></p>
<p>内核使用<code>page_address_htable</code>散列表记录高端内存页框和线性地址的关系：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 本散列表记录了高端内存页框与永久内核映射映射包含的线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">page_address_slot</span> &#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> lh;			<span class="hljs-comment">/* List of page_address_maps */</span><br>	<span class="hljs-type">spinlock_t</span> lock;			<span class="hljs-comment">/* Protect this bucket&#x27;s list */</span><br>&#125; ____cacheline_aligned_in_smp page_address_htable[<span class="hljs-number">1</span>&lt;&lt;PA_HASH_ORDER];<br></code></pre></td></tr></table></figure>
典型的list_head嵌入链表结构。实际上每个节点是<code>page_address_map</code>：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Describes one page-&gt;virtual association</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page_address_map</span> &#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page;<br>	<span class="hljs-type">void</span> *<span class="hljs-keyword">virtual</span>;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> list;<br>&#125;;<br></code></pre></td></tr></table></figure></p>
<p>####Appendix</p>
<p><code>page_address</code>函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * page_address返回页框对应的线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">page_address</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>	<span class="hljs-type">void</span> *ret;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page_address_slot</span> *pas;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果页框不在高端内存中(PG_highmem标志为0)，则线性地址总是存在的。</span><br><span class="hljs-comment">	 * 并且通过计算页框下标，然后将其转换成物理地址，最后根据物理地址得到线性地址。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PageHighMem</span>(page))<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 本句等价于__va((unsigned long)(page - mem_map) &lt;&lt; 12)</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">lowmem_page_address</span>(page);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 否则页框在高端内存中(PG_highmem标志为1)，则到page_address_htable散列表中查找。</span><br><span class="hljs-comment">	 */</span><br>	pas = <span class="hljs-built_in">page_slot</span>(page);<br>	ret = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-built_in">spin_lock_irqsave</span>(&amp;pas-&gt;lock, flags);<br>	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">list_empty</span>(&amp;pas-&gt;lh)) &#123;<br>		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page_address_map</span> *pam;<br><br>		<span class="hljs-built_in">list_for_each_entry</span>(pam, &amp;pas-&gt;lh, list) &#123;<br>			<span class="hljs-comment">/**</span><br><span class="hljs-comment">			 * 在page_address_htable中找到，返回对应的物理地址。</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-keyword">if</span> (pam-&gt;page == page) &#123;<br>				ret = pam-&gt;<span class="hljs-keyword">virtual</span>;<br>				<span class="hljs-keyword">goto</span> done;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 没有在page_address_htable中找到，返回默认值NULL。</span><br><span class="hljs-comment">	 */</span><br>done:<br>	<span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;pas-&gt;lock, flags);<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>kmap/kunmap</code>: 一目了然的设计 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 建立永久内核映射。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">kmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * kmap是允许睡眠的，意思是说不能在中断和可延迟函数中调用。</span><br><span class="hljs-comment">	 * 如果试图在中断中调用，那么might_sleep会触发异常。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">might_sleep</span>();<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果页框不属于高端内存，则调用page_address直接返回线性地址。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PageHighMem</span>(page))<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">page_address</span>(page);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 否则调用kmap_high真正建立永久内核映射。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">kmap_high</span>(page);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为高端内存建立永久内核映射。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> fastcall *<span class="hljs-title">kmap_high</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vaddr;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * For highmem pages, we can&#x27;t trust &quot;virtual&quot; until</span><br><span class="hljs-comment">	 * after we have the lock.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * We cannot call this from interrupts, as it may block</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 这个函数不会在中断中调用，也不能在中断中调用。</span><br><span class="hljs-comment">	 * 所以，在这里只需要获取自旋锁就行了。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">spin_lock</span>(&amp;kmap_lock);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * page_address有检查页框是否被映射的作用。</span><br><span class="hljs-comment">	 */</span><br>	vaddr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">page_address</span>(page);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 没有被映射，就调用map_new_virtual把页框的物理地址插入到pkmap_page_table的一个项中。</span><br><span class="hljs-comment">	 * 并在page_address_htable散列表中加入一个元素。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (!vaddr)<br>		vaddr = <span class="hljs-built_in">map_new_virtual</span>(page);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 使页框的线性地址所对应的计数器加1.</span><br><span class="hljs-comment">	 */</span><br>	pkmap_count[<span class="hljs-built_in">PKMAP_NR</span>(vaddr)]++;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 初次映射时,map_new_virtual中会将计数置为1,上一句再加1.</span><br><span class="hljs-comment">	 * 多次映射时,计数值会再加1.</span><br><span class="hljs-comment">	 * 总之,计数值决不会小于2.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (pkmap_count[<span class="hljs-built_in">PKMAP_NR</span>(vaddr)] &lt; <span class="hljs-number">2</span>)<br>		<span class="hljs-built_in">BUG</span>();<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 释放自旋锁.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">spin_unlock</span>(&amp;kmap_lock);<br>	<span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*) vaddr;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为建立永久内核映射建立初始映射.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">map_new_virtual</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vaddr;<br>	<span class="hljs-type">int</span> count;<br><br>start:<br>	count = LAST_PKMAP;<br>	<span class="hljs-comment">/* Find an empty entry */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 扫描pkmap_count中的所有计数器值,直到找到一个空值.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">for</span> (;;) &#123;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 从上次结束的地方开始搜索.</span><br><span class="hljs-comment">		 */</span><br>		last_pkmap_nr = (last_pkmap_nr + <span class="hljs-number">1</span>) &amp; LAST_PKMAP_MASK;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 搜索到最后一位了.在从0开始搜索前,刷新计数为1的项.</span><br><span class="hljs-comment">		 * 当计数值为1表示页表项可用,但是对应的TLB还没有刷新.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (!last_pkmap_nr) &#123;<br>			<span class="hljs-built_in">flush_all_zero_pkmaps</span>();<br>			count = LAST_PKMAP;<br>		&#125;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 找到计数为0的页表项,表示该页空闲且可用.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (!pkmap_count[last_pkmap_nr])<br>			<span class="hljs-keyword">break</span>;	<span class="hljs-comment">/* Found a usable entry */</span><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * count是允许的搜索次数.如果还允许继续搜索下一个页表项.则继续,否则表示没有空闲项,退出.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (--count)<br>			<span class="hljs-keyword">continue</span>;<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Sleep for somebody else to unmap their entries</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 运行到这里,表示没有找到空闲页表项.先睡眠一下.</span><br><span class="hljs-comment">		 * 等待其他线程释放页表项,然后唤醒本线程.</span><br><span class="hljs-comment">		 */</span><br>		&#123;<br>			<span class="hljs-built_in">DECLARE_WAITQUEUE</span>(wait, current);<br><br>			__set_current_state(TASK_UNINTERRUPTIBLE);<br>			<span class="hljs-comment">/**</span><br><span class="hljs-comment">			 * 将当前线程挂到pkmap_map_wait等待队列上.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-built_in">add_wait_queue</span>(&amp;pkmap_map_wait, &amp;wait);<br>			<span class="hljs-built_in">spin_unlock</span>(&amp;kmap_lock);<br>			<span class="hljs-built_in">schedule</span>();<br>			<span class="hljs-built_in">remove_wait_queue</span>(&amp;pkmap_map_wait, &amp;wait);<br>			<span class="hljs-built_in">spin_lock</span>(&amp;kmap_lock);<br><br>			<span class="hljs-comment">/* Somebody else might have mapped it while we slept */</span><br>			<span class="hljs-comment">/**</span><br><span class="hljs-comment">			 * 在当前线程等待的过程中,其他线程可能已经将页面进行了映射.</span><br><span class="hljs-comment">			 * 检测一下,如果已经映射了,就退出.</span><br><span class="hljs-comment">			 * 注意,这里没有对kmap_lock进行解锁操作.关于kmap_lock锁的操作,需要结合kmap_high来分析.</span><br><span class="hljs-comment">			 * 总的原则是:进入本函数时保证关锁,然后在本句前面关锁,本句后面解锁.</span><br><span class="hljs-comment">			 * 在函数返回后,锁仍然是关的.则外层解锁.</span><br><span class="hljs-comment">			 * 即使在本函数中循环也是这样.</span><br><span class="hljs-comment">			 * 内核就是这么乱,看久了就习惯了.不过你目前可能必须得学着适应这种代码.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">page_address</span>(page))<br>				<span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">page_address</span>(page);<br><br>			<span class="hljs-comment">/* Re-start */</span><br>			<span class="hljs-keyword">goto</span> start;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 不管何种路径运行到这里来,kmap_lock都是锁着的.</span><br><span class="hljs-comment">	 * 并且last_pkmap_nr对应的是一个空闲且可用的表项.</span><br><span class="hljs-comment">	 */</span><br>	vaddr = <span class="hljs-built_in">PKMAP_ADDR</span>(last_pkmap_nr);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 设置页表属性,建立虚拟地址和物理地址之间的映射.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">set_pte</span>(&amp;(pkmap_page_table[last_pkmap_nr]), <span class="hljs-built_in">mk_pte</span>(page, kmap_prot));<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 1表示相应的项可用,但是TLB需要刷新.</span><br><span class="hljs-comment">	 * 但是我们这里明明建立了映射,为什么还是可用的呢,其他地方不会将占用么?</span><br><span class="hljs-comment">	 * 其实不用担心,因为返回kmap_high后,kmap_high函数会将它再加1.</span><br><span class="hljs-comment">	 */</span><br>	pkmap_count[last_pkmap_nr] = <span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">set_page_address</span>(page, (<span class="hljs-type">void</span> *)vaddr);<br><br>	<span class="hljs-keyword">return</span> vaddr;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 撤销先前由kmap建立的永久内核映射</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kunmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * kmap和kunmap都不允许在中断中使用。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">in_interrupt</span>())<br>		<span class="hljs-built_in">BUG</span>();<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果对应页根本就不是高端内存，当然就没有进行内核映射，也就不用调用本函数了。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PageHighMem</span>(page))<br>		<span class="hljs-keyword">return</span>;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * kunmap_high真正执行unmap过程</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">kunmap_high</span>(page);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解除高端内存的永久内核映射</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> fastcall <span class="hljs-title">kunmap_high</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vaddr;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr;<br>	<span class="hljs-type">int</span> need_wakeup;<br><br>	<span class="hljs-built_in">spin_lock</span>(&amp;kmap_lock);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 得到物理页对应的虚拟地址。</span><br><span class="hljs-comment">	 */</span><br>	vaddr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">page_address</span>(page);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * vaddr会==0，可能是内存越界等严重故障了吧。</span><br><span class="hljs-comment">	 * BUG一下</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (!vaddr)<br>		<span class="hljs-built_in">BUG</span>();<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 根据虚拟地址，找到页表项在pkmap_count中的序号。</span><br><span class="hljs-comment">	 */</span><br>	nr = <span class="hljs-built_in">PKMAP_NR</span>(vaddr);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * A count must never go down to zero</span><br><span class="hljs-comment">	 * without a TLB flush!</span><br><span class="hljs-comment">	 */</span><br>	need_wakeup = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">switch</span> (--pkmap_count[nr]) &#123;<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>		<span class="hljs-built_in">BUG</span>();<span class="hljs-comment">/* 一定是逻辑错误了，多次调用了unmap */</span><br>	<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Avoid an unnecessary wake_up() function call.</span><br><span class="hljs-comment">		 * The common case is pkmap_count[] == 1, but</span><br><span class="hljs-comment">		 * no waiters.</span><br><span class="hljs-comment">		 * The tasks queued in the wait-queue are guarded</span><br><span class="hljs-comment">		 * by both the lock in the wait-queue-head and by</span><br><span class="hljs-comment">		 * the kmap_lock.  As the kmap_lock is held here,</span><br><span class="hljs-comment">		 * no need for the wait-queue-head&#x27;s lock.  Simply</span><br><span class="hljs-comment">		 * test if the queue is empty.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 页表项可用了。need_wakeup会唤醒等待队列上阻塞的线程。</span><br><span class="hljs-comment">		 */</span><br>		need_wakeup = <span class="hljs-built_in">waitqueue_active</span>(&amp;pkmap_map_wait);<br>	&#125;<br>	<span class="hljs-built_in">spin_unlock</span>(&amp;kmap_lock);<br><br>	<span class="hljs-comment">/* do wake-up, if needed, race-free outside of the spin lock */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 有等待线程，唤醒它。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (need_wakeup)<br>		<span class="hljs-built_in">wake_up</span>(&amp;pkmap_map_wait);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="临时内核映射">临时内核映射</h3>
<p>内核在 FIXADDR_START 到 FIXADDR_TOP
之间保留了一些线性空间用于特殊需求。这个空间称为”固定映射空间”在这个空间中，有一部分用于高端内存的临时映射。临时内核映射可以用在中断处理程序和可延迟函数内部，它们从不阻塞当前进程。</p>
<p>这块空间具有如下特点：</p>
<ol type="1">
<li>每个 CPU 占用一块空间</li>
<li>在每个 CPU 占用的那块空间中，又分为多个小空间，每个小空间大小是 1 个
page，每个小空间用于一个目的，这些目的定义在 kmap_types.h 中的
<code>km_type</code> 中。</li>
</ol>
<p>任一页框都可以通过一个窗口映射到内核地址空间，这些窗口非常少。</p>
<p>每个CPU有自己的13个窗口集合： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_HIGHMEM</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> D(n) __KM_FENCE_##n ,</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> D(n)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 系统为每个CPU预留了13个临时内核映射页表项。这是它们在线性地址表中的下标。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">km_type</span> &#123;<br><span class="hljs-built_in">D</span>(<span class="hljs-number">0</span>)	KM_BOUNCE_READ,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">1</span>)	KM_SKB_SUNRPC_DATA,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">2</span>)	KM_SKB_DATA_SOFTIRQ,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">3</span>)	KM_USER0,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">4</span>)	KM_USER1,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">5</span>)	KM_BIO_SRC_IRQ,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">6</span>)	KM_BIO_DST_IRQ,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">7</span>)	KM_PTE0,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">8</span>)	KM_PTE1,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">9</span>)	KM_IRQ0,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">10</span>)	KM_IRQ1,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">11</span>)	KM_SOFTIRQ0,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">12</span>)	KM_SOFTIRQ1,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">13</span>)	KM_TYPE_NR<br>&#125;;<br></code></pre></td></tr></table></figure>
同一窗口永不会被两个不同的控制路径同时使用。km_type的每个符号都只能由一种内核成分使用，并以此而命名。KM_TYPE_NR不是线性地址，而是CPU产生可用窗口的个数。</p>
<p>这些符号都只是线性地址的一个下标: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">fixed_addresses</span> &#123;<br>	FIX_HOLE,<br>	FIX_VSYSCALL,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_LOCAL_APIC</span><br>	FIX_APIC_BASE,	<span class="hljs-comment">/* local (CPU) APIC) -- required for SMP or not */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_IO_APIC</span><br>	FIX_IO_APIC_BASE_0,<br>	FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + MAX_IO_APICS<span class="hljs-number">-1</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_VISWS_APIC</span><br>	FIX_CO_CPU,	<span class="hljs-comment">/* Cobalt timer */</span><br>	FIX_CO_APIC,	<span class="hljs-comment">/* Cobalt APIC Redirection Table */</span> <br>	FIX_LI_PCIA,	<span class="hljs-comment">/* Lithium PCI Bridge A */</span><br>	FIX_LI_PCIB,	<span class="hljs-comment">/* Lithium PCI Bridge B */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_F00F_BUG</span><br>	FIX_F00F_IDT,	<span class="hljs-comment">/* Virtual mapping for IDT */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_CYCLONE_TIMER</span><br>	FIX_CYCLONE_TIMER, <span class="hljs-comment">/*cyclone timer register*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIGHMEM</span><br>	FIX_KMAP_BEGIN,	<span class="hljs-comment">/* reserved pte&#x27;s for temporary kernel mappings */</span><br>	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)<span class="hljs-number">-1</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ACPI_BOOT</span><br>	FIX_ACPI_BEGIN,<br>	FIX_ACPI_END = FIX_ACPI_BEGIN + FIX_ACPI_PAGES - <span class="hljs-number">1</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PCI_MMCONFIG</span><br>	FIX_PCIE_MCFG,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	__end_of_permanent_fixed_addresses,<br>	<span class="hljs-comment">/* temporary boot-time mappings, used before ioremap() is functional */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NR_FIX_BTMAPS	16</span><br>	FIX_BTMAP_END = __end_of_permanent_fixed_addresses,<br>	FIX_BTMAP_BEGIN = FIX_BTMAP_END + NR_FIX_BTMAPS - <span class="hljs-number">1</span>,<br>	FIX_WP_TEST,<br>	__end_of_fixed_addresses<br>&#125;;<br><br></code></pre></td></tr></table></figure>
所以每个CPU都有KM_TYPE_NR个固定的映射线性地址。</p>
<p>当要进行一次临时映射的时候，需要指定映射的目的，根据映射目的，可以找到对应的小空间，然后把这个空间的地址作为映射地址。这意味着一次临时映射会导致以前的映射被覆盖。通过
<code>kmap_atomic()</code>可实现临时映射:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 建立临时内核映射</span><br><span class="hljs-comment"> * type和CPU共同确定用哪个固定映射的线性地址映射请求页。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">kmap_atomic</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-keyword">enum</span> km_type type)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">enum</span> <span class="hljs-title class_">fixed_addresses</span> idx;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vaddr;<br><br>	<span class="hljs-comment">/* even !CONFIG_PREEMPT needs this, for in_atomic in do_page_fault */</span><br>	<span class="hljs-built_in">inc_preempt_count</span>();<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果被映射的页不属于高端内存，当然用不着映射。直接返回线性地址就行了。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PageHighMem</span>(page))<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">page_address</span>(page);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 通过type和CPU确定线性地址。</span><br><span class="hljs-comment">	 */</span><br>	idx = type + KM_TYPE_NR*<span class="hljs-built_in">smp_processor_id</span>();<br>	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_HIGHMEM</span><br>	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">pte_none</span>(*(kmap_pte-idx)))<br>		<span class="hljs-built_in">BUG</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 将线性地址与页表项建立映射。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">set_pte</span>(kmap_pte-idx, <span class="hljs-built_in">mk_pte</span>(page, kmap_prot));<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 当然，最后必须刷新一下TLB。然后才能返回线性地址。</span><br><span class="hljs-comment">	 */</span><br>	__flush_tlb_one(vaddr);<br><br>	<span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*) vaddr;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __fix_to_virt(x)	(FIXADDR_TOP - ((x) &lt;&lt; PAGE_SHIFT))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIXADDR_TOP	((unsigned long)__FIXADDR_TOP)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __FIXADDR_TOP	0xfffff000</span><br></code></pre></td></tr></table></figure>
<p>撤销<code>kunmap_atomic</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 撤销内核临时映射</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kunmap_atomic</span><span class="hljs-params">(<span class="hljs-type">void</span> *kvaddr, <span class="hljs-keyword">enum</span> km_type type)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_HIGHMEM</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vaddr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) kvaddr &amp; PAGE_MASK;<br>	<span class="hljs-keyword">enum</span> <span class="hljs-title class_">fixed_addresses</span> idx = type + KM_TYPE_NR*<span class="hljs-built_in">smp_processor_id</span>();<br><br>	<span class="hljs-keyword">if</span> (vaddr &lt; FIXADDR_START) &#123; <span class="hljs-comment">// FIXME</span><br>		<span class="hljs-built_in">dec_preempt_count</span>();<br>		<span class="hljs-built_in">preempt_check_resched</span>();<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (vaddr != __fix_to_virt(FIX_KMAP_BEGIN+idx))<br>		<span class="hljs-built_in">BUG</span>();<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * force other mappings to Oops if they&#x27;ll try to access</span><br><span class="hljs-comment">	 * this pte without first remap it</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 取消映射并刷新TLB</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">pte_clear</span>(kmap_pte-idx);<br>	__flush_tlb_one(vaddr);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 允许抢占，并检查调度点。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">dec_preempt_count</span>();<br>	<span class="hljs-built_in">preempt_check_resched</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>高端内存是物理内存的概念，无论何种映射，最终它映射到的是内核线性地址空间，和用户进程没有什么关系，不要混淆。</p>
<h2 id="buddy-system伙伴系统algorithm">Buddy
System（伙伴系统）Algorithm</h2>
<p>内存管理的经典问题：碎片化 两种解决方案： -
非连续空闲页框映射到连续的线性地址 -
定制一套体系处理空闲连续页框块，分配与回收</p>
<p>出于种种原因，Linux内核使用第二种方案（详见ULK，实际上一言以蔽之——第二种方案更契合Linux）。这个方案就是buddy
system。空闲页框分组为11个双向循环链表，每个链表存储大小为1,2,4,8,16,32,64,128,256,512,1024个连续的页框，形成块。每个块的第一个页框的首地址都是该块大小的整数倍。</p>
<p>涉及的数据结构主要是两个，前面提到的所有page数组mem_map以及free_area。
关于mem_map，前面初始化的代码中可以看到它是整个node的page集合。而对于每个zone的page，都是node的page也就是mem_map的子集。zone的zone_mem_map成员就是在mem_map中的起始成员。
另一方面，zone的free_area数组存储了这11个链(MAX_ORDER=11)。看一下free_area结构：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">free_area</span> &#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>	free_list;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		nr_free;<br>&#125;;<br></code></pre></td></tr></table></figure>
经典的list_head双向循环链表，该链表包含每个空闲页框块(2^k)的起始页框的page。指向链表中相邻元素的指针存放在page的lru字段中（lru在页非空闲时用于其它目的）。nr_free表示空闲块的个数。page中的private存放了块的order（private在非空闲时也用于其它目的）。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span>&#123;<br>	...<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 可用于正在使用页的内核成分（如在缓冲页的情况下，它是一个缓冲器头指针。）</span><br><span class="hljs-comment">	 * 如果页是空闲的，则该字段由伙伴系统使用。</span><br><span class="hljs-comment">	 * 当用于伙伴系统时，如果该页是一个2^k的空闲页块的第一个页，那么它的值就是k.</span><br><span class="hljs-comment">	 * 这样，伙伴系统可以查找相邻的伙伴，以确定是否可以将空闲块合并成2^(k+1)大小的空闲块。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-keyword">private</span>;		<span class="hljs-comment">/* Mapping-private opaque data:</span><br><span class="hljs-comment">					 * usually used for buffer_heads</span><br><span class="hljs-comment">					 * if PagePrivate set; used for</span><br><span class="hljs-comment">					 * swp_entry_t if PageSwapCache</span><br><span class="hljs-comment">					 * When page is free, this indicates</span><br><span class="hljs-comment">					 * order in the buddy system.</span><br><span class="hljs-comment">					 */</span><br>	...<br>&#125;;<br></code></pre></td></tr></table></figure></p>
<h3 id="alloc">alloc</h3>
<p><code>__rmqueue()</code>负责在zone中找空闲块，顺着上次看到的<code>__alloc_pages</code>看下去，<code>__alloc_pages()=&gt;buffered_rmqueue()=&gt;__rmqueue()</code>：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在管理区中找到一个空闲块。</span><br><span class="hljs-comment"> * 它需要两个参数：管理区描述符的地址和order。Order表示请求的空闲页块大小的对数值。</span><br><span class="hljs-comment"> * 如果页框被成功分配，则返回第一个被分配的页框的页描述符。否则返回NULL。</span><br><span class="hljs-comment"> * 本函数假设调用者已经禁止和本地中断并获得了自旋锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *__rmqueue(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">free_area</span> * area;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> current_order;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 从所请求的order开始，扫描每个可用块链表进行循环搜索。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;<br>		area = zone-&gt;free_area + current_order;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 对应的空闲块链表为空，在更大的空闲块链表中进行循环搜索。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">list_empty</span>(&amp;area-&gt;free_list))<br>			<span class="hljs-keyword">continue</span>;<br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 运行到此，说明有合适的空闲块。</span><br><span class="hljs-comment">		 */</span><br>		page = <span class="hljs-built_in">list_entry</span>(area-&gt;free_list.next, <span class="hljs-keyword">struct</span> page, lru);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 首先在空闲块链表中删除第一个页框描述符。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">list_del</span>(&amp;page-&gt;lru);<br>		<span class="hljs-built_in">rmv_page_order</span>(page);<br>		area-&gt;nr_free--;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 并减少空闲管理区的空闲页数量。</span><br><span class="hljs-comment">		 */</span><br>		zone-&gt;free_pages -= <span class="hljs-number">1UL</span> &lt;&lt; order;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 如果2^order空闲块链表中没有合适的空闲块，那么就是从更大的空闲链表中分配的。</span><br><span class="hljs-comment">		 * 将剩余的空闲块分散到合适的链表中去。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">expand</span>(zone, page, order, current_order, area);<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 直到循环结束都没有找到合适的空闲块，就返回NULL。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 由此也可以看到buddy
system的策略算法。优先在等尺寸链上找，如果找不到则采用类似glibc的“small
first，best
fit”策略，在更大的链上找，并进行切割。切割手法也很简单,简单来说，如果切割1024给256，那么切割后前512链到k=9的链，剩下的256链到k=8的链（都是基于page
frame对齐的，所以切割比glibc容易管理得多）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *<br><span class="hljs-built_in">expand</span>(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-keyword">struct</span> page *page,<br> 	<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-keyword">struct</span> free_area *area)<br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size = <span class="hljs-number">1</span> &lt;&lt; high;<br><br>	<span class="hljs-keyword">while</span> (high &gt; low) &#123;<br>		area--;<br>		high--;<br>		size &gt;&gt;= <span class="hljs-number">1</span>;<br>		<span class="hljs-built_in">BUG_ON</span>(<span class="hljs-built_in">bad_range</span>(zone, &amp;page[size]));<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 后半部分(page[size])加入free_area-&gt;free_list中，并设定order</span><br><span class="hljs-comment">         * 前半部分(page)，继续进行分裂或者返回</span><br><span class="hljs-comment">         */</span><br>		<span class="hljs-built_in">list_add</span>(&amp;page[size].lru, &amp;area-&gt;free_list);<br>		area-&gt;nr_free++;<br>		<span class="hljs-built_in">set_page_order</span>(&amp;page[size], high);<br>	&#125;<br>	<span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="free">free</h3>
<p>释放使用<code>__free_pages_bulk()</code>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 按照伙伴系统的策略释放页框。</span><br><span class="hljs-comment"> * page-被释放块中所包含的第一个页框描述符的地址。</span><br><span class="hljs-comment"> * zone-管理区描述符的地址。</span><br><span class="hljs-comment"> * order-块大小的对数。</span><br><span class="hljs-comment"> * base-纯粹由于效率的原因而引入。其实可以从其他三个参数计算得出。</span><br><span class="hljs-comment"> * 该函数假定调用者已经禁止本地中断并获得了自旋锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __free_pages_bulk (<span class="hljs-keyword">struct</span> page *page, <span class="hljs-keyword">struct</span> page *base,<br>		<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * page_idx包含块中第一个页框的下标。</span><br><span class="hljs-comment">	 * 这是相对于管理区中的第一个页框而言的。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_idx;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *coalesced;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * order_size用于增加管理区中空闲页框的计数器。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> order_size = <span class="hljs-number">1</span> &lt;&lt; order;<br><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(order))<br>		<span class="hljs-built_in">destroy_compound_page</span>(page, order);<br><br>	page_idx = page - base;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 大小为2^k的块，它的线性地址都是2^k * 2 ^ 12的整数倍。</span><br><span class="hljs-comment">	 * 相应的，它在管理区的偏移应该是2^k倍。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">BUG_ON</span>(page_idx &amp; (order_size - <span class="hljs-number">1</span>));<br>	<span class="hljs-built_in">BUG_ON</span>(<span class="hljs-built_in">bad_range</span>(zone, page));<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 增加管理区的空闲页数</span><br><span class="hljs-comment">	 */</span><br>	zone-&gt;free_pages += order_size;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 最多循环10 - order次。每次都将一个块和它的伙伴进行合并。</span><br><span class="hljs-comment">	 * 每次从最小的块开始，向上合并。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">while</span> (order &lt; MAX_ORDER<span class="hljs-number">-1</span>) &#123;<br>		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">free_area</span> *area;<br>		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *buddy;<br>		<span class="hljs-type">int</span> buddy_idx;<br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 最小块的下标。它是要合并的块的伙伴。</span><br><span class="hljs-comment">		 * 注意异或操作的用法，是如何用来寻找伙伴的。</span><br><span class="hljs-comment">		 * 相当于在page_idx加上或者减去1 &lt;&lt; order的距离就是buddy_idx</span><br><span class="hljs-comment">		 */</span><br>		buddy_idx = (page_idx ^ (<span class="hljs-number">1</span> &lt;&lt; order));<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 通过伙伴的下标找到页描述符的地址。</span><br><span class="hljs-comment">		 */</span><br>		buddy = base + buddy_idx;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">bad_range</span>(zone, buddy))<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 判断伙伴块是否是大小为order的空闲页框的第一个页。</span><br><span class="hljs-comment">		 * 首先，伙伴的第一个页必须是空闲的(_count == -1)</span><br><span class="hljs-comment">		 * 同时，必须属于动态内存(PG_reserved被清0,PG_reserved为1表示留给内核或者没有使用)</span><br><span class="hljs-comment">		 * 最后，其private字段必须是order</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">page_is_buddy</span>(buddy, order))<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 运行到这里，说明伙伴块可以与当前块合并。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-comment">/* Move the buddy up one level. */</span><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 伙伴将被合并，将它从现有链表中取下。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">list_del</span>(&amp;buddy-&gt;lru);<br>		area = zone-&gt;free_area + order;<br>		area-&gt;nr_free--;<br>		<span class="hljs-built_in">rmv_page_order</span>(buddy);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 计算parent_idx</span><br><span class="hljs-comment">         */</span><br>		page_idx &amp;= buddy_idx;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 将合并了的块再与它的伙伴进行合并。</span><br><span class="hljs-comment">		 */</span><br>		order++;<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 伙伴不能与当前块合并。</span><br><span class="hljs-comment">	 * 将块插入适当的链表，并以块大小的order更新第一个页框的private字段。</span><br><span class="hljs-comment">	 */</span><br>	coalesced = base + page_idx;<br>	<span class="hljs-built_in">set_page_order</span>(coalesced, order);<br>	<span class="hljs-built_in">list_add</span>(&amp;coalesced-&gt;lru, &amp;zone-&gt;free_area[order].free_list);<br>	zone-&gt;free_area[order].nr_free++;<br>&#125;<br></code></pre></td></tr></table></figure> 理解了buddy
system的策略，代码也就一目了然了。
调用链：<code>__free_pages()=&gt;__free_pages_ok()=&gt;free_pages_bulk()=&gt;__free_pages_bulk()</code>。</p>
<h2 id="cpu页框高速缓存">CPU页框高速缓存</h2>
<p>内核经常请求或释放单个页框（对应order=0的情况），为了提升性能，内存管理区定义了一个每CPU页框高速缓存用于包含一些预先分配的页框。我们先前在Zoned
Page Frame分配器中的分配和释放操作代码中已经看过了。
Linux为每个内存管理区和每CPU提供了两个高速缓存：热高速和冷高速。两种类型针对不同的请求而设计。</p>
<p>zone的<code>pageset</code>成员保存了两个高速缓存： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 管理区每CPU页框高速缓存描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pageset</span> &#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 热高速缓存和冷高速缓存。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pages</span> pcp[<span class="hljs-number">2</span>];	<span class="hljs-comment">/* 0: hot.  1: cold */</span><br>&#125; ____cacheline_aligned_in_smp;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存管理区页框高速缓存描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pages</span> &#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 高速缓存中的页框个数</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> count;		<span class="hljs-comment">/* number of pages in the list */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 下界，低于此就需要补充高速缓存。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> low;		<span class="hljs-comment">/* low watermark, refill needed */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 上界，高于此则向伙伴系统释放页框。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> high;		<span class="hljs-comment">/* high watermark, emptying needed */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 当需要增加或者减少高速缓存页框时，操作的页框个数。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> batch;		<span class="hljs-comment">/* chunk size for buddy add/remove */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 高速缓存中包含的页框描述符链表。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> list;	<span class="hljs-comment">/* the list of pages */</span><br>&#125;;<br></code></pre></td></tr></table></figure></p>
<h3 id="alloc-1">alloc</h3>
<p>回顾一下处理<code>order==0</code>时使用CPU页框高速缓存分配的场景：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回第一个被分配的页框的页描述符。如果内存管理区没有所请求大小的一组连续页框，则返回NULL。</span><br><span class="hljs-comment"> * 在指定的内存管理区中分配页框。它使用每CPU页框高速缓存来处理单一页框请求。</span><br><span class="hljs-comment"> * zone:内存管理区描述符的地址。</span><br><span class="hljs-comment"> * order：请求分配的内存大小的对数,0表示分配一个页框。</span><br><span class="hljs-comment"> * gfp_flags:分配标志，如果gfp_flags中的__GFP_COLD标志被置位，那么页框应当从冷高速缓存中获取，否则应当从热高速缓存中获取（只对单一页框请求有意义。）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *<br><span class="hljs-built_in">buffered_rmqueue</span>(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">int</span> order, <span class="hljs-type">int</span> gfp_flags)<br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-type">int</span> cold = !!(gfp_flags &amp; __GFP_COLD);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果order!=0，则每CPU页框高速缓存就不能被使用。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (order == <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pages</span> *pcp;<br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 检查由__GFP_COLD标志所标识的内存管理区本地CPU高速缓存是否需要被补充。</span><br><span class="hljs-comment">		 * 其count字段小于或者等于low</span><br><span class="hljs-comment">		 */</span><br>		pcp = &amp;zone-&gt;pageset[<span class="hljs-built_in">get_cpu</span>()].pcp[cold];<br>		<span class="hljs-built_in">local_irq_save</span>(flags);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 当前缓存中的页框数低于low，需要从伙伴系统中补充页框。</span><br><span class="hljs-comment">		 * 调用rmqueue_bulk函数从伙伴系统中分配batch个单一页框</span><br><span class="hljs-comment">		 * rmqueue_bulk反复调用__rmqueue，直到缓存的页框达到low。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (pcp-&gt;count &lt;= pcp-&gt;low)<br>			pcp-&gt;count += <span class="hljs-built_in">rmqueue_bulk</span>(zone, <span class="hljs-number">0</span>,<br>						pcp-&gt;batch, &amp;pcp-&gt;list);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 如果count为正，函数从高速缓存链表中获得一个页框。</span><br><span class="hljs-comment">		 * count减1</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-comment">/* 这就是分配的核心了，直接操作就行了，哪那么多__rmqueue，所以快 */</span><br>		<span class="hljs-keyword">if</span> (pcp-&gt;count) &#123;<br>			page = <span class="hljs-built_in">list_entry</span>(pcp-&gt;list.next, <span class="hljs-keyword">struct</span> page, lru);<br>			<span class="hljs-built_in">list_del</span>(&amp;page-&gt;lru);<br>			pcp-&gt;count--;<br>		&#125;<br>		<span class="hljs-built_in">local_irq_restore</span>(flags);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 没有和get_cpu配对使用呢？</span><br><span class="hljs-comment">		 * 这就是内核，外层一定调用了get_cpu。这种代码看起来头疼。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">put_cpu</span>();<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 内存请求没有得到满足，或者是因为请求跨越了几个连续页框，或者是因为被选中的页框高速缓存为空。</span><br><span class="hljs-comment">	 * 调用__rmqueue函数(因为已经保护了，直接调用__rmqueue即可)从伙伴系统中分配所请求的页框。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (page == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">spin_lock_irqsave</span>(&amp;zone-&gt;lock, flags);<br>		page = __rmqueue(zone, order);<br>		<span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;zone-&gt;lock, flags);<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果内存请求得到满足，函数就初始化（第一个）页框的页描述符</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (page != <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">BUG_ON</span>(<span class="hljs-built_in">bad_range</span>(zone, page));<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 将第一个页清除一些标志，将private字段置0，并将页框引用计数器置1。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">mod_page_state_zone</span>(zone, pgalloc, <span class="hljs-number">1</span> &lt;&lt; order);<br>		<span class="hljs-built_in">prep_new_page</span>(page, order);<br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 如果__GFP_ZERO标志被置位，则将被分配的区域填充0。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (gfp_flags &amp; __GFP_ZERO)<br>			<span class="hljs-built_in">prep_zero_page</span>(page, order, gfp_flags);<br><br>		<span class="hljs-keyword">if</span> (order &amp;&amp; (gfp_flags &amp; __GFP_COMP))<br>			<span class="hljs-built_in">prep_compound_page</span>(page, order);<br>	&#125;<br>	<span class="hljs-keyword">return</span> page;<br>&#125;<br><br><span class="hljs-comment">//展开看补充页框的操作，实际上也是通过__rmqueue操作的，通过拿到的page-&gt;lru链到传入的pcp-&gt;list：</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">rmqueue_bulk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order, </span></span><br><span class="hljs-params"><span class="hljs-function">			<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count, <span class="hljs-keyword">struct</span> list_head *list)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-type">int</span> allocated = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page;<br>	<br>	<span class="hljs-built_in">spin_lock_irqsave</span>(&amp;zone-&gt;lock, flags);<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>		page = __rmqueue(zone, order);<br>		<span class="hljs-keyword">if</span> (page == <span class="hljs-literal">NULL</span>)<br>			<span class="hljs-keyword">break</span>;<br>		allocated++;<br>		<span class="hljs-built_in">list_add_tail</span>(&amp;page-&gt;lru, list);<br>	&#125;<br>	<span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;zone-&gt;lock, flags);<br>	<span class="hljs-keyword">return</span> allocated;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="free-1">free</h3>
<p>再回顾一下free：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先检查page指向的页描述符。</span><br><span class="hljs-comment"> * 如果该页框未被保留，就把描述符的count字段减1</span><br><span class="hljs-comment"> * 如果count变为0,就假定从与page对应的页框开始的2^order个连续页框不再被使用。</span><br><span class="hljs-comment"> * 这种情况下，该函数释放页框。</span><br><span class="hljs-comment"> */</span><br>fastcall <span class="hljs-type">void</span> __free_pages(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br>	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PageReserved</span>(page) &amp;&amp; <span class="hljs-built_in">put_page_testzero</span>(page)) &#123;<br>		<span class="hljs-keyword">if</span> (order == <span class="hljs-number">0</span>)<br>			<span class="hljs-built_in">free_hot_page</span>(page);<br>		<span class="hljs-keyword">else</span><br>			__free_pages_ok(page, order);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>暂时只关心先对于<code>order==0</code>的情况处理(即高速缓存)：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> fastcall <span class="hljs-title">free_hot_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">free_hot_cold_page</span>(page, <span class="hljs-number">0</span>);<br>&#125;<br>	<br><span class="hljs-function"><span class="hljs-type">void</span> fastcall <span class="hljs-title">free_cold_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">free_hot_cold_page</span>(page, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">/* 这两个都是封装 */</span><br><span class="hljs-comment">/* core api */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放单个页框到页框高速缓存。</span><br><span class="hljs-comment"> * page-要释放的页框描述符地址。</span><br><span class="hljs-comment"> * cold-释放到热高速缓存还是冷高速缓存中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> fastcall <span class="hljs-title">free_hot_cold_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">int</span> cold)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * page_zone从page-&gt;flag中，获得page所在的内存管理区描述符。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">zone</span> *zone = <span class="hljs-built_in">page_zone</span>(page);<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pages</span> *pcp;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>	<span class="hljs-built_in">arch_free_page</span>(page, <span class="hljs-number">0</span>);<br><br>	<span class="hljs-built_in">kernel_map_pages</span>(page, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-built_in">inc_page_state</span>(pgfree);<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">PageAnon</span>(page))<br>		page-&gt;mapping = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-built_in">free_pages_check</span>(__FUNCTION__, page);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 冷高速缓存还是热高速缓存??</span><br><span class="hljs-comment">	 */</span><br>	pcp = &amp;zone-&gt;pageset[<span class="hljs-built_in">get_cpu</span>()].pcp[cold];<br>	<span class="hljs-built_in">local_irq_save</span>(flags);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果缓存的页框太多，就清除一些。</span><br><span class="hljs-comment">	 * 调用free_pages_bulk将这些页框释放给伙伴系统。</span><br><span class="hljs-comment">	 * 当然，需要更新一下count计数。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (pcp-&gt;count &gt;= pcp-&gt;high)<br>		pcp-&gt;count -= <span class="hljs-built_in">free_pages_bulk</span>(zone, pcp-&gt;batch, &amp;pcp-&gt;list, <span class="hljs-number">0</span>);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 将释放的页框加到高速缓存链表上。并增加count字段。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">list_add</span>(&amp;page-&gt;lru, &amp;pcp-&gt;list);<br>	pcp-&gt;count++;<br>	<span class="hljs-built_in">local_irq_restore</span>(flags);<br>	<span class="hljs-built_in">put_cpu</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id="总结">总结</h2>
<p>到此，关于页框的管理策略，从zoned alloc/free system到((per CPU
cache)+buddy
system)，一系列的算法已经了然于胸。物理内存的层层架构、支配与回收也就这么回事儿。</p>
<p>ULK的这张图很透彻： <img src="20171020_3.jpg" srcset="/img/loading.gif" lazyload /></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux/" class="category-chain-item">Linux</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/linux-kernel/" class="print-no-link">#linux-kernel</a>
      
        <a href="/tags/ulk/" class="print-no-link">#ulk</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Linux内核学习——内存管理之页框管理</div>
      <div>https://r00tk1ts.github.io/2017/10/20/Linux内存管理-页框管理/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>r00tk1t</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2017年10月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2017/10/24/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/" title="Linux内核学习——内存管理之内存区管理">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux内核学习——内存管理之内存区管理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/08/27/Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%92%A4%E9%94%80/" title="Linux内核学习——Linux进程的创建与撤销">
                        <span class="hidden-mobile">Linux内核学习——Linux进程的创建与撤销</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/diy/yinghua.js"></script>
<script src="/js/diy/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
