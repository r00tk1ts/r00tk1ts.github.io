

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="r00tk1t">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux内核的进程切换可谓精彩绝伦，遗憾的是，ULK对此的介绍不够详尽，而毛批中也是一带而过，所以一时云里雾里。本文是我参考了大量资料，反复研磨后对Linux内核中进程切换的一点理解。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核学习——Linux进程切换">
<meta property="og:url" content="https://r00tk1ts.github.io/2017/08/26/Linux%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/index.html">
<meta property="og:site_name" content="玉涵的技能书">
<meta property="og:description" content="Linux内核的进程切换可谓精彩绝伦，遗憾的是，ULK对此的介绍不够详尽，而毛批中也是一带而过，所以一时云里雾里。本文是我参考了大量资料，反复研磨后对Linux内核中进程切换的一点理解。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/08/26/Linux%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/20170826_1.jpg">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/08/26/Linux%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/20170826_2.jpg">
<meta property="og:image" content="https://r00tk1ts.github.io/2017/08/26/Linux%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/20170826_3.jpg">
<meta property="article:published_time" content="2017-08-26T02:20:11.000Z">
<meta property="article:modified_time" content="2024-04-22T03:34:00.161Z">
<meta property="article:author" content="r00tk1t">
<meta property="article:tag" content="linux-kernel">
<meta property="article:tag" content="ulk">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://r00tk1ts.github.io/2017/08/26/Linux%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/20170826_1.jpg">
  
  
  
  <title>Linux内核学习——Linux进程切换 - 玉涵的技能书</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"r00tk1ts.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>玉涵的技能书</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/doc/">
                <i class="iconfont icon-books"></i>
                <span>藏经阁</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Linux内核学习——Linux进程切换"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2017-08-26 10:20" pubdate>
          2017年8月26日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          101 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Linux内核学习——Linux进程切换</h1>
            
            
              <div class="markdown-body">
                
                <p>Linux内核的进程切换可谓精彩绝伦，遗憾的是，ULK对此的介绍不够详尽，而毛批中也是一带而过，所以一时云里雾里。本文是我参考了大量资料，反复研磨后对Linux内核中进程切换的一点理解。</p>
<span id="more"></span>
<h1 id="linux内核学习linux进程切换">Linux内核学习——Linux进程切换</h1>
<p>对于Linux这种分时操作系统来说，内核必须有能力挂起CPU正在运行的进程，以复杂的策略调度另外一个进程。这就是进程切换。在Linux中，这也常被称为任务切换或上下文切换。</p>
<blockquote>
<p>Linux的进程和任务是一回事，按我的理解，一般内核进程叫任务，用户进程叫进程。</p>
</blockquote>
<p>每个进程有自己的地址空间，相互隔离，而CPU是共享的。于是，进程切换时，CPU寄存器的L/S(Load
and
Save)大法需要内核来谨慎的完成。进一步说，折腾寄存器的这组数据叫硬件上下文，它是进程可执行上下文的一个子集。硬件上下文的一部分放在TSS段，剩余部分放在内核态堆栈。</p>
<p><font color="red">进程切换只发生在内核态!</font></p>
<h2 id="任务状态段">任务状态段</h2>
<p>TSS段在我另一篇文章中简单提到过(Linux内存寻址)，它用来存放硬件上下文。尽管Linux根本不使用硬件上下文切换，但还是强制它为系统中每个不同CPU创建一个TSS，原因有二：
-
x86的一个CPU从用户态切换到内核态时，它就从TSS中获取内核态堆栈的地址(中断和异常中的sysenter-&gt;系统调用)。
-
用户态进程试图通过in或out指令访问一个I/O端口时，CPU需要访问存在TSS的I/O许可权位图以检查该进程是否有访问端口的权利。</p>
<p>TSS的结构定义成tss_struct：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 描述TSS的格式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tss_struct</span> &#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>	back_link,__blh;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	esp0;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>	ss0,__ss0h;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	esp1;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>	ss1,__ss1h;	<span class="hljs-comment">/* ss1 is used to cache MSR_IA32_SYSENTER_CS */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	esp2;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>	ss2,__ss2h;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	__cr3;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	eip;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	eflags;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	eax,ecx,edx,ebx;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	esp;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	ebp;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	esi;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	edi;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>	es, __esh;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>	cs, __csh;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>	ss, __ssh;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>	ds, __dsh;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>	fs, __fsh;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>	gs, __gsh;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>	ldt, __ldth;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>	trace, io_bitmap_base;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * The extra 1 is there because the CPU will access an</span><br><span class="hljs-comment">	 * additional byte beyond the end of the IO permission</span><br><span class="hljs-comment">	 * bitmap. The extra byte must be all 1 bits, and must</span><br><span class="hljs-comment">	 * be within the limit.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	io_bitmap[IO_BITMAP_LONGS + <span class="hljs-number">1</span>];<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Cache the current maximum and the last task that used the bitmap:</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> io_bitmap_max;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_struct</span> *io_bitmap_owner;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * pads the TSS to be cacheline-aligned (size is 0x100)</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __cacheline_filler[<span class="hljs-number">35</span>];<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * .. and then another 0x100 bytes for emergency kernel stack</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack[<span class="hljs-number">64</span>];<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure>
<p>每次进程切换时，内核更新TSS的某些字段以便相应CPU控制单元可以安全检索到它需要的信息。因此，TSS反映了CPU上当前进程的特权级，但对于没有运行的进程来说，并未保留TSS（TSS跟随CPU而不是进程，这和intel的初衷不同）。</p>
<p>每个TSS有自己的8字节任务状态段描述符(TSSD)，放在GDT中，CPU的tr寄存器包含相应TSS的TSSD，同时包含两个隐藏的非编程字段：TSSD的Base和Limit域。关于这些的设计，可以参考我之前写的“Linux内存寻址”。</p>
<p>所以，Linux的TSS跟着CPU走，那么进程切换时，进程的硬件上下文就必须保存在别处。于是，Linux的每个进程描述符包含一个类型为thread_struct的thread字段，只要进程被换出，就把硬件上下文存于此。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程被切换出去后，内核把它的硬件上下文保存在这个结构中。</span><br><span class="hljs-comment"> * 它包含大部分CPU寄存器，但是不包含eax、ebx这样的通用寄存器,他们的值保留在内核堆栈中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_struct</span> &#123;<br><span class="hljs-comment">/* cached TLS descriptors. */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">desc_struct</span> tls_array[GDT_ENTRY_TLS_ENTRIES];<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	esp0;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	sysenter_cs;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	eip;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	esp;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	fs;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	gs;<br><span class="hljs-comment">/* Hardware debugging registers */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	debugreg[<span class="hljs-number">8</span>];  <span class="hljs-comment">/* %%db0-7 debug registers */</span><br><span class="hljs-comment">/* fault info */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	cr2, trap_no, error_code;<br><span class="hljs-comment">/* floating point info */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 为支持选择性装入FPU、MMX和XMM寄存器，引入此结构。</span><br><span class="hljs-comment">	 * 当切换进程时，将进程的这些寄存器保存在i387结构中。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">union</span> <span class="hljs-title class_">i387_union</span>	i387;<br><span class="hljs-comment">/* virtual 86 mode info */</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm86_struct</span> __user * vm86_info;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		screen_bitmap;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		v86flags, v86mask, saved_esp0;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		saved_fs, saved_gs;<br><span class="hljs-comment">/* IO permissions */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	*io_bitmap_ptr;<br><span class="hljs-comment">/* max allowed port in the bitmap, in bytes: */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	io_bitmap_max;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_THREAD  &#123;							\</span><br><span class="hljs-meta">	.vm86_info = NULL,						\</span><br><span class="hljs-meta">	.sysenter_cs = __KERNEL_CS,					\</span><br><span class="hljs-meta">	.io_bitmap_ptr = NULL,						\</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure>
<p>可以看到诸如eip，esp，fs，gs等寄存器放在了这里，但是一些通用的eax等寄存器却不在这里（他们在内核堆栈）。</p>
<h2 id="进程切换的入口">进程切换的入口</h2>
<p>进程切换只可能发生在schedule()函数中，这个函数涉及了复杂的调度策略，在选出一个合适的待换入进程后，执行进程切换。
本节，我们只关心进程切换。</p>
<p>进程切换本质上由两步组成：切换页全局目录以安装一个新的地址空间；切换内核态堆栈和硬件上下文。</p>
<p>忽略调度策略，schedule()对进程切换的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp">switch_tasks:<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 运行到这里，开始进行进程切换了。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (next == rq-&gt;idle)<br>		<span class="hljs-built_in">schedstat_inc</span>(rq, sched_goidle);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * prefetch提示CPU控制单元把next的进程描述符的第一部分字段的内容装入硬件高速缓存。</span><br><span class="hljs-comment">	 * 这改善了schedule的性能。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">prefetch</span>(next);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 清除TIF_NEED_RESCHED标志。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">clear_tsk_need_resched</span>(prev);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 记录CPU正在经历静止状态。主要与RCU相关。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">rcu_qsctr_inc</span>(<span class="hljs-built_in">task_cpu</span>(prev));<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 减少prev的平均睡眠时间</span><br><span class="hljs-comment">	 */</span><br>	prev-&gt;sleep_avg -= run_time;<br>	<span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)prev-&gt;sleep_avg &lt;= <span class="hljs-number">0</span>)<br>		prev-&gt;sleep_avg = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 更新进程的时间戳</span><br><span class="hljs-comment">	 */</span><br>	prev-&gt;timestamp = prev-&gt;last_ran = now;<br><br>	<span class="hljs-built_in">sched_info_switch</span>(prev, next);<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(prev != next)) &#123;<span class="hljs-comment">/* prev和next不同，需要切换 */</span><br>		next-&gt;timestamp = now;<br>		rq-&gt;nr_switches++;<br>		rq-&gt;curr = next;<br>		++*switch_count;<br><br>		<span class="hljs-built_in">prepare_arch_switch</span>(rq, next);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * context_switch执行真正的进程切换</span><br><span class="hljs-comment">		 */</span><br>		prev = <span class="hljs-built_in">context_switch</span>(rq, prev, next);<br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 当进程再次被切换进来后，以下代码被接着运行。</span><br><span class="hljs-comment">		 * 但是此时prev并不指向当前进程，而是指代码从哪一个进程切换到本进程。</span><br><span class="hljs-comment">		 * 由于此时已经进行了进程空间的切换，寄存器中缓存的变量等都不再有效，所以用barrier产生一个优化屏障。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">barrier</span>();<br><br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 对前一个进程进行一些收尾工作，比如减少它的mm_struct,task_struct的引用计数等。</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">finish_task_switch</span>(prev);<br>	&#125; <span class="hljs-keyword">else</span><span class="hljs-comment">/* 如果prev和next是同一个进程，就不做进程切换。当prev仍然是当前活动集合中的最高优先级进程时，这是有可能发生的。 */</span><br>		<span class="hljs-built_in">spin_unlock_irq</span>(&amp;rq-&gt;lock);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 在前几句中(context_switch之后)，prev代表的是从哪个进程切换到本进程。</span><br><span class="hljs-comment">	 * 在继续进行调度之前(因此在context_switch中开了中断，可能刚切回本进程就来了中断，并需要重新调度)，将prev设置成当前进程。</span><br><span class="hljs-comment">	 */</span><br>	prev = current;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 重新获得大内核锁。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(<span class="hljs-built_in">reacquire_kernel_lock</span>(prev) &lt; <span class="hljs-number">0</span>))<br>		<span class="hljs-keyword">goto</span> need_resched_nonpreemptible;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 打开抢占，并检查是否需要重新调度。</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">preempt_enable_no_resched</span>();<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 同时检查其他进程是否设置了当前进程的TIF_NEED_RESCHED标志，</span><br><span class="hljs-comment">	 * 如果是，则整个schedule()函数重新开始执行，否则函数结束</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(<span class="hljs-built_in">test_thread_flag</span>(TIF_NEED_RESCHED)))<br>		<span class="hljs-keyword">goto</span> need_resched;<br></code></pre></td></tr></table></figure>
<p>此时prev和next指向换出和换入的进程，进入context_switch函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * context_switch - switch to the new MM and the new</span><br><span class="hljs-comment"> * thread&#x27;s register state.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 建立next的地址空间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-type">task_t</span> * <span class="hljs-title">context_switch</span><span class="hljs-params">(<span class="hljs-type">runqueue_t</span> *rq, <span class="hljs-type">task_t</span> *prev, <span class="hljs-type">task_t</span> *next)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *mm = next-&gt;mm;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *oldmm = prev-&gt;active_mm;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果是切换到一个内核线程，新进程就使用pre的地址空间，避免了TLB的切换</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!mm)) &#123;<br>		next-&gt;active_mm = oldmm;<br>		<span class="hljs-built_in">atomic_inc</span>(&amp;oldmm-&gt;mm_count);<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * 作为更进一步的优化措施，如果新进程是内核线程，就将进程设置为懒惰TLB模式</span><br><span class="hljs-comment">		 * xie.baoyou注：请想一下，如果内核线程切换出去后，可能又会回到上一个进程，此时就根本不需要切换地址空间。</span><br><span class="hljs-comment">		 * 皆大欢喜，大家都省事了，这叫“懒人有懒福”</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">enter_lazy_tlb</span>(oldmm, next);<br>	&#125; <span class="hljs-keyword">else</span><span class="hljs-comment">/* 否则就需要切换内地址空间。 */</span><br>		switch_mm(oldmm, mm, next);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果上一个线程是内核线程或正在退出的进程，就把prev内存描述符的指针保存到运行队列的prev_mm中。</span><br><span class="hljs-comment">	 * 并清空rq-&gt;prev_mm</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!prev-&gt;mm)) &#123;<br>		prev-&gt;active_mm = <span class="hljs-literal">NULL</span>;<br>		<span class="hljs-built_in">WARN_ON</span>(rq-&gt;prev_mm);<br>		rq-&gt;prev_mm = oldmm;<br>	&#125;<br><br>	<span class="hljs-comment">/* Here we just switch the register state and the stack. */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 终于可以真正的切换了。</span><br><span class="hljs-comment">	 */</span>	<br>	switch_to(prev, next, prev);<br><br>	<span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="晦涩的switch_to">晦涩的switch_to</h2>
<p>这个switch_to是个宏，它很有意思，因为除了prev和next外，还有个last参数：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程切换时，切换内核态堆栈和硬件上下文。</span><br><span class="hljs-comment"> * prev-被替换的进程</span><br><span class="hljs-comment"> * next-新进程</span><br><span class="hljs-comment"> * last-在任何进程切换中，到三个进程而不是两个。假设内核决定暂停A而激活B，那么在schedule函数中，prev指向A而next指向B。</span><br><span class="hljs-comment"> *      当切换回A后，就必须暂停另外一个进程C。而LAST则指向C进程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> switch_to(prev,next,last) do &#123;					\</span><br><span class="hljs-meta">	unsigned long esi,edi;						\</span><br><span class="hljs-meta">	<span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="hljs-meta">	 * 在真正执行汇编代码前，已经将prev存入eax，next存入edx中了。</span></span><br><span class="hljs-comment"><span class="hljs-meta">	 */</span></span><br><br>				<span class="hljs-comment">/**</span><br><span class="hljs-comment">				 * 保存eflags和ebp到内核栈中。必须保存是因为编译器认为在switch_to结束前，</span><br><span class="hljs-comment">				 * 它们的值应当保持不变。</span><br><span class="hljs-comment">				 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;pushfl\n\t&quot;</span>					\</span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-string">&quot;pushl %%ebp\n\t&quot;</span>					\</span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      * 把esp的内容保存到prev-&gt;thread.esp中</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      * 这样该字段指向prev内核栈的栈顶。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      */</span></span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-string">&quot;movl %%esp,%0\n\t&quot;</span>	<span class="hljs-comment">/* save ESP */</span>		\</span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      * 将next-&gt;thread.esp装入到esp.</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      * 此时，内核开始在next的栈上进行操作。这条指令实际上完成了从prev到next的切换。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      * 由于进程描述符的地址和内核栈的地址紧挨着，所以改变内核栈意味着改变当前进程。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      */</span></span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-string">&quot;movl %5,%%esp\n\t&quot;</span>	<span class="hljs-comment">/* restore ESP */</span>	\</span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      * 将标记为1f的地址存入prev-&gt;thread.eip.</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      * 当被替换的进程重新恢复执行时，进程执行被标记为1f的那条指令。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      */</span></span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-string">&quot;movl $1f,%1\n\t&quot;</span>		<span class="hljs-comment">/* save EIP */</span>		\</span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      * 将next-&gt;thread.eip的值保存到next的内核栈中。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      * 这样，_switch_to调用ret返回时，就会跳转到next-&gt;thread.eip执行。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      * 这个地址一般情况下就会是1f.</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      */</span></span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-string">&quot;pushl %6\n\t&quot;</span>		<span class="hljs-comment">/* restore EIP */</span>	\</span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      * 注意，这里不是用call，是jmp，这样，上一条语句中压入的eip地址就可以执行了。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      */</span></span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-string">&quot;jmp __switch_to\n&quot;</span>				\</span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      * 到这里，进程A再次获得CPU。它从栈中弹出ebp和eflags。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">		      */</span></span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-string">&quot;1:\t&quot;</span>						\</span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-string">&quot;popl %%ebp\n\t&quot;</span>					\</span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-string">&quot;popfl&quot;</span>						\</span></span><br><span class="hljs-params"><span class="hljs-function">		     :<span class="hljs-string">&quot;=m&quot;</span> (prev-&gt;thread.esp),<span class="hljs-string">&quot;=m&quot;</span> (prev-&gt;thread.eip),	\</span></span><br><span class="hljs-params"><span class="hljs-function">		     <span class="hljs-comment">/* last被作为输出参数，它的值会由eax赋给它。 */</span></span></span><br><span class="hljs-params"><span class="hljs-function">		      <span class="hljs-string">&quot;=a&quot;</span> (last),<span class="hljs-string">&quot;=S&quot;</span> (esi),<span class="hljs-string">&quot;=D&quot;</span> (edi)			\</span></span><br><span class="hljs-params"><span class="hljs-function">		     :<span class="hljs-string">&quot;m&quot;</span> (next-&gt;thread.esp),<span class="hljs-string">&quot;m&quot;</span> (next-&gt;thread.eip),	\</span></span><br><span class="hljs-params"><span class="hljs-function">		      <span class="hljs-string">&quot;2&quot;</span> (prev), <span class="hljs-string">&quot;d&quot;</span> (next))</span></span>;				\<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></p>
<p>这个宏是用AT&amp;T汇编语法写的，不是很好理解，虽然上述代码根据ULK的描述，已一一按桩插入，但我们还是展开成最终反汇编码说明。</p>
<blockquote>
<p>AT&amp;T汇编语法的基础知识，可以参考毛批的第一章。</p>
</blockquote>
<ol type="1">
<li>eax和edx分别保存prev和next: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">movl prev, %eax<br>movl next, %edx<br></code></pre></td></tr></table></figure></li>
<li>eflags和ebp保存到prev的内核堆栈： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">pushfl<br>pushl %ebp<br></code></pre></td></tr></table></figure></li>
<li>把esp的内容保存到prev-&gt;thread.esp中使得该字段指向prev内核堆栈栈顶：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">movl %esp, 484(%eax)<br></code></pre></td></tr></table></figure>
484(%eax)表示内存单元地址为eax+484，也就是prev-&gt;thread.esp。</li>
<li>把next-&gt;thread.esp装入esp。esp指向了next的内核栈，就代表此时内核切换到了next的内核栈。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">movl 484(%edx), %esp<br></code></pre></td></tr></table></figure></li>
<li>把标记为1的地址放入prev-&gt;thread.eip，这表示替换的进程再次恢复执行时，restore出eip，从1处继续执行：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">movl $1f, 480(%eax)<br></code></pre></td></tr></table></figure> 480(%eax)就是prev-&gt;thread.eip</li>
<li>对称的，把next-&gt;thread.eip的值（大概率就是上一次压入的1的地址，如果它未被换出过，那情况要复杂一些）压入next内核栈：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">pushl 480(%edx)<br></code></pre></td></tr></table></figure></li>
<li>跳到__switch_to() C函数： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">jmp __switch_to<br></code></pre></td></tr></table></figure></li>
<li>从__switch_to回来后，实际上已经变成了next进程，而__switch_to实际上内部是通过ret返回的，那么返回地址也就刚好是push的next-&gt;thread.eip。玩安全的想必非常熟悉，这是经典的push+jmp+ret伪造call指令。于是，next执行从1标签开始的指令，进行restore，而此时因为堆栈早已换成next自己的，所以pop出来的也就是上一次被换出时保存的ebp和eflags。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">1:<br>popl %ebp<br>popfl<br></code></pre></td></tr></table></figure></li>
<li>拷贝eax的内容到switch_to的第三个参数last标记的内存区域中：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">movl %eax, last<br></code></pre></td></tr></table></figure>
prev和next是进程堆栈中的两个局部变量，那么对于两个进程来说，我们把prev标志的称为A，next标志的称为B。A的进程堆栈中有着prev和next，在切换前夕，prev是A，next是B。当跳到__switch_to后，ret回来，此时就是进程B的堆栈，而B的堆栈中同样有上一次的prev和next，B的prev应该是B本身，而B的next应该是上一次B切换到C时的C。而我们设计上，希望从A切换到B时，不仅能够保证A的prev和next正确，还要保证切换到B后，B的prev也是正确的。
如果只是单纯的A-&gt;B-&gt;A在不会有问题，他们的prev和next都是正确的，但是如果A-&gt;B，C-&gt;A就会有问题:（注意，这里换入的进程的prev还没有被eax重置，这一忽略曾让我怀疑人生）</li>
</ol>
<p><img src="20170826_1.jpg" srcset="/img/loading.gif" lazyload /></p>
<p>由于A此前在切换到B时，堆栈上prev和next保存的分别是A和B，那么如果我们从C到A时，A的prev依然是A，这就有问题了。A的prev明明应该是C才对（这就是前面说的我们不仅要保证换出的C的prev和next正确，换入的A的prev也应该正确，至于A的next，who
care?等它再次切换时自己就处理好了）。本质上来讲，这其实就是堆栈切换后，局部变量因为他的含义需要相应调整的故事。
所以switch_to宏多引入了一个last变量，last实际上就是prev，__switch_to返回值eax实际上就是A的prev，因为执行__switch_to时prev变量指向的还是A的prev，而ret回去后，prev变量就是B的堆栈上的prev。因此，借由__switch_to前传递A的prev，ret后再返回这个A的prev值给B，用于覆盖B的prev，那么B的prev由谁覆盖？答案就是last，eax值返回给last，用last覆盖B的prev，从而保持了prev的字面意义。</p>
<p>如果说prev和next是变化的状态量，随着进程切换而改变意义，那么这个一开始和prev一致的last就是个过程量，用于切换后以A的prev正确的重置B的prev。prev和next是输入型变量，last是输出型变量，用于指明切换后被覆盖的地址。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">movl %eax, last<br></code></pre></td></tr></table></figure></p>
<p>这一过程非常的复杂，我自己也是研究了好久才弄明白，但是当我捋清了整个流程，便惊叹于内核设计的绝伦精妙。</p>
<p>我在网上淘金时，挖到了描述这一过程不错的图例：</p>
<p><img src="20170826_2.jpg" srcset="/img/loading.gif" lazyload /> <img src="20170826_3.jpg" srcset="/img/loading.gif" lazyload /></p>
<h2 id="switch_to函数">__switch_to函数</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __switch_to函数执行大多数进程切换的工作。</span><br><span class="hljs-comment"> * 进程切换的工作开始于switch_to宏，但是它的主要工作还是由__switch_to完成。</span><br><span class="hljs-comment"> * 这个函数是寄存器传参的函数。在switch_to宏中，参数已经保存在eax和edx中了.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> fastcall * __switch_to(<span class="hljs-keyword">struct</span> task_struct *prev_p, <span class="hljs-keyword">struct</span> task_struct *next_p)<br>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_struct</span> *prev = &amp;prev_p-&gt;thread,<br>				 *next = &amp;next_p-&gt;thread;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 通过读取current_thread_info()-&gt;cpu,获得当前进程在哪个CPU上运行.</span><br><span class="hljs-comment">	 * 因为在schedule函数中已经调用了禁用抢占,所以这里可以直接使用smp_processor_id()</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> cpu = <span class="hljs-built_in">smp_processor_id</span>();<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">tss_struct</span> *tss = &amp;<span class="hljs-built_in">per_cpu</span>(init_tss, cpu);<br><br>	<span class="hljs-comment">/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * __unlazy_fpu宏有选择的保存FPU\MMX\XMM寄存器的内容.</span><br><span class="hljs-comment">	 * 它可能会延后保存这些寄存器的内容.</span><br><span class="hljs-comment">	 */</span><br>	__unlazy_fpu(prev_p);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Reload esp0, LDT and the page table pointer:</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 把next_p-&gt;thread.esp0装入本地CPU的TSS的esp0字段.</span><br><span class="hljs-comment">	 * 任何由sysenter汇编指令产生的从用户态到内核态的特权级转换将把这个地址复制到esp寄存器.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">load_esp0</span>(tss, next);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Load the per-thread Thread-Local Storage descriptor.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 将next_p进程使用的线程局部存储(TLS)段装入本地CPU的全局描述符表.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-built_in">load_TLS</span>(next, cpu);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Save away %fs and %gs. No need to save %es and %ds, as</span><br><span class="hljs-comment">	 * those are always kernel segments while inside the kernel.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 把fs和gs段寄存器的内容分别存放在prev_p-&gt;thread.fs和prev_p-&gt;thread.gs中.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movl %%fs,%0&quot;</span>:<span class="hljs-string">&quot;=m&quot;</span> (*(<span class="hljs-type">int</span> *)&amp;prev-&gt;fs))</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movl %%gs,%0&quot;</span>:<span class="hljs-string">&quot;=m&quot;</span> (*(<span class="hljs-type">int</span> *)&amp;prev-&gt;gs))</span></span>;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Restore %fs and %gs if needed.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 不管是prev还是next,只要他们使用了fs和gs,那么,都需要将next中的fs,gs更新到段寄存器.</span><br><span class="hljs-comment">	 * 即使next并不使用fs,但是只要prev使用了,也需要更新.这样可以防止next通过fs,gs访问prev的数据.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(prev-&gt;fs | prev-&gt;gs | next-&gt;fs | next-&gt;gs)) &#123;<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * loadsegment可能会装载一个无效的段寄存器.CPU可能会产生一个异常.</span><br><span class="hljs-comment">		 * 但是loadsegment会采用代码修正技术来处理这种情况.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">loadsegment</span>(fs, next-&gt;fs);<br>		<span class="hljs-built_in">loadsegment</span>(gs, next-&gt;gs);<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Now maybe reload the debug registers</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 用debugreg数组的内容dr0..dr7中的6个调试寄存器.这允许定义四个断点区域.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(next-&gt;debugreg[<span class="hljs-number">7</span>])) &#123;<br>		<span class="hljs-built_in">loaddebug</span>(next, <span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">loaddebug</span>(next, <span class="hljs-number">1</span>);<br>		<span class="hljs-built_in">loaddebug</span>(next, <span class="hljs-number">2</span>);<br>		<span class="hljs-built_in">loaddebug</span>(next, <span class="hljs-number">3</span>);<br>		<span class="hljs-comment">/* no 4 and 5 */</span><br>		<span class="hljs-built_in">loaddebug</span>(next, <span class="hljs-number">6</span>);<br>		<span class="hljs-built_in">loaddebug</span>(next, <span class="hljs-number">7</span>);<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 如果必要,更新TSS中的IO位图.当next或者prev有其自己的定制IO权限位图时必须这么做.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(prev-&gt;io_bitmap_ptr || next-&gt;io_bitmap_ptr))<br>		<span class="hljs-comment">/**</span><br><span class="hljs-comment">		 * handle_io_bitmap并不立即更新位图,而是采用一种懒模式的方法.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-built_in">handle_io_bitmap</span>(next, tss);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * return产生的汇编指令是movl %edi, %eax,ret.</span><br><span class="hljs-comment">	 * 这里有保护eax和返回地址的问题.请仔细理解.</span><br><span class="hljs-comment">	 * 除了需要理解switch_to宏中的jmp指令外,对于没有产生切换,而是第一次开始执行的进程.</span><br><span class="hljs-comment">	 * 它并不会跳回switch_to,而是找到ret_from_fork函数的超始地址.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">return</span> prev_p;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，进程切换中硬件上下文的实质性工作都是在这里处理的，而__switch_to返回值就是传入的prev_p，也就是switch_to中的prev局部变量，这个变量在执行jmp
__switch_to之前代表着A的prev。</p>
<p>值得一提的是，__switch_to的函数参数不是通过栈传递的，而是指定了eax和edx寄存器，__switch_to什么都没有做，只是在对应Makefile中写上了<code>KBUILD_CFLAGS += -msoft-float -mregparm=3 -freg-struct-return</code>，-mregparm=3表示默认使用3个寄存器传参。</p>
<p><font color="red">一言以蔽之，进程切换的关键操作无非就是切换地址空间、切换内核堆栈、切换内核控制流程以及必要寄存器的现场保护与还原。</font></p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a
target="_blank" rel="noopener" href="http://home.ustc.edu.cn/~hchunhui/linux_sched.html">x86体系结构下Linux-2.6.26的进程调度和切换</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/titer1/article/details/45289159">linux
进程调度switch_to宏浅析+系统执行过程总结</a></li>
<li><a
target="_blank" rel="noopener" href="http://www.cnblogs.com/visayafan/archive/2011/12/10/2283660.html">【内核】进程切换
switch_to 与 __switch_to</a></li>
<li>《深入理解Linux内核》</li>
<li>《Linux内核源代码情景分析(上)》</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux/" class="category-chain-item">Linux</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/linux-kernel/" class="print-no-link">#linux-kernel</a>
      
        <a href="/tags/ulk/" class="print-no-link">#ulk</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Linux内核学习——Linux进程切换</div>
      <div>https://r00tk1ts.github.io/2017/08/26/Linux进程切换/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>r00tk1t</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2017年8月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2017/08/27/Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%92%A4%E9%94%80/" title="Linux内核学习——Linux进程的创建与撤销">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux内核学习——Linux进程的创建与撤销</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/08/22/Linux%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/" title="Linux内核学习——Linux进程概述">
                        <span class="hidden-mobile">Linux内核学习——Linux进程概述</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/diy/yinghua.js"></script>
<script src="/js/diy/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
