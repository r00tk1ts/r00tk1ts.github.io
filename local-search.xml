<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>格物致知(1)——你什么进制？我什么进制？</title>
    <link href="/2023/05/06/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(1)%E2%80%94%E2%80%94%E4%BD%A0%E4%BB%80%E4%B9%88%E8%BF%9B%E5%88%B6%EF%BC%9F%E6%88%91%E4%BB%80%E4%B9%88%E8%BF%9B%E5%88%B6%EF%BC%9F/"/>
    <url>/2023/05/06/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(1)%E2%80%94%E2%80%94%E4%BD%A0%E4%BB%80%E4%B9%88%E8%BF%9B%E5%88%B6%EF%BC%9F%E6%88%91%E4%BB%80%E4%B9%88%E8%BF%9B%E5%88%B6%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>在我入坑之前就时长听大佬说：计算机的世界是二进制的，所有的信息都用0和1来表达。这对习惯于使用十进制的人脑来说显得捉摸不透：为什么要用二进制，十进制不香吗？另外啥叫信息？计算机为啥要表达？它要表达啥？不知道年轻的你有没有此等困惑，今天就让我们来揭开遮掩的幕布，看破这背后的戏法与魔术。</p><span id="more"></span><h1 id="你什么进制我什么进制">你什么进制？我什么进制？</h1><p>在研究计算机为什么是二进制之前，我们先抛开先入为主的偏见，思考一下：为什么人脑习惯用十进制，阿拉伯数字为啥用10当做基数来设计？这个问题很简单，掰掰我们的手指，数一数一共有几根，答案也就呼之欲出了。得益于我们的手指数量，最早的计数方式便选择10作为基数，而随着智慧的启蒙与时代的发展，阿拉伯人设计出以10作为基数的阿拉伯数字，推动了数字革命，终而家喻户晓、流传沿用至今。幼儿园老师教我们加减法运算时，其核心就在于凑10，当我们掌握了凑10技巧以后（也就是明白了进制的意义），就可以口算相当大规模的数字加减运算了。</p><p>而在计算机的世界则流行的是一种二进制运算，为什么是2而不是10呢，这是因为二值信号更容易被表示、传输和存储，2这个数字很有power，他可以表示两种极端对立的特性，比如：有和无、阴与阳、光与暗、高和低、顺时针和逆时针等等。对二值信号进行存储和计算的电子线路简单可靠、易于设计，制造商可以在一个单独的硅片上集成数百万乃至数十亿个这样的电路。</p><p>正所谓太极生两仪、两仪生四象、四象生八卦，单个二值信息本身作用有限，但是当把多个二值信息排成队、通过排列组合就可以一生万物，正如我们在第零讲中反复提到的核心思想：对抽象的事物赋予特定的语义。对连续二值信息的排列组合可以让我们对任何有限集合赋予语义，比如字符编码、CPU指令，再比如今天要讲的主角：数值信息的表达与存储。</p><h2 id="初识二进制">初识二进制</h2><p>二进制运算法则和十进制没什么区别，不过是逢2进位罢了，这里介绍一个简单的口算进制转换技巧：我们按照从低到高，记住一连串的二进制位为1的实际值，比如<code>B11111111</code>从低位到高位分别是1、2、4、8、16、32、64、128，当我们有一个十进制数为69，想要转换成二进制来表示的话，就用这些数字来凑：<code>69=64+4+1</code>，亦即第0、2、6位为1（计算机的世界下标往往从0开始），其余位为0，最终写成<code>B01000101</code>。这里的前缀B表示二进制，是英文binary首字母的缩写。</p><blockquote><p>你可能还见过其他的二进制表示法，不同语言的写法可能不同，比如python里是用0b作为前缀，但这些都不重要，他只是为了区分其他进制而携带的标记，我们只需要知道它表示二进制就行。</p></blockquote><p>好，看到这里相信你已经学会怎么口算了，那么留一个问题给读者：250用二进制表示要怎么写呢？</p><h2 id="超量召唤十六进制">超量召唤：十六进制</h2><p>有的同学可能注意到，为啥69的二进制最高位在第6位，我却在最高位前面补了个0凑成8位呢？这是因为大多数计算机存储的最小单元是字节(Byte)，一个字节=8个位(bit)，常常写作1B(yte)=8b(its)，故而常常以8作为分组。因此，一个字节表达的范围就是<code>B00000000~B11111111</code>，换算到十进制就是<code>0~255</code>，由于使用二进制书写显得格外不方便，大家就对2进行了折叠，选择<code>2^4=16</code>来作为基数（<del>二进制的怪兽有四只，要上了，欧巴类、xyz召唤：十六进制</del>），用十六进制来表示（使用数字<code>0~9,A~F</code>来表示每个位值，也就是从0到15，其中<code>A~F</code>大小写均可）。如此，一个字节就只需要两个十六进制数来表示，大大缩减了书写长度，此时值域区间为<code>0x00~0xFF</code>（这里的<code>0x</code>是用户表示十六进制的前缀，可能还有<code>0xFFH、FFH</code>的写法，H是十六进制——Hex的缩写）。</p><p><img src="2023-05-11-19-53-30.png" /></p><p>所以十六进制只是二进制的升维，本质上没有什么区别，那么十六进制怎么口算呢？很简单，我们通过展开十六进制数、转成二进制格式，在此前二进制口算窍门的基础上，再做一层映射即可：</p><p><img src="2023-05-12-09-36-50.png" /></p><p>让我们来试试：十进制的250，对应的十六进制数怎么表示呢？首先我们把250拆分成：128+64+32+16+8+2，也就是对第1、3、4、5、6、7位置1、其余置0，二进制写作<code>B11111010</code>，进一步，每4位做一下折叠，最终得到：<code>0xFB</code>。</p><p>当然了，在我们熟悉十六进制数字之后，可以跳过二进制转换这一层，直接使用十六进制数来口算：比如<code>250=15*16+10</code>，15就是<code>F</code>、10就是<code>B</code>，也可以得到<code>0xFB</code>的结果。</p><blockquote><p>实际上我们只需要掌握十六进制数的阅读方法即可，如果口算不是为了装B，那就毫无意义(doge）。</p></blockquote><h2 id="数值类型与尺寸">数值类型与尺寸</h2><p>我们上中学的时候，对数字的划分一般都是采用自然数、实数、复数等概念来进行划分，但在计算机的世界，划分规则却迥然不同。各大编程语言往往都会定义各种各样的数据类型，它们作用不同、长短不一，但总体而言，数值在大分类上可以被归类成这两种：整型数和浮点型数。在这两大类的基础上，编程语言一般会在设计上根据尺寸长短（也就是确定数值范围、即多少个字节），将整型和浮点型细分成多种类型。另一方面，由于数值有正负之分，为了便于日常开发者的使用，在大部分编程语言里还对每一种类型再进一步拆分成有符号和无符号型。</p><p>整型数就是整数，不管他的尺寸有多大，哪怕你定义成64个字节的超大范围，它能表示的数值也仅限于整数。比如我们定义一个<code>uint8_t</code>的类型，长度为1个字节，那么它所能表示的数值范围就是<code>0~255</code>，假如我们想让这个范围能表示负数，那么不妨再设计一个<code>sint8_t</code>型，长度依然是1个字节，此时数值范围就是<code>-128~127</code>。对于无符号数来说，如何使用单字节来存储<code>0~255</code>显得非常直接，0就存储为<code>0x00</code>、1就存储为<code>0x01</code>、240就存储为<code>0xF0</code>、255就存储为<code>0xFF</code>，这和十六进制表示数值的设计是完全统一的，我们姑且也把这叫做一种编码（尽管这层转换什么都没做）。但是负数要怎么存储呢？目前并没有一个单独的信息位来告诉我们这个数是positive还是negative呀。</p><h3 id="麻烦的符号">麻烦的符号</h3><p>看来简单的一比一编码行不通，一旦涉及了正负的概念，还是得考虑编码规则。考虑到正负本身无非也是一种信息，且恰好就是个二值信息，所以如果我们在原有尺寸的基础上，让出最高位、作为正负符号的表示，其余位仍然代表数值，看起来就可以解决这个case。比如对于此前我们设计的<code>sint8_t</code>，它一共有8个bits，我们让最高位（第7位）为0时代表正、为1时代表负，那么它所能表示的范围就变成了<code>-127~127</code>。此时B11111111在作为<code>sint8_t</code>的时候，它的值就是-127，而作为<code>uint8_t</code>时，它的值是255。</p><p>这种简单粗暴的设计看起来很美好，但实际上却经不起推敲：比如我们考虑对-4和+8做加法运算，二进制写作B10000100和B00001000，正常的结果应该是+4，当计算机操作二进制数按位计算时，答案却是错误的B10001100，也就是-12：</p><p>-4: 1 0 0 0 0 1 0 0</p><p>8: 0 0 0 0 1 0 0 0</p><ul><li>: 1 0 0 0 1 1 0 0</li></ul><p>经过分析，我们发现这里第一个问题就在于符号位是不能直接进行加法运算的，因为我们在计算时并不知道最终结果应该是正还是负。此外，第二个问题在于正数和负数的加法运算，其实相当于是减法，这里的计算逻辑实际上忽略了这一事实，而是进行简单的4+8，所以最终才得出了-12的结果。</p><p>尽管我们经过分析，或许能够梳理出一套正确计算的逻辑，但从计算机来说，这就显得太过于复杂了，对于计算机来说，它只能做加法运算，至于你这些数字的背后代表了哪些数值，它是丝毫不关心的。因此，我们需要精心设计一个编码机制，使得它能够在计算机的世界对正负数的加减法操作（计算机只能做加法，减法也是加法（与负数相加））得到一个正确结果的相应编码值。</p><h3 id="整型数编码">整型数编码</h3><h4 id="无符号数">无符号数</h4><p>对于无符号数来说，完全可以沿用最自然的编码规则：</p><p><img src="2023-05-15-10-22-21.png" /></p><p>长度为w的0、1串映射到无符号整数，比如：</p><p><img src="2023-05-15-10-23-23.png" /></p><p>显得既直观又简单。由于无符号数不涉及减法，也没有符号，所以计算机的加法运算无论对于哪两个数操作，结果都是正确的。</p><h4 id="有符号数">有符号数</h4><p>而对于有符号数，最常见的一种编码方式叫做补码(two'scomplement)。在这个定义中，将字的最高有效位解释为负权(negativeweight)，类似无符号数，使用函数来定义：</p><p><img src="2023-05-15-10-26-28.png" /></p><p>最高位<spanclass="math inline">\(-x_{w-1}\)</span>也叫符号位，它的权重为<spanclass="math inline">\(-2^{w-1}\)</span>，当该符号位为时表示负数（值为负），为0时表示整数（值为非负，也就是正数+0），这么说比较抽象，还是展开看看几个例子：</p><p><img src="2023-05-15-10-54-08.png" /></p><p>为什么要设计这个权重呢，实际上它是对减法运算的一种模拟，对于负数来说，它最终用于表达的二进制值是权重作用后的结果，如此，当我们对复数进行加法运算时，这个权重就发挥了作用。</p><p><img src="2023-05-15-10-55-17.png" /></p><p>比如重新考虑<code>-8+4</code>，对<code>sint8_t</code>类型，-8的补码是B11111000，4的补码是B00000100，二者相加：</p><p>1 1 1 1 1 0 0 0 0 0 0 0 0 1 0 0 + 1 1 1 1 1 1 0 0 =&gt; -4的补码</p><p>通过计算机的加法运算后，得到的正好就是-4的补码。</p><p>再比如<code>-4+8</code>：-4的补码是B11111100，8的补码是B00001000，二者相加：</p><div class="hljs code-wrapper"><pre><code class="hljs">  1 1 1 1 1 1 0 0  0 0 0 0 1 0 0 0</code></pre></div><ul><li><ol type="1"><li>0 0 0 0 0 1 0 0 =&gt; 产生进位，丢弃溢出位，最终结果是4的补码</li></ol></li></ul><p>由于尺寸限制，这里的加法运算产生了溢出，最终溢出位被丢弃，而最高位（符号位）刚好因为进位而变成0（语义上代表非负数），这一巧合实际上就是我们精心设计的补码编码规则而产生的。</p><h4 id="补码反码与原码">补码、反码与原码</h4><p>各版本大学计算机基础的教材往往都会提到这么几个概念，补码我们已经知道了，那么啥叫反码和原码呢？</p><p>反码和原码是另外两种表示有符号数的标准方法：原码(Sign-Magnitude)：最高有效位是符号位，用来确定剩下的位应该取负权还是正权：</p><p><img src="2023-05-15-11-28-20.png" /></p><p>反码(Ones' Complement)：除了最高有效位的权是<spanclass="math inline">\(-(2^{w-1}-1)\)</span>而不是<spanclass="math inline">\(-2^{w-1}\)</span>，它和补码完全一样：</p><p><img src="2023-05-15-11-27-27.png" /></p><p>对于原码和反码来说，它们对数字0的编码都有两种：B00000000被解释成+0，在原码编码中B10000000被解释成-0、反码编码中B11111111被解释成-0。反码和原码相对于补码是截然不同的编码方式，只可惜大部分教科书混淆了三者之间的关系，从字面值上看，正数的补码和原码一致，而负数的补码则是反码+1（毕竟权重里多了个-1），这种取巧的办法更适合我们人类去计算有符号数的补码编码值，但实际上它们之间没什么关系，每种编码方式本身都是内部闭环的。所以坊间总流传这么一个说法：正数的补码是它的原码、负数的补码是它的反码+1。久而久之，我们只学会了怎么计算有符号数的补码编码值，却根本没搞懂补码的设计奥义，当真是买椟还珠。</p><blockquote><p>虽然上古时代曾生产过基于反码表示的机器，但现代机器都一致使用补码来编码有符号数。此外，浮点数使用的编码方式是原码，我们稍后会看到。</p></blockquote><h3 id="c语言中的数值类型">C语言中的数值类型</h3><p>上面的<code>sint8_t</code>,<code>uint8_t</code>是我杜撰的，我们找个真实的编程语言来举例。比如，在C语言中，有着以下的常见类型：</p><p><img src="2023-05-12-17-47-18.png" /></p><p>注意到C在设计上针对整型数分成了<code>short、int、long、int32_t、int64_t</code>这几种，它们的尺寸单调非递减，且在不同位数的机器架构里长度不同。<code>char</code>是一个比较特殊的类型，它只有单个字节，常用来表示ASCII字符，但本质上存储的只是个数字罢了，它具体是什么取决于你怎么用它。<code>char</code>这种设计放在现代来看显得小家子气（比如go直接定义<code>byte</code>型），这主要是因为C诞生年代太过久远，和现代编程语言的设计相当脱轨。</p><blockquote><p>实际上x64（64位）机器也可以编译x86(32位)的C程序，此时类型尺寸按32位的标准生效。</p></blockquote><h4 id="有符号数和无符号数的转换">有符号数和无符号数的转换</h4><p>截止到目前，我们对有符号数和无符号数可以说是区别对待，可是在实际生产环境中，我们很可能会遇到两种类型数混用甚至需要进行计算的场合，那怎么办呢？不同语言都提供了它们之间的转换方法，比如在C语言中就有显式强制类型转换和隐式类型转换这两种。然而语言层面往往只是提供能力，二者进行计算最终得到的值，归根结底取决于你对它的解读方式。</p><p>举个例子，比如下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">short</span> <span class="hljs-type">int</span> v = <span class="hljs-number">-12345</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> uv = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)v;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v=%d, uv=%u\n&quot;</span>, v, uv);<br></code></pre></div></td></tr></table></figure><p>前方施工中。。。</p>]]></content>
    
    
    <categories>
      
      <category>编程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>格物致知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格物致知(0)——系统漫游</title>
    <link href="/2023/04/13/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(0)%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <url>/2023/04/13/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(0)%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>对于想要学习编程的新人来说，当下无疑是最好的时节，编程语言发展至今，新生代的语言在诞生之初往往伴随着强大的生态附属以及友好的语法特性，这大大降低了上手门槛，使得新手也可以轻松地完成任务而不必陷于囹圄。当下也是最坏的时节，现代编程语言高高在上，屏蔽了太多细节与原理，这鸿沟天堑阻绝了新人知其所以然的机会，却又如何技进于道？本系列将以CSAPP(ComputerSystems: A Programmer'sPerspective，中译本为《深入理解计算机系统》)为蓝本，接轨当下，让我们格物致知，打通认知体系的奇经八脉。</p><span id="more"></span><h1 id="系统漫游">系统漫游</h1><p>众所周知，计算机系统是由硬件和软件组成的，不论是超级计算机、集群服务器，还是家用电脑、移动端设备(平板、手机)、IoT设备（如路由器、摄像头）应皆如是。硬件五花八门、各司其职，对于非特定领域开发者来说，我们只需要了解两个核心硬件：中央处理器(CPU)和内存(主存，一般称RAM)即可。</p><blockquote><p>除了CPU以外，还有一种叫图形显示器(GPU)的东西，这东西在当下可是大展身手，无出其右（同学，便宜的矿卡来一块不？都是锻炼过的，GPT用了都说好）。机械硬盘(SATA)、固态硬盘(SSD)对于一台主机来说很重要，但站在程序开发者视角来说则没那么重要。至于显示器、鼠标、键盘等等都属于外设，如果不是为了打游戏，那么研究它们毫无意义(doge)</p></blockquote><p>硬件虽然服务于软件，但硬件才是大爹。事实上，互联网的崛起、从单点到分布式，以及历年的技术革命：诸如大数据、云计算、区块链再到当前潜在商业价值巨大的GPT，之所以能够surfing在浪潮之巅，根本上都是因为硬件的迭代升级。硬件的能力突破了某个瓶颈以后（算力、造价、效率等等...），业界大能才能把此前仅限于理论可行的方案落地，开辟出当前欣欣向荣的生态大环境。</p><p>那么硬件和软件是怎么沟通的呢？不同硬件厂商繁多，标准规格大相径庭，如果将这些都暴露给软件开发者，那简直是一场噩梦。事实上在上古时代，编程就是这样一件不可思议的狠活，程序开发者需要去理解使用的硬件，对着它的规格书使用原生接口来完成自己的工作。随着软件的发展，先驱者抽象出中间层（在软件开发领域，没有什么事是一个中间层搞不定的，如果有，就再加一个中间层），让它负责对接所有硬件，开发者只需要和这个中间层打交道即可。那么这个中间层是什么呢？它的真身就是我们常常说的操作系统(OS,OperatingSystem)，操作系统实际上也经历了漫长的发展历史长河，一直到现在我们耳熟能详的Windows,Linux, Mac OS, Android,IOS等。时至今日，我们更愿意称它们为“现代操作系统”，“现代”这一限定词可谓意义非凡，它浓缩了这一路上面对重重困境披荆斩棘的解决之道，并最终沉淀成标准，任岁月打磨。</p><blockquote><p>即使是家喻户晓的Windows，实际上也有着漫长的历史，严格来说，Windows不是具体的某个系统，而是一种徽章，从最古老的DOS到Windows9x再到Windows NT，底层的变化翻天覆地，而Win7（前身是赫赫有名的失败品Vista）之后历经Win 8、Win 10再到“内测”的Win11，安全加固、系统生态等方方面面都愈发成熟。</p></blockquote><blockquote><p>如果说Windows是自立门户、自成标准，那么像Linux, Mac OS, FreeBSD,Solaris都算作类Unix系统，它们有着相当多的共同点，比如遵守POSIX标准，集成了GNU套件。</p></blockquote><p>操作系统实际上也是软件，事实上，它就是我们开机以后第一个运行的体量最大的软件，OS提供了其他软件运行的土壤。现代操作系统整体分为两大部分：内核(kernel)和外壳(shell)，内核负责决策、调度和资源管理，里面住着的都是一等公民（常驻的内核代码：进程管理、内存管理、文件设备I/O、中断），外壳则面向开发者与用户进行交互：你只能通过使用我开放的接口、组合成你想实现的功能。通过这些接口（即系统API）我们可以编写各种程序，进而完成各种各样的软件，只不过受制于人（你得看具体OS厂商的脸色），能做的事儿有限。</p><p><img src="2023-04-13-19-19-46.png" /></p><blockquote><p>你可能会问：为啥现代操作系统要分层呢？大家写的程序都和OS内核平起平坐，功能岂不是更丰富？嗯，上古时期DOS就是这么干的，所以那个年代病毒满天飞，挡都挡不住。</p></blockquote><p>因此，在现代操作系统中，生态环境被分成了两部分：内核态与用户态。</p><ul><li>与硬件打交道的代码通通运行在内核层，各类硬件设备分门别类一般有着业界统一标准或是自定义标准，OS通过设备驱动来与它们交互，它们以插件的形式，或先天集成在OS内核里，或后天装载插入；</li><li>我们日常所用的大部分软件，诸如chrome浏览器、QQ音乐、Steam等它们之中的大部分工作在用户态；</li><li>像是一些防护软件比如火绒、360、QQ电脑管家等则兼具用户与内核态，为什么说是兼具呢？因为用户态有功能局限性，防护软件要和那些无孔不入的恶意程序对抗，那势必要下沉到内核去获取更高的权限与更强大的power。实际上，操作系统并不仅仅提供用户态的接口，内核层往往也会提供，而除了少量做设备驱动和二进制安全研究的人士，大部分开发者是用不到它们的。</li></ul><blockquote><p>内核态与用户态是现代操作系统的概念，在很多上下文中会等价于Ring0/3态，后者是站在CPU的视角来看的，虽然二者有一定区别，但基本绑定。</p></blockquote><blockquote><p>在我尚未学习内核/驱动编程的时候，总觉着写内核态程序的高人一等，直到上下求索、建立一定的知识体系后才明白：写程序就是写程序，本没有什么优劣，不过是所在的层与生态环境不同罢了。</p></blockquote><p>操作系统作为中间层，其常驻的内核代码会控制CPU与内存的调度与分配，我们知道程序无非就是代码+数据（代码其实也是数据，嗯，这就是二进制安全的关键），每一行代码的执行都由CPU来完成，而数据则放置于内存。对于CPU来说，各厂商的指令集迥然不同，在CPU的世界里，一切都是二进制的，它的眼里只有0和1，对于一连串的0101...0011，不同厂商对他们进行了特有的定义，比如通过规定指令集定长，其中1100表示功能A、0011表示功能B、1010表示功能C等等。那么，按照这样的设计，当我们使用不同的CPU编写程序（包括编写操作系统）时，就需要去对着厂商的手册，一点一点手码0101吗？啊，这。。。</p><p>当下显然不会，这就要说起编程语言的发展历程了~</p><h2 id="编程语言简史">编程语言简史</h2><h3 id="机器语言">机器语言</h3><p>CPU按架构会有自己的指令集，它们的背后也确实就是0101，只不过厂商赋予了语义并在硬件上实现了相应的功能。上古时期的编程确实就是直接写0101（这个时候的CPU还称不上是CPU）来完成的，彼时我们称其为机器语言，显然，机器语言对机器绝对友好，但对程序员绝对不友好，它的缺点肉眼可见：难记难改难纠错、费时费力费树脂（卧槽，原！）。痛，太痛了！</p><blockquote><p>世界上的第一个程序媛叫Ada，头像参考二进制安全必备神器：IDA Pro~</p></blockquote><p>业界把机器语言称为“第一代计算机语言”。</p><h3 id="汇编语言">汇编语言</h3><p>为了克服机器语言不说人话的问题，大佬们给CPU聘请了翻译(诶，您给翻译翻译什么叫0101？什么他么的叫0101？什么他么的叫他么的0101？)，而这就产生了第二代计算机语言：汇编语言。简单来说，汇编语言就是将机器码翻译成与实际意义相关的英文+数字缩写助记符（所以汇编指令也叫机器码助记符），比如<code>mov eax, 3</code>表示把数值<code>3</code>赋值给寄存器<code>eax</code>（至于什么是寄存器，这个学到的时候再说）。汇编语言的好处就在于相比于机器语言，编写起来没那么男的女的折磨，我们先用汇编助记符来编写程序，编写完成后经过翻译再变成机器码给到CPU去执行，而这个负责翻译的模块则被称作：汇编器。</p><p>汇编语言是一种低级语言（这里的低级不含贬义，只是说它所在的层级较低，与底层更近），它和具体的CPU指令集绑定，因此并不通用，尽管相对机器语言书写上舒服了很多，但编写门槛依然较高无法让人满意。</p><h3 id="高级语言">高级语言</h3><p>还记得前面讲操作系统时我们曾遇到的困境吗？不只是CPU，其他硬件的不同厂商标准规格都可能千差万别，如果需要开发者每一个都掌握，那属实crazy。这一点对于编程语言来说也一样，既然汇编难用又不通用，我们何不再架上一层中间层，搞一个统一的语言出来，再多安排几个翻译员，每个人专门负责从统一语言到某一个特定汇编语言的翻译工作。通过这一中间层的屏蔽，开发者只需要掌握这门统一语言即可编写在任何CPU指令集上运行的程序，而无需了解特定的指令集。（你看，我就说没什么困难是一个中间层搞不定的吧~）而且，在设计上我们也可以让这门统一语言尽量说人话，从而降低编写的难度与维护的成本。</p><p>而这，其实就是第三代编程语言：高级语言的由来。只不过，在漫长的历史长河中，有太多大能都达成了此共识，其结果就是高级编程语言如雨后春笋般，甚至直到2023的现在还在源源不断的涌现，从古早的BASIC、PASCAL、C、FORTRAN到现在的Go、Rust，它们都是高级编程语言，随着时代的进步，其中难免有一些被环境所淘汰，但也有一些历久弥新，每个不同的高级语言都蕴含了作者独特的审美与对环境生态、软件开发的理解，伴随着社区、使用群体的发展各自开宗立派、培养着自家忠实的拥趸。</p><p>高级语言在设计上大体分为两派：编译型和解释型。前者（比如C、C++）主张对编写的源代码进行前置处理：通过一种叫“编译”的方式把它变成汇编语言，再由汇编器变成机器码，最终在机器上执行，它的核心要点在于：所有代码在一开始就要全部翻译成最终的机器码，运行时直接执行；而后者（比如Ruby，Python、Javascript）则主张后置处理：在运行时通过解释器来一步一步地、当我执行到具体的某一行时，让同声传译把它变成机器码执行，每说一句就翻译一句原地执行。显然，前者把一些重活放在了编译期，得到的好处就是运行时更快，但后者则因为实时处理的模式往往在语法上可以更加灵活。而在高级语言发展过程中，这两派逐渐水乳交融、佛道双修，比如像Java、C#，它们都是半编译、半解释型，再像是Javascript、Python这种一开始做成解释型的，为了能够针对热点代码提速或是公共代码复用，也陆续引入了JIT、预编译的能力。</p><p>总之，高级语言在设计上与自然语言（英语）更接近（可别跟我提易语言，真不熟……），而与硬件功能相分离，便于开发者掌控而屏蔽底层差异。高级语言的优点在于：通用性强、兼容性好、便于移植，但同样的，天下没有免费的晚餐，相比直接写汇编来说其生成的代码更加臃肿，性能上也有所差距。因此像操作系统这种对性能要求苛刻的程序会经常在高级语言里内联汇编代码（通俗理解就是：高级语言的局部嵌入汇编代码，这需要高级语言的支持）来提速。</p><blockquote><p>但另一方面，在2023的今天，现代编译器已今非昔比可谓十分强大，在现代的一些架构上已然抹平甚至超越了使用汇编语言来编写的程序性能（编译器比我聪明系列）。</p></blockquote><h2 id="缘起hello-world">缘起"Hello, world"</h2><p>“Hello,world”之于编程，就好比“衬衫的价格是”之于英语听力。不管你是何门何派、哪个语种，入门的第一站都是"Hello,world"，经久不衰。这一切，都要从此说起：我们意兴盎然的选择了某门语言，开始修炼本门功法，不同门派的功法各有千秋：有些功法小巧精妙(C)，有些功法直捣黄龙(go)，有些功法艰深晦涩(C++)，有些功法必先自宫(Rust)，有些功法大开大阖(Java)，有些功法乱七八糟(你猜我说的是谁？)。</p><p>然而不管我们选择了哪一派，从它变成母语的那一天开始，我们就被深深地打上了相应的烙印。尽管在修炼过程中我们能够解决越来越多的问题，但与此同时它所植入的灵魂烙印也把我们的解题思维牢牢限制在本家系统之内。直到皇天不负有心人，本家功夫大成，我们得以窥探别门别派的心法口诀，坐而悟道。而本门功夫，修炼周期各有长短，这期间一旦受其他门派影响，轻则自我怀疑，重则道心破碎。</p><blockquote><p>有些选择了C语言的小伙伴，学了一年也不会做任何酷炫的app，只会在黑框框里跑四则运算，看到邻家8岁的小男孩都用python写AI画图了，顿时道心破碎，弃C如敝履。</p></blockquote><p>我们现在分别使用C、Java和Python来写一个Hello, world：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, world\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, world&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>嗯，按照各家功法所述，我们应该分别保存成hello.c, hello.java,hello.py。还记得功法让我们怎么称呼它们吗？对，源文件！这些文件里的内容就是源代码，它们都是文本文件。那么源文件怎么执行起来输出“Hello,world”呢？这个时候，各家功法就有所分歧了.</p><h3 id="c">C</h3><p>C是一门编译型语言，使用C语言编写的hello.c需要经过预处理器、编译器、汇编器、链接器来一步一步处理，最终生成二进制可执行文件，不同平台都制定了可执行文件组织结构的标准，比如在Windows里叫PE(PortableExecutable)，像是我们平时双击的xxx.exe就是典型的PE可执行文件（实际上.sys,.dll也都是PE，前者是内核态所运行的驱动程序、后者是用于共享的动态链接库），而在大部分类Unix系统里用ELF(Executableand LinkingFormat)），它们往往没有后缀名。实际上后缀名只是一种浮于表面的印记，通过盖戳的方式让人类更容易分辨它是一个什么文件，真正决定文件制式的是它的内容信息，图片、视频、文本、可执行文件，他们各有各的标准结构。</p><blockquote><p>既然后缀名只是印记，那岂不是可以用来诱骗？早年的恶意软件、病毒可不就是充分利用了此种手段，整个Windows乌烟瘴气。用户也可以利用这一小手段：比如我上小学的时候，隐藏文件早就不用系统提供的方法了，我会把他的后缀改成其他资源的类型，诶嘿，你打不开了吧！后来到了中学，懂得套路又多了一些，这次就直接打开二进制编辑器，偷偷改掉某某视频的文件头~</p></blockquote><blockquote><p>Mac OS逼格比较高，它的可执行文件格式叫Mach-O（Mach Object FileFormat），是一种类似ELF的制式，iOS也是这套。</p></blockquote><p>也就是说，我们的源代码经过了重重流水线关卡，最终变成可执行文件。现在我来问你，这每道关卡都在折腾啥？相信这个问题应该难不倒有一年以上C编程经验的同学，毕竟C派重视基础，门徒大都喜欢刨根问底。</p><p><img src="2023-04-14-17-16-42.png" /></p><p>一言以蔽之：预处理器负责展开头文件、处理宏；编译器负责将加工后的源文件翻译成汇编语言源代码；汇编器再将汇编语言转化成机器码、生成可重定向的目标程序；最终由链接器整合所有目标程序，按照可执行文件的制式整合成可执行文件。整个过程说起来简单，但其实每一步展开都是宏篇巨幅。作为编程导论，我们暂不去深入了解每一步都是怎么做的，我们的疑问是：为什么需要这几步？如果上面的内容你有认真看过并思考过，那么这个问题的答案是显而易见的：我们需要在设计上分层，每一层各司其职，邻层相濡、隔层相忘。上图的中间部分，从C源代码编译成汇编、再从汇编到机器码这一过程相信通过上文你已经十分理解了，那么剩下的头尾各有什么作用呢？</p><p>先说头部的预处理器：预处理器这一步实际上是C语言特有的，它在设计上有一个头文件和源文件的区分，头文件做公开声明，源文件做内隐实现，你在写代码的时候可以引用别人的代码库，比如hello.c中的printf函数，它在前面通过<code>#include</code>宏引入的<code>stdio.h</code>中声明，作用就是在标准输出按照C-format制式打印字符串。此外，C语言还支持一种被称为宏(macro)的强大功能（宏和指针可谓是C的两大神器，一旦掌握了这两个东西，写起C来可谓运斤成风），宏代码的替换也是在预处理器中完成的，而具体怎么操作，等我们深入学习C语言时再做展开。</p><p>再说尾部的链接器：实际上我们生成的hello.o只包含了在hello.c中书写的单个文件的那部分代码，而对于整个工程项目来说，我们可能会写出一大堆源文件，且除了自己写的代码，可能还需要引用别人的生成代码（标准库或是第三方库，比如例子里的printf.o就是标准库所提供的），而把这些.o文件组织成最终的单一可执行文件，就是链接器的工作。</p><blockquote><p>【进阶】实际上在C语言里，上图的printf函数默认情况下并不是直接通过链接printf.o来使用，C标准库默认以动态链接库的形式存在，在程序被加载器吊起到内存时会挂载所需的动态链接库。当然，这是后话，新人不必急于理解。至于加载器，唔，可执行文件在磁盘里躺着的时候和被加载到内存去执行的时候，结构上还是有些差异的，需要个引导者来做初始化操作。</p></blockquote><p>我们来看看，经过编译器编译之后，生成的汇编源代码长什么样，这里我们选取最新的gcc12.2，先看看在Intel x86-64架构下的生成物：</p><p><img src="2023-04-18-11-52-29.png" /></p><p>当他链接成.o的时候，我们看到的则一般被称为反汇编码：</p><p><img src="2023-04-18-11-47-44.png" /></p><p>相比后者，提供给汇编器的前者一般会有一些脚手架，用来辅助编写汇编程序，比如<code>.LC0</code>部分的数据段，而后者则是CPU在真实执行时的汇编指令，或者这里叫机器指令更合适。每行汇编指令的上面还显示了对应的机器码，这里使用的是十六进制（只是二进制的一种简化写法，相对来说更加友好）显式。这些机器码就是CPU执行时真正的指令，不同的数字就是0和1的排列组合，表示了不同的功能。</p><p>好，让我们换个架构，比如从Intel x86-64换到ARM64，再编译链接一下：</p><p><img src="2023-04-18-11-48-16.png" /></p><p>不同的处理器架构指令集的设计千奇百怪，但是对于编写hello.c的开发者来说，我们完全可以不必理解它们，因为这些工作已经由翻译们（编译器）完成了。</p><h3 id="python">Python</h3><p>Python是一门解释型语言，前面也提到过，解释型语言是聘请了个同声传译，在代码运行时实时翻译成所在架构的机器码，而这个同声传译在这类语言里一般被称为虚拟机(VM,VirtualMachine)或是执行引擎（比如Javascript的V8引擎）。当我们在终端执行pythonhello.py时，会直接在终端打印出"Hello,world"，他不需要像C语言那样要先编译再执行本体："gcc hello.c -o hello&amp;&amp;./hello"，而是直接把.py文件作为参数传给python解释器，python解释器会先把<code>print('Hello, world')</code>翻译成字节码(Opcode，也叫操作码，在Python的世界里指<code>PyCodeObject</code>)，再由VM解析字节码实时变成机器码。</p><blockquote><p>字节码不是机器码，它是一些解释型语言在更上层制定的语法规则，它们一般类似机器码也有着像汇编那样的助记符，但所有平台通用（相当于也是个中间层，字节码到机器码的翻译交给了平台上具体的虚拟机）。</p></blockquote><blockquote><p>【进阶】Python代码执行一般来说经过以下四步：1.将源代码解析为解析树(ParserTree)；2.将解析树转换为抽象语法树(Abstract SyntaxTree)；3.将抽象语法树转换到控制流图(Control FlowGraph)；4.根据流图将字节码(bytecode) 发送给虚拟机(VM)。</p></blockquote><p>我们看下hello.py在执行时首先被翻译成的字节码：</p><p><img src="2023-04-18-16-34-08.png" /></p><p>是不是和汇编助记符很像？其实本质上都是一个思想，只是所处的层级不同罢了。</p><p>还记得解释型语言相比编译型语言的劣势吗？没错，运行时速度慢！毕竟你同声传译再强，也打不过提前抄标准答案的作弊狗（2023的今天，这话其实也不绝对了，解释型甚至也可以进行实时优化，根据运行时更丰富的信息生成更高效的代码，性能甚至超越编译型）。</p><blockquote><p>Python其实一开始被作者设计出来的时候，仅仅只是当做一个玩具，万万没想到的是，其简约极致的风格收获了大批粉丝，无数大佬先辈把python社区经营的如日中天，随着历史发展，python的语言生态逐渐丰富起来，就像是滚雪球一样，python最终承受了他原本不该承受的国之重任。</p></blockquote><p>就像C可以引用公共库一样，python也有公共库，只不过在python的世界里这叫做“包（package）”，当你需要使用其他人的函数方法时，只需要在文件头去<code>import xxxx</code>即可，这就和C的<code>#include &lt;xxx.h&gt;</code>有异曲同工之妙。为了能够提速，python把可以复用的包在首次执行时翻译生成的字节码转储(dump)到同名的<code>.pyc</code>后缀文件里，嗯，这里面涉及了工程的另一个思想本质：缓存、空间换时间。</p><p>所以你看，解释型和编译型的界限在2023的今天已经不是那么泾渭分明，虽然python是一门解释型语言，但到处都有编译型的影子。</p><h3 id="java">Java</h3><p>Java相比Python，从一开始的设计上就显得更理直气壮了：老子就是半编译、半解释型，你能咋地？Java也使用虚拟机（大名鼎鼎的JVM,Java VirtualMachine）和字节码的概念，我们编写的hello.java源文件首先会经过编译(<code>javac hello.java</code>)，生成完整的字节码，它被转储到文件<code>.class</code>后缀同名文件，Java编译过程并不会直接生成可执行文件，而是在运行时通过<code>java hello</code>来去自动加载所需的<code>.class</code>并通过JVM去解释opcode，最终转换成特定平台的机器码。</p><p><img src="2023-04-18-17-01-09.png" /></p><p>比如上图是一个可视化的Java字节码，它以二进制的形式存储到<code>.class</code>中。</p><p>所以Java在江湖上有一句经典口号：一次编译，到处运行！实际上，这就得益于其半编译、半解释的设计，我们在任何平台上都可以先运行编译器把它转成字节码，然后你可以随便拷贝到任何架构上，让特定的架构的JVM充当同声传译，把字节码转成相应的机器码（话虽如此，但也有水土不服的情况，毕竟理想很丰满，厂商很骨感）。</p><h3 id="小结">小结</h3><p>实际上所有的高级语言设计上都可以抽象成这样一个模型：</p><p>Source code ---&gt; |Compiler| ---Mid code---&gt; |Runtime| &lt;---Lib</p><p>只不过不同语言各有取舍，每一环节的任务或轻或重罢了。</p><h2 id="文本文件二进制文件">文本文件？二进制文件？</h2><p>上面我们曾频频提起文本文件和二进制文件，比如我们说源代码都是文本文件、生成的可执行文件、转储的字节码文件则都是二进制文件。那么二者到底是什么，又有何区别呢？不急，我们先思考这样一个问题：你编写的这些源代码，它们是怎么存放在存储媒介（比如硬盘）的呢？计算机的世界都是0和1，那么每一个字符、每一个汉字都是怎么对应到具体的0和1呢？</p><p>如果你理解了前文，那么相信聪明的你已经想到了答案：如法炮制，无非也是制定一个规则，给每个字符都映射一个0和1的排列组合嘛！没错，实际上，这一思想应用在这里，就叫做：“编码”。</p><h3 id="编码从ascii到utf8">编码：从ASCII到UTF8</h3><p>计算机是美国人发明的，美国人说英语，他们在设计之初为了满足自身使用需求，搞了一套如今广为流传的ASCII（AmericanStandard Code for Information Interchange,美国信息交换标准代码）码。</p><p><img src="2023-04-19-11-28-24.png" /></p><p>整张映射表对128个字符进行了编码，这其中包括了阿拉伯数字、26个英语字母的大小写、各种普通符号以及一些不可见的控制字符。比如大写字母A对应的ASCII码是65（二进制表示为B0100001），阿拉伯数字0的ASCII码是48（二进制表示为0110000），其他像是空格(SP)、换行(LF)等普通符号与不可见字符也有对应的映射码，它们在表中以大写名称标注。</p><blockquote><p>【维基百科】:ASCII由电报码发展而来。第一版标准发布于1963年，1967年经历了一次主要修订，最后一次更新则是在1986年，至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符。用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。</p></blockquote><p>由于一共是128个字符，这个量级刚好是2的7次方，换算成2进制的话也就是说至多需要7个二进制位（也叫bit），从B0000000一直到B1111111（这个B前缀是用于表示二进制binary）。为了方便说明，人们一般从低位到高位把每一位进行标号，对应到上图就是b7~b0。</p><p>随着计算机在世界范围的普及，ASCII的128个字符就显得捉襟见肘，在流传到一些西欧国家后，大家开始了整活儿，既然128个不够用，那我就扩展一下，加个倍，变成256个总够了吧。嗯，人性都是狭隘且自私的，愚蠢的西方人于是搞了一套EASCII(ExtendedASCII)出来，在ASCII的基础上又新增了128个字符（从B10000000到B11111111）用于表示西欧语言的特有字符，包括表格符号、计算符号、希腊字母和特殊的拉丁符号。虽然EASCII解决了部分西欧语言的显示问题，但世界可不止你西欧和北美。一旦把视角切到古老的东方，这些狭隘的编码手法在浩如烟海的象形文字面前显得是那么脆弱，那么的不堪一用。于是乎，在这段历史长河的至暗时刻，大大小小的国际组织、国家都在ASCII的基础上衍化出自己的编码标准，因编码不同而导致的水土不服问题频出。</p><p>比如在中国，先后曾衍生出GB2312、GBK、GB18030的编码，这类编码的设计思想就在于：基于128个ASCII，向上扩展到2个字节来表示中文、数学符号、罗马希腊字母、日文假名等等，而128个ASCII则原封不动还是用1个字节来表示，而这就是输入法常提示的全角与半角的由来。</p><p>终于，美国人意识到了ASCII设计之初的狭隘，几经辗转，有一个在加州的组织制定了全球统一的编码规则——Unicode(中文名称为统一码，又译作万国码、统一字元码、统一字符编码)。现在的软件系统大多采用Unicode，如XML（ExtensibleMarkupLanguage，可扩展置标语言）、Java都默认采用Unicode，Unicode不是一种特定的编码，而是更上一层的编码规则，向下有多种具体的编码格式，如今最常用的就是向下兼容ASCII的UTF-8以及和UCS-2兼容的UTF-16。</p><blockquote><p>Unicode一经问世，备受认可，为ISO纳入国际标准，成为通用字符集，即ISO/IEC10646（ISO老白嫖怪了，经典操作：方案是你的，但标准我来制定，谁叫你Unicode组织只是个商业机构呢）。</p></blockquote><p>纵观历史长河，我们发现ASCII编码的核心问题在于表示每个字符的bit位太少，所以各种扩展编码都进行了加倍甚至超级加倍的动作，只不过大家的映射表都是自制，因此可能同一个字符在不同编码映射表里的值并不相同，所以当鸡同鸭讲时、鸭听到的全是乱码，这是任由扩展而带来的衍生问题。Unicode大一统后，一概使用一致的字集编码。Unicode默认采用的编码是UCS-2，它采用16位的编码空间（也就是每个字符占用2Bytes，最多可表示2^16=65536个字符），事实上6w+的字符量已经足以cover全球主要语言的大多数字符，但unicode还是提供了一个扩展机制，允许表示一百多万个字符（还能怎样，2个字节不够，那就3个，3个不够就4个）。</p><p>为了能够兼容ASCII，像是英文字母“A”，它的ASCII值是65（十六进制表示是0x41,0x是十六进制hex的前缀），用unicode编码时我们保证其值不发生改变，由于UCS-2是16位，那么高位就用0填充，写成：U+0041。值是相同的，唯一的区别在于，从1个字节变成了2个字节，体积膨胀了一倍。至于各种其他乌七八糟的字符，我们预先按区间划分做dispatch即可，比如中文“一”对应的值是U+4e00（十进制就是19968），舒服了。</p><p>UCS-2在设计上和ASCII一样，都是定长编码，其带来的问题就在于对于那些一个Byte（8bit）就足以表达的字符，我们不得不用两个Bytes来存储，这会导致存储上的冗余（存了太多不必要的0x00）。而另一方面，由于像是ASCII囊括的那些字符，往往在日常工作中都是高频出现，这就会进一步加剧存储上的冗余。</p><blockquote><p>现代存储单元的最小单位一般是Byte(字节)。</p></blockquote><p>那么怎么办呢？我们发现罪魁祸首在于UCS-2是定长的，如果我们能设计一种变长的编码，也就是可长可短的编码方式，这个空间浪费问题不就迎刃而解了吗？</p><p>但是使用变长又会引入新的问题：我怎么知道这一次解码时，是该取长度1还是长度2呢？所以我们需要制定一种规则，让解码的时候有迹可循。比如，我们设计这样一系列规则：</p><ul><li>对于单Byte字符，8bit位中最高位必须等于0（ASCII只有128个嘛，这点可以办到）</li><li>对于需要N Bytes的字符：<ul><li>首个Byte：<ul><li>高位前N位为<code>1</code></li><li>第N位为<code>0</code></li></ul></li><li>其余Byte：<ul><li>高位以<code>10</code>开头</li></ul></li><li>未提及的位使用对应的unicode补充，不足的在高位用0补充</li></ul></li></ul><p>实际上这就是UTF-8编码，文字说起来很抽象，用图表展示会更直观：</p><p><img src="2023-04-19-15-40-11.png" /></p><p>经过这种方式，我们在解码时就可以根据第一个Byte的控制头来识别到底是要连续读入几个Byte，又要怎么把他们还原成原始code。那么现在我有个问题留给你思考：为啥其余Byte也要安排个<code>10</code>控制头呢？</p><p>经过UTF-8编码，我们的字符就变成了这样：</p><p><img src="2023-04-19-15-41-03.png" /></p><blockquote><p>除了UTF-8以外，还有其他的编码方式，比如UTF-16（2或4字节变长）、UTF-32（4字节定长）。</p></blockquote><p>细心的读者可能会发现这样一个问题：变长编码虽然解决了单字节变双字节存储冗余的问题，但由于控制字符的存在也引入了额外成本，一些字符可不仅仅是2个字节，而是3个甚至是4个（比如汉字通通都是3个），而这对比UCS-2或者是像中文的GB2312,GBK,GB18030来说，对于存储汉字实际上也是会造成冗余的。</p><p>UTF-8确实有着这一问题，但其设计实际上是早期互联网传输的带宽限制与国际字符互通的双向妥协（彼时本地存储的价格已经被降得很低，不再成为瓶颈）。因此，在2023的今天，你可能还能找到一些使用GBK等中文字符集的场景（比如MySQL），甚至可能还会有C语言遗老跟你讲strlen和中文字符长短的故事。毕竟对于包含大量中文的文本文件，使用GBK编码相比UTF-8确实能省近乎1/3的存储空间。</p><h3 id="文本文件">文本文件</h3><p>使用各种编码编写的文本，存储到文件里，这个文件就被称作“文本文件”。我们平时使用编辑器去展示和修改文本内容，实际上这一过程都是经过编解码处理的（你书写的字符经过编码存储到底层文件，编辑器把文件里的数据解码成字符显示出来）。一些常用编辑器乃至IDE(IntegratedDevelopment Environment,集成开发环境)都有选择使用何种编码的功能，即使是Windows的记事本也有着多种编码供你选择（其中就包括UTF-8）。</p><p>如果我们使用二进制编辑器打开编写的hello.c，就会看到磁盘里存储的实际上正是编码后的01序列。</p><p><img src="2023-04-19-17-28-53.png" /></p><h3 id="二进制文件">二进制文件</h3><p>除了文本文件以外，其他文件都是二进制文件。实际上二者本质并没有什么不同，你完全可以把文本文件当成一种特殊的二进制文件，业界之所以有这样的流行概念来加以区分，无非是因为很多标准、API的设计木已成舟，比如C标准库和POSIX的文件接口设计，就有着针对二者的区分。</p><p>每种不同的二进制文件都有着自己的格式，比如前文所讲的：hello.c编译链接生成的二进制可执行文件就有着自己的格式。</p><p><img src="2023-04-19-17-32-11.png" /></p><p>二进制编辑器毕竟不是可视化的，对于不同种类的二进制文件一般需要特定的编辑器才能可视化，比如图片也是二进制文件，但像是PhotoShop、美图秀秀这类可视化编辑软件却可以呈现图片的内容，这一过程本质上和文本编辑器打开文本文件没有什么区别。我们用二进制编辑器打开上面的图片，看看它里面的数据：</p><p><img src="2023-04-19-17-33-41.png" /></p><p>肉眼根本无法理解，我们没办法直接从这些二进制数据在脑海中还原出它是怎样的一张图，只能隐约看到一些“性状特征”：比如有个png字符躺在最前面，它其实是png类型文件的标志头。</p><blockquote><p>电影《黑客帝国》的大佬可是手改二进制，大脑里自动还原成小电影的哦，恐怖如斯！</p></blockquote><h2 id="机器码执行简述">机器码执行简述</h2><p>一个经典的硬件系统组成结构如图：</p><p><img src="2023-04-20-11-58-13.png" /></p><p>我们的程序被操作系统加载到内存之后，最终的机器码是交由CPU来一条条执行的。这些机器码在可执行文件中也以数据的形式存在（遵循冯诺依曼架构）。CPU内部被拆分成控制单元、运算/逻辑单元(ALU)和寄存器(Register)，ALU负责计算、寄存器负责暂存数据、控制器负责在内存、总线和寄存器之间传递数据。内存是一种临时的存储设备，关机之后它的数据会全部丢失，而我们的程序字节码平时是躺在可执行文件中寄放在硬盘上的，硬盘是一种持久化的数据存储，关机并不会擦除已经写入的数据。因此，在计算机运行期间，加载器把可执行文件加载到内存（当你双击打开exe的时候），里面的机器码通过总线送到CPU的ALU，然后一条条指令执行下去。</p><blockquote><p>【维基百科】冯·诺伊曼结构（英语：Von Neumannarchitecture），也称冯·诺伊曼模型（Von Neumannmodel）或普林斯顿结构（Princetonarchitecture），是一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构。存储程序计算机在体系结构上主要特点有：1.以运算单元为中心2.采用存储程序原理 3.存储器是按地址访问、线性编址的空间4.控制流由指令流产生 5.指令由操作码和地址码组成 6.数据以二进制编码</p></blockquote><blockquote><p>为什么内存不做成持久化的呢？一方面是成本问题，另一方面则是没有必要。内存相比机械硬盘哪怕是固态它的速度完全不在一个量级上，像我们的PC，硬盘动不动就1TB、2TB，但内存可能只有16GB、32GB。DRAM的随机读取要比你SATA的随机读取快上1000倍。</p></blockquote><p>那么为什么需要寄存器呢？答案很简单：要提速。尽管内存相比硬盘，它的速度快上了好几个量级，但是对于以纳秒为量纲的现代处理器来说，完全不在一个次元。因此CPU会设计出或多或少的寄存器在内存和ALU之间传话（如果说ALU是皇帝，内存是大臣，那么寄存器就是太监），不同的CPU架构有着不同数量的寄存器，每个寄存器都有它自己的用途，而寄存器的大小则取决于总线的宽度（也就是你一次性最多能传输多少bit数据），比如对于64位系统来说，寄存器的存储空间就是64bit=8Bytes大小。寄存器相比从内存读取数据还要再快上100倍（在2023年的今天，可能远远不止100倍了），但寄存器毕竟存储量级受限于总线宽度与个数，从制作成本和设计上来讲，想要完全通过寄存器来满足针对内存使用上的提速是远远不够的。那怎么办呢？既然寄存器造价太高，我们何不找个折中的法子：做一个中间缓存层，挑一种比DRAM更快且比寄存器更能吃的硬件如何？而这就是现代处理中颇为重要的一个概念：高速缓存。</p><p>高速缓存采用的是一种叫SRAM的存储媒介，相比DRAM它的速度更快但相应的造价也更高。而这一中间层能够起到高额的缓存命中率，本质上的原因在于：我们CPU去执行的指令或者取的数据往往都具有局部连续性，比如一大段机器指令是加载到连续的一段内存，所以在CPU通过总线去取某一条指令的时候，实际上会一次性批量把连续的内存数据（此时就是连续的机器指令）全部拿到并置入高速缓存，等到我们需要继续执行下一条机器码指令时，缓存直接命中进而达成提速的效果。</p><p>实际上现代处理器不仅有缓存，甚至是多级缓存，比如经典的三级缓存模型：</p><p><img src="2023-04-20-15-39-36.png" /></p><p>自顶向下容量逐渐增大，访问速度也逐渐降低。当缓存未命中时，缓存系统会向更底层的层次搜索。</p><ul><li>L1 Cache：在CPU核心内部，分为指令缓存和数据缓存，分开存放CPU使用的指令和数据；</li><li>L2 Cache： 在CPU核心内部，尺寸比L1更大；</li><li>L3 Cache： 在CPU核心外部，所有CPU核心共享同一个L3缓存。</li></ul><p>越顶层的缓存为了提升命中率，功能分类会越细致，层层漏斗下去，最终走到内存。整个计算机系统的存储设备可以组织成一个金字塔型：</p><p><img src="2023-04-20-15-49-24.png" /></p><p>这一张图可谓是把工程实践中“分层”与“缓存”的概念发挥得淋漓尽致。</p><h2 id="操作系统眼里的程序">操作系统眼里的程序</h2><p>一个程序从编写到执行的整个过程，目前就仅剩一个环节就可以完整的自顶向下串起来了，那就是：程序从磁盘上加载到内存的过程。这一步骤由操作系统的加载器完成，它会把躺在硬盘上的可执行文件加载映射到内存中，作为一个独立的进程存在，拥有着自己独立的虚拟内存地址空间。</p><h3 id="进程process">进程(Process)</h3><p>这里就提到了一个在操作系统中非常重要的概念：进程。我们在学操作系统这门课时，老师往往要求熟读并背诵这样两个概念：进程是资源分配的基本单位；线程是任务调度和执行的基本单位。这两句真言本身并没有错，但对于初学者来说确是难以理解的学术派黑话。什么他么资源分配、任务调度，究竟到底什么是进程？</p><p>我们来打个比方：可执行文件躺在硬盘里的时候，你可以把它看成是一种被冻结的生命模板，而在加载到内存后，模板被唤醒克隆出一个新的生命。每个生命体都是一个进程，进程在操作系统里有着唯一的ID标识，同一个生命模板也可以被加载多次，但是它们每次克隆出的都是新生命，彼此隔离。进程实际上是操作系统对一个正在运行的有生命的程序的一种抽象，为什么说它是资源分配的基本单位呢？因为在现代操作系统中，每个进程都有独立的虚拟内存地址空间（当然，不止这一种资源），站在每个进程的第一人称视角来看，它都在独占硬件（处理器、内存和I/O设备），进程之间彼此隔离，谁也看不到谁，只有操作系统才知晓所有进程的存在。</p><p>但是我们知道，硬件设备是唯一的，内存需要大家共享，CPU即使有多核，它的核数也是先天锁定的（你总不能说我CPU就8核，那进程只能有8个吧）。当我们把视角从进程第一人称切到上帝（操作系统）视角来看，就会发现其实每个进程都在交错、并发执行（也就是说轮换着共用多个CPU核）。为什么说是既交错又并发呢？因为进程数往往是远超CPU核数的，所以当多个进程同时在运行的时候，操作系统就得通过某种策略去调度分配，比如我一共有8核，那么在t0时刻，就会有8个进程在同时运行，而等到t1时刻，可能相比t0发生了轮换，此时是另外8个进程同时运行（可能和t0的8个有重叠：可能是连续执行了完整的duration，也可能是被换出之后又换入）。</p><blockquote><p>简单来说，CPU有多少核，就支持同时执行多少条指令。虽然这样说并不严谨，毕竟现代CPU往往有线程超卖的设计，但不妨碍理解。</p></blockquote><blockquote><p>不同类型的操作系统有着迥然不同的调度策略，类型上一般是分为实时操作系统和分时操作系统。我们平时使用的大部分OS像是Windows，Linux都是分时操作系统，它们有时间片的概念，时间片到期或进程(线程)主动让出的时候会让给其他进程(线程)。</p></blockquote><p>而内存则一般是做了一层从物理内存到虚拟内存的映射，操作系统会欺骗每个进程：你们都在独立使用整块DRAM（甚至超卖，比如对32位系统来说有4GB大小的虚拟内存空间，但物理内存DRAM可能只有2G），而只有在进程真正去读写某一小块特定的地址时，操作系统才会真正把物理内存交给你使用。</p><h3 id="虚拟内存线性地址空间">虚拟内存：线性地址空间</h3><p>虚拟内存空间按地址进行索引，整片空间是连续线性的，而地址空间的大小取决于系统位数，对于32位机器来说，这个大小就是4GB，对于现如今最常见的64位机器来说，大小甚至达到了256TB。</p><p><img src="2023-04-20-19-36-33.png" /></p><p>比如上图是一个进程在32位Linux系统上的线性地址空间图，它被分割成了多段，每一段存放特定的资源，比如：代码段（也就是你程序编译链接后的机器码）、数据段、堆(Heap)、栈(Stack)等等。整个寻址空间有4GB的大小，地址范围从0x00000000到0xffffffff。</p><blockquote><p>【进阶】在32位Linux上默认情况下高1GB是内核空间，所有进程共享。低3GB才是进程在用户态可用的线性地址空间。Windows上则默认是高2GB为内核空间，嗯，Windows内核真大。</p></blockquote><h3 id="线程thread">线程(Thread)</h3><p>实际上并发执行并不仅限于多个进程，在现代操作系统中，每个进程内部其实也可以并行执行多个任务，而这，就引出了线程。进程可以管理多个线程，每个线程负责一条控制流，它们共享所属进程的同一片线性地址空间（也就是说彼此天然就看得见），但各自有着私有的资源（比如每个线程都有自己的Stack）。对于那些只有一条控制流的进程，进程或是线程的概念可能显得没那么重要，事实上进程和线程只是现代操作系统抽象出的概念，它们在不同的操作系统里的设计各有差异，在Windows中，进程和线程可以说是一板一眼，进程就是个空壳子，对于那些只有一个控制流的进程它们默认会有一个主线程。而在Linux中情况就比较复杂，进程和线程的概念受历史原因有过多次改版升级，所以并不像Windows那样纯粹。</p><blockquote><p>【进阶】Linux内核弱化了进程、线程的概念（不像Windows进程严格管理线程，调度单位只能是线程，弱化了进程父子关系，使得进程看起来可以通过CreateProcess凭空捏一个出来），内核都是task_struct统一管理，比如<code>vfork()</code>出来的轻量级进程甚至可以与其他进程共享线性地址空间（只不过有个额外标志）。由于历史原因，Linux也遵守了真香定律。以pthread的两种实现LinuxThread（Linux2.4以前）和NPTL（2.5以后）为例，早期内核是没有TGID的，只有PID，所以内核根本就没有线程的概念，在内核眼里都是进程，都是调度器调度的单元，而这就给LinuxThread的实现带来了难题——LinuxThread采用1:1模型，即每个线程都是LWP对应一个内核线程（这个线程的概念是从我们的视角出发的）。而NPTL时代，内核引入TGID，此时依然是1:1模型，但不是简单的LWP了，TGID把这些线程联系了起来，NPTL创建线程时传递一个特有的CLONE_THREAD标志，内核把TGID填写为调用者的PID，PID填写新线程号（原本的进程号）。</p></blockquote><p>为了便于理解，我们采用Windows的视角，统一把线程视为执行流，进程视为管理员。因此CPU核的切换实际上是发生在线程上的，那么线程1是怎么切换到线程2上的呢？我们之前说切换的动作需要内核代码来做，内核代码是运行在内核态的，而我们的代码运行在用户态，怎么就跑着跑着就丢了，就执行到内核的切换代码去了呢？</p><p>事实上，每一个用户态的进程在运行时都会经常进入到内核态，当我们调用了一些系统调用(systemcall)的时候，就会从用户态切换到内核态，比如我们的程序进行了文件I/O、网络I/O、各种资源申请等等操作（一般会引起阻塞）时都会发生这一切换，在内核态想要切换回用户态的前夕，根据操作系统的类型以及调度策略，会去判断是否要将当前所用的CPU核轮换给另一个嗷嗷待哺的线程（比如时间片过没过期啊，优先级啊等等）。</p><p><img src="2023-04-20-20-14-56.png" /></p><p>你可能会问，假如我写个死循环在那里空转，我绝对不自己触发系统调用，那我的CPU核不就没机会让出去了吗？虽然你的想法很危险，但这确实是一个好问题。实际上，现代操作系统内核里还有个特等公民：中断。中断优先级高于内核线程，一旦发生了中断那么一定得让出一个CPU核来立即响应（中断在内核态的地位就好比Linux系统里信号在用户态的地位）。中断处理告一段落后，才会返还给内核线程，此时就产生了线程切换的时点。中断有很多种，这其中用于保证现代操作系统能够进行线性调度的那位爷叫”时钟中断“，时钟中断会通过硬件定时产生，所以年轻人，躲得了初一、躲不了十五。</p><blockquote><p>还有个缺页异常(PageFault)中断也很重要，它是实现每个进程的虚拟内存地址空间的基石，日后我们讲具体的操作系统时再做展开。</p></blockquote><h3 id="通信与竞态">通信与竞态</h3><p>同一个进程下的多个线程彼此是看得见的，因此它们完全可以在用户态互通往来，A1看得见A2，A2也看得见A1，但是A1和A2都无法看见另一个进程B下的B1,B2...另一方面，并发相比单一执行流虽然效率上成倍增长，但也带来了一个新问题：竞态(RaceCondition，也程竞争条件、竞争冒险)，它旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。此词源自于两个信号试着彼此竞争，来影响谁先输出。当线程A1和线程A2同时试图修改一块内存，在没有并发控制的情况下，最后的结果依赖于两个进程的执行顺序与时机，并发访问冲突可能会导致最后的结果不符合预期。</p><p>那么怎么解决竞态问题呢？这就需要我们对共同访问的资源（一般被称为临界区）进行互斥保护，操作系统API乃至一些现代高级语言本身都提供了各种保护的手段，归纳来讲其实就两种思路：”上锁“和”执行不可打断“。锁的设计多种多样，它的思想就是：卫生间就一个，你先进去了就要锁门，防止别人在你答辩的时候误入。等你舒服了之后，锁才会被释放，其他人才有机会使用。而所谓的执行不可打断，就是指我整个过程一气呵成，从所有人的视角看整个动作都是一瞬间完成的，不会被中途打断，也就从根源上避免了竞态，我们一般称其为”原子操作“（这一命名较为古老，是取原子为最小单元不可再拆分之意）。</p><p>当然竞态不一定非要是多核环境下才能触发，即使你只有单核，但是由于CPU轮换调度机制，你的线程A1完全可能在临界区操作中途被打断，换给了A2，而A2又进入了临界区开始操作，此情此景亦会产生竞态。</p><p>实际上我们把镜头拉起，除了同一进程下的多个线程可能会发生竞态以外，即使是多个进程之间也可能会产生竞态。尽管进程之间彼此看不到（主要是看不到彼此的地址空间和独有资源），但它们可能会共同修改同一个磁盘上的文件，我们回过头思考：线程之间的竞态解决本质上是靠线程之间彼此的交互来达成的，这对于进程来说也是一样，但进程天然彼此隔离，所以就需要操作系统去提供一些通信的手段来让进程之间也能互通往来，而这就是大名鼎鼎的IPC（Inter-ProcessCommunication, 进程间通信(Inter-ProcessCommunication)）。进程通信手法多种多样，具体则视操作系统的实现，日后我们有机会讲某一个操作系统时再做展开。</p><blockquote><p>当然，进程通信并不只是为了解决竞态，它原本的目的就是通信本身。不同进程、或是相同程序的不同进程实例之间需要交流的场景非常繁杂，甚至并不局限于同一台机器，即使是两台机器之间，也可以通过网络I/O来达成RPC(RemoteProcedure Call,远端过程调用)。RPC这一概念在2023的今天相当流行，毕竟微服务盛行，服务与服务之间都是通过RPC请求来做server/client级联交互。</p></blockquote><blockquote><p>相对于RPC的是LPC(Local ProcedureCall，本地过程调用)，也就是同一台机器不同进程之间调用（A进程调用B进程的某个接口），只不过LPC的工作都是由IPC完成的（可以这样理解：LPC和RPC在概念上都属于上层，而IPC则是一种实现机制，是底层基础，甚至类Unix系统里都抛弃了LPC的概念，它们认为RPC是LPC能力的超集）。</p></blockquote><h3 id="协程coroutine">协程(Coroutine)</h3><p>协程（Coroutine，也称作微线程（micro-thread）、纤程(fiber)）是近些年才兴起的概念，简单来说，它是一种用户态的轻量级线程。线程是操作系统的概念，物理CPU的调度是在线程之间进行轮转切换，前面我们有提到：CPU在线程之间的切换需要有一个从用户态陷入到内核态的过程，而这个过程实际上是有较高的开销的。另一方面，尽管多线程可以成倍提速（比如对于服务器来说，每个请求进来我都开个线程单独处理），但因线程本身占用资源较多，在系统内受物理资源(CPU核数、内存)限制，数量并不是多多益善（像是服务器一般要做池化管理）。而协程相比线程来说，在面向高并发场景的服务器开发来说，其天然的特性得到了发挥，相比线程具有相当的优势。</p><p>在2023的今天，许多高级语言都内置了协程的能力，像是C++、Python，甚至像Go语言天然就基于协程来编程。</p><blockquote><p>C++在20标准通过了无栈协程coroutine，但仅仅包含了编译器需要实现的底层功能（语法上形如co_awaitbalabala...），通用API的实现Executors已确认会在23标准纳入，同时还会纳入networking库。</p></blockquote><blockquote><p>Python从最初的半协程：生成器yield到asyncio、async/await、asynico，协程的体系不断被完善。</p></blockquote><p>协程之间的切换在用户态完成，并不会陷入到内核，且协程本身占用资源较少，这在异步编程的场景中，极大地节省了开销、提高了性能，于此同时，在大部分编程语言中，协程由于其可以采用结构化并发的编程技法，使得相比传统编写异步代码的CallbackHell或是Promise/Future来说，编写得到了简化、代码可读性与维护性也更高。</p><p>当然协程本身的实现颇为复杂，想要对协程有深刻的理解需要具备相当的异步编程经验（常见于服务器后台网络编程），作为编程导论，我们浅尝辄止，留待日后专题展开。</p><h2 id="总结">总结</h2><p>系统漫游作为开篇第零章，旨在让每一位开发者对自己在用的计算机有一个宏观的、整体能够衔接上的理解。本文谈及的知识点涉及了计算机的基本组成、操作系统、编程语言等专题，通过抽丝剥茧、层层递进的方式带领读者步入编程世界的大门。我们在学习一门技法的同时，一定要养成思考的习惯，如此方能将杂糅零碎的知识点拼凑成完整的体系结构，知其所以然。一旦知识体系成型，日后对于新知识的吸纳将显得顺理成章、自然而然，疑难杂症的排查亦可心中有数、有迹可循。</p><p align="right">by 玉涵，完稿于2023年4月22日深夜，雨</p>]]></content>
    
    
    <categories>
      
      <category>编程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>格物致知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++模板从入门到劝退(2)——型别推导、万能引用与完美转发</title>
    <link href="/2022/06/07/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(2)%E2%80%94%E2%80%94%E5%9E%8B%E5%88%AB%E6%8E%A8%E5%AF%BC%E3%80%81%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    <url>/2022/06/07/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(2)%E2%80%94%E2%80%94%E5%9E%8B%E5%88%AB%E6%8E%A8%E5%AF%BC%E3%80%81%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述严谨性，按照笔者的归纳方式穿针引线，为痴迷于黑魔法而又始终不得其解的同学打通任督二脉。</p><p>本篇是走进模板世界的最后一道前菜，通过型别推导、万能引用与完美转发这三个C++11所引入的新机制，我们得以对模板的世界管中窥豹。</p><span id="more"></span><h1 id="型别推导万能引用与完美转发">型别推导、万能引用与完美转发</h1><p>上一讲的最后我们提到了一种特殊的引用类型：万能引用(UniversalReference)，万能引用虽然长得很像普通的右值引用，但二者却有着本质差别。万能引用是形如<code>T&amp;&amp;</code>的引用类型，当且仅当<code>T</code>的型别需要被直接推导时，万能引用的最终类型判定需要介入引用折叠规则，虽然上一讲我们有提到，但却浅尝辄止。而说到型别推导(TypeDeduction)，这是一个迷人且拥有非常复杂的判定规则的设定，在传统C++中，它始终和模板一起出现，因此传统的C++开发者即使对模板望而生畏、不了解型别推导也不会在日常开发工作中因此而困扰，而C++11引入了<code>auto</code>和<code>decltype</code>关键字，将型别推导的作用放大到开发者的日常中，至此，在现代C++开发中，开发者或多或少都需要亿点点型别推导的知识。</p><blockquote><p><code>auto</code>这个关键字早就存在（从C语言继承过来的legacy），但是在现代操作系统中这玩意毫无卵用，C++11罕见的废弃了<code>auto</code>原本的语义而重新定义了它，要知道，C++可是个相当保守的老顽固。</p></blockquote><h2 id="函数模板实参推导">函数模板实参推导</h2><p>回想一下传统C++中的函数模板实参推导(Function Template ArgumentDeduction)，一个函数模板想要实例化出具体的函数需要确定所有的模板实参，而这里的确定一般有两种手法：一种是显式地指定；另一种是让编译器根据上下文自行推断。实际上这两种手法也常常混用，即函数模板实参的确定由二者共同完成。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里只做了模板声明，省略了定义，这里只是为了做推导演示</span><br><span class="hljs-comment">// 但我们要知道：函数一旦需要执行的话，那么其定义是必不可少的</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> To, <span class="hljs-keyword">typename</span> From&gt;</span><br><span class="hljs-function">To <span class="hljs-title">convert</span><span class="hljs-params">(From f)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">int</span>&gt;(d);    <span class="hljs-comment">// 需要实例化出int convect&lt;int, double&gt;(double)&#123;...&#125;</span><br>    <span class="hljs-type">char</span> c = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">char</span>&gt;(d);  <span class="hljs-comment">// 需要实例化出int convert&lt;int, char&gt;(char)&#123;...&#125;</span><br>    <span class="hljs-built_in">int</span>(*ptr)(<span class="hljs-type">float</span>) = convert; <span class="hljs-comment">// 需要实例化出int convert&lt;int, float&gt;(float)&#123;...&#125;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这就是一个显式指定 +型别推导的例子，第一行我们仅指定了<code>To</code>为<code>int</code>型，<code>From</code>则根据传入的参数<code>d</code>被编译器推导成<code>double</code>型，它与<code>d</code>的类型一致。第二行与第一行类似，只不过显式指定的<code>To</code>类型是<code>char</code>。第三行则有些不同，它定义了一个型别为<code>int(*)(float)</code>的函数指针变量<code>ptr</code>，使其指向<code>convert</code>函数，这里<code>To</code>和<code>From</code>都需要编译器来做推导，根据函数指针类型，分别将<code>To</code>推导成<code>int</code>、<code>From</code>推导成<code>float</code>。<code>ptr</code>实际指向的是函数模板<code>convert</code>实例化出的形如<code>int convert&lt;int, float&gt;(float)&#123;...&#125;</code>的函数，而非<code>convert</code>本身，我们知道函数模板本身只是模板，是没有实体对象的。</p><blockquote><p>该例出自https://en.cppreference.com/w/cpp/language/template_argument_deduction，道行够深的同学一定要通读。</p></blockquote><p>如果将上例中的<code>To</code>和<code>From</code>顺序颠倒，会发生什么事呢？由于模板参数<code>To</code>并没有出现在函数的参数列表中，故某些情况编译器无法通过上下文来推导出<code>To</code>的类型，我们只好这样来写：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> From, <span class="hljs-keyword">typename</span> To&gt;</span><br><span class="hljs-function">To <span class="hljs-title">convert</span><span class="hljs-params">(From f)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;(d);    <span class="hljs-comment">// 完全显式指定，编译器不再需要按参数d的类型做推导</span><br>    <span class="hljs-type">char</span> c = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">double</span>, <span class="hljs-type">char</span>&gt;(d);  <span class="hljs-comment">// 完全显式指定，编译器不再需要按参数d的类型做推导</span><br>    <span class="hljs-built_in">int</span>(*ptr)(<span class="hljs-type">float</span>) = convert;         <span class="hljs-comment">// 还是可以完成推导，需要实例化出int convert&lt;int, float&gt;(float)&#123;...&#125;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>顺序的调换导致我们前两行的自动推导失效，从而不得不完全显式地指定，代码也写成了“愚型”。而另一方面，我们也可以看出，对于函数模板来说，大多数情况的模板实参型别推导还是依赖于函数调用的参数列表，这其中出现了的模板参数往往可以进行推导。我们简单总结下，对于函数模板<code>template&lt;typename T&gt;void f(T param);</code>，编译器可以根据我们实际调用时传入的实参类型来进行推导(<code>f(argument);</code>)，得出模板参数<code>T</code>的类型和相应的参数列表(<code>T param</code>)。</p><p>然而这只是一种情况，也是最简单的情况。实际上，我们需要考虑的维度有三个：</p><ul><li>模板参数本身：<code>T</code></li><li>函数参数列表：不一定是<code>T param</code>，很可能对<code>T</code>做了CV限定或是引用/指针修饰，我们记为<code>ParamType</code></li><li>函数调用实参：<code>argument</code>这个表达式的型别可以千奇百怪</li></ul><p><code>T</code>型别的推导实际上是<code>ParamType</code>和<code>argument</code>的共同作用，从<code>ParamType</code>的视角来看，大抵有着四种情况：</p><ul><li><code>ParamType</code>既非指针也非引用</li><li><code>ParamType</code>是个指针</li><li><code>ParamType</code>是个左值引用</li><li><code>ParamType</code>是个万能引用</li></ul><h3id="paramtype既非指针也非引用"><code>ParamType</code>既非指针也非引用</h3><p>这是最简单的情况：按值传递。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;<br><br><span class="hljs-built_in">f</span>(argument);<br></code></pre></div></td></tr></table></figure><p>值传递的推导规则非常轻量：编译器在推导时会忽略掉<code>argument</code>的顶层CV限定和引用修饰。结合第一讲中的值语义，这一点其实非常好理解：值传递的形参本质上是实参的副本，所以实参的顶层<code>const</code>,<code>volatile</code>特性形参完全可以不care，拷贝以后就跟数据源头毫无瓜葛了，通俗的理解是”大可以我改我的，反正我又不影响你“。至于引用修饰，那就更没关系了，都值语义了，它只能影响从哪个源头拷贝而已。</p><p>此外还要注意，值传递推导所忽略的CV限定只有顶层(top)，底层(bottom)CV限定是不能被忽略的，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> ptr = <span class="hljs-string">&quot;Fun with pointers&quot;</span>;    <span class="hljs-comment">// ptr是个指向const对象的const指针</span><br><span class="hljs-built_in">f</span>(ptr); <span class="hljs-comment">// T被推导成const char*，底层const得以保留，也必须保留</span><br></code></pre></div></td></tr></table></figure><blockquote><p><code>const</code>是限定<code>char</code>还是限定pointer，要看它的位置在<code>*</code>的左边还是右边。</p></blockquote><p>其实这也很好理解，因为值语义拷贝的是个指针，指针本身的<code>const</code>限定可以被擦掉，但是它所指向的类型的<code>const</code>限定是绝对不可以擦掉的。</p><p>来看一些用例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// param类型和T类型始终一致</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    <span class="hljs-comment">// 打印T的型别和param的型别</span><br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);       <span class="hljs-comment">// 最简单的情景，T被推导为int</span><br>    <span class="hljs-built_in">f</span>(cx);      <span class="hljs-comment">// 由于const被忽略，T依然被推导为int</span><br>    <span class="hljs-built_in">f</span>(rx);      <span class="hljs-comment">// 先忽略掉引用、再忽略掉const，T还是被推导成int</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);      <span class="hljs-comment">// T被推导为int*</span><br>    <span class="hljs-built_in">f</span>(&amp;cx);     <span class="hljs-comment">// T被推导为const int*，底层const特性不能忽略</span><br>    <span class="hljs-built_in">f</span>(&amp;rx);     <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(pcx);     <span class="hljs-comment">// T被推导为const int*, 底层const特性不能忽略</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// 顶层const被忽略，T被推导为const int*</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">intint<br>intint<br>intint<br>int *int *<br>const int *const int *<br>const int *const int *<br>const int *const int *<br>const int *const int *<br></code></pre></div></td></tr></table></figure><p>C++标准库的<code>typeid</code>贼鸡儿难用，由于标准没有规定其<code>name</code>成员函数的输出结果，各大编译器花式整活，输出结果尽是些听不懂的“方言”，另一方面<code>typeid</code>也是运行期输出，没那个味儿。作为一名C++程序员，我们遇到困难，也不要怕，微笑着(bushi)……自己实现一个编译期类型计算的方法(当然，本鶸搬运的是so大神的实现)：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span><br><span class="hljs-function">std::string_view</span><br><span class="hljs-function"><span class="hljs-title">type_name</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __clang__</span><br>    string_view p = __PRETTY_FUNCTION__;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">34</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">34</span> - <span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(__GNUC__)</span><br>    string_view p = __PRETTY_FUNCTION__;<br><span class="hljs-meta">#  <span class="hljs-keyword">if</span> __cplusplus &lt; 201402</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">36</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">36</span> - <span class="hljs-number">1</span>);<br><span class="hljs-meta">#  <span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">49</span>, p.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;;&#x27;</span>, <span class="hljs-number">49</span>) - <span class="hljs-number">49</span>);<br><span class="hljs-meta">#  <span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>    string_view p = __FUNCSIG__;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">84</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">84</span> - <span class="hljs-number">7</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>现阶段初学者还不需要理解这段代码，实际上他并没有做什么神奇的操作，只是对不同的编译器生成的函数签名中截取了想要的部分字符串而已。总之，现在只需要知道<code>type_name</code>这个函数模板可以输出任何模板参数<code>T</code>的类型。</p><h3 id="paramtype是个指针"><code>ParamType</code>是个指针</h3><p>模板形如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T* param)</span></span>;  <br></code></pre></div></td></tr></table></figure><p>此时，形参<code>param</code>的类型已经被限制成必须是某个类型的指针型，指针型本质上也是按值传递（拷贝的是地址值，即指针型变量存储的value），推导规则就尝试将实参<code>argument</code>“适配”到形参上去，形参类型确定了，那么<code>T</code>的类型也就确定了，此时形参和<code>T</code>是不同的。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T* param)</span> </span>&#123;<br>    <span class="hljs-comment">// 输出T的类型和形参param的类型</span><br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">int</span>* px = &amp;x;<br>    <span class="hljs-type">int</span>*&amp; rpx = px;             <span class="hljs-comment">// 指针的引用，</span><br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* pcx = &amp;x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> pcpx = &amp;x; <span class="hljs-comment">// 当然了，像rpx,pcpx这种东西你日常编程基本遇不到，这里只是为了让例子尽量丰满</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);   <span class="hljs-comment">// T被推导为int, param被推导为int*</span><br>    <span class="hljs-built_in">f</span>(px);   <span class="hljs-comment">// 同上</span><br>    <span class="hljs-built_in">f</span>(rpx);  <span class="hljs-comment">// 同上</span><br>    <span class="hljs-built_in">f</span>(pcx);  <span class="hljs-comment">// T被推导为const int, param被推导为const int* </span><br>    <span class="hljs-built_in">f</span>(pcpx); <span class="hljs-comment">// T被推导为const int, param被推导为const int*</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">intint *<br>intint *<br>intint *<br>const intconst int *<br>const intconst int *<br></code></pre></div></td></tr></table></figure><p>实际上，指针型的推导和第一种情况的值推导很相似，引用修饰和顶层const同样会被忽略，只不过<code>T</code>的类型和形参<code>param</code>的类型有所区别罢了。</p><h3 id="paramtype是左值引用"><code>ParamType</code>是左值引用</h3><p>模板形如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;<br></code></pre></div></td></tr></table></figure><p>这种情况相当于限定了形参<code>param</code>的类型一定是某个类型的左值引用，这就意味着我们的传参方式是按引用传递(传址)，因此一方面实参<code>argument</code>的引用修饰会被忽略（因为不管是不是引用类型，最终推导出的形参都必须是个左值引用），另一方面其CV限定不会也不能被忽略，因为相比于值传递，我们此时传递的对象并不会拷贝一份，因此其<code>const</code>,<code>volatile</code>特性绝对不能忽略或者舍弃。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);       <span class="hljs-comment">// T被推导为int, param被推导为int&amp;</span><br>    <span class="hljs-built_in">f</span>(cx);      <span class="hljs-comment">// T被推导为const int, param被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(rx);      <span class="hljs-comment">// rx本身的reference会被忽略，因此和传递cx没什么两样</span><br><br>    <span class="hljs-comment">//f(&amp;x);    // 这三个都不能通过编译，因为param是左值引用必须绑定到左值上</span><br>    <span class="hljs-comment">//f(&amp;cx);   // 取地址符表达式是prvalue，不能被lvalue reference绑定</span><br>    <span class="hljs-comment">//f(&amp;rx);</span><br><br>    <span class="hljs-built_in">f</span>(pcx);     <span class="hljs-comment">// T被推导为const int*, param被推导为const int*&amp;</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// T被推导为const int* const, param被推导为const int* const&amp;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">intint &amp;<br>const intconst int &amp;<br>const intconst int &amp;<br>const int *const int *&amp;<br>const int *constconst int *const &amp;<br></code></pre></div></td></tr></table></figure><p>而说到左值引用，就不得不提到C++中的万金油：const左值引用，试想如果我们前置地对<code>param</code>型别增加一个<code>const</code>限定会如何呢？</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);   <span class="hljs-comment">// T被推导为int, param被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(cx);  <span class="hljs-comment">// T被推导为int, param被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(rx);  <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);  <span class="hljs-comment">// const左值引用也可以绑定到右值上，因此编译通过。T被推导为int*，param被推导为const int*&amp;</span><br>    <span class="hljs-built_in">f</span>(&amp;cx); <span class="hljs-comment">// T被推导为const int*，param被推导为const int* const &amp;</span><br>    <span class="hljs-built_in">f</span>(&amp;rx); <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(pcx); <span class="hljs-comment">// pcx是左值，T被推导为const int*, param绑定其上，本身追加const限定，因此被推导为const int* const&amp;</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// 同上，不管T本身是否有顶层const, param都会具有顶层const</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">intconst int &amp;<br>intconst int &amp;<br>intconst int &amp;<br>int *int *const &amp;<br>const int *const int *const &amp;<br>const int *const int *const &amp;<br>const int *const int *const &amp;<br>const int *const int *const &amp;<br></code></pre></div></td></tr></table></figure><p>这些例子看起来很绕，但实际上，如果你搞懂了基于值语义和引用语义的型别推导原则，它们都是显而易见的。</p><h3 id="paramtype是万能引用"><code>ParamType</code>是万能引用</h3><p>这里就和上一讲的结尾接轨了，它是C++11引入右值引用后，自然而然演化出的产物。我将C++标准对万能引用的定义翻译成白话：万能引用是一种特殊的引用类型，它所引用的类型需要被推导，且携带了用于型别推导的实参的值分类信息，使得其可以被<code>std::forward</code>完美转发。我们先忽略最后半句，通过函数模板参数来理解一下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123; <span class="hljs-comment">// 此时T&amp;&amp;是个万能引用，不论类型如何，我们知道param一定是引用，所以是按引用传递</span><br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);       <span class="hljs-comment">// x是左值，按引用传递就视为左值引用，这和你用x作为实参去调用一个形参为int&amp;的函数没什么区别</span><br>                <span class="hljs-comment">// 因此T被推导成int&amp;, param也被推导成int&amp;（此时发生了引用折叠）</span><br>    <span class="hljs-built_in">f</span>(cx);      <span class="hljs-comment">// cx也是左值，但因为按引用传递，const特性必须保留</span><br>                <span class="hljs-comment">// 因此T被推导成const int&amp;, param也被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(rx);      <span class="hljs-comment">// 同上，是否按引用传递取决于形参有没有reference修饰，这一点跟实参本身是不是reference没关系</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);      <span class="hljs-comment">// &amp;x是右值，只有右值引用才能绑定到右值上，因此param只能被推导成int* &amp;&amp;(int指针型的右值引用)</span><br>                <span class="hljs-comment">// 此时T被推导为int*</span><br>    <span class="hljs-built_in">f</span>(&amp;cx);     <span class="hljs-comment">// 同上</span><br>    <span class="hljs-built_in">f</span>(&amp;rx);     <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(pcx);     <span class="hljs-comment">// pcx是左值，故T被推导为const int*&amp;，param也一样</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// cpcx是左值，故T被推导为const int* const &amp;, param也一样</span><br>                <span class="hljs-comment">// 只不过按引用传递的情况，顶层const必须保留</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">int &amp;int &amp;<br>const int &amp;const int &amp;<br>const int &amp;const int &amp;<br>int *int *&amp;&amp;<br>const int *const int *&amp;&amp;<br>const int *const int *&amp;&amp;<br>const int *&amp;const int *&amp;<br>const int *const &amp;const int *const &amp;<br></code></pre></div></td></tr></table></figure><p>可以看到万能引用终归是个引用，不管是左值引用还是右值引用，不管有没有CV限定，最终都得是按引用传递，因此规则上和第三种：<code>ParamType</code>为左值引用时相同，只不过它多了一步根据实参来确定引用类型（同时也解决了传统C++中，只能用const左值引用来按引用传递右值以避免拷贝的局限性设计问题）。</p><p>事实上，我们大可以将分类改成两类，即前两种是一类，后两种是一类，分类的口径则是形参的传递方式（值传递还是引用传递）。</p><blockquote><p>不管是标准手册还是广为流传的参考书，它们对型别推导的归纳看上去都非常的复杂（哪怕是用很简单的例子），本质上是因为它们没有从值语义或是引用语义来出发，事实上，只要你拿捏住一件事：推导过程中形参究竟是值传递还是引用传递，那么不管多复杂的case，都有迹可循。</p></blockquote><h2 id="auto与decltype">auto与decltype</h2><p>以函数模板实参推导为例，我们看穿了型别推导背后的机制：值传递和引用传递的差别对待。C++11为了简化历来饱受诟病的又臭又长的语法(诸如<code>std::map&lt;std::string, std::vector&lt;std::string&gt;&gt;::const_iterator</code>)，引入了<code>auto</code>和<code>decltype</code>这两个关键字。这两位爷都是用于型别推导的，只是推导的规则不同，<code>auto</code>这个关键字的使用在现代C++中要分两个场景来看：其一是最常见的为变量做型别推导；其二是为函数返回类型做推导（C++14之后才发糖支持）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 第一种场景：变量型别推导</span><br><span class="hljs-keyword">auto</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; r = a;<br><span class="hljs-keyword">auto</span> *p = &amp;a;<br><br><span class="hljs-comment">// 第二种场景：函数返回类型推导</span><br><span class="hljs-comment">// 在C++11中，只能写作：</span><br><span class="hljs-comment">// auto f() -&gt; decltype(666) &#123; return 666; &#125;</span><br><span class="hljs-comment">// 虽然看起来只是加了个尾部型别推导，但这里的auto只是个占位符（PlaceHolder），与C++14中真正用于推导的auto有本质差别</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">666</span>; &#125;<br></code></pre></div></td></tr></table></figure><p>无论哪一种场景，<code>auto</code>所应用的推导规则实际上就是模板实参推导的规则。我们知道，前面在做函数模板实参推导时，需要考量的有3个维度：模板参数<code>T</code>，函数形参类型<code>ParamType</code>和传递的实参<code>argument</code>。如何类比呢？实际上我们可以把<code>auto</code>看做模板参数<code>T</code>，而<code>auto</code>结合CV限定和引用、指针修饰而成的最终变量类型则看做<code>ParamType</code>，<code>=</code>右边的表达式看做<code>argument</code>。</p><blockquote><p><code>auto</code>的型别推导与模板实参推导的规则实际上有一点不同：前者会将花括号语法视为<code>std::initializer_list</code>(C++17有所调整，仅限于'='右边)，而后者并不会。<code>std::initializer_list</code>这个东西在C++11引入，主要是为了给花括号初始化语法做补丁，然而C++语法的复杂导致这个东西在很多使用场景下显得格格不入，之后的标准演进中也一直在缝缝补补。</p></blockquote><p>我们直接看例子，按照上面描述的置换规则置换一下，再根据在模板实参推导中已掌握的知识，揣摩一下输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;            <span class="hljs-comment">// 值传递，对应case 1，T被推导为int，x的类型也是int</span><br>    <span class="hljs-keyword">auto</span>&amp; rx = x;           <span class="hljs-comment">// 引用传递，对应case3, T被推导为int, rx的类型是int&amp;</span><br>    <span class="hljs-keyword">auto</span>&amp;&amp; rrx = <span class="hljs-number">666</span>;       <span class="hljs-comment">// 引用传递，对应case4，auto&amp;&amp;是个万能引用</span><br>                            <span class="hljs-comment">// 666是prvalue，故T被推导为int，rrx的类型是int&amp;&amp;</span><br>    <span class="hljs-keyword">auto</span>&amp;&amp; lrx = x;         <span class="hljs-comment">// 引用传递，对应case4，auto&amp;&amp;是个万能引用</span><br>                            <span class="hljs-comment">// x是lvalue，故T被推导为int&amp;，lrx的类型也是int&amp;</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> cx = x;      <span class="hljs-comment">// 值传递，T被推导为int, cx的类型是const int</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; rcx = x;    <span class="hljs-comment">// 引用传递，T被推导为int, rcx的类型是const int&amp;</span><br><br>    <span class="hljs-keyword">auto</span>* px = &amp;x;          <span class="hljs-comment">// 值传递，T被推导为int, px的类型是int*</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>* pcx = &amp;cx;  <span class="hljs-comment">// 值传递，T被推导为int, pcx的类型是const int*    </span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>* <span class="hljs-type">const</span> cpcx = &amp;cx;   <span class="hljs-comment">// 值传递，T被推导为int, cpcx的类型是const int* const</span><br><br>    <span class="hljs-comment">// 这里用到了decltype这个specifier，我们暂且只需要知道decltype(variable)可以原封不动的给出variable的类型</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of x: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(x)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of rx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(rx)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of rrx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(rrx)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of cx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(cx)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of rcx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(rcx)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of px: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(px)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of pcx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(pcx)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of cpcx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(cpcx)&gt;() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">type of x: int<br>type of rx: int &amp;<br>type of rrx: int &amp;&amp;<br>type of lrx: int &amp;<br>type of cx: const int<br>type of rcx: const int &amp;<br>type of px: int *<br>type of pcx: const int *<br>type of cpcx: const int *const<br></code></pre></div></td></tr></table></figure><blockquote><p>思考一下：如果<code>auto* pcx2 = &amp;cx;</code>，<code>pcx2</code>是什么类型？<code>auto* const &amp; pcx3 = &amp;cx;</code>呢？如果你可以轻松地推导出来，那么恭喜你，你已经领悟了型别推导的奥义。</p></blockquote><p><code>decltype</code>也有两个与<code>auto</code>类似的使用场景，一种就是像上例那样使用的对变量做'='右边表达式的型别推导，另一种也是用在函数返回值推导中，写作<code>decltype(auto)</code>。</p><p><code>decltype</code>相比<code>auto</code>则没有那么麻烦的推导规则，它只是简单粗暴的告诉我们给定实参(<code>argument</code>)的真实类型（意味着不会忽略CV限定、引用修饰）。<code>argument</code>是一个表达式（也包括实体(entity)的情况），但通过前两节的学习，我们知道表达式的值类型有多种情况，所以还是要分情况讨论下：</p><ul><li>如果<code>argument</code>是没有套上小括号的变量(严格的说法是id-expression，不过为了便于理解我们忽略官方的黑话)或是类成员访问表达式(通俗的理解这也是个变量)，decltype给出其本身的类型。</li><li>否则，对于其他类型<code>T</code>的表达式<ul><li>如果表达式的值分类是xvalue，则推导为<code>T&amp;&amp;</code></li><li>如果表达式的值分类是lvalue，则推导为<code>T&amp;</code></li><li>如果表达式的值分类是prvalue，则推导为<code>T</code></li></ul></li></ul><p>这实际上就是cppreference给出的<code>decltype</code>说明符的解释，初学者可能会对第一条款中提到的小括号包裹感到奇怪，实际上它的本质原因在于entity和expresion的区别，假设有变量<code>int a = 3;</code>，<code>a</code>我们可以说它是一个entity，但是<code>(a)</code>就不再是一个实体，而是一个表达式了，套上小括号意味着表达式需要被计算(或处理)，即使我们对<code>a</code>什么都没做，它也需要处理。因此，对于<code>(a)</code>来说，它是个表达式，要根据第二条款来判定，由于<code>(a)</code>是个lvalue，所以此时型别为<code>int&amp;</code>。</p><blockquote><p>说到这里就不得不提一个现代C++中很有意思的坑：返回值类型支持<code>decltype(auto)</code>推导后，对于函数返回语句如果要返回一个变量，那么写成<code>return a;</code>和<code>return (a);</code>意义完全不同，前者会被推导为<code>a</code>的类型，而后者被推导为<code>a</code>的左值引用类型。而如果没有用到推导，而是老老实实的返回<code>a</code>的类型，那么这两种写法其实都可以，只不过后者做了一次计算，不会引入其他问题。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">double</span> x;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">get_ref</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *p)</span> </span>&#123; <span class="hljs-keyword">return</span> *p; &#125;<br><br><span class="hljs-comment">// 相当于C++11中的auto get_ref_forward1(const int* p) -&gt; decltype(get_ref(p))</span><br><span class="hljs-comment">// 由于get_ref(p)是个表达式返回的是个lvalue，故推导成const int&amp;</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">get_ref_forward1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_ref</span>(p);<br>&#125;<br><br><span class="hljs-comment">// 值传递，返回的一定是个值类型，此时的实参是get_ref(p)，忽略掉顶层CV限定，于是推导为int</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_ref_forward2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_ref</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-keyword">decltype</span>(a.x) y = <span class="hljs-number">1.0</span>;  <span class="hljs-comment">// 对于entity，y推导成其本身的类型double</span><br>    <span class="hljs-keyword">decltype</span>((a.x)) z = y;  <span class="hljs-comment">// 由于小括号的存在导致按表达式来推导，(a.x)是左值故推导成double&amp;</span><br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;             <br>    <span class="hljs-keyword">decltype</span>(i) j = i;      <span class="hljs-comment">// 对于entity，j推导成本身类型int</span><br>    <span class="hljs-keyword">decltype</span>((i)) k = j;    <span class="hljs-comment">// 由于小括号的存在导致按表达式来推导，(i)是左值故推导成int&amp;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i;       <br>    <span class="hljs-keyword">decltype</span>(ci) cj = ci;   <span class="hljs-comment">// 推导成const int，decltype不会像auto那样忽略顶层CV限定</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of y: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(y)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of z: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(z)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of j: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(j)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of k: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(k)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of cj: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(cj)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of return value of get_ref_forward1: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">get_ref_forward1</span>(&amp;ci))&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of return value of get_ref_forward2: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">get_ref_forward2</span>(&amp;ci))&gt;() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">type of y: double<br>type of z: double &amp;<br>type of j: int<br>type of k: int &amp;<br>type of cj: const int<br>type of return value of get_ref_forward1: const int &amp;<br>type of return value of get_ref_forward2: int<br></code></pre></div></td></tr></table></figure><blockquote><p>思考一下：如果get_ref_forward2的返回类型写作<code>auto&amp;</code>，又该是什么类型呢？</p></blockquote><h2 id="恼人的数组与函数">恼人的数组与函数</h2><p>凡是总有例外，在C++中，有两种类型天生需要被特殊处理，那就是从C语言继承过来的数组和函数名称。在C语言中，数组和指针常常混用，绝大部分场景都可以互为代替使用，这就导致很多人将数组和指针视为同一种东西的不同写法，虽然这个看法是错误的，但在日常开发中，用这样一种局限性的看法来读写代码确实会使事情简单化。函数名称则简单不少，在C中几乎被视为相应的函数指针类型。C++继承了C的legacy，但随着C++语法规则的不断演进，数组和函数名称逐渐显得格格不入，为此，C++做了很多语法上兼容性处理，在很多语境下，数组会退化(decay)成指向其首元素的指针型，而函数名称会退化(decay)成相应的函数指针型。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> name[] = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-comment">// name的类型是const char[6]</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* p1 = name;          <span class="hljs-comment">// 数组退化，p1指向name的首元素</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* p2 = <span class="hljs-string">&quot;world&quot;</span>;       <span class="hljs-comment">// &quot;world&quot;是一个字符串字面量左值，类型为const char[6]</span><br>                                <span class="hljs-comment">// 数组退化，p2指向&quot;world&quot;首元素</span><br></code></pre></div></td></tr></table></figure><p>从C++的视角来看，假如没有退化规则，那么对指针的初始化显然是不合法的，但为了兼容C的legacy，不得不做了容忍。另一方面，在C中我们经常写:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-comment">// 这在C中非常常见，但如果是在C++11之后是不合法的，尽管编译器只抛了warning：</span><br>                        <span class="hljs-comment">// ISO C++11 does not allow conversion from string literal to &#x27;char *&#x27; </span><br>                        <span class="hljs-comment">// 字符串字面量是左值（意味着可以被取地址），它有着const特性，底层const不能丢，所以得用const char*</span><br><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;world&quot;</span>;   <span class="hljs-comment">// 这是C语言对字符数组发放的语法糖，str的类型实际上是char[6]</span><br>                        <span class="hljs-comment">// 等价于char str[6] = &#123;&#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;\0&#x27;&#125;</span><br>                        <span class="hljs-comment">// C语言一方面支持定界值省略，另一方面对字符数组做了照顾：花括号初始化语法可以改写为字符串字面量</span><br>                        <span class="hljs-comment">// C++继承了C，所以这在C++中也合法，且语义相同，注意区分和前者的差别</span><br></code></pre></div></td></tr></table></figure><p>为了说明两种语法的差别，我们编写如下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;world&quot;</span>;<br><br>    cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of p: %p\n&quot;</span>, p);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of \&quot;hello\&quot;: %p\n&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of str: %p\n:&quot;</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of \&quot;world\&quot;: %p\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">hello world<br>address of p: 0x10232bea4<br>address of &quot;hello&quot;: 0x10232bea4<br>address of str: 0x16dad76f8<br>:address of &quot;world&quot;: 0x10232bf03<br></code></pre></div></td></tr></table></figure><p>显然，<code>p</code>和<code>"hello"</code>的地址是相同的，说明它们是同一个对象。而<code>str</code>则和<code>"world"</code>有所不同，<code>str</code>只是以<code>char</code>为单位逐个拷贝了<code>"world"</code>的数据到自身的存储单元而已，其类型是<code>char[6]</code>。</p><p>再来看看当数组涉及型别推导时，效果如何：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">f</span>(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">type of T: int *<br>type of param: int *<br>type of T: char *<br>type of param: char *<br></code></pre></div></td></tr></table></figure><p>由于<code>param</code>值传递，所以推导时数组类型发生了退化，降级成对应的首元素指针型。而如果改为按引用传递，则不会发生decay：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);                          <br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-built_in">move</span>(str));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">type of T: int (&amp;)[5]<br>type of param: int (&amp;)[5]<br>type of T: char [6]<br>type of param: char (&amp;&amp;)[6]<br></code></pre></div></td></tr></table></figure><p>可以看到param就是传递进来的参数的原本类型。</p><p>如果说上面的例子根据我们的口诀来看还算中规中矩，那下面这个就有点反人类了：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里的定界6不能少，否则param是个非法的数组引用</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T (&amp;param)[<span class="hljs-number">6</span>])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 虽然写作T[]，但因为值传递的关系，还是退化成了T*，定界写不写都无所谓，随便写什么都行</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T param[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);<br>    <span class="hljs-built_in">g</span>(v);<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">f</span>(str);<br>    <span class="hljs-built_in">g</span>(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">type of T: int<br>type of param: int (&amp;)[6]<br>type of T: int<br>type of param: int *<br>type of T: char<br>type of param: char (&amp;)[6]<br>type of T: char<br>type of param: char *<br></code></pre></div></td></tr></table></figure><blockquote><p>我特意把v改成了6个成员，思考一下如果这里不改的话会不会有啥问题？</p></blockquote><p>另外，由于数组引用并不是个直截了当的类型，如果我们写成<code>T (&amp;&amp;param)[6]</code>会编译报错，因为此时param不再是一个万能引用。</p><p>你以为这样就结束了？当数组和非类型模板参数相遇时，还有更离谱的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 函数模板也可以重载，但要注意可能会引发的ambiguous调用问题</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T (&amp;param)[<span class="hljs-number">5</span>])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;template f:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T (&amp;param)[N])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;nontype template f:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T param[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;template g:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T param[N])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;nontype template g:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);                   <span class="hljs-comment">// 优先匹配template f，template f比nontype template f更特殊</span><br>    <span class="hljs-built_in">g</span>(v);                   <span class="hljs-comment">// 只能匹配template g，因为值传递会退化成指针</span><br>                            <span class="hljs-comment">// 即使把template g注释掉也无法匹配nontype template g</span><br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;   <br>    <span class="hljs-built_in">f</span>(str);                 <span class="hljs-comment">// 只能匹配nontype template f，因为template f不满足匹配条件无法成为candidate</span><br>    <span class="hljs-built_in">g</span>(str);                 <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">template f:<br>type of T: int<br>type of param: int (&amp;)[5]<br>template g:<br>type of T: int<br>type of param: int *<br>nontype template f:<br>type of T: char<br>type of param: char (&amp;)[6]<br>template g:<br>type of T: char<br>type of param: char *<br></code></pre></div></td></tr></table></figure><p>因为decay的关系，nontype templateg实际上无法被用到，如果我们把它改写成传引用呢：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T (&amp;param)[N])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;nontype template g:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>此时就会遇到编译错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">test_array3.cpp:37:5: error: call to &#x27;g&#x27; is ambiguous<br>    g(v);<br>    ^<br>test_array3.cpp:21:6: note: candidate function [with T = int]<br>void g(T param[]) &#123;<br>     ^<br>test_array3.cpp:28:6: note: candidate function [with T = int, N = 5]<br>void g(T (&amp;param)[N]) &#123;<br>     ^<br>test_array3.cpp:40:5: error: call to &#x27;g&#x27; is ambiguous<br>    g(str);<br>    ^<br>test_array3.cpp:21:6: note: candidate function [with T = char]<br>void g(T param[]) &#123;<br>     ^<br>test_array3.cpp:28:6: note: candidate function [with T = char, N = 6]<br>void g(T (&amp;param)[N]) &#123;<br>     ^<br>2 errors generated.<br></code></pre></div></td></tr></table></figure><p>因为两个版本此时都可以完成匹配作为candidate，但二者之间论优先级或者说特殊性并不能分出高下，所以导致了函数模板重载所常见的ambiguous错误。</p><blockquote><p>实际上当涉及到类模板对数组的特化时，情形远远比这里给出的例子要复杂得多，另一方面未定界数组实际上也有特殊的手法来传递推导。考虑到不希望这一部分内容喧宾夺主故不做展开，有兴趣的同学可以看一下《C++Templates》5.4的内容。</p></blockquote><p>函数名称和函数指针的情景和数组很像：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &lt; b ? b : a;<br>&#125;<br><br><span class="hljs-keyword">using</span> func = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>(my_max);              <span class="hljs-comment">// decay，退化成函数指针</span><br>    <span class="hljs-built_in">g</span>(my_max);              <span class="hljs-comment">// 不会decay</span><br>    <span class="hljs-built_in">g</span>(std::<span class="hljs-built_in">move</span>(my_max));   <span class="hljs-comment">// 对函数名称进行move没意义</span><br><br>    func fp = my_max;       <span class="hljs-comment">// fp本身就是函数指针类型</span><br>    <span class="hljs-built_in">f</span>(fp);                  <span class="hljs-comment">// 不需要退化，单纯的值传递</span><br>    <span class="hljs-built_in">g</span>(fp);                  <span class="hljs-comment">// 注意是函数指针的左值引用</span><br>    <span class="hljs-built_in">g</span>(std::<span class="hljs-built_in">move</span>(fp));       <span class="hljs-comment">// 注意是函数指针的右值引用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">int (*)(int, int)<br>int (*)(int, int)<br>int (int, int)&amp;<br>int (int, int)&amp;<br>int (int, int)&amp;<br>int (int, int)&amp;<br>int (*)(int, int)<br>int (*)(int, int)<br>int (*)(int, int)&amp;<br>int (*)(int, int)&amp;<br>int (*)(int, int)<br>int (*)(int, int)&amp;&amp;<br></code></pre></div></td></tr></table></figure><p>相信读到这里的你，一定会觉着上面的结果一目了然。</p><h2 id="完美转发">完美转发</h2><p>最后谈谈完美转发。</p><p>除了我们之前详细解读过的<code>std::move</code>，C++11在标准库中还定义了一个非常常用的<code>std::forward</code>，相信对于大部分现代C++初学者来说，<code>std::forward</code>和<code>std::move</code>一度云里雾里。我们先撇开<code>std::forward</code>，来看看如下的一个使用场景：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(T&amp;&amp;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in func1, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>    <span class="hljs-comment">// 我们希望把param原封不动的“渗透”到下一层</span><br>    <span class="hljs-built_in">func2</span>(param);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;in func2, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">666</span>;<br>    <span class="hljs-built_in">func1</span>(a);       <span class="hljs-comment">// a是左值，所以func1中T被推导成int&amp;，param也是int&amp;，此时向下调用func2传递的依然是左值引用</span><br>                    <span class="hljs-comment">// 所以func2中的T和param也都是int&amp;，这是符合预期的 </span><br>    <span class="hljs-built_in">func1</span>(<span class="hljs-number">2333</span>);    <span class="hljs-comment">// 2333是纯右值，func1中T被推导成int，param被推导成int&amp;&amp;，此时向下调用func2传递的是右值引用类型的param</span><br>                    <span class="hljs-comment">// 尽管param的类型是右值引用，但param本身是个左值（具名的变量），这就导致渗透传递时func2中</span><br>                    <span class="hljs-comment">// T和param被推导成int&amp;，这就不符合预期了，我们的引用型在渗透过程中变质了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">in func1, T:int&amp;, param:int&amp;<br>in func2, T:int&amp;, param:int&amp;<br>in func1, T:int, param:int&amp;&amp;<br>in func2, T:int&amp;, param:int&amp;<br></code></pre></div></td></tr></table></figure><p>我们在<code>func1</code>中又调用了<code>func2</code>，且原封不动的将参数<code>param</code>传递了下去，希望能够把左值引用或是右值引用这一特性渗透到下一层，然而事与愿违，由于在C++语法中，即使类型为右值引用的具名变量其本身依然是个左值，这就导致了不可传递性。</p><p>可能有的小伙伴说了，我们不是学过<code>std::move</code>吗，只需要调用<code>func2</code>时对<code>param</code>再<code>move</code>一下不就行了吗？</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in func1, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>    <span class="hljs-comment">// 强制传递右值引用</span><br>    <span class="hljs-built_in">func2</span>(<span class="hljs-built_in">move</span>(param));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>显然，如果按照这个写法，上述例子中后者的运行结果符合预期，可是前者却又出了问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">in func1, T:int&amp;, param:int&amp;<br>in func2, T:int, param:int&amp;&amp;<br>in func1, T:int, param:int&amp;&amp;<br>in func2, T:int, param:int&amp;&amp;<br></code></pre></div></td></tr></table></figure><p>为什么呢？因为你把一个原本是左值引用的param强制转成了右值引用向下传递！可以说是按下葫芦浮起瓢。可是这种需求在我们日常开发中很常见啊，就真的没办法兼容吗？不，成年人的世界从来都是：我全都要~</p><p>我们采用标准库中的<code>std::forward</code>试一下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in func1, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>    <span class="hljs-built_in">func2</span>(forward&lt;T&gt;(param));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">in func1, T:int&amp;, param:int&amp;<br>in func2, T:int&amp;, param:int&amp;<br>in func1, T:int, param:int&amp;&amp;<br>in func2, T:int, param:int&amp;&amp;<br></code></pre></div></td></tr></table></figure><p>可以发现确实达成了我们想要的结果，而这就是C++中所谓的完美转发(PerfectForwarding)。那么问题来了，<code>std::forward</code>只不过是标准库中的函数，既不是什么语法糖，也不是什么黑科技，它是怎么做到完美转发的呢？</p><p>实际上<code>std::forward</code>并没有做什么神奇的操作，它背后所依赖的原理就在于：我们需要区分左值引用和右值引用，而这一信息其实通过param是可以知晓的，param要么是一个左值引用、要么是一个右值引用，而对于这两种情况，我们需要一种if-else的逻辑来分别处理，对于前者来说，我们直接传递下去即可；而对于后者来说，渗透传递时我们要做一次<code>std::move</code>来把它强制转成右值引用。</p><p>另一方面，<code>std::forward</code>是一个函数模板，我们传入了<code>param</code>作为参数，而<code>param</code>携带了引用类型的信息，所以只需要编写重载函数，分别处理左值引用和右值引用的不同<code>param</code>即可：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp; param)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp;&amp; param)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>remove_reference_t</code>是标准库中的一种typetrait，可以洗掉类型<code>T</code>的引用修饰，这里是为了先确保拿到一个纯净类型，然后再分别施加左值引用或者是右值引用的修饰，注意，对于后者而言<code>remove_reference_t&lt;T&gt;&amp;&amp;</code>不是万能引用，而是一个彻彻底底的右值引用。于是，当我们向<code>std::forward</code>传递一个左值时，会匹配到第一个函数模板，此时<code>T</code>是左值引用，因此返回的类型根据引用折叠规则已然是一个左值引用；而当传递右值时，则会匹配到第二个函数模板，此时<code>T</code>不是引用类型，但返回的类型由于<code>static_cast&lt;T&amp;&amp;&gt;</code>将<code>T</code>强制转成了其右值引用类型。</p><p>实际上上面的代码与各大编译器厂商实现的标准库<code>std::forward</code>如出一辙，只是标准库中的代码有更多的诸如constexpr、noexcept等杂七杂八的修饰。</p><h2 id="参考文献">参考文献</h2><ul><li><ahref="https://en.cppreference.com/w/cpp/language/template_argument_deduction">Templateargument deduction</a></li><li><ahref="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/">EffectiveModern C++</a></li><li><ahref="https://en.cppreference.com/w/cpp/language/reference">Referencedeclaration</a></li><li><ahref="https://en.cppreference.com/w/cpp/language/auto">Placeholder typespecifiers</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>program-language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>cpp-templates</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++模板从入门到劝退(1)——右值引用与移动语义</title>
    <link href="/2022/06/04/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(1)%E2%80%94%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
    <url>/2022/06/04/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(1)%E2%80%94%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述严谨性，按照笔者的归纳方式穿针引线，为痴迷于黑魔法而又始终不得其解的同学打通任督二脉。</p><p>本篇是走进模板世界的第二道前菜，只有搞懂了这些C++中的基本概念，才能掌握模板世界的黑魔法。</p><span id="more"></span><h1 id="右值引用与移动语义">右值引用与移动语义</h1><h2 id="右值引用初探">右值引用初探</h2><p>上一讲我们对表达式的值分类进行了展开，围绕值语义和引用语义的探讨对现代C++的左值和右值有了深入的理解。但搞懂值分类的区分仅是第一步，我们尚未揭晓移动语义的帷幕。</p><p>在传统C++中，引用非常纯粹，比如代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> &amp;b = a; <span class="hljs-comment">// 这里的&amp;不是取址符，而是左值引用的声明符</span><br></code></pre></div></td></tr></table></figure><p>其中<code>b</code>就是<code>a</code>的引用，开发者简单地将<code>b</code>视为变量<code>a</code>的别名，通过<code>b</code>和<code>a</code>对变量值进行读写本质上并没有什么不同。引用语法相比从C继承的指针来说更加简洁，也更容易理解。而从现代C++的视角来看，这里的<code>b</code>是一个左值引用（显然，它绑定的<code>a</code>是个左值），这里对左值的强调是为了区分C++11所引入的另一种引用类型：右值引用。那么右值引用如何声明呢？既然是全新的语法，那肯定得量身定制：语法规定用<code>&amp;&amp;</code>作为右值引用的声明符。因此，形如<code>S&amp; D;</code>是将<code>D</code>声明为<code>S</code>所确定类型的左值引用；形如<code>S&amp;&amp; D;</code>则是将<code>D</code>声明为<code>S</code>所确定类型的右值引用。顾名思义，左值引用绑定到左值，右值引用绑定到右值（也就是xvalue和prvalue）。</p><blockquote><p>你可能还见到过别人这样写:<code>int&amp; b = a;</code>，声明符的空格位置和上述写法相反，而实际上这里怎么书写都是正确的（<code>&amp;</code>两边都有空格也无所谓），因为<code>&amp;</code>是声明符而非取地址符(addressof)，我个人习惯于这种写法，它有一种把<code>&amp;</code>和<code>int</code>联系起来的感觉。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span>&amp; b = a;         <span class="hljs-comment">// 正确：b是绑定到左值a的左值引用</span><br><span class="hljs-type">int</span>&amp; c = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 错误：字面量1是prvalue，左值引用不能绑定到右值</span><br><span class="hljs-type">int</span>&amp;&amp; d = a + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 正确：算术运算符表达式是prvalue</span><br><br>std::string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>std::strin&amp;&amp; r1 = s1;                                   <span class="hljs-comment">// 错误：右值引用不能绑定到左值</span><br>std::string&amp;&amp; r2 = s1 + s1;                             <span class="hljs-comment">// 正确：左右操作数为std::string的操作符重载(operator+)返回的是一个值类型，值分类上是prvalue</span><br>std::string&amp;&amp; r3 = <span class="hljs-built_in">static_cast</span>&lt;std::string&amp;&amp;&gt;(s1);      <span class="hljs-comment">// 正确：到右值引用类型转换的表达式值类型是xvalue</span><br></code></pre></div></td></tr></table></figure><p>上面是用基础内建类型<code>int</code>和标准库的<code>std::string</code>类类型作为示例演示的说明。</p><p>关于引用，还有些开发者必须知道的细节：</p><ul><li>引用必须被初始化为指代一个有效的对象或函数，这一点对左值引用一如既往，对右值引用也一视同仁。</li><li>尽管void类型存在指针，但不存在引用，实际上<code>void*</code>语义上也并非<code>void</code>类型的指针，而是某种未知/不确定类型的指针。</li><li>不存在引用类型的引用（禁止套娃），也不存在引用类型的指针或是引用的数组（但是存在数组的引用(<code>int(&amp;a)[3]</code>)），本质原因在于引用并非对象。</li><li>引用类型本身不能有CV(const/volatile)限定（顶层），但被引用的类型可以有CV限定(底层)，本质原因同样是在于引用并非对象。</li></ul><h2 id="引用与const限定">引用与const限定</h2><p>上述的最后一个条例提到了CV限定，它是指C++运行时对对象的一种<code>const</code>或<code>volatile</code>限定，后者对于大部分开发场景来说十分罕见(这货跟其他语言比如Java的<code>volatile</code>有着甚许微妙差别，而<code>volatile</code>在Java日常编程中十分常见)，而前者则常伴于身。对于引用来说，<code>const</code>限定无疑让语法的复杂度提升了一个维度，我们先用<code>int</code>基础内建类型来做示例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b = a;           <span class="hljs-comment">// 正确：const左值引用可以绑定到非const变量</span><br>b = <span class="hljs-number">2</span>;                      <span class="hljs-comment">// 错误：左值引用b所绑定的变量有const限定，RT不可修改</span><br><span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(b) = <span class="hljs-number">2</span>;    <span class="hljs-comment">// 正确：const引用的RT限定可以通过const_cast来擦除，这里确实修改了变量a的值为2；</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">test2.cpp:9:7: error: cannot assign to variable &#x27;b&#x27; with const-qualified type &#x27;const int &amp;&#x27;</span><br><span class="hljs-comment">    b = 2;</span><br><span class="hljs-comment">    ~ ^</span><br><span class="hljs-comment">test2.cpp:8:16: note: variable &#x27;b&#x27; declared const here</span><br><span class="hljs-comment">    const int&amp; b = a;</span><br><span class="hljs-comment">    ~~~~~~~~~~~^~~~~</span><br><span class="hljs-comment">1 error generated.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;ra = a;     <span class="hljs-comment">// 错误：常量右值引用亦不能绑定到左值</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">test2.cpp:11:17: error: rvalue reference to type &#x27;const int&#x27; cannot bind to lvalue of type &#x27;int&#x27;</span><br><span class="hljs-comment">    const int&amp;&amp; ra = a;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;rb = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 正确：常量右值引用当然可以绑定到prvalue，只不过毫无卵用</span><br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span>&amp; d = c;         <span class="hljs-comment">// 错误：左值引用类型与所绑定的变量类型不一致</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">test2.cpp:11:11: error: binding reference of type &#x27;int&#x27; to value of type &#x27;const int&#x27; drops &#x27;const&#x27; qualifier</span><br><span class="hljs-comment">    int&amp;&amp; d = c;</span><br><span class="hljs-comment">          ^   ~</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; e = c;  <span class="hljs-comment">// 正确</span><br><span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(e) = <span class="hljs-number">2</span>;    <span class="hljs-comment">//正确：虽然语法上可以通过const_cast擦除来间接访问修改const对象，但产生的结果是undefined behaviour，不要依赖UB行为</span><br><span class="hljs-type">int</span>&amp;&amp; f = c;        <span class="hljs-comment">// 错误：右值引用类型与所绑定的变量类型不一致（第一关都没过去）</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">test2.cpp:17:11: error: binding reference of type &#x27;int&#x27; to value of type &#x27;const int&#x27; drops &#x27;const&#x27; qualifier</span><br><span class="hljs-comment">    int &amp;&amp;f = c;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-comment">// 一个出人意料的case</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; g = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 正确：虽然字面量1是prvalue，但是const左值引用可以绑定到右值（可以理解成字面量值先隐式转换成了一个匿名的const int，然后将const引用与其绑定）</span><br></code></pre></div></td></tr></table></figure><p>根据上述代码，我们简单归纳一下：</p><ul><li>引用绑定过程中const限定不能drop，但是可以add。换句话说，非const引用不能绑定const值，但const引用可以绑定到非const值。</li><li>对于绑定到非const值的const引用，可以通过<code>const_cast</code>来做临时的remove以开绿灯。</li><li>const左值引用之所以可以绑定到右值，是为了语言的向前兼容性，传统C++无所谓左值引用，可以理解成是const引用到非左值的绑定。</li></ul><blockquote><p>关于const左值引用可以绑定到右值的历史原因与标准化演进，可以参考《C++设计与演化》一书。</p></blockquote><table><thead><tr class="header"><th>引用类型</th><th>非const左值</th><th>const左值</th><th>非const右值</th><th>const右值</th></tr></thead><tbody><tr class="odd"><td>非const左值引用</td><td>是</td><td>否</td><td>否</td><td>否</td></tr><tr class="even"><td>const左值引用</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr class="odd"><td>非const右值引用</td><td>否</td><td>否</td><td>是</td><td>否</td></tr><tr class="even"><td>const右值引用</td><td>否</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h2 id="移动构造和移动赋值运算符">移动构造和移动赋值运算符</h2><p>连同上一讲，我们耗费了大量的篇幅来对左值、右值、引用与const做了阐释，可是不论是左值引用还是右值引用，引用终归只是个引用，我们知道引用本身不会产生拷贝，但是这和移动语义有什么关系呢？截止到目前，我们利用右值引用并不能做将资源A移动给资源B的操作。</p><p>到这里，就需要正式介绍C++11所引入的移动语义了，与传统的类成员函数：拷贝构造器(copyctor)和拷贝赋值运算符(copyassignment)对应，C++11为支持移动语义，引入了额外的两个类成员函数：移动构造器(movector)和移动赋值运算符(moveassignment)。正如拷贝构造器和拷贝赋值运算符的“孪生性”，移动构造器和移动赋值运算符也是如此，相比前一对的<code>const Object&amp;</code>参数，后一对的参数换成了右值引用<code>Object&amp;&amp;</code>。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Object</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;default ctor&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">const</span> Object&amp; rhs) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy ctor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Object</span>(Object &amp;&amp;rhs) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move ctor&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    Object&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Object&amp; rhs) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy assignment&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    Object&amp; <span class="hljs-keyword">operator</span>=(Object&amp;&amp; rhs) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move assignment&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Object</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Object a;       <span class="hljs-comment">// 调用默认构造器</span><br>    Object b = a;   <span class="hljs-comment">// 调用拷贝构造器</span><br><br>    Object c;       <span class="hljs-comment">// 调用默认构造器</span><br>    c = a;          <span class="hljs-comment">// 调用拷贝赋值运算符</span><br><br>    Object d = <span class="hljs-built_in">static_cast</span>&lt;Object&amp;&amp;&gt;(c);    <span class="hljs-comment">// 调用移动构造器</span><br>    Object e;                               <span class="hljs-comment">// 调用默认构造器</span><br>    e = <span class="hljs-built_in">static_cast</span>&lt;Object&amp;&amp;&gt;(c);           <span class="hljs-comment">// 调用移动赋值运算符</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">default ctor<br>copy ctor<br>default ctor<br>copy assignment<br>move ctor<br>default ctor<br>move assignment<br></code></pre></div></td></tr></table></figure><p>实际上看到这里你就会发现，所谓的移动构造器，不过就是一种参数为对象右值引用类型的构造器罢了，C++语法上的扩充仅仅是右值语义而已，移动构造和移动赋值运算符不过是一种优雅的称谓。</p><blockquote><p>你可能听说过默认构造器+BigFive（传统C++的BigThree(拷贝构造、拷贝赋值运算符、析构)再填上这两个移动兄弟，正好凑成五排(bushi)），当然这不是标准化的称谓（应该是侯捷老师带来的叫法），但编译器确实会按照标准所规定的那样，对默认构造和BigFive做一些特殊照顾。</p></blockquote><blockquote><p>思考：如果上述代码不定义移动构造器和移动赋值，那么<code>Object d = static_cast&lt;Object&amp;&amp;&gt;(c);</code>和<code>e = static_cast&lt;Object&amp;&amp;&gt;(c);</code>会不会编译报错呢？如果不会又该调用谁呢？</p></blockquote><p>然而很快你就会发现另一个问题，对<code>Object</code>来说，移动构造器和拷贝构造器除了打印信息不同以外，没有任何区别。回想一下传统C++中曾学过的拷贝构造器，如果是编译器默认生成的版本，拷贝构造器所做的事非常简单：</p><ul><li>对于基础内建类型、POD(Plain OfData)和指针类型，它以bit为单位将对象A中相应数据成员复制到对象B对应数据成员的存储地址。</li><li>对于复杂类型，则调用其拷贝构造函数，如有嵌套则逐层递归。</li></ul><p>基于第一条，如果数据成员里有指针类型，我们就<strong>必须</strong>自己重写BigFive，因为尽管C++基于值语义的默认拷贝动作是深拷贝，但是对于指针型变量来说，深拷贝拷贝的是地址值，而不是该地址所指向的对象（所以在C++中，这种情况被称作浅拷贝，此浅拷贝和其他引用语义编程语言中的浅拷贝有着微妙差别）。</p><blockquote><p>这里的“必须“并不是语法要求，而是基于编程常理，或者换句话说，如果不这样做，就很可能会引入诸如doublefree, uaf, memory leak等问题。这也是C++上手门槛高的一个原因。</p></blockquote><p>而另一方面，<code>Object</code>是个空类，我们原本打算通过<code>Object d = static_cast&lt;Object&amp;&amp;&gt;(c);</code>调用移动构造器把<code>c</code>“搬空”，资源归属转移到<code>d</code>而不是复制给<code>d</code>，可在实际实现移动构造器的时候才发现<code>Object</code>空空如也。没错，这个例子中<code>Object</code>是个空类（当然这种情况其实例化对象也是有size的），对于这种类本不用定义它的BigFive（编译器会默认生成），因为它并没有需要区分拷贝或者移动的资源。</p><p>我们改进一下，引入三个数据成员，分别用具有代表性的基础类型<code>int</code>，标准库的复杂类类型<code>std::string</code>和指针类型<code>char*</code>，请一定仔细阅读代码注释：<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// custom ctor</span><br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">const</span> string&amp; name, <span class="hljs-type">int</span> size) : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">size_</span>(std::<span class="hljs-built_in">max</span>(size, <span class="hljs-number">16</span>)), <span class="hljs-built_in">data_ptr_</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size_]) &#123;&#125;<br><br>    <span class="hljs-comment">// copy ctor</span><br>    <span class="hljs-comment">// 对于拷贝构造器来说，我们需要对name_调用std::string的拷贝构造器来做一次copy</span><br>    <span class="hljs-comment">// 而基础内建类型没有拷贝构造器，它只能进行bit copy，这也是自动生成的拷贝构造器的动作</span><br>    <span class="hljs-comment">// 自动生成的copy ctor对data_ptr_做的也是bit copy，但显然我们希望对其做深拷贝，因此要自己写逻辑</span><br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">const</span> Object&amp; rhs) : <span class="hljs-built_in">name_</span>(rhs.name_), <span class="hljs-built_in">size_</span>(rhs.size_), <span class="hljs-built_in">data_ptr_</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[rhs.size_]) &#123;<br>        std::<span class="hljs-built_in">copy</span>(rhs.data_ptr_, rhs.data_ptr_ + rhs.size_, data_ptr_);<br>    &#125;<br><br>    <span class="hljs-comment">// move ctor</span><br>    <span class="hljs-comment">// 对于移动构造器来说，我们只需要对name_调用std::string的移动构造器来做move而非copy</span><br>    <span class="hljs-comment">// 基础内建类型没有移动构造器，它只能进行bit copy，这也是自动生成的移动构造器的动作</span><br>    <span class="hljs-comment">// 自动生成的move ctor对于data_ptr_做的也是bit copy，但显然我们不仅希望做浅拷贝，还希望传进来的右值引用所refer to的值可以被转移释放（偷走）</span><br>    <span class="hljs-built_in">Object</span>(Object &amp;&amp;rhs) : <span class="hljs-built_in">name_</span>(std::<span class="hljs-built_in">move</span>(rhs.name_)), <span class="hljs-built_in">size_</span>(rhs.size_), <span class="hljs-built_in">data_ptr_</span>(rhs.data_ptr_) &#123;<br>        rhs.data_ptr_ = <span class="hljs-literal">nullptr</span>;<br>        rhs.size_ = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// copy assignment</span><br>    <span class="hljs-comment">// 拷贝赋值运算符是copy ctor的孪生，用于适配非初始化赋值情景的赋值值语义</span><br>    <span class="hljs-comment">// 参数类型为const左值引用，意味着可以绑定到所有const/非const左值或右值，因此右操作数是啥都接得住</span><br>    Object&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Object&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            <span class="hljs-type">char</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[rhs.size_];<br>            std::<span class="hljs-built_in">copy</span>(rhs.data_ptr_, rhs.data_ptr_ + rhs.size_, ptr);<br>            <span class="hljs-keyword">if</span> (data_ptr_ != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">delete</span>[] data_ptr_;<br>            &#125;<br>            data_ptr_ = ptr;<br>            size_ = rhs.size_;<br>            name_ = rhs.name_;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// move assignment</span><br>    <span class="hljs-comment">// 移动赋值运算符是move ctor的孪生，用于适配非初始化赋值情景的赋值值语义</span><br>    <span class="hljs-comment">// 参数类型为右值引用，意味着仅可以绑定到非const右值引用，同时对于传递非const右值引用时</span><br>    <span class="hljs-comment">// 根据函数重载的优先级会优先匹配，换句话说，如果没有该定义，那就只能退一步去调用copy assignment</span><br>    Object&amp; <span class="hljs-keyword">operator</span>=(Object&amp;&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            <span class="hljs-keyword">if</span> (data_ptr_ != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">delete</span>[] data_ptr_;<br>            &#125;<br>            data_ptr_ = rhs.data_ptr_;<br>            size_ = rhs.size_;<br><br>            name_ = std::<span class="hljs-built_in">move</span>(rhs.name_);<br>            rhs.data_ptr_ = <span class="hljs-literal">nullptr</span>;<br>            rhs.size_ = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// dtor</span><br>    <span class="hljs-comment">// 对于拥有raw pointer数据成员的类来说，析构都是少不了的</span><br>    ~<span class="hljs-built_in">Object</span>() &#123; <span class="hljs-keyword">if</span>(data_ptr_ != <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">delete</span>[] data_ptr_; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DebugPrint</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; size_ &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(data_ptr_) &lt;&lt; std::endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    <span class="hljs-type">int</span> size_;<br>    <span class="hljs-type">char</span>* data_ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Object <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">32</span>)</span></span>;<br>    <span class="hljs-function">Object <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">64</span>)</span></span>;<br><br>    Object c = a;<br>    Object d = std::<span class="hljs-built_in">move</span>(b);    <span class="hljs-comment">// std::move见下文</span><br><br>    a.<span class="hljs-built_in">DebugPrint</span>();     <br>    b.<span class="hljs-built_in">DebugPrint</span>();    <br>    c.<span class="hljs-built_in">DebugPrint</span>();<br>    d.<span class="hljs-built_in">DebugPrint</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">a320x60000180d120<br>00x0<br>a320x60000180d140<br>b640x600000d0c1c0<br></code></pre></div></td></tr></table></figure><p>在解释运行结果之前，我们先来说明一个C++11标准库所引入的一个非常常见的函数模板：<code>std::move</code>，该函数的名称如果是从C++的语法角度来看非常的具有误导性，<code>std::move</code>本身并不能做”移动“或者说“资源归属转移”操作，它仅仅是返回一个调用参数的右值引用而已，在我们的代码中，它曾两次出现：</p><ul><li><code>Object d = std::move(b);</code></li><li><code>Object(Object &amp;&amp;rhs) : name_(std::move(rhs.name_)), size_(rhs.size_), data_ptr_(rhs.data_ptr_)&#123;...&#125;</code></li></ul><p>由于<code>std::move</code>函数模板本身比较复杂（个锤子），这里暂且按下不表，只需要了解这两行可以等价替换成：</p><ul><li><code>Object d = static_cast&lt;Object&amp;&amp;&gt;(b);</code></li><li><code>Object(Object &amp;&amp;rhs) : name_(static_cast&lt;std::string&amp;&amp;&gt;(rhs.name_)), size_(rhs.size_), data_ptr_(rhs.data_ptr_)&#123;...&#125;</code></li></ul><p>再来看看运行结果，<code>a</code>的打印结果直截了当，三个成员的值(<code>data_ptr_</code>的值就是地址，只不过通过<code>cout</code>打印需要做一点小小的trick)符合预期，尽管我们曾进行了<code>Object c = a;</code>的操作，但是由于值语义，这里调用的是<code>Object</code>的拷贝构造器，拷贝构造器并没有修改<code>a</code>的数据成员（事实上const左值引用也修改不了（不考虑const_cast绿灯大法））</p><p>而<code>b</code>的打印结果就不那么直观了，看上去<code>name_</code>变成了空字符串，<code>size_</code>也变成了<code>0</code>，<code>data_ptr_</code>更是变成了空指针。这是为什么呢，我们不是明明调用customctor构造了一个“有血有肉”的<code>b</code>对象实例吗，为何它的数据看起来就像是被搬空了一样呢？没错，它的数据正是被搬空了，答案就在于<code>Object d = std::move(b);</code>这一行代码，这里由于参数类型是<code>Object&amp;&amp;</code>，故优先匹配上了移动构造器而非拷贝构造器，而移动构造器中，我们的所作所为正是将参数的数据成员搬空！<strong>换言之，<code>std::move</code>就像是一个标记器，它将一个左值标记成了将亡值(还记得上一讲的表达式值分类吗？返回类型为右值引用的类型转换表达式是一个xvalue)，而后根据值语义和重载函数参数匹配规则，触发了移动构造器(或移动赋值运算符)的调用，而真正做资源归属转移的正是移动构造器(或移动赋值运算符)，这也就是上文一再强调，<code>std::move</code>本身没有做移动操作，真凶另有其人，<code>std::move</code>只能算作一个帮凶，没有移动构造器(或移动赋值运算符)，它什么也做不成。</strong></p><p>接下来，<code>c</code>是复制的<code>a</code>，由于我们的拷贝构造器中对<code>data_ptr_</code>做了深拷贝，故其打印结果与<code>a</code>并不相同。而<code>d</code>是移动的<code>b</code>，打印出的结果实际上就是<code>b</code>未被搬空前的成员值。</p><p>总结一下，这里用了三种典型的数据类型来对比拷贝和移动的差别：</p><ul><li>对于基础内建类型，无所谓拷贝还是移动，通通copy bit by bit</li><li>对于复杂的类类型嵌套，递归调用它本身的拷贝或移动构造器(or赋值运算符)</li><li>对于指针类型，默认行为是copy bit bybit，但我们往往需要自己重写BigFive来谨慎处理</li></ul><p>看到这里，一些同学一定会有这样的问题：说好的移动语义，怎么看上去还是东拼西凑呢？语法上为什么不对基础类型也来一个移动语义呢？比如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> b = std::<span class="hljs-built_in">move</span>(a);<br><br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; b &lt;&lt; endl;<br>cout &lt;&lt; &amp;a &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;<br><span class="hljs-comment">// 输出结果:</span><br><span class="hljs-comment">// 3  3</span><br><span class="hljs-comment">// 0x16d11b7180x16d11b714</span><br><span class="hljs-comment">// a并没能被搬空，甚至继续使用也没有问题，a和b的地址也各不相同</span><br></code></pre></div></td></tr></table></figure><p>还记得移动语义的初衷吗？我们想要解决的是大对象冗余的拷贝，像是基础内建类型这种size非常小的数据，比如64bit机寄存器就可以一次性装载8B数据了，copy的成本过于低廉，真要支持个移动说不定反而效率更低(其他引用语义的语言如Java又何尝不是如此)。</p><blockquote><p>基础类型的raw数组也一样是copy bit by bit,但这个成本可能会很高昂，这也是modern C++不推荐用raw数组的原因之一。</p></blockquote><p>而另一方面，对于复杂的类类型比如<code>std::string</code>，它本身也是基础类型、指针和其他复杂类型堆砌而成，因此，它内部的移动构造或是移动赋值运算符的实现其实和我们这里对<code>size_</code>和<code>data_ptr_</code>的处理大同小异。</p><h2 id="移动语义的本质">移动语义的本质</h2><p>在了解了语言层面的移动语义实现机制后，我们需要再从复杂的语法规则中跳出来，高屋建瓴的思考移动语义的适用场景。一言以蔽之：<strong>移动语义适用于那些当某种资源已确定不再被需要的场景，此时仅需要通过移动语义做资源归属转移而非复制。</strong>C++为支撑移动语义所提供的语言机制，从值分类到右值引用再到移动构造/赋值运算符帮助我们完成了这一项工作，仅此而已。</p><p>上文中的例子是个"can be cast toxvalue"的场景，其中<code>b</code>不再被需要，通过<code>std::move</code>我们拿到其xvalue传递给了<code>d</code>的移动构造器，进而窃取资源。实际使用中，往往还有另一种场景，就是传入移动构造器的参数不是xvalue，而是一个prvalue，这常见于将那些返回类型为非引用类型的函数调用结果作为构造器参数的情景（虽然以前也有(N)RVO遮了羞）。</p><p>于是，对于移动构造器来说，我们在将参数的资源窃为己有后，一般会将其重置为默认态或者零值态（标准没有硬性规定要如何善后，但是规定了接下来对它的操作皆是UB行为（由编译器具体实现机制来买单）），正如我们在上例中对<code>size_</code>清零，对<code>data_ptr_</code>置空的操作，而<code>std::string</code>的移动构造器则是将字符串重置成空串作为善后处理手段。而移动赋值运算符则麻烦一点，因为被赋值的对象可能有历史的数据，尤其是对于指针型就要及时释放，避免memoryleak。</p><p>此外，移动构造器和移动赋值运算符只是两种比较特别的成员函数，并不是说移动只能在这两种函数内处理，比如，我们定义这样一个构造器：<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>&#123;<br><span class="hljs-keyword">public</span>：<br>    <span class="hljs-built_in">Object</span>(std::string&amp;&amp; name) : <span class="hljs-built_in">name_</span>(std::<span class="hljs-built_in">move</span>(name)), <span class="hljs-built_in">size_</span>(<span class="hljs-number">16</span>), <span class="hljs-built_in">data_ptr_</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">16</span>]) &#123;&#125;<br>    。。。<br>&#125;;<br></code></pre></div></td></tr></table></figure>参数也可以是一个右值引用，此时我们可以通过<code>std::string</code>的移动构造器来将参数的资源偷走，而如果不进行窃取的话，比如改成：<code>name_(name)</code>（就会调用<code>std::string</code>的拷贝构造，因为<code>name</code>本身是左值）。</p><h2 id="stdmove">std::move</h2><p>上文也提到<code>std::move</code>是个函数模板，它的标准定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp;&amp;&gt;(<span class="hljs-type">__t</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>想要理解<code>std::move</code>，需要前置掌握这两个知识点：</p><ol type="1"><li><code>std::remove_reference_t&lt;T&gt;</code>是个typetrait，它会cut掉类型<code>T</code>的引用修饰符，返回裁剪后的类型，实际上是<code>typename std::remove_reference&lt;T&gt;::type</code>的别名模板，由C++14标准引入。</li><li>函数参数类型<code>T&amp;&amp;</code>在此并非右值引用，这里它搭配模板参数一起出现（本质上是<code>T</code>需要被推导时），是一个万能引用(UniversalReference)，它的真实类型遵循引用折叠规则。<ol type="1"><li>左值引用-左值引用<code>T&amp; &amp;</code>：左值引用<code>T&amp;</code></li><li>左值引用-右值引用<code>T&amp; &amp;&amp;</code>：左值引用<code>T&amp;</code></li><li>右值引用-左值引用<code>T&amp;&amp; &amp;</code>：左值引用<code>T&amp;</code></li><li>右值引用-右值引用<code>T&amp;&amp; &amp;&amp;</code>：右值引用<code>T&amp;&amp;</code></li></ol></li></ol><blockquote><p>Scott的《Effective Modern C++》的称其为万能引用（UniversalReference），这并不是标准的称呼，C++标准出台后称其为转发引用(ForwardingReference)，这个名称历来被诟病见名不知义，远不如Scott给出的称呼（当然它能当选也说明有忠实的拥趸，必有可取之处），故坊间皆以“万能引用”的说法传世，我们也弃用这个标准的说法，使用“万能引用”。</p></blockquote><blockquote><p>所有的引用折叠最终都代表一个引用，要么是左值引用，要么是右值引用。如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</p></blockquote><p>因此，对于<code>std::move</code>来说：</p><ul><li>如果传入的是左值，则参数类型被推导成左值引用，通过<code>static_cast</code>类型转换成右值引用返回。</li><li>如果传入的是右值，则参数类型被推导成右值引用，也通过<code>static_cast</code>类型转换成右值引用返回。</li></ul><p>至此，我们完成了右值引用和移动语义的学习，下一讲我们深入了解引用折叠、万能引用和完美转发机制。</p><h2 id="参考文献">参考文献</h2><ul><li><ahref="https://docs.microsoft.com/en-us/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170">Lvaluesand Rvalues</a></li><li><ahref="https://en.cppreference.com/w/cpp/language/value_category">Valuecategories</a></li><li><ahref="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/">EffectiveModern C++</a></li><li><ahref="https://stackoverflow.com/questions/39552272/is-there-a-difference-between-universal-references-and-forwarding-references">Isthere a difference between universal references and forwardingreferences?</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>program-language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>cpp-templates</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++模板从入门到劝退(0)——左值与右值</title>
    <link href="/2022/05/27/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(0)%E2%80%94%E2%80%94%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/"/>
    <url>/2022/05/27/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(0)%E2%80%94%E2%80%94%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述严谨性，按照笔者的归纳方式穿针引线，为痴迷于黑魔法而又始终不得其解的同学打通任督二脉。</p><p>本篇是走进模板世界的第一道前菜，只有搞懂了这些C++中的基本概念，才能掌握模板世界的黑魔法。</p><span id="more"></span><h1 id="左值与右值">左值与右值</h1><p>随着C++11新标准的制定，C++正式进入现代(modern)时代，相对于传统(traditional/old)C++、新标准的推行可谓是革命性的船新版本。而这一变革带来了两种情况：</p><ol type="1"><li>C++神教的新教徒在阅读传统C++代码时会满脸黑人问号：这是个什么方言？</li><li>尚未解锁现代C++的传统C++程序员在接触新标准时会惊呼：还有这种操作？快住手，这根本不是C++！</li></ol><blockquote><p>在《C++ Primer5th》问世时，我曾自信满满淘得一本，自诩有着刷了4遍4th的经验，打开了新世界的大门，然后直接自闭。</p></blockquote><p>当大家聊起C++11时，最先想到的可能就是移动语义，没错，这个移动语义可谓是万恶之源，它一方面解决了C++长久以来的顽疾，另一方面也让原本就复杂的语法规则变本加厉。</p><h2 id="值语义">值语义</h2><p>传统C++的顽疾在于基于值语义(ValueSemantics)的冗余拷贝和赋值。所谓值语义，这是很多OO(ObjectOriented)语言中没有的概念，诸如Java,C#等大多数语言，几乎所有的变量都是引用语义(ReferenceSemantics)（它们天生有着GC(GarbageCollector)来管理所有对象的生命周期，开发者无需操心）。而C++并没有做如此现代化的封装，对外呈现的语言生态相当裸露，值语义是指目标对象由源对象拷贝生成，生成的目标对象与源对象毫无关系彼此独立（一些引用语义的编程语言可能只有基础类型是值语义，但同样的它们为了消除违和感对值语义只字不提，而是强调基础类型的特殊性）。对于不了解值语义的C++初学者来说，会想当然的把C++中的引用看成和其他引用语义编程语言中引用的对等概念，这在传统C++中最多是在使用体验上感觉到有些别扭，而到了C++11后，由于对左值引用、右值引用进行了区分，就使得原本理解上的缺失被进一步放大，自然而然得感觉右值引用莫名其妙。</p><blockquote><p>C++对变量生命周期的一种优雅管理方式是RAII，不过不代表RAII能解决所有场景的变量生命期管理需求，更不代表GC没用。</p></blockquote><p>我们以纯OO语言Java为例，如果写这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1;<br><br>        System.out.println(System.identityHashCode(s1));<br>        System.out.println(System.identityHashCode(s2));<br>        System.out.println(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">2060468723<br>2060468723<br>true<br></code></pre></div></td></tr></table></figure><p>可以看到，Java中<code>s1,s2</code>就是引用语义的典范，它们指向的对象是同一个，而在引用语义的编程语言中，这也被称作浅拷贝(ShallowCopy)：在进行赋值、方法传参和返回值时，对于引用类型（非基本类型）一概按引用传递（传址）。</p><blockquote><p>是不是觉着很简单很直观，如果再定义一个<code>String s3 = "hello";</code>，思考下<code>s3</code>和<code>s1</code>是不是同一个对象呢？如果换成<code>String s3 = new String("hello"); String s4 = new String("hello");</code>，<code>s3</code>和<code>s4</code>和<code>s1</code>又是什么关系呢？当然，这是Java体系下的另一个话题了。</p></blockquote><p>再看Python 3:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">s1 = <span class="hljs-string">&quot;hello&quot;</span><br>s2 = s1<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(s1))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(s2))<br></code></pre></div></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">4341128096<br>4341128096<br></code></pre></div></td></tr></table></figure><p>显然赋值操作是按引用进行传递，<code>s1,s2</code>所指是同一个对象。</p><blockquote><p>我常说python是一门乱七八糟的语言，所谓“动态类型一时爽，代码重构火葬场”。如果定义<code>s3 = "hello"</code>，<code>s3</code>和<code>s1</code>是什么关系呢？如果把"hello"换成"helloworld"呢？当然，这也是Python体系下的另一个话题了。</p></blockquote><blockquote><p>对于Java和Python这类工程/工具语言，没必要过于学究，实际上许多经验丰富的Java/Python程序员对这两个问题也是懵逼的，但这丝毫不影响写出健壮可用的代码，这些问题可能也就面试会被问到。。。但是对于C++来说，凡事都得学究一点，哪怕是经验丰富的C++程序员也常常犯语法错误。</p></blockquote><p>那么在C++中，对于标准库的<code>string</code>来说，我们进行类似的赋值是什么结果呢？</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span>&#123;<br>    string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>    string s2 = s1;<br><br>    cout &lt;&lt; &amp;s1 &lt;&lt; endl;<br>    cout &lt;&lt; &amp;s2 &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">0x16d94f678<br>0x16d94f660<br></code></pre></div></td></tr></table></figure><p>可以看到<code>s1,s2</code>的地址并不相同，对于非基础类型，C++中使用相同类型的对象做初始化赋值的语义是去调用该类型的拷贝构造器(copyctor)（C++中初始化赋值和普通的赋值语义并不等同，后者在这种情况下调用的是拷贝赋值操作符(copyassignment))。此外，对于第一行<code>string s1 = "hello";</code>也并没有表面看上去那样简单，<code>std::string</code>并不是基础类型，赋值初始化在C++的语义是调用相应的拷贝构造器，但是由于<code>"hello"</code>这个字符串字面量的类型是<code>const char[6]</code>（有界常量字符数组，而且标准规定字符串字面量是左值），并不能匹配拷贝构造器的参数，因此按照常理来说编译应该报错才对。但另一方面，C++在某些特定场合支持适宜的隐式(implicit)转换，上述代码会先用<code>"hello"</code>隐式的生成一个临时的string对象（这需要<code>std::string</code>有一个接受<code>const char[6]</code>或其退化(decay)类型的构造器），然后再调用拷贝构造器将临时对象复制给<code>s1</code>。</p><p>我们尝试来探讨一下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 如果加explicit关键字，那么String s1 = &quot;hello&quot;;就无法进行隐式转换而报错</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pstr) : <span class="hljs-built_in">s_</span>(pstr) &#123; cout &lt;&lt; <span class="hljs-string">&quot;call custom ctor&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; rhs) : <span class="hljs-built_in">s_</span>(rhs.s_) &#123; cout &lt;&lt; <span class="hljs-string">&quot;call copy ctor&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-keyword">private</span>:<br>    string s_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span>&#123;<br>    String s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>    String s2 = s1;<br><br>    cout &lt;&lt; &amp;s1 &lt;&lt; endl;<br>    cout &lt;&lt; &amp;s2 &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">call custom ctor<br>call copy ctor<br>0x7ff7b4ac1658<br>0x7ff7b4ac1640<br></code></pre></div></td></tr></table></figure><p>显然，运行结果并不符合预期，理论上除了<code>String s2=s1;</code>这一行会调用copyctor以外，<code>String s1 = "hello";</code>也应该调用一次才对，为什么只看到了一次customctor呢？这是因为C++11标准定义了复制省略(CopyElision)技术（诸如<code>String s1 = "hello";</code>的写法其实非常的符合直觉，但是因为值语义的关系，C++却不得不多做一次值拷贝），要求编译器在实现时对这一情景做一次合理的拷贝消除。实际上，在C++11标准化之前各大厂商的编译器就已经为这事买单了（委员会的“懒汉们”永远是亡羊补牢），传统C++的开发者应该也了解诸如RVO(ReturnValue Optimization), NRVO(Named Return ValueOptimization)等技术，而这本质上做的就是特定场合的复制省略（未标准化之前，可以视作语言天然缺陷的遮羞布）。</p><p>如果我们通过编译选项关闭复制省略(-fno-elide-constructors)，重新运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">call custom ctor<br>call copy ctor<br>call copy ctor<br>0x7ff7bf7ba658<br>0x7ff7bf7ba618<br></code></pre></div></td></tr></table></figure><h2 id="表达式值分类">表达式值分类</h2><p>C++中基于值语义的拷贝构造和拷贝赋值，可能会导致大对象的冗余拷贝从而引发性能瓶颈。虽然开发者可以通过指针和引用来规避掉部分场景的copy（编译器也十分配合的蒙上遮羞布），但还是有诸多场景无可避免。我曾看过这么一个形象的比喻：要把大象从A冰箱转移到B冰箱需要几步呢？普通青年的做法是3步：打开冰箱A和B的门；把大象从A转移(move)到B；关闭冰箱A和B。2B青年的做法则是：打开冰箱A和B的门；启用量子复制系统在冰箱B克隆出大象；启用射频消融技术将A中大象解体气化。没错，C++曾经就是这个2B青年。</p><p>移动(move)这件事本身很好理解，因为这是一个符合直觉的做法，但是对背着重重历史包袱的C++来说，想要从语言层面理解移动，就需要前置理解这样一个概念：左值(lvalue)和右值(rvalue)。实际上，左值和右值并不是C++11所引入的术语，这两个概念的历史由来可以追溯到编程语言CPL，那么彼时何为左值和右值呢？顾名思义，在赋值操作符('=')左边的就是左值，右边的就是右值，而这也是左值和右值得以命名的历史原因。C语言继承了CPL的分类法，但是弱化了赋值的作用，C语言中左值一开始表示可以被赋值的对象，但由于<code>const</code>的引入，这类对象被修正称作“可更改的左值”，而右值则被视为“值”的同义词，分类上通通都叫作其他(others)（函数和非对象值）。由于const，我们不能再通过表达式值可否修改来判断是否是左值，而是通过是否可寻址（于是坊间流传的一个不严谨的说法就是：左值对应变量的存储位置，右值对应变量的值本身）。</p><blockquote><p>一种说法是ISO C中的lvalue其实是locatorvalue的缩写，算是个美丽的巧合。</p></blockquote><p>传统C++(C++98)对表达式的值分类继承了C的做法，但复辟了右值的称呼，此外，C++98规定函数为左值（因为可以被取地址，在后续的标准演进中函数甚至当家做主成了一等公民，实际上除了函数还有一些其他类似情况的表达式也被视为左值），而C++中的引用可以被绑定在左值之上，但不能绑定到右值（只有const引用可以绑定到右值）。截止C++03，我们把具有标识(identity)的表达式视为左值，没有标识的表达式视为右值。因此，名称、指针、引用都是左值，是命名对象，它们有可以寻址的确定内存地址；字面量、临时对象等视为右值，右值仅在创建它的表达式中可以被访问。函数名称是左值，数组名称是常量左值（只不过大多数表达式中函数名和数组名被自动隐式转换成右值）。右值的生命周期短暂，所以需要左值去捕获它，把右值拷贝(copy)给左值是常规操作。</p><p>然而在C++11之后，为了支撑移动语义引入了右值引用，因此左值和右值的定义发生了很大变化。右值引用可以绑定到右值上来给临时对象续命，而移动语义则把临时对象移动(move)而不是拷贝(copy)到左值对象上。对于左值和右值的分类，标准不得不做一些扩充和修正：</p><ul><li>左值(lvalue): 指定一个对象(object)或函数(function)。<ul><li>如果<code>E</code>是某种类型的指针类型，那么<code>*E</code>就是一个左值表达式，它引用的是<code>E</code>所指向的对象(object)或函数(function)。</li><li>调用一个返回类型为左值引用的函数，其结果是一个左值。</li></ul></li><li>将亡值(xvalue): expiringvalue的缩写，也指定一个对象，这个对象通常是生命周期即将结束的状态，因此它可以被移动。xvalue是某些涉及右值引用的表达式的结果。<ul><li>调用一个返回类型为右值引用的函数，其结果就是一个xvalue。</li></ul></li><li>泛左值(glvalue): lvalue或者是xvalue。</li><li>右值(rvalue):xvalue，临时的对象或子对象，或者是与对象无关的值。</li><li>纯右值(prvalue): 非xvalue的rvalue。<ul><li>调用一个返回类型为非引用类型的函数，其结果就是一个prvalue。</li></ul></li></ul><p><img src="2022-05-30-14-22-25.png" /></p><blockquote><p>大部分初学者都会因为不了解xvalue和prvalue的概念而想当然地把lvalue和rvalue想象成同一层级的概念，而这在学习过程中就会遇到重重困扰，进而对rvalue的概念云里雾里。实际上rvalue是个混合分类。</p></blockquote><p>自此，表达式的值分类不仅考虑了标识(identify)，还考虑了可移动性(movability)。我们按照标准做一下归纳：</p><ul><li>左值(lvalue): 具有标识，不可移动。</li><li>将亡值(xvalue): 具有标识，可以移动。</li><li>纯右值(prvalue): 没有标识，可以移动。</li><li>泛左值(glvalue): 具有标识</li><li>右值(rvalue): 可以移动</li></ul><p>这样一分类，是不是有种恍然大悟的感觉~</p><p>那么再看看三种基本值类型都对应哪些表达式呢？这里参考reference手册并裁剪掉一些cornercase：</p><ul><li>左值(lvalue):<ul><li>变量名、函数名、数据成员<ul><li>即使变量类型是右值引用，变量本身依然是左值(这不是特例，是正统的语法规则)</li><li><code>std::getline</code></li><li><code>std::cin</code>, <code>std::endl</code></li></ul></li><li>返回类型为左值引用的函数调用或操作符重载或类型转换<ul><li><code>std::getline(std::cin, str)</code></li><li><code>std::cout &lt;&lt; 1</code>, <code>str1 = str2</code>,<code>++it</code></li><li><code>static_cast&lt;int&amp;&gt;(val)</code></li></ul></li><li>返回类型为函数右值引用的函数调用或操作符重载或类型转换<ul><li><code>static_cast&lt;void (&amp;&amp;)(int)&gt;(x)</code></li></ul></li><li>内建(built-in)的赋值与复合赋值表达式<ul><li><code>a=b</code></li><li><code>a+=b</code>,<code>a*=b</code></li></ul></li><li>内建(built-in)的前缀自增、自减<ul><li><code>a++</code></li><li><code>a--</code></li></ul></li><li>内建(built-in)的解引用表达式<ul><li><code>*p</code></li></ul></li><li>内建(built-in)的下标操作符表达式<ul><li><code>a[n]</code>, <code>p[n]</code></li></ul></li><li>对象成员访问，内建(built-int)的指针成员访问<ul><li><code>a.m</code>(<code>m</code>不能是枚举成员，也不能是非静态成员函数）</li><li><code>t.m</code>(<code>t</code>为右值且<code>m</code>为非静态数据成员)</li><li><code>p-&gt;m</code>(<code>m</code>不能是成员枚举值，也不能是非静态成员函数)</li></ul></li><li>对象的成员指针访问，内建(built-in)的指针的成员指针访问（成员指针的指针本质上是偏移，和普通的指针不太一样，导致这两个东西非常的拗口和别扭）<ul><li><code>a.*mp</code>(<code>a</code>是左值，<code>mp</code>是数据成员指针)</li><li><code>p-&gt;*mp</code>(<code>mp</code>是数据成员指针)</li></ul></li><li>右端为左值的逗号表达式<ul><li><code>a, b</code>(<code>b</code>是左值)</li></ul></li><li>二、三操作数为特定值的三元运算符</li><li>字符串字面量(String Literal)<ul><li><code>"hello"</code></li></ul></li></ul></li><li>纯右值(prvalue):<ul><li>字面量<ul><li><code>42</code></li><li><code>'a'</code></li><li><code>true</code></li><li><code>nullptr</code></li></ul></li><li>返回类型为非引用的函数调用或操作符重载或类型转换<ul><li><code>str.substr(1, 2)</code></li><li><code>str1 + str2</code></li><li><code>it++</code></li><li><code>static_cast&lt;double&gt;(x)</code>,<code>std::string&#123;&#125;</code>, <code>(int)42</code></li></ul></li><li>内建(built-in)的后缀自增、自减表达式<ul><li><code>a++</code></li><li><code>b--</code></li></ul></li><li>内建(built-in)的算数、逻辑、比较、取地址表达式<ul><li><code>a + b</code>, <code>a % b</code>, <code>a &amp; b</code>,<code>a &lt;&lt; b</code></li><li><code>a &amp;&amp; b</code>, <code>a || b</code>,<code>!a</code></li><li><code>a &lt; b</code>, <code>a == b</code>,<code>a &gt;= b</code></li><li><code>&amp;a</code></li></ul></li><li>对象成员访问，内建(built-in)的指针成员访问<ul><li><code>a.m</code>(<code>m</code>是成员枚举值或非静态成员函数)</li><li><code>p-&gt;m</code>(<code>m</code>是成员枚举值或非静态成员函数)</li></ul></li><li>对象的成员指针访问，内建(built-in)的指针的成员指针访问<ul><li><code>a.*mp</code>(<code>mp</code>是成员函数指针)</li><li><code>p-&gt;*mp</code>(<code>mp</code>是成员函数指针)</li></ul></li><li>右端为右值的逗号表达式</li><li>二、三操作数为特定值的三元表达式</li><li><code>this</code>指针</li><li>枚举值</li><li>lambda表达式<ul><li><code>[](int x)&#123; return x * x; &#125;</code></li></ul></li></ul></li><li>将亡值(xvalue):<ul><li>返回类型为右值引用的函数调用或操作符重载或类型转换<ul><li><code>std::move(x)</code></li><li><code>static_cast&lt;char&amp;&amp;&gt;(x)</code></li></ul></li><li>对象成员访问<ul><li><code>t.m</code>(<code>t</code>是右值且<code>m</code>是非静态非引用数据成员)</li></ul></li><li>对象的成员指针访问<ul><li><code>t.*mp</code>(<code>t</code>是右值且<code>mp</code>是数据成员指针)</li></ul></li><li>二、三操作数为特定值的三元表达式</li></ul></li></ul><blockquote><p>三元表达式目前的分类比较复杂，详见https://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator</p></blockquote><p>这里的分类因C++历史的演进而变得非常复杂，初学者没必要全盘记住，实际上日后了解了更多的细节后，会发现这里的分类其实是非常直观的。至此，如果你能看到这里，那么恭喜你，基础的内容你已经掌握了，下一讲，我们谈谈右值引用和移动语义。</p><h2 id="参考文献">参考文献</h2><ul><li><ahref="https://docs.microsoft.com/en-us/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170">Lvaluesand Rvalues</a></li><li><ahref="https://en.cppreference.com/w/cpp/language/value_category">Valuecategories</a></li><li><ahref="https://en.wikipedia.org/wiki/Value_(computer_science)">Value(ComputerScience)</a></li><li><ahref="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/">EffectiveModern C++</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>program-language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>cpp-templates</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十二)——图和网络</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%8C)%E2%80%94%E2%80%94%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%8C)%E2%80%94%E2%80%94%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>这一讲作为第一部分的最后一节内容，主要着重于描述线性代数的应用。</p><h1 id="图和网络">图和网络</h1><h2 id="有向图">有向图</h2><p>给定一个有向图：4节点，5条边 <imgsrc="2022-05-14-16-56-35.png" /></p><p>可以用如下方式来抽象描述：。 <span class="math display">\[\begin{array}{c | c c c c}&amp; node_1 &amp; node_2 &amp; node_3 &amp; node_4\\ \hlineedge_1 &amp; -1     &amp; 1      &amp; 0      &amp; 0\\ edge_2 &amp; 0      &amp; -1     &amp; 1      &amp; 0\\ edge_3 &amp; -1     &amp; 0      &amp; 1      &amp; 0\\ edge_4 &amp; -1     &amp; 0      &amp; 0      &amp; 1\\ edge_5 &amp; 0      &amp; 0      &amp; -1     &amp; 1\end{array}\]</span></p><p>写成<span class="math inline">\(5\times 4\)</span>矩阵来表示如下：<span class="math display">\[A=\begin{bmatrix}-1 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; -1 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; -1 &amp; 1\end{bmatrix}\]</span></p><p>该矩阵叫做关联矩阵，其中每一列代表一个节点，每一行代表一条边（正负代表方向）。</p><p>通过观察前三行，可以看出这三个行向量线性相关，而实际上，它的物理意义就是这三个向量（三条边）可以形成回路。关联矩阵一般是稀疏阵，因为每一行只有两个非零元素。</p><h3 id="a的零空间"><span class="math inline">\(A\)</span>的零空间</h3><p>矩阵<span class="math inline">\(A\)</span>的零空间可以通过解<spanclass="math inline">\(Ax=0\)</span>来得到，有： <spanclass="math display">\[Ax=\begin{bmatrix}-1 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; -1 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; -1 &amp; 1\end{bmatrix}\begin{bmatrix}x_1\\ x_2\\ x_3\\ x_4\end{bmatrix}=0\]</span></p><p>展开得： <span class="math display">\[\begin{bmatrix}x_2-x_1\\ x_3-x_2\\ x_3-x_1\\ x_4-x_1\\ x_4-x_3\end{bmatrix}=\begin{bmatrix}0\\ 0\\ 0\\ 0\\ 0\end{bmatrix}\]</span></p><p>引入矩阵的实际意义：将<spanclass="math inline">\(x=\begin{bmatrix}x_1 &amp; x_2 &amp; x_3 &amp;x_4\end{bmatrix}\)</span>视为各节点电势，则式子中的诸如<spanclass="math inline">\(x_2-x_1\)</span>的元素，可以看做该边上的电势差。容易看出其中一个解<spanclass="math inline">\(x=\begin{bmatrix}1\\ 1\\ 1\\1\end{bmatrix}\)</span>，即等电势情况，此时电势差为<spanclass="math inline">\(0\)</span>。化简<spanclass="math inline">\(A\)</span>易得<spanclass="math inline">\(rank(A)=3\)</span>，所以其零空间维数应为<spanclass="math inline">\(n-r=4-3=1\)</span>，即<spanclass="math inline">\(\begin{bmatrix}1\\1\\1\\1\end{bmatrix}\)</span>就是其零空间的一组基。</p><p>Q: 那么以电势为例，零空间的物理意义是什么呢？ A:电势差和电流的形成之间有着直接关系，<spanclass="math inline">\(b=0\)</span>说明我们求解的情况是各个边上都没有电流（或者说电势差）的情况，而我们最后所得到的解就意味着，当各点电势相等时，边上电流（电势差）为零，符合我们的常识。而这就是零空间的物理意义。</p><h3 id="a的左零空间"><spanclass="math inline">\(A\)</span>的左零空间</h3><p><span class="math inline">\(A\)</span>的左零空间是什么呢？或者说<spanclass="math inline">\(A^T\)</span>的零空间是什么呢？即求<spanclass="math inline">\(A^Ty=0\)</span>： <span class="math display">\[A^Ty=0=\begin{bmatrix}-1 &amp; 0 &amp; -1 &amp; -1 &amp; 0\\ 1 &amp; -1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; -1\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}\begin{bmatrix}y_1\\ y_2\\ y_3\\ y_4\\ y_5\end{bmatrix}=\begin{bmatrix}-y_1-y_3-y_4\\ y_1-y_2\\ y_2+y_3-y_5\\ y_4+y_5\end{bmatrix}=\begin{bmatrix}0\\ 0\\ 0\\ 0\end{bmatrix}\]</span></p><p>接着说上文提到的的电势差，引入<spanclass="math inline">\(y\)</span>的实际物理意义：即各边上的电流。电流和电势差的关系服从欧姆定律：边上的电流值是边上电势差的倍数，这个倍速就是边的电导，亦即电阻的倒数，通常我们把这个常数视为一个系数矩阵记为<spanclass="math inline">\(C\)</span>。于是，矩阵<spanclass="math inline">\(C\)</span>就将电势差与电流联系了起来： <spanclass="math display">\[y=\begin{bmatrix}y_1\\ y_2\\ y_3\\ y_4\\ y_5\end{bmatrix}=C\begin{bmatrix}x_2-x_1\\ x_3-x_2\\ x_3-x_1\\ x_4-x_1\\ x_4-x_3\end{bmatrix}\]</span></p><p>实际上<spanclass="math inline">\(A^Ty=0\)</span>阐释的就是“基尔霍夫电流定律”（KCL），基尔霍夫电流定律是一个平衡方程，守恒定律，它说明了流入等于流出，电荷在结点上不会积累。</p><p>对于<spanclass="math inline">\(A^T\)</span>，有上文得出其零空间的维数是<spanclass="math inline">\(2\)</span>，则零空间的基应该有两个向量。假设<spanclass="math inline">\(y_1=1\)</span>，也就是令<spanclass="math inline">\(1\)</span>安培的电流在边<spanclass="math inline">\(1\)</span>上流动，由图看出<spanclass="math inline">\(y_2\)</span>也应该为<spanclass="math inline">\(1\)</span>，再令<spanclass="math inline">\(y_3=-1\)</span>，也就是让<spanclass="math inline">\(1\)</span>安培的电流流回节点<spanclass="math inline">\(1\)</span>，得出<spanclass="math inline">\(y_4=y_5=0\)</span>；</p><p>得到一个符合KCL的向量<span class="math inline">\(\begin{bmatrix}1\\1\\ -1\\ 0\\0\end{bmatrix}\)</span>，代回方程组发现此向量即为一个解，这个解发生在节点<spanclass="math inline">\(1,2,3\)</span>组成的回路中，该解即为零空间的一个基。</p><p>如法炮制可以得出另一个基向量：<spanclass="math inline">\(\begin{bmatrix}0\\ 0\\ 1\\ -1\\1\end{bmatrix}\)</span>，这实际上是节点<spanclass="math inline">\(1,3,4\)</span>构成的回路。</p><p>如此，我们得到<spanclass="math inline">\(N(A^T)\)</span>的一组基为<spanclass="math inline">\(\begin{bmatrix}1\\ 1\\ -1\\ 0\\0\end{bmatrix}\quad\begin{bmatrix}0\\ 0\\ 1\\ -1\\1\end{bmatrix}\)</span>。</p><blockquote><p>节点<spanclass="math inline">\(1,2,3,4\)</span>构成的大回路实际上是两个基向量回路的叠加。</p></blockquote><h3 id="a的行空间"><span class="math inline">\(A\)</span>的行空间</h3><p>亦即<spanclass="math inline">\(A^T\)</span>的列空间，方便起见我们直接计算<spanclass="math inline">\(A^T\)</span>的列空间： <spanclass="math display">\[A^T=\begin{bmatrix}-1 &amp; 0 &amp; -1 &amp; -1 &amp; 0\\ 1 &amp; -1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; -1\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}\]</span></p><p>显然，<span class="math inline">\(A^T\)</span>的主列为第<spanclass="math inline">\(1,2,4\)</span>列，对应在图中就是边<spanclass="math inline">\(1,2,4\)</span>，可以发现这三条边没有组成回路（<strong>换句话说，线性无关等价于没有回路</strong>）。由<spanclass="math inline">\(4\)</span>个节点与<spanclass="math inline">\(3\)</span>条边组成的图没有回路，就表明<spanclass="math inline">\(A^T\)</span>的对应列向量线性无关，也就是（<spanclass="math inline">\(nodes-1\)</span>）条边线性无关。</p><blockquote><p>没有回路的图叫作树。</p></blockquote><p>再看左零空间的维数公式：<span class="math inline">\(dimN(A^T)=m-r\)</span>，左零空间的维数就是相互无关的回路的数量，于是得到<spanclass="math inline">\(loops=edges-(nodes-1)\)</span>，整理得： <spanclass="math display">\[nodes-edges+loops=1\]</span></p><p>此等式对任何图均有效，任何图都有此拓扑性质，这就是著名的欧拉公式：<span class="math display">\[节点数-边数+最小回路数=1\]</span></p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十一)——矩阵空间、秩1矩阵和小世界图</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4%E3%80%81%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4%E3%80%81%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>本讲是上一讲的扩展内容，共分为3部分，第一部分延续上一讲介绍了矩阵空间的特性并延展到微分方程的例子，第二部分介绍了一个特殊的秩1矩阵，第三部分介绍了图的概念以及图与矩阵的关系。</p><span id="more"></span><h1 id="矩阵空间秩1矩阵和小世界图">矩阵空间、秩1矩阵和小世界图</h1><h2 id="矩阵空间">矩阵空间</h2><p>话接上一讲，以<span class="math inline">\(3\times3\)</span>矩阵为例，矩阵空间记为<spanclass="math inline">\(M\)</span>，则其一组基为： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>另一方面，对称阵<spanclass="math inline">\(S\)</span>的基也非常容易找到： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\end{bmatrix}\]</span></p><p>上三角阵<span class="math inline">\(U\)</span>的基： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>对角矩阵<span class="math inline">\(D\)</span>的基： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>因此，有：<span class="math inline">\(dim M=9\)</span>，<spanclass="math inline">\(dim S=6\)</span>，<span class="math inline">\(dimU=6\)</span>，<span class="math inline">\(dim D=3\)</span>。</p><ul><li>求和（sum）：<span class="math inline">\(S+U=M,dim(S+U)=9\)</span>；</li><li>求交（intersect）：<span class="math inline">\(S \cap U=D, dim(S\cap U)=3\)</span>；</li></ul><p>可以看出：<span class="math inline">\(dim S + dim U=12=dim(S+U) +dim(S \cap U)\)</span>。</p><blockquote><p><span class="math inline">\(S+U\)</span>可以看出就是<spanclass="math inline">\(M\)</span>，但是要注意<spanclass="math inline">\(S+U\)</span>并不是<span class="math inline">\(S\cup U\)</span>，后者只包含了<spanclass="math inline">\(S\)</span>和<spanclass="math inline">\(U\)</span>，而前者包含的是<spanclass="math inline">\(S\)</span>中元素和<spanclass="math inline">\(U\)</span>中元素的线性组合，这样的线性组合显然包含了<spanclass="math inline">\(S\)</span>和<spanclass="math inline">\(U\)</span>，也即 <span class="math inline">\((S\cup U) \subseteq (S + U)\)</span>。</p></blockquote><p>空间内元素还可以进一步扩展，不仅限于矩阵或向量，比如还可以是微分方程的解。</p><h2 id="微分方程">微分方程</h2><p>求解：<spanclass="math inline">\(\frac{d^2y}{dx^2}+y=0\)</span>，即<spanclass="math inline">\(y&#39;&#39;+y=0\)</span></p><p>方程的解有：<span class="math inline">\(y=\cos{x}, \quad y=\sin{x},\quad y=e^{ix}, \quad y=e^{-ix}\)</span>等等（<spanclass="math inline">\(e^{ix}=\cos{x}+i\sin{x}, \quade^{-ix}=\cos{x}-i\sin{x}\)</span>）</p><p>只考虑实数范围，该方程的通解为：<span class="math inline">\(y=c_1\cos{x} + c_2 \sin{x}\)</span>。</p><p>所以，该方程的零空间的一组基为<span class="math inline">\(\cos{x},\sin{x}\)</span>，零空间的维数为<spanclass="math inline">\(2\)</span>。同理，如果考虑复数范围，那么<spanclass="math inline">\(e^{ix}, e^{-ix}\)</span>也可以作为另一组基。</p><p>该微分方程的所有解的集合实际上就可以看做是一个“向量空间”，或者应该叫“解空间”，他们满足加法和数乘的封闭性。</p><h2 id="秩1矩阵">秩1矩阵</h2><p>秩<span class="math inline">\(1\)</span>矩阵也即秩为<spanclass="math inline">\(1\)</span>的矩阵。所有的秩<spanclass="math inline">\(1\)</span>矩阵都可以表示成一列乘以一行（<spanclass="math inline">\(A=UV^T\)</span>）的形式，如： <spanclass="math display">\[A=\begin{bmatrix}1&amp;4&amp;5\\ 2&amp;8&amp;10\end{bmatrix}=\begin{bmatrix}1\\ 2\end{bmatrix}\begin{bmatrix}1&amp;4&amp;5\end{bmatrix}\]</span></p><p>其中<span class="math inline">\(dimC(A)=1=dimC(A^T)\)</span>，<spanclass="math inline">\(U, V\)</span>均为列向量。</p><p>秩<spanclass="math inline">\(1\)</span>矩阵类似积木，任何矩阵都是有秩<spanclass="math inline">\(1\)</span>矩阵搭建而成的，如对于一个<spanclass="math inline">\(5 \times 17\)</span>秩为<spanclass="math inline">\(4\)</span>的矩阵，只需要<spanclass="math inline">\(4\)</span>个秩一矩阵就可以组合出来，具体过程类似于我们在第3讲中提到的矩阵乘法中的“列乘行”形式。</p><p>另外，矩阵的加法存在这样的性质：<span class="math inline">\(rank(A+B)\lerank(A)+rank(B)\)</span>。这意味着：对于同样规模的同秩矩阵所组成的集合，其加法是不封闭的。两个<spanclass="math inline">\(5\times 6\)</span>的秩为<spanclass="math inline">\(4\)</span>矩阵相加，结果的秩可能大于<spanclass="math inline">\(4\)</span>。</p><h2 id="示例">示例</h2><p>在<span class="math inline">\(\mathbb{R}^4\)</span>空间中有向量<spanclass="math inline">\(v=\begin{bmatrix}v_1\\ v_2\\ v_3\\v_4\end{bmatrix}\)</span>，取<spanclass="math inline">\(\mathbb{R}^4\)</span>中满足<spanclass="math inline">\(v_1+v_2+v_3+v_4=0\)</span>的所有向量组成一个向量空间<spanclass="math inline">\(S\)</span>，则<spanclass="math inline">\(S\)</span>是一个向量子空间。易看出，不论是使用系数乘以该向量，或是用两个满足条件的向量相加，其结果仍然落在分量和为零的向量空间中。</p><p><strong><span class="math inline">\(S\)</span>的维数</strong>从另一个角度看，<spanclass="math inline">\(v_1+v_2+v_3+v_4=0\)</span>等价于: <spanclass="math display">\[\begin{bmatrix}1&amp;1&amp;1&amp;1\end{bmatrix}\begin{bmatrix}v_1\\v_2\\v_3\\v_4\end{bmatrix}=0\]</span></p><p>则<span class="math inline">\(S\)</span>就是<spanclass="math inline">\(A=\begin{bmatrix}1&amp;1&amp;1&amp;1\end{bmatrix}\)</span>的零空间。<spanclass="math inline">\(rank(A)=1\)</span>，则对其零空间有<spanclass="math inline">\(rank(N(A))=n-r=3=dim N(A)\)</span>，则<spanclass="math inline">\(S\)</span>的维数是<spanclass="math inline">\(3\)</span>。</p><p>矩阵<span class="math inline">\(A\)</span>的四个基本子空间： -行空间：<span class="math inline">\(dimC(A^T)=1\)</span>，其中的一组基是<spanclass="math inline">\(\begin{bmatrix}1\\ 1\\ 1\\1\end{bmatrix}\)</span>； - 零空间：<span class="math inline">\(dimN(A)=3\)</span>，其中的一组基是<spanclass="math inline">\(\begin{bmatrix}-1\\ 1\\ 0\\0\end{bmatrix}\begin{bmatrix}-1\\ 0\\ 1\\0\end{bmatrix}\begin{bmatrix}-1\\ 0\\ 0\\ 1\end{bmatrix}\)</span> -列空间：<span class="math inline">\(dimC(A)=1\)</span>，其中一组基是<spanclass="math inline">\(\begin{bmatrix}1\end{bmatrix}\)</span>，可以看出列空间就是整个<spanclass="math inline">\(\mathbb{R}^1\)</span>空间。 - 左零空间：<spanclass="math inline">\(dim N(A^T)=0\)</span>，因为<spanclass="math inline">\(A\)</span>转置后没有非零的<spanclass="math inline">\(v\)</span>可以使<spanclass="math inline">\(Av=0\)</span>成立，就是<spanclass="math inline">\(\begin{bmatrix}0\end{bmatrix}\)</span>。</p><p>综上，<span class="math inline">\(dim C(A^T)+dim N(A)=4=n, dimC(A)+dim N(A^T)=1=m\)</span></p><h2 id="小世界图">小世界图</h2><p><strong>图是点和边的集合，边连通各个点。</strong></p><p><img src="2022-05-14-16-41-56.png" /></p><p>假设，每个人是图中的一个节点，如果两个人为朋友关系，则在这两个人的节点间添加一条边，通常来说，从一个节点到另一个节点只需要不超过<spanclass="math inline">\(6\)</span>步（即六条边）即可到达，这就是大名鼎鼎的“<strong>六度分割理论</strong>”。</p><p>图与矩阵有怎样的联系呢？下一讲会进行阐述。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十)——四个基本子空间</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81)%E2%80%94%E2%80%94%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81)%E2%80%94%E2%80%94%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>这一讲系统地讲解了矩阵的四个基本子空间：行空间，列空间，零空间和左零空间。他们关系密切且极其重要，对于每个子空间，我们探索了基和维数并高度概括了其背后的关联性。</p><span id="more"></span><h1 id="四个基本子空间">四个基本子空间</h1><p>现有<span class="math inline">\(m \times n\)</span>矩阵<spanclass="math inline">\(A\)</span>，已知<spanclass="math inline">\(rank(A)=r, r\le min(n,m)\)</span>，则有： *行空间<span class="math inline">\(C(A^T) \in \mathbb{R}^n, dimC(A^T)=r\)</span>。 * 零空间<span class="math inline">\(N(A) \in\mathbb{R}^n, dim N(A)=n-r\)</span>。 * 列空间<spanclass="math inline">\(C(A) \in \mathbb{R}^m, dim C(A)=r\)</span>。 *左零空间<span class="math inline">\(N(A^T) \in \mathbb{R}^m, dimN(A^T)=m-r\)</span>。</p><p>根据上一讲的内容，列空间和零空间的维数和基我们都已了然于胸，而实际上，行空间和左零空间也如出一辙，不过就是把<spanclass="math inline">\(A\)</span>做了转置以后，如法炮制得到的列空间和零空间。</p><blockquote><p>列空间的基：主元所在列的所有向量；零空间的基：所有线性无关的特解。</p></blockquote><p>事实上，除了先转置再如法炮制的法子以外，对于行空间和左零空间，我们还有更便捷的求解方法。</p><h2 id="行空间">行空间</h2>假如我们换个角度思考，直接来看<spanclass="math inline">\(A\)</span>的行向量组，消元得到： $ A=<span class="math display">\[\begin{bmatrix}1 &amp; 2 &amp; 3 &amp; 1\\ 1 &amp; 1 &amp; 2 &amp; 1\\ 1 &amp; 2 &amp; 3 &amp; 1\end{bmatrix}\underrightarrow{消元}\begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1\\ 0 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}\]</span><p>=R $</p><p>消元的本质是做行变换，此时A的列空间发生变化（<spanclass="math inline">\(C(R) \neqC(A)\)</span>），但却并不影响行空间，所以可以在<spanclass="math inline">\(R\)</span>中看出前两行就是行空间的一组基。所以，可以得出无论对于矩阵<spanclass="math inline">\(A\)</span>还是<spanclass="math inline">\(R\)</span>，其行空间的一组基，可以由<spanclass="math inline">\(R\)</span>矩阵的前<spanclass="math inline">\(r\)</span>行向量组成。</p><blockquote><p>这里的<spanclass="math inline">\(R\)</span>就是第七讲提到的简化行阶梯形式。</p></blockquote><h2 id="左零空间">左零空间</h2><p>对于左零空间，有<span class="math inline">\(A^Ty=0 \rightarrow(A^Ty)^T=0^T\rightarrow y^TA=0^T\)</span>，因此得名。</p><p>采用Gauss-Jordan消元，将增广矩阵<spanclass="math inline">\(\left[\begin{array}{c|c}A_{m \times n} &amp; I_{m\times m}\end{array}\right]\)</span>中<spanclass="math inline">\(A\)</span>的部分划为简化行阶梯形式<spanclass="math inline">\(\left[\begin{array}{c|c}R_{m \times n} &amp; E_{m\times m}\end{array}\right]\)</span>，此时矩阵<spanclass="math inline">\(E\)</span>会将所有的行变换记录下来。</p><p>则<span class="math inline">\(EA=R\)</span>，而在前几讲中，有当<spanclass="math inline">\(A&#39;\)</span>是<spanclass="math inline">\(m\)</span>阶可逆方阵时，<spanclass="math inline">\(R&#39;\)</span>即是<spanclass="math inline">\(I\)</span>，所以<spanclass="math inline">\(E\)</span>就是<spanclass="math inline">\(A^{-1}\)</span>。</p><p>本例中 <span class="math display">\[\left[\begin{array}{c|c}A_{m \times n} &amp; I_{m \timesm}\end{array}\right]=\left[\begin{array}{c c c c|c c c}1 &amp; 2 &amp; 3 &amp; 1 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 1 &amp; 2 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\ 1 &amp; 2 &amp; 3 &amp; 1 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\underrightarrow{消元}\left[\begin{array}{c c c c|c c c}1 &amp; 0 &amp; 1 &amp; 1 &amp; -1 &amp; 2 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; -1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 1\end{array}\right]=\left[\begin{array}{c|c}R_{m \times n} &amp; E_{m \timesm}\end{array}\right]\]</span></p><p>则 <span class="math display">\[EA=\begin{bmatrix}-1 &amp; 2  &amp; 0\\ 1  &amp; -1 &amp; 0\\ -1 &amp; 0  &amp; 1\end{bmatrix}\cdot\begin{bmatrix}1 &amp; 2 &amp; 3 &amp; 1\\ 1 &amp; 1 &amp; 2 &amp; 1\\ 1 &amp; 2 &amp; 3 &amp; 1\end{bmatrix}=\begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1\\ 0 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}=R\]</span></p><p>很明显，式中<span class="math inline">\(E\)</span>的最后一行对<spanclass="math inline">\(A\)</span>的行做线性组合后，得到<spanclass="math inline">\(R\)</span>的最后一行，即<spanclass="math inline">\(0\)</span>向量，也就是<spanclass="math inline">\(y^TA=0^T\)</span>。另一方面，<spanclass="math inline">\(E\)</span>的第三行对应的行向量就是矩阵<spanclass="math inline">\(A\)</span>的左零空间的基。</p><h2 id="矩阵空间">矩阵空间</h2><p>不只是向量可以构建出空间，万物皆可构造出空间，只要满足加法和数乘的封闭性即可。</p><p>举个例子，矩阵可以同向量一样，做求和、数乘。那么什么样的矩阵构成的空间满足封闭性呢？比如，设所有<span class="math inline">\(3 \times3\)</span>矩阵组成的矩阵空间为<spanclass="math inline">\(M\)</span>。则上三角矩阵、对称矩阵、对角矩阵（前两者的交集）都可以构成矩阵空间。</p>观察一下对角矩阵，如果取： $<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix} \quad\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 3 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix} \quad\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 7\end{bmatrix}\]</span><p>$</p><p>可以发现，任何三阶对角矩阵均可用这三个矩阵的线性组合生成，因此，他们生成了三阶对角矩阵空间，即这三个矩阵是三阶对角矩阵空间的一组基。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(九)——线性相关性、基和维数</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B9%9D)%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E3%80%81%E5%9F%BA%E5%92%8C%E7%BB%B4%E6%95%B0/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B9%9D)%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E3%80%81%E5%9F%BA%E5%92%8C%E7%BB%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>这一讲对向量组的线性相关性、线性无关性做了进一步的阐释，之后引出向量空间中基和维数的概念。</p><span id="more"></span><h1 id="线性相关性基和维数">线性相关性、基和维数</h1><h2 id="线性相关线性无关">线性相关、线性无关</h2><p>所谓的线性相关和线性无关是用于描述向量组中所有向量的关系，根据此前所掌握的知识，我们知道：以<spanclass="math inline">\(A\)</span>中列向量组为例，如果不存在零解以外的零向量的线性组合，那么列向量组就是线性无关的，否则就是线性相关的。</p><p>进一步，我们可以知道，如果向量组包含一个零向量，那么该向量组一定是线性相关的（因为零向量的可以取任意分量）。</p><p>总结： 给定<span class="math inline">\(v_1,\ v_2,\ \cdots,\v_n\)</span>是<span class="math inline">\(m\times n\)</span>矩阵<spanclass="math inline">\(A\)</span>的列向量： - 如果<spanclass="math inline">\(A\)</span>零空间中有且仅有<spanclass="math inline">\(0\)</span>向量，则各向量线性无关，此时有：<spanclass="math inline">\(rank(A)=n\)</span>。 - 如果存在非零向量<spanclass="math inline">\(c\)</span>使得<spanclass="math inline">\(Ac=0\)</span>，则存在线性相关向量，此时有：<spanclass="math inline">\(rank(A)\lt n\)</span>。</p><p>用此前课程所掌握的知识来描述，前者就是列满秩，此时没有自由列，也就没有自由变量，因此零空间只有零向量，因而向量组线性无关；后者则存在自由列，零空间除了零向量以外还有其他向量，因而向量组线性相关。</p><p>至此，向量组的线性相关性与矩阵的零空间就联系起来了。</p><h2 id="基和维数">基和维数</h2><p>对于线性无关的情况，我们实际上关心的正是这一组“最小的”向量组：它们线性无关，且能生成相应大小的向量空间。而这恰恰就是“基”的概念。</p><p>向量空间的基本质上就是一个向量组，我们之所以额外地称这些向量组为基是因为其既有两个性质：- 向量组中的向量线性无关 -向量组中的向量能够生成相应大小的整个向量空间</p><p>因此，如果需要确定一个向量空间，那么只需要把向量空间对应的基找出来即可，向量空间对应的基包含了这个向量空间的全部有用信息。</p><p>进一步，对于向量空间<spanclass="math inline">\(\mathbb{R}^n\)</span>中的<spanclass="math inline">\(n\)</span>个向量，如果想要构成基，那么以这<spanclass="math inline">\(n\)</span>个向量为列向量的矩阵<spanclass="math inline">\(A\)</span>必然是可逆的。</p><p>显然向量空间<spanclass="math inline">\(\mathbb{R}^n\)</span>的基有无穷多个，而我们平常在选取的时候，则一般会选择标准基，所谓的<strong>标准基</strong>，就是向量空间中最明显的基，把每个基向量以一定顺序作为列向量，可以组成一个单位矩阵。另一方面，这无穷多个基有着一个共同点：基所包含的向量（基向量）的个数是一定的。而这个确定的基向量的个数实际上就表示了向量空间的大小，我们一般称其为向量空间的“<strong>维数</strong>”。</p><h2 id="示例">示例</h2><p><span class="math inline">\(A=\begin{bmatrix} 1 &amp; 2 &amp; 3 &amp;1 \\ 1 &amp; 1 &amp; 2 &amp; 1 \\ 1 &amp; 2 &amp; 3 &amp; 1\end{bmatrix}\)</span></p><p>A的列向量线性相关，其零空间中有非零向量，所以<spanclass="math inline">\(rank(A)=2\)</span>，即主元存在的列数，亦是列空间的维数。</p>可以很容易的求得<span class="math inline">\(Ax=0\)</span>的两个解，如$x_1=<span class="math display">\[\begin{bmatrix}-1\\ -1\\ 1\\ 0\end{bmatrix}\]</span>, x_2=<span class="math display">\[\begin{bmatrix}-1\\ 0\\ 0\\ 1\end{bmatrix}\]</span><p><spanclass="math inline">\(，而特解的个数就是自由变量的个数，所以\)</span>n-rank(A)=2$，即自由变量存在的列数，亦是零空间的维数。</p><p>由此观之： - 列空间维数<span class="math inline">\(dim C(A)=rank(A),C(A)\in \mathbb{R}^m\)</span> - 零空间维数<spanclass="math inline">\(dim N(A)=n-rank(A), N(A)\in\mathbb{R}^n\)</span></p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(八)——求解Ax=b：可解性和解的结构</title>
    <link href="/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AB)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-b%EF%BC%9A%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <url>/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AB)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-b%EF%BC%9A%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>这一讲系统的讲解了线性方程组<spanclass="math inline">\(Ax=b\)</span>的求解，对可解性和解的结构进行了展开说明，得到了具体的通用解法：<spanclass="math inline">\(X_p+X_n\)</span>，并按照秩与<spanclass="math inline">\(m,n\)</span>的关系对解做了归类。</p><h1 id="求解axb可解性和解的结构">求解<spanclass="math inline">\(Ax=b\)</span>：可解性和解的结构</h1><p>我们知道<span class="math inline">\(Ax=b\)</span>未必有解，当<spanclass="math inline">\(A\)</span>的列空间无法线性组合出<spanclass="math inline">\(b\)</span>时，方程组是无解的。而在有解时可能存在唯一解，也可能存在无穷多个解，那么这其中又有什么规律呢？我们尝试按照上一讲对<spanclass="math inline">\(Ax=0\)</span>的研究方法来进行消元操作。</p><h2 id="可解性">可解性</h2><p>依然采用上一讲的矩阵：<span class="math inline">\(A=\begin{bmatrix} 1&amp; 2 &amp; 2 &amp; 2 \\ 2 &amp; 4 &amp; 6 &amp; 8 \\ 3 &amp; 6 &amp;8 &amp; 10 \end{bmatrix}\)</span>，求<spanclass="math inline">\(Ax=b\)</span>的特解。</p><p>这一次<span class="math inline">\(b\)</span>不再是<spanclass="math inline">\(0\)</span>向量，我们消元时写出增广矩阵： <spanclass="math display">\[\left[\begin{array}{c c c c|c}1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\ 2 &amp; 4 &amp; 6 &amp; 8 &amp; b_2\\ 3 &amp; 6 &amp; 8 &amp; 10 &amp; b_3\end{array}\right]\underrightarrow{消元}\left[\begin{array}{c c c c|c}1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\ 0 &amp; 0 &amp; 2 &amp; 4 &amp; b_2-2b_1\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; b_3-b_2-b_1\end{array}\right]\]</span></p><p>从最后一行可见，要使<spanclass="math inline">\(Ax=b\)</span>有解，则必须满足<spanclass="math inline">\(b_3-b_2-b_1=0\)</span>，而这就是可解性。</p><blockquote><p>我们此前按照列空间视角：<spanclass="math inline">\(b\)</span>必须要属于<spanclass="math inline">\(A\)</span>的列空间才有解，也就是<spanclass="math inline">\(A\)</span>中各列的线性组合。而这里我们换个角度来理解可解性。</p></blockquote><p><strong>我们尝试归纳一下可解性：如果<spanclass="math inline">\(A\)</span>中各行线性组合产生了零行，那么向量<spanclass="math inline">\(b\)</span>的分量在同样的线性组合后也必须为零。</strong></p><h2 id="解的结构">解的结构</h2><p>我们假设<span class="math inline">\(b=\begin{bmatrix} 1\\ 5\\ 6\end{bmatrix}\)</span>满足可解性，那么<spanclass="math inline">\(Ax=b\)</span>的解是什么呢？直观上来看，消元以后我们得到了两个方程，但是未知数有4个，因此，理论上我们可以找到无穷多个解（因为存在自由变量）。<span class="math display">\[\begin{cases}x_1+2x_2+2x_3+2x_4 = 1\\ 2x_3+4x_4 = 3\end{cases}\]</span></p><p>首先我们找出一个特解：先让所有的自由变量取<spanclass="math inline">\(0\)</span>，以解出此时主变量的值。这里自由变量是<spanclass="math inline">\(x_2\)</span>和<spanclass="math inline">\(x_4\)</span>，带入其中求得<spanclass="math inline">\(x_1=-2,x_3=\frac{3}{2}\)</span>，故特解<spanclass="math inline">\(x_p=\begin{bmatrix} -2\\ 0\\ \frac{3}{2}\\ 0\end{bmatrix}\)</span>。</p><p>显然，将特解<spanclass="math inline">\(x_p\)</span>加上上一讲所学的零空间中的任意向量(写为<spanclass="math inline">\(x_n\)</span>)即可得到通解：<spanclass="math inline">\(x=x_p+x_n\)</span>。</p><blockquote><p>显然<spanclass="math inline">\(A(x_p+x_n)=Ax_p+Ax_n=b+0=b\)</span></p></blockquote><p>而上一讲中我们得到了<spanclass="math inline">\(x_n=x_4\begin{bmatrix} 2\\ 0\\ -2\\ 1\end{bmatrix}+x_2\begin{bmatrix} -2\\ 1\\ 0\\ 0\end{bmatrix}\)</span></p><blockquote><p>自由变量取<spanclass="math inline">\(0\)</span>只是为了方便计算，实际上你想取啥都行，因为它们就是从自由变量那里“借”来的。</p></blockquote><h2 id="解与秩的关系">解与秩的关系</h2><p>考虑秩为<span class="math inline">\(r\)</span>的<spanclass="math inline">\(m\times n\)</span>的矩阵<spanclass="math inline">\(A\)</span>，显然<span class="math inline">\(r\leqm, r\leq n\)</span>。 当列满秩时(<spanclass="math inline">\(r=n\)</span>)，意味着每一列都有主元，那么也就没有自由变量，此时零空间只有零向量，因此若<spanclass="math inline">\(b\)</span>满足可解性，则解唯一。</p><p>而当行满秩时(<spanclass="math inline">\(r=m\)</span>)，意味着每一行都有主元，即没有零行，此时对<spanclass="math inline">\(b\)</span>就没有任何约束，那么<spanclass="math inline">\(Ax=b\)</span>是必然有解的。进一步，当<spanclass="math inline">\(m&lt;n\)</span>时，此时意味着存在自由列（自由变量），此时零空间还有特解的线性组合，因此<spanclass="math inline">\(Ax=b\)</span>有无穷解；而当<spanclass="math inline">\(m=n\)</span>时，则不存在自由列，因此仅有唯一解。</p><p>总结如下： <span class="math display">\[\begin{array}{c|c|c|c}r=m=n&amp;r=n\lt m&amp;r=m\lt n&amp;r\lt m,r\lt n\\ R=I&amp;R=\begin{bmatrix}I\\0\end{bmatrix}&amp;R=\begin{bmatrix}I&amp;F\end{bmatrix}&amp;R=\begin{bmatrix}I&amp;F\\0&amp;0\end{bmatrix}\\1\ solution&amp;0\ or\ 1\ solution&amp;\infty\ solution&amp;0\ or\\infty\ solution\end{array}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(七)——求解Ax=0：主变量，特解</title>
    <link href="/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%83)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-0%EF%BC%9A%E4%B8%BB%E5%8F%98%E9%87%8F%EF%BC%8C%E7%89%B9%E8%A7%A3/"/>
    <url>/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%83)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-0%EF%BC%9A%E4%B8%BB%E5%8F%98%E9%87%8F%EF%BC%8C%E7%89%B9%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>这一讲深入探讨了求解<spanclass="math inline">\(Ax=0\)</span>过程中，消元法所得到的主列、自由列、自由变量与特解以及它们与矩阵的秩的关系。</p><span id="more"></span><h1 id="求解ax0-主变量特解">求解<spanclass="math inline">\(Ax=0\)</span>: 主变量，特解</h1><p>给定一个<span class="math inline">\(3\times 4\)</span>的矩阵： <spanclass="math inline">\(A=\begin{bmatrix}  1&amp;2&amp;2&amp;2  \\2&amp;4&amp;6&amp;8  \\ 3&amp;6&amp;8&amp;10 \end{bmatrix}\)</span></p><p>欲求<spanclass="math inline">\(Ax=0\)</span>的特解，首先通过高斯消元法找到主变量：<span class="math display">\[A=\begin{bmatrix}1 &amp; 2 &amp; 2 &amp; 2\\ 2 &amp; 4 &amp; 6 &amp; 8\\ 3 &amp; 6 &amp; 8 &amp; 10\end{bmatrix}\underrightarrow{eliminate}\begin{bmatrix}\underline{1} &amp; 2 &amp; 2 &amp; 2\\ 0 &amp; 0 &amp; \underline{2} &amp; 4\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}=U\]</span></p><p>可以看出经过消元后，主变量还剩2个（下划线元素），因此矩阵<spanclass="math inline">\(A\)</span>的秩就是2，即<spanclass="math inline">\(r=2\)</span>。主变量所在的列我们称为主列，其余列则称为自由列。自由列中的变量我们称为自由变量，那么自由变量的个数就是：<spanclass="math inline">\(n-r=4-2=2\)</span>。</p><p>高斯消元处理后，线性相关的行就会被暴露出来，比如<spanclass="math inline">\(A\)</span>矩阵的行三实际上就是行一和行二的加和，所以在消元后整行都变成了<spanclass="math inline">\(0\)</span>(<spanclass="math inline">\(0\)</span>行，即没有主元)。另一方面，线性相关的列也会被暴露，我们在消元过程中发现第二列原本要做主元的元素变成了0，这恰恰是因为第二列和前面的列（这里只有第一列）线性相关（刚好是2倍列1），因此第二列没有主元，是自由列。而同样的，第四列也没有主元，这就说明第四列实际上是前三列的线性组合（二倍第三列减去第二列）。</p><p>消元的本质是行变换，行变换改变的是列向量（从而可能改变列空间），但是无法改变列向量之间的线性相关性。另一方面，消元不会改变零空间，因为<spanclass="math inline">\(b\)</span>为<spanclass="math inline">\(0\)</span>时，随你怎么折腾，他都是<spanclass="math inline">\(0\)</span>，解不会改变。</p><p>因此，<span class="math inline">\(Ax=0\)</span>求解问题变成了对<spanclass="math inline">\(Ux=0\)</span>的求解，首先我们找出主变量和自由变量，<spanclass="math inline">\(x_1\)</span>和<spanclass="math inline">\(x_3\)</span>是主变量，<spanclass="math inline">\(x_2\)</span>和<spanclass="math inline">\(x_4\)</span>是自由变量。自由变量可以对其分配任意的值（不关你赋什么值，都会被其他线性相关的列的某个值里抵消掉）。</p><p><strong>我们对自由变量随意赋值，一般采用的一种简单策略是：对其中一个自由变量赋值为<spanclass="math inline">\(1\)</span>，其余赋值为<spanclass="math inline">\(0\)</span>，循环往复。</strong></p><blockquote><p>这种策略非常优雅且直观，类似控制变量法的思想，我们每次只关注其中一个自由变量，其他都砍成<spanclass="math inline">\(0\)</span>，这样就可以避免自由变量的相互影响，从而得到所有的线性无关的特解。</p></blockquote><p>通过这样的策略，我们对自由变量进行赋值，并回代求出主变量：</p><ul><li>令<span class="math inline">\(x_2=1, x_4=0\)</span>求得特解<spanclass="math inline">\(x=c_1\begin{bmatrix}-2\\ 1\\ 0\\0\end{bmatrix}\)</span></li><li>令<span class="math inline">\(x_2=0, x_4=1\)</span>求得特解<spanclass="math inline">\(x=c_2\begin{bmatrix}2\\ 0\\ -2\\1\end{bmatrix}\)</span></li></ul><p>到这里，结果就很显而易见了：<strong>零空间所包含的就是特解的线性组合，每个自由变量对应着一个特解，特解之间线性无关。</strong></p><h2 id="rrefreduced-row-echelon-form">RREF(Reduced row echelonform)</h2><p>上例中消元得到的<spanclass="math inline">\(U\)</span>矩阵是个上三角阵，实际上还可以进一步简化成<spanclass="math inline">\(R\)</span>矩阵，即RREF(Reduced row echelonform)——简化行阶梯形式。</p><p><span class="math inline">\(R\)</span>矩阵中主元上下的元素都是0：<span class="math display">\[U=\begin{bmatrix}\underline{1} &amp; 2 &amp; 2 &amp; 2\\ 0 &amp; 0 &amp; \underline{2} &amp; 4\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}\underrightarrow{自底向上}\begin{bmatrix}\underline{1} &amp; 2 &amp; 0 &amp; -2\\ 0 &amp; 0 &amp; \underline{1} &amp; 2\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}=R\]</span></p><p>将<spanclass="math inline">\(R\)</span>矩阵中的主变量放在一起，自由变量放在一起（列交换），得到：<span class="math display">\[R=\begin{bmatrix}\underline{1} &amp; 2 &amp; 0 &amp; -2\\ 0 &amp; 0 &amp; \underline{1} &amp; 2\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}\underrightarrow{列交换}\left[\begin{array}{c c | c c}1&amp;0&amp;2&amp;-2\\0&amp;1&amp;0&amp;2\\ \hline 0&amp;0&amp;0&amp;0\end{array}\right]=\begin{bmatrix}I &amp; F\\ 0 &amp; 0\end{bmatrix}\textrm{，其中}I\textrm{为单位矩阵，}F\textrm{为自由变量组成的矩阵}\]</span></p><p>计算零空间矩阵<span class="math inline">\(N\)</span>（nullspacematrix），其列为特解，有<span class="math inline">\(RN=0\)</span>。<span class="math display">\[\begin{align}x_{pivot}=-Fx_{free}\\ \begin{bmatrix}I&amp;F\end{bmatrix}\begin{bmatrix}x_{pivot}\\ x_{free}\end{bmatrix}=0\\ N=\begin{bmatrix}-F\\ I\end{bmatrix}\end{align}\]</span></p><p>在本例中<span class="math inline">\(N=\begin{bmatrix}  -2&amp;2  \\0&amp;-2  \\ 1&amp;0  \\ 0&amp;1\end{bmatrix}\)</span>，与上面求得的两个<spanclass="math inline">\(x\)</span>特解一致。</p><p>主元的概念是消元带来的，而消元过程中挖掘的实际上就是行、列的线性相关性。</p><p><strong>总结：<span class="math inline">\(A\)</span> 的主元个数 =<span class="math inline">\(A\)</span> 矩阵线性无关的列的个数 = <spanclass="math inline">\(A^T\)</span> 矩阵线性无关的行的个数 = <spanclass="math inline">\(A^T\)</span> 的主元个数。</strong></p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(六)——列空间和零空间</title>
    <link href="/2022/05/03/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AD)%E2%80%94%E2%80%94%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/05/03/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AD)%E2%80%94%E2%80%94%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>这一讲主要介绍了<strong>列空间</strong>和<strong>零空间</strong>。二者都是四个基本子空间的重要成员。</p><span id="more"></span><h1 id="列空间和零空间">列空间和零空间</h1><h2 id="子空间的并和交">子空间的并和交</h2><p>某向量空间的两个子空间<span class="math inline">\(P\)</span>和<spanclass="math inline">\(L\)</span>，它们的并（<spanclass="math inline">\(P\cup L\)</span>）不一定是子空间，但它们的交(<spanclass="math inline">\(P\capL\)</span>)一定是子空间，这一点是显而易见的。</p><h2 id="列空间大小">列空间大小</h2><p><span class="math display">\[\begin{bmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1(n-1)} &amp; a_{1n}\\ a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2(n-1)} &amp; a_{2n}\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots\\ a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{m(n-1)} &amp; a_{mn}\end{bmatrix}\cdot\begin{bmatrix}x_{1}\\ x_{2}\\ \vdots\\ x_{n-1}\\ x_{n}\end{bmatrix}=\begin{bmatrix}b_{1}\\ b_{2}\\ \vdots\\ b_{m}\end{bmatrix}\]</span></p><p>矩阵<spanclass="math inline">\(A\)</span>的列空间是由它的各列线性组合构成。在探究列空间的大小时，又将回到这个问题：<spanclass="math inline">\(Ax=b\)</span>是否对任意的<spanclass="math inline">\(b\)</span>都有解？或者说，什么样的<spanclass="math inline">\(b\)</span>方程组才有解？</p><p>从列空间的视角出发，这一问题有更加具象的回答方式：<strong><spanclass="math inline">\(Ax=b\)</span>有解，当且仅当<spanclass="math inline">\(b\)</span>属于<spanclass="math inline">\(A\)</span>的列空间。只有当<spanclass="math inline">\(b\)</span>是<spanclass="math inline">\(A\)</span>各列的线性组合时，<spanclass="math inline">\(Ax=b\)</span>才有解。</strong></p><p>因此，矩阵列空间的大小实际上与各列的线性无关性有关系，越多的列线性无关，那么它们能构成的列空间就越大，越多的列线性相关，那么其中相关的那一部分对列空间的构建就毫无贡献。</p><h2 id="零空间">零空间</h2><p>零空间由让<span class="math inline">\(Ax=0\)</span>成立的所有<spanclass="math inline">\(x\)</span>组成。显然，零空间包含零向量，而零空间本身也是向量空间（满足矩阵加法与数乘的封闭性）。</p><blockquote><p>特别注意：零空间不是零向量空间，零向量空间只包含一个零向量，本质上是<spanclass="math inline">\(R^0\)</span>，零空间是一种子空间，可以包含无数个向量。</p></blockquote><p>如果<span class="math inline">\(b\not=0\)</span>，那么对于<spanclass="math inline">\(x\)</span>的求解是否能够找到一种向量空间呢？显然答案是不能，因为若 <spanclass="math inline">\(b\not=0\)</span>，那么<spanclass="math inline">\(x\)</span>就不可能等于<spanclass="math inline">\(0\)</span>，这就意味着如果要形成向量空间，那么是不包含零向量的，显然这违背了我们此前的推论：向量空间必然包含零向量。因此，解集并不能构成一个向量空间。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(五)——转置、置换和向量空间R</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%94)%E2%80%94%E2%80%94%E8%BD%AC%E7%BD%AE%E3%80%81%E7%BD%AE%E6%8D%A2%E5%92%8C%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%94)%E2%80%94%E2%80%94%E8%BD%AC%E7%BD%AE%E3%80%81%E7%BD%AE%E6%8D%A2%E5%92%8C%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R/</url>
    
    <content type="html"><![CDATA[<p>这一讲内容包括转置、置换和向量空间<spanclass="math inline">\(R\)</span>，实际上是基于<spanclass="math inline">\(A=LU\)</span>的剖解提纲挈领，形而上学，引出线性代数的核心内容——向量空间。</p><span id="more"></span><h1 id="转置置换和向量空间r">转置、置换和向量空间R</h1><p>对于可逆矩阵<spanclass="math inline">\(A\)</span>，在消元过程中可能会遇到主元为0的情况，此时就需要进行行变换，而行变换的本质实际上就是左乘一个置换矩阵<spanclass="math inline">\(P\)</span>而已。上一讲中已经讲过了置换矩阵<spanclass="math inline">\(P\)</span>，当它左乘矩阵<spanclass="math inline">\(A\)</span>时，从行视角来看实际上就是对<spanclass="math inline">\(A\)</span>的行进行交换。当行变换找到新的不为0的主元时，消元得以继续进行。</p><h2 id="对称矩阵">对称矩阵</h2><p>转置以后矩阵没有发生变化的矩阵，称为对称矩阵，即<spanclass="math inline">\(A^T=A\)</span>，置换矩阵群中有4个就是对称矩阵。一种简单的生成对称矩阵的方法是：矩阵的转置和矩阵自身相乘<spanclass="math inline">\((R^TR)\)</span>。</p><p>证明如下： <span class="math display">\[(R^TR)^T = R^T(R^T)^T = R^TR\]</span></p><p>显然，矩阵<spanclass="math inline">\(R\)</span>转置后再转置就是本体，因此上式成立。</p><h2 id="向量空间">向量空间</h2><p>何为向量空间： 1. 必须通过原点。 2.向量空间必须对数乘和加法两种运算是封闭的，亦即对线性组合封闭。</p><blockquote><p>所谓封闭，就是说任意向量的数乘、求和运算得到的向量也在该空间中。至于必须通过原点，这是显然的，如果不通过原点，那么空间不可能封闭。</p></blockquote><p>高维向量空间又包含各种低维的向量子空间。</p><h3 id="二维向量空间">二维向量空间</h3><p>对于<spanclass="math inline">\(R^2\)</span>来说，向量空间内的子空间可以轻易的枚举：</p><ul><li><span class="math inline">\(R^2\)</span>本身</li><li>任何过原点的直线</li><li>零向量空间(只包含零向量)</li></ul><h3 id="三维向量空间">三维向量空间</h3><p>进一步，对于<spanclass="math inline">\(R^3\)</span>来说，子空间就多了一个维度：</p><ul><li><span class="math inline">\(R^3\)</span>本身</li><li>任何过原点的直线</li><li>任何过原点的平面</li><li>零向量空间(只包含零向量)</li></ul><p>显然，<spanclass="math inline">\(R^2\)</span>的向量子空间是更高维度<spanclass="math inline">\(R^3\)</span>子空间的子集，以此类推。</p><p>那么矩阵是如何构建向量子空间的呢？显而易见的方法是通过枚举列向量来构造：即选取各列进行线性组合，所有线性组合的结果构成的就是一个特定的子空间，这个子空间一般称作矩阵的列空间，记为<spanclass="math inline">\(C(A)\)</span>，它也是矩阵4大重要子空间中的一个。</p><blockquote><p>这一讲主要是为了让大家先接受向量空间这一概念，因为线性代数的核心都是围绕着向量空间来描摹，如果不能在脑海中将矩阵投射成向量空间来理解，那么后续的课程也都无法真正掌握。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(四)——A的LU分解</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%9B%9B)%E2%80%94%E2%80%94A%E7%9A%84LU%E5%88%86%E8%A7%A3/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%9B%9B)%E2%80%94%E2%80%94A%E7%9A%84LU%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>本讲主要是围绕<span class="math inline">\(A\)</span>的<spanclass="math inline">\(LU\)</span>分解，深入展开矩阵乘法、逆与转置的关系。最后自然而然的引出了置换矩阵。</p><span id="more"></span><h1 id="a的lu分解"><span class="math inline">\(A\)</span>的<spanclass="math inline">\(LU\)</span>分解</h1><h2 id="ab的逆"><span class="math inline">\(AB\)</span>的逆</h2><p><span class="math inline">\(AB\)</span>如果有逆，那么其逆显然是<spanclass="math inline">\(B^{-1}A^{-1}\)</span>，因为有： <spanclass="math display">\[\begin{align}(AB)(B^{-1} A^{-1})=I\\ (B^{-1} A^{-1})(AB)=I\end{align}\]</span></p><p>根据结合律法则，我们把括号挪一下，俩俩结合成<spanclass="math inline">\(I\)</span>，上式一目了然。</p><h2 id="ab的转置"><span class="math inline">\(AB\)</span>的转置</h2><p>显然是<span class="math inline">\(B^TA^T\)</span>（用<spanclass="math inline">\(C\)</span>每个元素的求和分别计算即可证等），由此可见转置如果想要拆除括号，则内层矩阵的转置顺序要倒置。</p><h2 id="at的逆"><span class="math inline">\(A^T\)</span>的逆</h2><p>显然： <span class="math display">\[\begin{align}(AA^{-1})^T = I^T = I\\ (A^{-1})^TA^T = I\end{align}\]</span></p><p>因此<span class="math inline">\(A^T\)</span>的逆矩阵就是<spanclass="math inline">\((A^{-1})^T\)</span>，即<spanclass="math inline">\((A^T)^{-1}=(A^{-1})^T\)</span>。</p><h2 id="alu和eau的关系"><span class="math inline">\(A=LU\)</span>和<spanclass="math inline">\(EA=U\)</span>的关系</h2><p>通过不断的左乘，可以让矩阵<spanclass="math inline">\(A\)</span>变换为<spanclass="math inline">\(U\)</span>，而只需要在乘法两边同时做乘<spanclass="math inline">\(E^{-1}\)</span>，就会得到<spanclass="math inline">\(A=E^{-1}U\)</span>，显然，<spanclass="math inline">\(L\)</span>和<spanclass="math inline">\(U\)</span>互为逆矩阵，<spanclass="math inline">\(U\)</span>是一个上三角，而<spanclass="math inline">\(L\)</span>则是一个下三角。</p><p>将<span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(A\)</span>变换为<spanclass="math inline">\(LU\)</span>需要的计算量也很好估计，时间复杂度为<spanclass="math inline">\(O(n^2+(n-1)^2+\dots+2^2+1^2)\)</span>，平方和相加我们初中就知道它等于<spanclass="math inline">\(O(\frac{n^3}{3})\)</span>。</p><h2 id="置换矩阵">置换矩阵</h2><p>3阶置换矩阵有6个： <span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\end{bmatrix}\]</span></p><p>这6个置换矩阵组成了一个很有意思的矩阵群，它们有非常有意思的性质：置换矩阵的逆等于其转置，这一点非常好理解，相当于被交换的列又再次被交换回来。</p><p><span class="math inline">\(n\)</span>阶方阵的置换矩阵有<spanclass="math inline">\(\binom{n}{1}=n!\)</span>个。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(三)——乘法和逆矩阵</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%89)%E2%80%94%E2%80%94%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%89)%E2%80%94%E2%80%94%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p>这一讲是对矩阵乘法和逆矩阵的深入说明。矩阵乘法主要介绍了按不同视角来理解的多种计算方式。逆矩阵则给出了求解非奇异矩阵的逆矩阵的方法。</p><span id="more"></span><h1 id="乘法和逆矩阵">乘法和逆矩阵</h1><h2 id="矩阵乘法的视觉意义">矩阵乘法的视觉意义</h2><p>矩阵乘法<span class="math inline">\(AB=C\)</span>，其中<spanclass="math inline">\(A\)</span>是<span class="math inline">\(m\timesn\)</span>阵，<span class="math inline">\(B\)</span>是<spanclass="math inline">\(n\times p\)</span>阵，我们知道得到的<spanclass="math inline">\(C\)</span>是一个<spanclass="math inline">\(m\times p\)</span>阵。对于<spanclass="math inline">\(C\)</span>中第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(j\)</span>列元素<spanclass="math inline">\(C_{ij}\)</span>。</p><p>从不同视角看矩阵乘法，我们可以给出不同的计算式：</p><h3 id="从每个元素的角度">从每个元素的角度</h3><p>有： <span class="math display">\[c_{ij}=row_i\cdot column_j = \sum_{k=i}^na_{ik}b_{kj}\]</span></p><p>其中<span class="math inline">\(a_{ik}\)</span>是矩阵<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(k\)</span>列元素，<spanclass="math inline">\(b_{kj}\)</span>是<spanclass="math inline">\(B\)</span>矩阵第<spanclass="math inline">\(k\)</span>行第<spanclass="math inline">\(j\)</span>列元素。 <spanclass="math inline">\(c_{ij}\)</span>可以看成是<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行乘以<spanclass="math inline">\(B\)</span>的第<spanclass="math inline">\(j\)</span>列。</p><h3 id="列的线性组合">列的线性组合</h3><p>从列的角度看，<span class="math inline">\(C\)</span>的各列是<spanclass="math inline">\(A\)</span>中各列的线性组合，组合方式由<spanclass="math inline">\(B\)</span>来确定。比如<spanclass="math inline">\(C\)</span>的第一列是 <spanclass="math inline">\(A\)</span>中各列相对于<spanclass="math inline">\(B\)</span>的第一列的一个线性组合。</p><p><span class="math display">\[\begin{bmatrix}&amp;&amp;\\ A_{col1}&amp;A_{col2}&amp;\cdots&amp;A_{coln}\\ &amp;&amp;\end{bmatrix}\begin{bmatrix}\cdots&amp;b_{1j}&amp;\cdots\\ \cdots&amp;b_{2j}&amp;\cdots\\ \cdots&amp;\vdots&amp;\cdots\\ \cdots&amp;b_{nj}&amp;\cdots\\ \end{bmatrix}=\begin{bmatrix}&amp;&amp;\\\cdots&amp;\left(b_{1j}A_{col1}+b_{2j}A_{col2}+\cdots+b_{nj}A_{coln}\right)&amp;\cdots\\ &amp;&amp;\end{bmatrix}\]</span></p><p>上面的运算为<span class="math inline">\(B\)</span>的第<spanclass="math inline">\(j\)</span>个列向量右乘矩阵<spanclass="math inline">\(A\)</span>，求得的结果就是<spanclass="math inline">\(C\)</span>矩阵的第<spanclass="math inline">\(j\)</span>列，即<spanclass="math inline">\(C\)</span>的第<spanclass="math inline">\(j\)</span>列是<spanclass="math inline">\(A\)</span>的列向量以<spanclass="math inline">\(B\)</span>的第<spanclass="math inline">\(j\)</span>列作为系数所求得的线性组合，<spanclass="math inline">\(C_j=b_{1j}A_{col1}+b_{2j}A_{col2}+\cdots+b_{nj}A_{coln}\)</span>。</p><h3 id="行的线性组合">行的线性组合</h3><p><span class="math inline">\(C\)</span>的各行是<spanclass="math inline">\(B\)</span>中各行的一个线性组合，组合方式由<spanclass="math inline">\(A\)</span>决定。比如<spanclass="math inline">\(C\)</span>的第一行是<spanclass="math inline">\(B\)</span>中各行相对于<spanclass="math inline">\(A\)</span>的第一行的一个线性组合。</p><p><span class="math display">\[\begin{bmatrix}\vdots&amp;\vdots&amp;\vdots&amp;\vdots\\ a_{i1}&amp;a_{i2}&amp;\cdots&amp;a_{in}\\ \vdots&amp;\vdots&amp;\vdots&amp;\vdots\end{bmatrix}\begin{bmatrix}&amp;B_{row1}&amp;\\ &amp;B_{row2}&amp;\\ &amp;\vdots&amp;\\ &amp;B_{rown}&amp;\end{bmatrix}=\begin{bmatrix}\vdots\\ \left(a_{i1}B_{row1}+a_{i2}B_{row2}+\cdots+a_{in}B_{rown}\right)\\ \vdots\end{bmatrix}\]</span></p><p>上面的运算为<span class="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>个行向量左乘矩阵<spanclass="math inline">\(B\)</span>，求得的结果就是<spanclass="math inline">\(C\)</span>矩阵的第<spanclass="math inline">\(i\)</span>行，即<spanclass="math inline">\(C\)</span>的第<spanclass="math inline">\(i\)</span>行是<spanclass="math inline">\(B\)</span>的行向量以<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行作为系数所求的的线性组合，<spanclass="math inline">\(C_i=a_{i1}B_{row1}+a_{i2}B_{row2}+\cdots+a_{in}B_{rown}\)</span>。</p><h3 id="从矩阵的角度看">从矩阵的角度看</h3><p><span class="math inline">\(A\)</span>的列乘以<spanclass="math inline">\(B\)</span>的行： <span class="math display">\[\begin{bmatrix}&amp;&amp;\\ A_{col1}&amp;A_{col2}&amp;\cdots&amp;A_{coln}\\ &amp;&amp;\end{bmatrix}\begin{bmatrix}&amp;B_{row1}&amp;\\ &amp;B_{row2}&amp;\\ &amp;\vdots&amp;\\ &amp;B_{rown}&amp;\end{bmatrix}=A_{col1}B_{row1}+A_{col2}B_{row2}+\cdots+A_{coln}B_{rown}\]</span></p><p><span class="math inline">\(A_{coli}B_{rowi}\)</span>是一个<spanclass="math inline">\(m\times 1\)</span>向量乘以一个<spanclass="math inline">\(1\times p\)</span>向量，其结果是一个<spanclass="math inline">\(m\times p\)</span>矩阵，而所有的<spanclass="math inline">\(m\times p\)</span>矩阵之和就是计算结果。</p><h3 id="分块来看">分块来看</h3><p><span class="math display">\[\left[\begin{array}{c|c}A_1&amp;A_2\\ \hlineA_3&amp;A_4\end{array}\right]\left[\begin{array}{c|c}B_1&amp;B_2\\\hlineB_3&amp;B_4\end{array}\right]=\left[\begin{array}{c|c}A_1B_1+A_2B_3&amp;A_1B_2+A_2B_4\\\hline A_3B_1+A_4B_3&amp;A_3B_2+A_4B_4\end{array}\right]\]</span></p><p>简写成： <span class="math display">\[\left[\begin{array}{c|c}A_1&amp;A_2\\ \hlineA_3&amp;A_4\end{array}\right]\left[\begin{array}{c|c}B_1&amp;B_2\\\hlineB_3&amp;B_4\end{array}\right]=\left[\begin{array}{c|c}C_1&amp;C_2\\\hline C_3&amp;C_4\end{array}\right]\]</span></p><p>可以看到 矩阵完全可以拆成多个块，各块的关联关系也一目了然。</p><h2 id="逆矩阵">逆矩阵</h2><p>逆矩阵分为左逆和右逆，不是所有方阵都可逆，对于方阵来说，左逆和右逆是相等的。</p><p>对这些有逆的矩阵，我们称其为可逆的或非奇异的。</p><p>如何判断一个矩阵是可逆的？从列图像来看，如果<spanclass="math inline">\(A^{-1}\)</span>存在，那么有<spanclass="math inline">\(AA^{-1}=I\)</span>，如果<spanclass="math inline">\(A\)</span>中各列无法线性组合成单位阵，则矩阵不可逆。相反，如果可以找到非零向量<spanclass="math inline">\(x\)</span>使得<spanclass="math inline">\(Ax=0\)</span>有解，那么<spanclass="math inline">\(A\)</span>也是不可逆的（某些列是相关的，反证法非常容易求证）。</p><p>那么如何求解一个逆矩阵呢？可以采用高斯-若尔当思想：构造这样一个增广矩阵： <spanclass="math inline">\(\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\\2&amp;7&amp;0&amp;1\end{array}\right]\)</span>，</p><p>右侧补充一个单位阵<spanclass="math inline">\(I\)</span>，接下来用消元法将左侧变为单位矩阵：</p><p><span class="math display">\[\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\\2&amp;7&amp;0&amp;1\end{array}\right]\xrightarrow{row_2-2row_1}\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\\0&amp;1&amp;-2&amp;1\end{array}\right]\xrightarrow{row_1-3row_2}\left[\begin{array}{cc|cc}1&amp;0&amp;7&amp;-3\\0&amp;1&amp;-2&amp;1\end{array}\right]\]</span></p><p>于是，我们就将矩阵从<spanclass="math inline">\(\left[\begin{array}{c|c}A&amp;I\end{array}\right]\)</span>变为<spanclass="math inline">\(\left[\begin{array}{c|c}I&amp;A^{-1}\end{array}\right]\)</span></p><p>而高斯-若尔当思想的本质是使用消元矩阵<spanclass="math inline">\(E\)</span>，对<spanclass="math inline">\(A\)</span>进行操作，<spanclass="math inline">\(E\left[\begin{array}{c|c}A&amp;I\end{array}\right]\)</span>，利用一步步消元有<spanclass="math inline">\(EA=I\)</span>，进而得到<spanclass="math inline">\(\left[\begin{array}{c|c}I&amp;E\end{array}\right]\)</span>，其实这个消元矩阵<spanclass="math inline">\(E\)</span>就是<spanclass="math inline">\(A^{-1}\)</span>，而高斯-若尔当法中的<spanclass="math inline">\(I\)</span>只是负责记录消元的每一步操作，待消元完成，逆矩阵就自然出现了。</p><p><strong>结论：如果矩阵可以通过行变换变成<spanclass="math inline">\(I\)</span>，那么矩阵就是可逆的。</strong></p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(二)——矩阵消元</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83/</url>
    
    <content type="html"><![CDATA[<p>高斯消元法是如今小学生都耳熟能详的解决齐次线性方程组的方法，课程第二讲主要讲授了高斯消元法应用在矩阵上的视觉效果与解读。</p><span id="more"></span><h1 id="矩阵消元">矩阵消元</h1><h2 id="非矩阵视角的消元">非矩阵视角的消元</h2><p>有三元方程组： <spanclass="math inline">\(\begin{cases}  x&amp;+2y&amp;+z&amp;=2  \\3x&amp;+8y&amp;+z&amp;=12  \\&amp;4y&amp;+z&amp;=2  \end{cases}\)</span></p><p>如果我们想通过消元法来解决，那么一般是考虑选中其中的一行，乘以某个系数对另外两行进行加法（系数为负就是减法）操作，以消除掉<spanclass="math inline">\(x\)</span>未知数，如此，后两个方程组就变成了二元一次方程组求解问题，而方法也是以此类推，用其中的一个消掉另一个的<spanclass="math inline">\(y\)</span>，最终剩下的那一行就只有<spanclass="math inline">\(z\)</span>了。在解出<spanclass="math inline">\(z\)</span>以后，再将<spanclass="math inline">\(z\)</span>回代到方程组，进而再解另外两个未知数<spanclass="math inline">\(x,y\)</span>。这种方法我们在小学的时候就已经掌握了。</p><h2 id="矩阵视角的消元">矩阵视角的消元</h2><p>方程组对应的矩阵形式<span class="math inline">\(Ax=b\)</span>为：<span class="math inline">\(\begin{bmatrix}  1&amp;2&amp;1  \\3&amp;8&amp;1  \\ 0&amp;4&amp;1  \end{bmatrix}\begin{bmatrix}  x  \\y  \\ z  \end{bmatrix}=\begin{bmatrix}  2  \\ 12  \\2\end{bmatrix}\)</span>。</p><p>实际上如果将消元的手法应用到矩阵上，本质上也并没有什么不同，从矩阵的视角来看，消元的第一步是选定第一行的第一个元素作为主元（对应<spanclass="math inline">\(x\)</span>系数），分别乘以不同的系数对第二、三行进行加法操作，进而消除掉第二、三行的首个元素。由于第三行原本首个元素就是0，故这里只需要对第二行操作：<spanclass="math inline">\(\begin{bmatrix}  \underline{1}&amp;2&amp;1  \\3&amp;8&amp;1  \\0&amp;4&amp;1\end{bmatrix}\xrightarrow{row_2-3row_1}\begin{bmatrix}  \underline{1}&amp;2&amp;1  \\0&amp;2&amp;-2  \\ 0&amp;4&amp;1\end{bmatrix}\)</span></p><p>这里暂时先不管对<spanclass="math inline">\(b\)</span>的影响（实际上也要跟着变化），矩阵<spanclass="math inline">\(A\)</span>经过消元变成了这个样子。</p><p>接下来，我们如法炮制，选择第二行的第二个元素(对应<spanclass="math inline">\(y\)</span>系数)作为主元，对第三行进行消元动作：<spanclass="math inline">\(\begin{bmatrix}  \underline{1}&amp;2&amp;1  \\0&amp;\underline{2}&amp;-2  \\0&amp;4&amp;1\end{bmatrix}\xrightarrow{row_3-2row_2}\begin{bmatrix}\underline{1}&amp;2&amp;1  \\0&amp;\underline{2}&amp;-2  \\0&amp;0&amp;\underline{5}\end{bmatrix}\)</span></p><p>到此，消元动作结束，最后一行仅剩<spanclass="math inline">\(z\)</span>的系数，即第三个元素5。</p><p>上例的矩阵是精心设计的，实际上消元过程中可能会遇到一些失效的情形：首先主元不能为0，为0的主元无论乘上什么样的系数都无法消除其他行的对应列。其次，如果消元过程中遇到主元位置为0，则需要交换行，使主元不为0。</p><p>消元结束后，我们就可以进行回代，由于方程组在矩阵消元时发生了变化，我们需要对<spanclass="math inline">\(b\)</span>也进行相同的操作以同步这些变化，如此我们写成下面的增广矩阵形式：<span class="math display">\[\left[\begin{array}{c|c}A&amp;b\end{array}\right]=\left[\begin{array}{ccc|c}  1&amp;2&amp;1&amp;2  \\ 3&amp;8&amp;1&amp;12  \\ 0&amp;4&amp;1&amp;2  \end{array}\right]\to\left[\begin{array}{ccc|c}1&amp;2&amp;1&amp;2\\ 0&amp;2&amp;-2&amp;6\\ 0&amp;4&amp;1&amp;2\end{array}\right]\to\left[\begin{array}{ccc|c}1&amp;2&amp;1&amp;2\\ 0&amp;2&amp;-2&amp;6\\ 0&amp;0&amp;5&amp;-10\end{array}\right]\]</span></p><p>此时方程组变为：<spanclass="math inline">\(\begin{cases}x&amp;+2y&amp;+z&amp;=2\\&amp;2y&amp;-2z&amp;=6\\&amp;&amp;5z&amp;=-10\end{cases}\)</span>，最后一行可以得出<spanclass="math inline">\(z=-2\)</span>，回代到<spanclass="math inline">\(2y-2z=6\)</span>得到<spanclass="math inline">\(y=1\)</span>，再进一步得到<spanclass="math inline">\(x=2\)</span>。</p><blockquote><p>可以用这里的方程组和我们小学时学到的消元法得到的方程组作对比，本质上完全一样。</p></blockquote><h2 id="矩阵消元的本质">矩阵消元的本质</h2><p>通过第一节课我们知道，对于矩阵乘法<spanclass="math inline">\(AB\)</span>可以看成是对矩阵<spanclass="math inline">\(B\)</span>中行按<spanclass="math inline">\(A\)</span>中系数的线性组合，如果<spanclass="math inline">\(B\)</span>想要维持不变，那么<spanclass="math inline">\(A\)</span>就得是个单位矩阵<spanclass="math inline">\(I\)</span>: <spanclass="math inline">\(\begin{bmatrix}  1&amp;0&amp;0  \\0&amp;1&amp;0  \\ 0&amp;0&amp;1\end{bmatrix}\)</span>这个单位矩阵就相当于我们实数运算中的1，只不过在矩阵的世界，它长这个样子。</p><blockquote><p>单位阵的三行彼此换一换，就能得到一个置换矩阵群，这个东西很有意思，以后会讲到。</p></blockquote><p>于是我们还原一下消元的第一步操作：<spanclass="math inline">\(row_2-3row_1\)</span> <spanclass="math inline">\(\begin{bmatrix}  1&amp;0&amp;0  \\-3&amp;1&amp;0  \\0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}  1&amp;2&amp;1  \\3&amp;8&amp;1  \\0&amp;4&amp;1\end{bmatrix}=\begin{bmatrix}  1&amp;2&amp;1  \\0&amp;2&amp;-2  \\ 0&amp;4&amp;1\end{bmatrix}\)</span></p><p>这个消元矩阵我们记作<spanclass="math inline">\(E_{21}\)</span>，即将第二行第一个元素变为0。</p><p>同理，我们找到<spanclass="math inline">\(E_{32}\)</span>，将第三行第二个元素变为0： <spanclass="math inline">\(\begin{bmatrix}  1&amp;0&amp;0  \\0&amp;1&amp;0  \\0&amp;-2&amp;1  \end{bmatrix}\begin{bmatrix}  1&amp;2&amp;1  \\0&amp;2&amp;-2  \\0&amp;4&amp;1\end{bmatrix}=\begin{bmatrix}  1&amp;2&amp;1  \\0&amp;2&amp;-2  \\ 0&amp;0&amp;5\end{bmatrix}\)</span></p><p><span class="math inline">\(E_{21}\)</span>和<spanclass="math inline">\(E_{32}\)</span>就是消元过程中用到的两个初等矩阵。</p><p>最后，我们将两步综合起来，即<spanclass="math inline">\(E_{32}(E_{21}A)=U\)</span>。矩阵的乘法是满足结合律的，所以这里的括号可以移动一下，即<spanclass="math inline">\((E_{32}E_{21})A=U\)</span>，这里的<spanclass="math inline">\(U\)</span>表示upper，即上三角矩阵（对角线下面的元素全都是0）。</p><h2 id="逆">逆</h2><p>如此，我们可以通过对<spanclass="math inline">\(A\)</span>做行变换得到<spanclass="math inline">\(U\)</span>，那么显然，如果要从<spanclass="math inline">\(U\)</span>变回<spanclass="math inline">\(A\)</span>我们只需要再反向操作一波即可，比如<spanclass="math inline">\(E_{21}\)</span>是从第二行减去三倍的第一行，那么它的反向操作就应该是第二行加上3倍的第一行，所以其逆矩阵就应该是<spanclass="math inline">\(\begin{bmatrix}1&amp;0&amp;0\\ 3&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix}\)</span>。</p><p>我们把矩阵<span class="math inline">\(E\)</span>的逆记作<spanclass="math inline">\(E^{-1}\)</span>，显然有<spanclass="math inline">\(E^{-1}E=I\)</span>，从行变换意义上来看，单位阵<spanclass="math inline">\(I\)</span>乘以<spanclass="math inline">\(A\)</span>相当于什么都没有改变，也就是二者抵消后的结果。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(一)——方程组的几何解释</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E2%80%94%E2%80%94%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E2%80%94%E2%80%94%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<p>开篇第一讲主要通过线性方程组引出矩阵，并传授了如何通过<strong>行图像</strong>和<strong>列图像</strong>来分别理解矩阵的意义。最后基于列的线性组合视角来初步解答了这样的一个问题：对任意向量<spanclass="math inline">\(b\)</span>，能否求解<spanclass="math inline">\(Ax=b\)</span>。</p><span id="more"></span><h1 id="方程组的几何解释">方程组的几何解释</h1><h2 id="二元一次方程组">二元一次方程组</h2><p>方程组： <span class="math inline">\(\begin{cases}  2x&amp;-y&amp;=0\\  -x&amp;+2y&amp;=3 \end{cases}\)</span></p><p>写作矩阵形式有： <spanclass="math inline">\(\begin{bmatrix}  2&amp;-1 \\  -1&amp;2\end{bmatrix} \begin{bmatrix}  x \\  y \end{bmatrix}= \begin{bmatrix} 0\\ 3 \end{bmatrix}\)</span></p><p>第一个矩阵一般称为系数矩阵<spanclass="math inline">\(A\)</span>，第二个矩阵成为向量<spanclass="math inline">\(x\)</span>，第三个矩阵称为向量<spanclass="math inline">\(b\)</span>，线性方程组写为<spanclass="math inline">\(Ax=b\)</span>。</p><h2 id="行图像row-picture">行图像(Row picture)</h2><p>如上例，按行解读如下：</p><ul><li>第一行为2个x和-1个y组合成0</li><li>第二行为-1个x和2个y组合成3</li></ul><p>这种解读与我们此前对二元一次方程组的解读方法是一致的，我们都知道，二元一次方程组实际上就是求解二维平面两条直线的交点：<img src="2022-05-02-12-15-37.png" /></p><p>交点坐标为<span class="math inline">\((1,2)\)</span>，即<spanclass="math inline">\(x=1, y=2\)</span>为方程组的解。</p><h2 id="列图像column-picture">列图像(Column picture)</h2><p>那么，如果我们换一个视角呢？我们把矩阵<spanclass="math inline">\(A\)</span>拆成列向量，进行如下线性组合： <spanclass="math inline">\(x \begin{bmatrix}  2 \\  -1 \end{bmatrix}+y\begin{bmatrix} -1 \\ 2 \end{bmatrix}= \begin{bmatrix} 0 \\ 3\end{bmatrix}\)</span></p><p>那么就可以解读为<span class="math inline">\(x\)</span>个<spanclass="math inline">\(col_1\)</span>和<spanclass="math inline">\(y\)</span>个<spanclass="math inline">\(col_2\)</span>的组合，其中<spanclass="math inline">\(\begin{bmatrix}2\\-1\end{bmatrix}\)</span>称为<spanclass="math inline">\(col_1\)</span>，<spanclass="math inline">\(\begin{bmatrix}-1\\2\end{bmatrix}\)</span>称为<spanclass="math inline">\(col_2\)</span>。</p><p>肉眼观察就可以看出，需要1个<spanclass="math inline">\(col_1\)</span>和2个<spanclass="math inline">\(col_2\)</span>，组合起来就可以变成<spanclass="math inline">\(\begin{bmatrix}0\\3\end{bmatrix}\)</span>。因此同样得出<spanclass="math inline">\(x=1, y=2\)</span>。</p><p>列向量相加的几何意义： <img src="2022-05-02-13-01-08.png" /></p><p>绿向量<span class="math inline">\(col_1\)</span>与蓝向量<spanclass="math inline">\(col_2\)</span>相加，按照平行四边形法则，合成的就是红向量<spanclass="math inline">\(b\)</span>。</p><p>进一步思考<span class="math inline">\(col_1\)</span>和<spanclass="math inline">\(col_2\)</span>的所有线性组合能够得到什么呢？显然它们可以铺满整个二维平面。那么<spanclass="math inline">\(Ax=b\)</span>如果按照列的线性组合来看，<strong>求解<spanclass="math inline">\(Ax=b\)</span>实际上就是在问询对于给定的<spanclass="math inline">\(b\)</span>，是否能够找到一种组合方式来让<spanclass="math inline">\(A\)</span>中各列向量<spanclass="math inline">\(col_i\)</span>可以组合成列向量<spanclass="math inline">\(b\)</span>。</strong></p><h2 id="三元一次方程组">三元一次方程组</h2><p><span class="math inline">\(\begin{cases}  2x&amp;-y&amp;&amp;=0\\  -x&amp;+2y&amp;-z&amp;=-1 \\  &amp;-3y&amp;+4z&amp;=4\end{cases}\)</span></p><p>写作矩阵形式： <span class="math inline">\(A=\begin{bmatrix}2&amp;-1&amp;0 \\ -1&amp;2&amp;-1 \\ 0&amp;-3&amp;4\end{bmatrix}\)</span>,<span class="math inline">\(b=\begin{bmatrix} 0\\ -1 \\ 4 \end{bmatrix}\)</span></p><p>如果按行图像来思考：三维直角坐标系中，每个方程都将确定一个平面，三个平面会相交于一点，该点即为方程组的解。</p><p>如果按列图像来思考，拆写成： <spanclass="math inline">\(x\begin{bmatrix} 2 \\ -1 \\ 0\end{bmatrix}+y\begin{bmatrix} -1 \\  2 \\-3\end{bmatrix}+z\begin{bmatrix} 0 \\ -1 \\4\end{bmatrix}=\begin{bmatrix} 0 \\ -1 \\ 4\end{bmatrix}\)</span></p><p>也就是<span class="math inline">\(x\)</span>个<spanclass="math inline">\(col_1\)</span>，<spanclass="math inline">\(y\)</span>个<spanclass="math inline">\(col_2\)</span>和<spanclass="math inline">\(z\)</span>个<spanclass="math inline">\(col_3\)</span>线性组合成列向量<spanclass="math inline">\(b\)</span>。通过列视角来看这个方程组的解非常显然，只需要<spanclass="math inline">\(x=0,y=0,z=1\)</span>即可满足（<spanclass="math inline">\(z\)</span>刚好等于<spanclass="math inline">\(b\)</span>），而从行视角来看就没有那么一目了然。</p><blockquote><p>当然了，这是精心构造的一组例子，并不是说列视角就比行视角优越，只是培养列视角分析问题的sense对线性代数这门课（我觉着更像一门语言）来说非常重要。</p></blockquote><p>那么问题又回来了，对于任意<spanclass="math inline">\(b\)</span>，是否都能求解<spanclass="math inline">\(Ax=b\)</span>呢？用列向量视角来说，就是<spanclass="math inline">\(col_1,col_2,col_3\)</span>三个列向量的线性组合是否可以填满整个三维坐标系？对上例来说，答案是肯定的。因为实际上这个<spanclass="math inline">\(A\)</span>矩阵是个<strong>非奇异矩阵、可逆矩阵</strong>（后续课程会讲到），对于任意的列向量<spanclass="math inline">\(b\)</span>，它总是有解的。</p><p>那么在什么情况下，三个列向量的组合得不到所有的<spanclass="math inline">\(b\)</span>呢？试想这样一种情况：三个列向量在同一平面，那么无论它们如何组合，产生的列向量也一定在该平面上，因此，对于不在该平面的列向量<spanclass="math inline">\(b\)</span>，方程组就是无解的。后续课程会学习到这种情况叫做<strong>奇异矩阵、不可逆矩阵</strong>。</p><p>人类的大脑是三维的，所以四维以上的空间是无法具象化的，但是我们从二维到三维，和从三维到更高维的过程实际上并没有什么差别，因此，通过列视角的线性组合，哪怕是100维的向量，思考与处理也如法炮制。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>楔子</title>
    <link href="/2022/05/01/%E6%A5%94%E5%AD%90/"/>
    <url>/2022/05/01/%E6%A5%94%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>上次折腾博客还是醉心于binarysecurity的时节，如今却是弃之如敝履。彼时彼刻，正如此时此刻，何移之速也！</p><p>互联网变化之快让人越来越浮躁，工作越久、越难以静下心来去专研某个领域的知识，不学无术就愈发膨胀，一点点丧失核心竞争力，最后与前沿脱轨，熬成药渣，泄入深渊。我不知道一个人应该如何消化掉鸡飞蛋打、毫无成就的日常工作的挫败感和996福报带来的身心俱疲，只是入行这么多年，的的确确是弄丢了意气风发、快意恩仇，满脑子想的尽是冠冕堂皇的不粘锅、踢皮球，冰与火，周旋久。</p><span id="more"></span><p>用如今的流行梗来说：小僧没有那种世俗的欲望。“举世誉之而不加劝，举世非之而不加沮。不以物喜，不以己悲。”秉承着这样的人生信条，靠物我两忘屏蔽了职场所有的画饼和PUA，也接受了“是岁年大旱，衢州人食人”的魔幻与惨案，甚至乐在其中。坦白来说，我不红眼那些蹭上时代红利的既得利益者，也不在乎能不能坐上位高权重的玉座，毕生所求不过自由，而自由其实并不意味着“想做什么就可以做什么”，而是“不想做什么，就可以不做”。壁立千仞，无欲则刚。</p><p>这么多年过去，扪心自问这一身本领从何而来，只道是“年少轻狂不服气，万千道法书中藏。穷经皓首等闲事，千锤百炼证沧桑。”算来前前后后，一共经历了三重心境上的变化：</p><ol type="1"><li>待到秋来九月八，我花开后百花杀：以前觉着自己得天独厚，是故事的主角，只要是自己想做的，一定可以做到最好。因此接受不了自己的平庸，拼尽全力证明自己。</li><li>横看成岭侧成峰，远近高低各不同：几经挫折后发现人确实有不同的天赋，我要找到自己擅长的领域，做到最好；不擅长的东西不要强求。</li><li>沉舟侧畔千帆过，病树前头万木春：终于认识到人与人的差距比人与狗的差距还大，强中自有强中手，一山更比一山高，逐渐接受了自己的平庸，与自己妥协，但心意却更加坚定。</li></ol><p>当认识到自己是一个废物的时候，就再也没有包袱了：没有必要和别人比较，我只想看看自己的天花板有多高。遂重整旗鼓，勤将劝勉，闭关清修……这回必定给大伙整个好活~</p><p>千头万绪，百感交集，不知从何说起，唯愿顺其自然，一切随缘。飘蓬入海沉浮定，马齿徒增未可知。</p><p align="right">by 玉涵，写于2022年5月1日深夜，雨</p>]]></content>
    
    
    <categories>
      
      <category>杂感</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
