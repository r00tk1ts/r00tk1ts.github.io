<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线性代数笔记(二十八)——正定矩阵和最小值</title>
    <link href="/2024/03/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E5%85%AB)%E2%80%94%E2%80%94%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <url>/2024/03/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E5%85%AB)%E2%80%94%E2%80%94%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>本节回归到实数域，重点讨论了正定矩阵这一主题，将之前所掌握的主元、行列式、特征值等知识联系起来，通过正定矩阵引出函数与矩阵之间的关系，介绍如何找到函数的最小值，并给出几何解释。</p><span id="more"></span><h1 id="正定矩阵和最小值">正定矩阵和最小值</h1><p>何为正定矩阵，先从2阶方阵入手，下面给出正定矩阵的4种判定法：</p><ol type="1"><li>特征值判定：两个特征值均为正数。即，<spanclass="math inline">\(\lambda_1 &gt; 0, \lambda_2 &gt; 0\)</span>。</li><li>行列式判定：<spanclass="math inline">\(a&gt;0,ac-b^2&gt;0\)</span>，即顺序主子式均为正值。</li><li>主元判定：主元皆为正数，即：<spanclass="math inline">\(a&gt;0,\frac{ac-b^2}{a} &gt; 0\)</span>。</li><li>判别式：<span class="math inline">\(x^TAx &gt; 0\)</span>。</li></ol><p>此外，正定矩阵都得是正定阵。</p><h2 id="二阶正定矩阵的探讨">二阶正定矩阵的探讨</h2><p>对于矩阵<span class="math inline">\(A=\begin{bmatrix}2&amp;6 \\6&amp;?\end{bmatrix}\)</span>，根据上述判定法的行列式判定法，我们知道，这里的<spanclass="math inline">\(?\)</span>处只要填上一个大于18的数，该矩阵就是正定的。</p><p>而如果正好填18进去，此时矩阵会变成一个奇异阵，它的行列式为0，只有一个主元2，特征值分别为0和20（由迹可以轻易算出）。对于这样的矩阵，我们可以成为半正定阵。</p><p>除了通过特征值、行列式和主元来判定，还可以用第四种判别式法来展开探讨：</p><p><span class="math display">\[x^TAx=\begin{bmatrix}x_1&amp;x_2\end{bmatrix}\begin{bmatrix}2&amp;6\\6&amp;18\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}=2x_1^2+12x_1x_2+18x_2^2\]</span></p><p>实际上这里的2,12,18就分别代表了a,2b和c。这是一个标准的二次型，没有线性项，那么根据判别式法，对于<spanclass="math inline">\(2x_1^2+12x_1x_2+18x_2^2\)</span>是否恒大于0呢？显然不是，因为在某种取值中，其结果可能恰好为0。</p><p>再来看看<span class="math inline">\(A\)</span>不是正定的情况：</p><p><span class="math display">\[x^TAx=\begin{bmatrix}x_1&amp;x_2\end{bmatrix}\begin{bmatrix}2&amp;6\\6&amp;7\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}=2x_1^2+12x_1x_2+7x_2^2\]</span></p><p>这一二次型呈现在坐标轴上是一个马鞍面：</p><p><img src="2024-03-09-17-41-17.png" /></p><p>从不同方向观察，它有着不同的性质，鞍点是某些方向的极值，但显然它不可能恒大于0。</p><p>而对于正定矩阵来说：</p><p><span class="math display">\[x^TAx=\begin{bmatrix}x_1&amp;x_2\end{bmatrix}\begin{bmatrix}2&amp;6\\6&amp;20\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}=2x_1^2+12x_1x_2+20x_2^2\]</span></p><p>它是一个开口始终朝上的二次型曲面，其最小值在原点取到，切面类似于二次函数曲线：</p><p><img src="2024-03-09-17-46-45.png" /></p><p>利用微积分的知识，我们可以知道对于<spanclass="math inline">\(f(x,y)=2x^2+12xy+20y^2\)</span>，原点处一阶偏导数为0，二阶偏导数为正可以知道原点处是极小值（在这里也是最小值），这是微积分的求最值方法，而对于线性代数来说，我们可以通过判定矩阵是否是正定阵，来得出函数是否有最小值。</p><p>将<span class="math inline">\(f(x,y)\)</span>配方：<spanclass="math inline">\(f(x,y)=2(x+3y)^2+2y^2\)</span>，显然，如果<spanclass="math inline">\(A\)</span>非正定，那么配方剩下的<spanclass="math inline">\(y^2\)</span>前的系数一定为负，而如果我们用<spanclass="math inline">\(f=1\)</span>这个平面来截取这个曲线，则得到的一定是个椭圆。</p><blockquote><p>实际上配方法反映到线性代数里就是消元： <imgsrc="2024-03-09-17-52-42.png" /></p></blockquote><h2 id="到n阶的推广">到n阶的推广</h2><p>微积分中我们求二阶偏导数极值时的<spanclass="math inline">\(f_{xx},f_{yy}\)</span>与<spanclass="math inline">\(f_{xy}^2\)</span>之间的关系也可以反映到矩阵的正定判定上，即二阶导数矩阵：</p><p><span class="math display">\[\begin{bmatrix}f_{xx} &amp; f_{xy} \\f_{yx} &amp; f_{yy}\end{bmatrix}\]</span></p><p>这里主对角线的两个元素都是某一个方向上的n阶导数(上例n=2)，为了存在极小值，它们必须为正。而函数的求导顺序不会改变结果，所以沿着对角线的元素天然是对称的(如上例的<spanclass="math inline">\(f_{xy}=f_{yx}\)</span>)。此外，微积分中求极小值时还要求<spanclass="math inline">\(f_{xx}*f_{yy} &gt;f_{xy}^2\)</span>，而这一点正与判定该矩阵是否为正定阵的方法不谋而合。</p><p><img src="2024-03-09-18-16-53.png" /></p><p>这一判断也可以推广到n维方阵。</p><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570107245&amp;p=28" scrolling="no" width="100%" height="500" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B28%5D%20%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B028.pdf">正定矩阵和最小值</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(二十七)——复数矩阵与FFT</title>
    <link href="/2024/03/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%B8%83)%E2%80%94%E2%80%94%E5%A4%8D%E6%95%B0%E7%9F%A9%E9%98%B5%E4%B8%8EFFT/"/>
    <url>/2024/03/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%B8%83)%E2%80%94%E2%80%94%E5%A4%8D%E6%95%B0%E7%9F%A9%E9%98%B5%E4%B8%8EFFT/</url>
    
    <content type="html"><![CDATA[<p>这一节延展到复数矩阵，介绍复数矩阵的运算特征，并介绍一个重要的复数矩阵：傅里叶矩阵。此外，还着重介绍了一种快速计算傅里叶变换的方法：快速傅里叶变换（FFT），它显著地降低了运算量。</p><span id="more"></span><h1 id="复数矩阵与fft">复数矩阵与FFT</h1><p>对于向量中的分量，如果包含虚数的话，很明显，针对实数域来计算长度内积的公式不再适用，我们需要对分量先取共轭，再转置相乘，才能避免谬误。</p><blockquote><p>比如<span class="math inline">\(\begin{bmatrix}1 \\i\end{bmatrix}\)</span>向量，传统的计算将得到模长为0，显然有误，它在两个方向上都有分量，实际长度应为<spanclass="math inline">\(\sqrt 2\)</span>。</p></blockquote><p>对复数向量<span class="math inline">\(\begin{bmatrix}z_1 \\ z_2 \\z_3 \\ ... \\ z_n\end{bmatrix}\)</span>，定义<spanclass="math inline">\(|z|^2=z^Hz=\bar z^Tz\)</span>。这里的<spanclass="math inline">\(H\)</span>表示Hermition，即共轭转置。复数向量的内积<spanclass="math inline">\(=y^Hx=\bar y^Tx\)</span>。</p><h2 id="对称阵">对称阵</h2><p>对于复数矩阵来说，对称阵的定义也要做类似的转变，联系上面内积的处理方法，复数矩阵中取共轭与转置往往是同步的，实际上，复数对称矩阵的定义也如法炮制：若<spanclass="math inline">\(\bar A^T=A\)</span>，则<spanclass="math inline">\(A\)</span>为对称阵。</p><p>例如，对于矩阵：</p><p><span class="math display">\[\begin{bmatrix}2 &amp; 3+i \\3-i &amp; 5\end{bmatrix}\]</span></p><p>主对角线上必须是实数，因为取共轭翻转后，元素不能变。沿着主对角线的元素必须共轭，因为相当于沿着对角线彼此互换了位置，取共轭互换前后元素要一致。上述的二阶复数矩阵就是一个对称矩阵，满足<spanclass="math inline">\(A^H=A\)</span>。它的特征值皆为实数，且特征向量彼此正交。</p><p>推广到特征向量正交这一概念，对一组复数向量<spanclass="math inline">\(q_1,q_2,...,q_n\)</span>，且<spanclass="math inline">\(\bar q_i^Tq_j=\left\{\begin{array}{rcl}0 &amp;i\neq j \\ 1 &amp; i = j\end{array}\right.\)</span>，它们是一组标准正交基。构成矩阵<spanclass="math inline">\(Q\)</span>，此时有<spanclass="math inline">\(Q^HQ=I\)</span>，这样的<spanclass="math inline">\(Q\)</span>矩阵被称为：酉矩阵。</p><h2 id="傅里叶变换">傅里叶变换</h2><p>傅里叶矩阵<spanclass="math inline">\(F_n\)</span>就是一个经典的酉矩阵：</p><p><span class="math display">\[F_n=\begin{bmatrix}1 &amp; 1 &amp; 1 &amp; ... &amp; 1 \\1 &amp; w &amp; w^2 &amp; ... &amp; w^{n-1} \\1 &amp; w^2 &amp; w^4 &amp; ... &amp; w^2{n-1} \\... &amp; ... &amp; ... &amp; ... &amp; ... \\1 &amp; w^{n-1} &amp; w^2{n-1} &amp; ... &amp; w^{(n-1)^2}\end{bmatrix}\]</span></p><p>其中<span class="math inline">\(w^n=1,w=e^{i2\pi /n}=cos(2\pi / n) +isin(2\pi / n)\)</span>。</p><p><img src="2024-03-09-15-38-43.png" /></p><p><spanclass="math inline">\(w\)</span>就反应在这个复数空间的单位圆上，<spanclass="math inline">\(n\)</span>就表示将圆等分成<spanclass="math inline">\(n\)</span>份，分别为:<spanclass="math inline">\(w,w^2...w^n\)</span>。</p><p>那么对于4阶傅里叶矩阵（也就是4等分）来说，此时<spanclass="math inline">\(w=e^{i2\pi /4}=i\)</span>:</p><p><span class="math display">\[F_4=\begin{bmatrix}1 &amp; 1 &amp; 1 &amp; 1 \\1 &amp; i &amp; -1 &amp; -i \\1 &amp; -1 &amp; 1 &amp; -1 \\1 &amp; -i &amp; -1 &amp; i\end{bmatrix}\]</span></p><p>显然，该矩阵各列向量彼此正交。还可以挖掘出其他有用的性质：<spanclass="math inline">\(F_4^HF_4=4I\)</span>。可以很方便的找到<spanclass="math inline">\(F_4\)</span>的逆。</p><h3 id="快速傅里叶变换">快速傅里叶变换</h3><p>我们发现对<spanclass="math inline">\(w\)</span>的幂运算实际上就是在单位元上转圈，那么推广到更高阶的傅里叶矩阵，我们还可以发现，高阶与低阶矩阵之间彼此也可以建立关联，<spanclass="math inline">\(F_6\)</span>和<spanclass="math inline">\(F_3\)</span>有着千丝万缕的联系，<spanclass="math inline">\(F_48\)</span>和<spanclass="math inline">\(F_4\)</span>有着联系，以此类推。具体以<spanclass="math inline">\(F_{64}\)</span>和<spanclass="math inline">\(F_{32}\)</span>为例，由于<spanclass="math inline">\(w_{32}=(w_{64})^2\)</span>，因此有：</p><p><span class="math display">\[\begin{bmatrix}F_{64}\end{bmatrix}=\begin{bmatrix}I &amp; D \\I &amp; -D\end{bmatrix}\begin{bmatrix}F_{32} &amp; 0 \\0 &amp; F_{32}\end{bmatrix}\begin{bmatrix}P\end{bmatrix}\]</span></p><p>置换矩阵<spanclass="math inline">\(P\)</span>分割奇偶行，对角矩阵<spanclass="math inline">\(D=\begin{bmatrix}1 \\ &amp; w \\ &amp; &amp; w^2\\ &amp; &amp; &amp; ... \\ &amp; &amp; &amp; &amp;w^{31}\end{bmatrix}\)</span>用来修正分割了奇偶行的矩阵，使其称为对角的两个<spanclass="math inline">\(F_32\)</span>的结构。</p><blockquote><p>以4阶矩阵为例，置换矩阵<span class="math inline">\(P=\begin{bmatrix}1&amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp;0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp;1\end{bmatrix}\)</span>，先陈列奇数行，再陈列偶数行。</p></blockquote><p>对角阵<span class="math inline">\(D\)</span>由<spanclass="math inline">\(w\)</span>的幂构成，可以通过验证发现，构造的左侧矩阵对奇偶行分割后的矩阵修成了<spanclass="math inline">\(F_{64}\)</span>。</p><blockquote><p>注：这里的证明比较麻烦，教授没有在课上给出，通过简单的<spanclass="math inline">\(F_6\)</span>和<spanclass="math inline">\(F_3\)</span>来验证发现确实正确。</p></blockquote><p>通过将64阶矩阵降级成32阶，我们大大节省了计算量，原本的64阶矩阵我们需要计算<spanclass="math inline">\(64*64\)</span>次，而经过FFT，则计算量简化到了<spanclass="math inline">\(2*32*32+32\)</span>次，加号前者是计算两个<spanclass="math inline">\(F_{32}\)</span>的计算量，而后者则是<spanclass="math inline">\(D\)</span>的计算量，一般称之为修正项的计算量。</p><p>32阶还可以继续降级成16阶，如此递归下去，可以进行<spanclass="math inline">\(\log_{2}{64}=6\)</span>次分解，最终只剩下修正量的计算。因此，最终的计算量即：<spanclass="math inline">\((n/2)\log_{2}{n}\)</span>次，随着<spanclass="math inline">\(n\)</span>的增大，对数时间复杂度所能起到的效果越显著。</p><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570104137&amp;p=27" scrolling="no" width="100%" height="500" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B27%5D%20%E5%A4%8D%E6%95%B0%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B027.pdf">复数矩阵与快速傅里叶变换</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++黑魔法系列之从optional到expected</title>
    <link href="/2024/02/01/C++%E9%BB%91%E9%AD%94%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BB%8Eoptional%E5%88%B0expected/"/>
    <url>/2024/02/01/C++%E9%BB%91%E9%AD%94%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BB%8Eoptional%E5%88%B0expected/</url>
    
    <content type="html"><![CDATA[<p>众所周知，想要在C++中写出通用的框架、组件代码并不简单，一来C++本身庞然大物包罗万象，大部分开发者并不了解像是”茴有四种写法“这种语言律师津津乐道的课题，对于晦涩难懂的模板元更是谈之色变，二来是历史悠久，在发展过程中为了向前兼容，遗留了各种特例特办的技术债，导致系统臃肿不堪。因此，尽管C++生态相当茂盛，但权威的第三方库却屈指可数（甚至其标准库都是风风雨雨缝缝补补，<del>偷得人家boost就剩个底裤</del>）。阅读优秀的开源代码是提升代码水平的捷径，本篇文章我们解读modernC++中常用的脚手架<code>std::optional</code>，并进阶到folly库所实现的更加强大的<code>folly::Expected</code>。</p><span id="more"></span><h1id="c黑魔法系列之从optional到expected">C++黑魔法系列之从optional到expected</h1><p>在日常编码过程中，我们经常会遇到这样一个问题：某些场景我们需要区分空值和默认值（一般是零值）。比如，对于一个返回值类型为<code>int</code>的函数，当值为0时，它的物理意义是什么，是真正的零值、还是代表了一种表达为空的属性（是否存在，是否有效等物理意义）？这是函数设计者需要结合实际场景来认真考虑的事。当然，二者的区分也不仅仅限定于某个语种，更不限定于函数的返回值。</p><h2 id="前菜protobuf的缺省与默认值">前菜：protobuf的缺省与默认值</h2><p>大名鼎鼎的protobuf协议便在这个问题上纠结了很久，从v2的required/optionaltag的强硬派重拳出击，比如协议：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// proto2</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> query = <span class="hljs-number">1</span>;                    # 必需<br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">int32</span> page_number = <span class="hljs-number">2</span> [default=<span class="hljs-number">0</span>];   # 可选，默认值为<span class="hljs-number">0</span>，有hasPageNumber() method<br>&#125;<br></code></pre></td></tr></table></figure><p>在proto2中，被标记为required的字段是必需品，而标记了optional的字段则是可缺省的，我们可以为其赋予默认值（比如page_number被显式地设置了一个默认值0）。每一个optional字段都会生成相应的<code>hasXXX</code>method桩代码，用以检查是否缺省。</p><blockquote><p>实际上proto2的序列化有坑，不论optional字段是真的缺省，还是被显式赋予了一个默认值，序列化以后这个信息都会被擦除，反序列化后，haxXXX总是返回false。归根结底是把默认值和缺省混为一谈了。</p></blockquote><blockquote><p>对proto2来说，若无显式设置默认值，则使用对应类型的零值做默认值，上例的page_number实际上不需要显式设置，这里只是为了演示才画蛇添足。</p></blockquote><p>在经历了大刀阔斧的升级后，v3干脆移除了required/optionaltag，所有的字段通通都是optional，但同时对于原始的基础类型，也不再生成<code>haxXXX</code>这样的桩代码。那么，对于上述协议：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// proto3</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-type">string</span> query = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int32</span> page_number = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>page_number是一个基础类型，我怎么区分page_number确实是0，还是压根没填呢？在损失了<code>hasXXX</code>方法后，我们只得另辟蹊径，一般来说，有两种迂回的办法：使用oneof嵌套，或是定义wrapper类型。前者是借助了oneof的特性，后者则是绕开了只对基础型移除<code>hasXXX</code>的限制。设计师面对上述两种黑魔法的大行其道，最终还是向用户妥协，自3.15版本起，protobuf又重新支持了optionaltag，此时就又可以像v2那样对page_number生成<code>hasXXX</code>的桩代码了。</p><p>摆上这样一道前菜只是为了热身，更多关于protobuf的内容就不在这里展开，以免喧宾夺主。</p><blockquote><p>v3的改革历来争议很大，核心争论点主要集中于required，详见stackoverflow高赞回答：https://stackoverflow.com/questions/31801257/why-required-and-optional-is-removed-in-protocol-buffers-3</p></blockquote><h2 id="函数的多返回值设计">函数的多返回值设计</h2><p>通过前面的热身我们不难发现，默认值与空值，根本就是两个维度上的事儿，protobuf的变革历程深刻地印证了这一点。那么，对于函数返回值的设计来说，也就意味着需要返回两个值，第一个是值对应的类型，第二个则是一个布尔，用来表示是否存在或者是否成功等等。</p><p>对于早期的编程语言，比如C，由于严格贯彻数学上函数的定义，返回值只能有一个，彼时，对于有多个返回值要求的场合，一般有两种解法：</p><ol type="1"><li>聚合多个返回值构建成新的struct</li><li>通过参数传入，也就是OUT型参数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// function 1</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">result</span> &#123;</span><br>  <span class="hljs-type">int</span> value;<br>  <span class="hljs-type">bool</span> exist;<br>&#125;;<br><br><span class="hljs-comment">// 此时还要注意返回指针的生命期问题</span><br><span class="hljs-keyword">struct</span> result* <span class="hljs-title function_">func1</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// ... &#125;</span><br><br><span class="hljs-comment">/// function 2</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">func2</span><span class="hljs-params">(<span class="hljs-type">bool</span> *exist)</span> &#123; <span class="hljs-comment">// ... &#125;</span><br></code></pre></td></tr></table></figure><p>这其中第二种解法比较有年代感，早期C标准库、linux内核代码常见这种设计，而WindowsSDK的CAPI则都是这种风格，甚至变本加厉，通过IN/OUT宏来标记参数去辅助接口的说明。比如，下面是Windows创建进程的CAPI（这个其实还算是相对清爽的）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">CreateProcessA</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in, optional]      LPCSTR                lpApplicationName,</span><br><span class="hljs-params">  [in, out, optional] LPSTR                 lpCommandLine,</span><br><span class="hljs-params">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="hljs-params">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="hljs-params">  [in]                BOOL                  bInheritHandles,</span><br><span class="hljs-params">  [in]                DWORD                 dwCreationFlags,</span><br><span class="hljs-params">  [in, optional]      LPVOID                lpEnvironment,</span><br><span class="hljs-params">  [in, optional]      LPCSTR                lpCurrentDirectory,</span><br><span class="hljs-params">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span><br><span class="hljs-params">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>而第一种方法则略显笨重，对于天生需要封装的结构体，这种设计是自然而然顺水推舟，但如果像是我们的需求，每次都把某种值类型和一个bool型封装成一个struct，那就显得太臃肿了。</p><p>现代的编程语言大多打破了函数只能有一个返回值的常规，最经典的比如go，它可以有任意多个返回值。因此，我们可以编写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>) &#123; <span class="hljs-comment">// ... &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    value, exist := func3()<br>    fmt.Printf(<span class="hljs-string">&quot;value=%d,exist=%v&quot;</span>, value, exist)<br>&#125;<br></code></pre></td></tr></table></figure><p>另一方面，尽管在语法上提供了任意多个返回值的直接支持，但在编写的代码中很少会遇到超过3个的情况。一般来说，返回值超过了3个，要么是函数的职责拆分不合理，要么是缺少结构的必要抽象(往往存在基本类型偏执)。此时，设计者会更倾向于上述的第一种解法。因此，尽管语言本身支持，但在实际编程中却另有取舍。</p><p>C++是C的超集，虽然发展到如今的C++23乃至26，早就和C标准分道扬镳了，但从C继承过来的历史包袱却是浑身难受（C风格数组、函数指针、<code>const char[N]</code>的字符串字面量等等都太过于原始，与现代语言的设计格格不入，在2024年，你很难想象一个现代编程语言不支持原生的字符串基本型）。</p><p>C++的STL弥补了很多语言天然的缺陷，再加上伟大的boost发光发热，硬是让这一难用的语言撑过了最艰难的蜕变期。STL提供了很多好用的容器，对于我们的需求，可以使用<code>std::pair&lt;int, bool&gt;</code>来满足：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">func4</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>); &#125;<br><br><span class="hljs-comment">// before C++11</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; ret = <span class="hljs-built_in">func4</span>();<br>    std::cout &lt;&lt; ret.first &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; ret.second &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在C++11之前，由于不支持返回类型推导，我们需要显式地定义返回值<code>ret</code>的类型，另一方面，对<code>pair</code>成员的访问，需要用<code>.first</code>，<code>.second</code>的形式。虽无go那般优雅，但也差强人意。</p><p><code>pair</code>对于那些需要成对存在的场合也相当好用，比如KV型结构<code>std::map&lt;Key,Value&gt;</code>的<code>value_type</code>就是<code>std::pair&lt;const Key, Value&gt;</code>类型。</p><p>而在C++11又引入了另一个非常强大的异质容器：<code>std::tuple</code>。相比于<code>std::pair</code>，<code>tuple</code>可以容纳任意多个成员，自然，<code>pair</code>能干的活它都能干：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">func5</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>); &#125;<br><br><span class="hljs-comment">// in C++11</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">func5</span>();<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(ret) &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(ret) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于<code>pair</code>，<code>tuple</code>的成员获取显得更加丑陋，这是为了泛用性而不得不做的牺牲。C++14和C++17相继引入了<code>std::tie</code>和语法层面的结构化绑定来遮羞：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// in C++14</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-type">bool</span> exist;<br>    std::<span class="hljs-built_in">tie</span>(value, exist) = <span class="hljs-built_in">func5</span>();<br>    std::cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; exist &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// in C++17</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> [value, exist] = <span class="hljs-built_in">func5</span>();<br>    std::cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; exist &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，这很modern。</p><h2 id="stdoptional-有还是没有啊"><code>std::optional</code>:有还是没有啊？</h2><p>上一节的拆分，我们既没有定义复杂的struct，也没有使用OUT型参数，而是选择了一个折中的方案：<code>pair</code>或是<code>tuple</code>来做wrapper。实际上，wrapper还可以有另一种封装方式，他不必携带多个返回值，他只需要携带额外的信息即可。对于上例来说，面向exist这个bool，使用C++的<code>std::optional</code>更为合适。</p><p><code>std::optional</code>是在C++17才正式引入到标准库的，实际上这东西早在boost时代就已经发光发热相当长一段时间了。我们来看一下官方定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">The class template std::optional manages an optional contained value,</span><br><span class="hljs-comment">i.e. a value that may or may not be present.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">A common use case for optional is the return value of a function that may fail. </span><br><span class="hljs-comment">As opposed to other approaches, such as std::pair&lt;T, bool&gt;, optional handles </span><br><span class="hljs-comment">expensive-to-construct objects well and is more readable, as the intent is expressed </span><br><span class="hljs-comment">explicitly.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Any instance of optional&lt;T&gt; at any given point in time either contains a value </span><br><span class="hljs-comment">or does not contain a value.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">If an optional&lt;T&gt; contains a value, the value is guaranteed to be allocated as part </span><br><span class="hljs-comment">of the optional object footprint, i.e. no dynamic memory allocation ever takes place. </span><br><span class="hljs-comment">Thus, an optional object models an object, not a pointer, even though operator*() </span><br><span class="hljs-comment">and operator-&gt;() are defined.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">When an object of type optional&lt;T&gt; is contextually converted to bool, </span><br><span class="hljs-comment">the conversion returns true if the object contains a value and false </span><br><span class="hljs-comment">if it does not contain a value.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">The optional object contains a value in the following conditions:</span><br><span class="hljs-comment">- The object is initialized with/assigned from a value of type T </span><br><span class="hljs-comment">  or another optional that contains a value.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">The object does not contain a value in the following conditions:</span><br><span class="hljs-comment">- The object is default-initialized.</span><br><span class="hljs-comment">- The object is initialized with/assigned from a value of type std::nullopt_t </span><br><span class="hljs-comment">  or an optional object that does not contain a value.</span><br><span class="hljs-comment">- The member function reset() is called.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">There are no optional references; a program is ill-formed if it instantiates an optional </span><br><span class="hljs-comment">with a reference type. In addition, a program is ill-formed if it instantiates an optional </span><br><span class="hljs-comment">with the (possibly cv-qualified) tag types std::nullopt_t or std::in_place_t.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">optional</span>;<br></code></pre></td></tr></table></figure><p>通过定义可以知晓，<code>optional&lt;T&gt;</code>的实例在某一时刻，要么包含一个类型为<code>T</code>的值，要么没有值。显然，对于我们的需求来说，它更加契合，毕竟，当<code>exist</code>为<code>false</code>的时候，其实返回的另一个<code>value</code>是没有实际意义的。关于这一点，相信有使用过go的开发者都深以为然，在go中，我们经常写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> data, err := fun(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// do something for error case, the data generately is nil or zero-valued</span><br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// use data forward</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而对于<code>fun</code>的设计者，不得不这样编写他的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span> ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> !sanityCheck() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;incorrect msg&quot;</span>)  <br>    &#125;<br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>尽管返回值有两个，但其实同一时刻只有一个是有效的，另一个则按照语言的惯用法设置合理的值。</p><p>有了<code>std::optional</code>，就可以这样来编写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sanityCheck</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">func6</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">sanityCheck</span>()) &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">calculate</span>()&#125;;<br>&#125;<br><br><span class="hljs-comment">// before C++11</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">func6</span>(); ret.<span class="hljs-built_in">has_value</span>()) &#123;<br>        std::cout &lt;&lt; *ret &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;empty result&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::optional&lt;T&gt;</code>的语义其实就是调用者告诉函数：“这个可以有”，而当函数返回的是一个<code>std::nullopt</code>时，就是反馈给调用者：“这个真没有”。</p><h3 id="stdoptional的实现">std::optional的实现</h3><p>正如官方手册所述，<code>std::optional</code>在实现上是一个类模板，本质上来讲它是一个<code>exist or not</code>的wrapper。</p><blockquote><p>If an optional<T> contains a value, the value is guaranteed to beallocated as part of the optional object footprint, i.e. no dynamicmemory allocation ever takes place. Thus, an optional object models anobject, not a pointer, even though operator*() and operator-&gt;() aredefined.</p></blockquote><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://stackoverflow.com/questions/42622015/how-to-define-an-optional-field-in-protobuf-3">Howto define an optional field in protobuf 3</a></li><li><ahref="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcessAfunction</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>cpp-templates</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++黑魔法系列之ScopeGuard源码剖析</title>
    <link href="/2023/12/01/C++%E9%BB%91%E9%AD%94%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8BScopeGuard%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2023/12/01/C++%E9%BB%91%E9%AD%94%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8BScopeGuard%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>众所周知，想要在C++中写出通用的框架、组件代码并不简单，一来C++本身庞然大物包罗万象，大部分开发者并不了解像是”茴有四种写法“这种语言律师津津乐道的课题，对于晦涩难懂的模板元更是谈之色变，二来是历史悠久，在发展过程中为了向前兼容，遗留了各种特例特办的技术债，导致系统臃肿不堪。因此，尽管C++生态相当茂盛，但权威的第三方库却屈指可数（甚至其标准库都是风风雨雨缝缝补补，<del>偷得人家boost就剩个底裤</del>）。阅读优秀的开源代码是提升代码水平的捷径，本篇文章我们来深度剖析大名鼎鼎的Facebookfolly库所实现的ScopeGuard。管中窥豹，可见一斑。</p><span id="more"></span><h1id="c黑魔法系列之scopeguard源码剖析">C++黑魔法系列之ScopeGuard源码剖析</h1><p>ScopeGuard是一种通用的RAII思想的实现。它可以保证某个函数在离开当前作用域时一定会被执行，基于这一语义，我们可以方便的编写出异常安全的代码，也可以实现像go语言中defer那样的语法糖。Facebook大名鼎鼎的folly库实现了一种通用的ScopeGuard实现，它被广泛应用于各种基础组件之上，通过模拟语法糖的形式让编写异常安全的代码变得简单。</p><p>本文则是对其源码实现的解剖，但与常规解析有所不同的是，我不会一上来就逐行逆向去讨论每一处代码的细节，而是提取出全局设计思想，一步一步按部就班实现所需的能力，最终reach源代码。</p><h2 id="异常触发的清洁工makeguard">异常触发的清洁工：makeGuard</h2><p>在ScopeGuard的源码中，开局就给了一个应用场景案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">User::addFriend</span><span class="hljs-params">(User&amp; newFriend)</span> </span>&#123;<br>    <span class="hljs-comment">// add the friend to memory</span><br>    friends_.<span class="hljs-built_in">push_back</span>(&amp;newFriend);<br> <br>    <span class="hljs-comment">// If the db insertion that follows fails, we should</span><br>    <span class="hljs-comment">// remove it from memory.</span><br>    <span class="hljs-keyword">auto</span> guard = <span class="hljs-built_in">makeGuard</span>([&amp;]() &#123; friends_.<span class="hljs-built_in">pop_back</span>(); &#125;);<br> <br>    <span class="hljs-comment">// this will throw an exception upon error, which</span><br>    <span class="hljs-comment">// makes the ScopeGuard execute UserCont::pop_back()</span><br>    <span class="hljs-comment">// once the Guard&#x27;s destructor is called.</span><br>    db_-&gt;<span class="hljs-built_in">addFriend</span>(<span class="hljs-built_in">GetName</span>(), newFriend.<span class="hljs-built_in">GetName</span>());<br> <br>    <span class="hljs-comment">// an exception was not thrown, so don&#x27;t execute</span><br>    <span class="hljs-comment">// the Guard.</span><br>    guard.<span class="hljs-built_in">dismiss</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个案例源于Andrie大佬的这篇文章：<ahref="https://drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758">Generic:Change the Way You Write Exception-Safe Code —Forever</a>，里面着重讲述了在C++中要如何简化编写异常安全的代码。</p><p>在函数<code>addFriend</code>执行过程中，可能会抛出某个异常，而从业务逻辑视角来看，我们希望一旦有异常抛出，那么就能够触发某些清理工作的执行。在上述代码中，传递给<code>makeGuard</code>的lambda函数就是清理任务，代码中的<code>db_-&gt;addFriend(...)</code>可能会抛异常，此时就需要执行清理任务lambda，而如果在执行过程中并未抛出任何异常，则清理任务不会执行。</p><p>对于这个例子，可能读者会比较奇怪，为什么要用这么”别扭“的写法呢？如果我写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">User::AddFriend</span><span class="hljs-params">(User&amp; newFriend)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Add the new friend to the database</span><br>    pDB_-&gt;<span class="hljs-built_in">AddFriend</span>(<span class="hljs-built_in">GetName</span>(), newFriend.<span class="hljs-built_in">GetName</span>());<br>    <span class="hljs-comment">// Add the new friend to the vector of friends</span><br>    friends_.<span class="hljs-built_in">push_back</span>(&amp;newFriend);<br>&#125;<br></code></pre></td></tr></table></figure><p>不是直接就大功告成？一旦<code>pDB_-&gt;AddFriend(GetName(), newFriend.GetName());</code>抛出了异常，那么根据C++的异常控制机理，下面的<code>friends_.push_back(&amp;newFriend);</code>不就恰恰不会执行了吗？</p><p>你说得对，但是我是说如果，<code>pDB_-&gt;AddFriend(GetName(), newFriend.GetName())</code>在成功修改了外部数据库的信息后，<code>friends_.push_back(&amp;newFriend)</code>抛出了异常，阁下又该如何应对？可能大部分业务都没这么敏感，往往也有一些纠错逻辑去补偿，但既然是例子，我们暂且钻一下牛角尖。</p><h3 id="try-catch-暴力解决">try-catch 暴力解决</h3><p>当然，对于这段简单的代码，看起来并不需要ScopedGuard这么高级的机制，我们只需要暴力编写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">User::AddFriend</span><span class="hljs-params">(User&amp; newFriend)</span> </span>&#123;<br>    friends_.<span class="hljs-built_in">push_back</span>(&amp;newFriend);<br>    <span class="hljs-keyword">try</span> &#123;<br>        pDB_-&gt;<span class="hljs-built_in">AddFriend</span>(<span class="hljs-built_in">GetName</span>(), newFriend.<span class="hljs-built_in">GetName</span>());<br>    &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>        friends_.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一样可以达成同样的效果。但是这种异常安全的代码，也带来了额外的开销：我们的程序变得臃肿，随着可能抛出异常代码块的增多，我们需要编写的try-catch块儿也更复杂，甚至还有需要嵌套的代码块儿，导致代码可维护性差，甚至晦涩难懂。</p><h3 id="raii">RAII</h3><p>那么，有没有什么更优雅的手法呢？本质上<code>friends_.push_back(&amp;newFriend);</code>是一种资源泄露，我们可以借助RAII(ResourceAcquisition Is Initialization)的思想来避免泄露：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VectorInserter</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">VectorInserter</span>(std::vector&lt;User*&gt;&amp; v, User&amp; u)<br>    : <span class="hljs-built_in">container_</span>(v), <span class="hljs-built_in">commit_</span>(<span class="hljs-literal">false</span>)<br>    &#123;<br>        container_.<span class="hljs-built_in">push_back</span>(&amp;u);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Commit</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        commit_ = <span class="hljs-literal">true</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">VectorInserter</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!commit_) container_.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;User*&gt;&amp; container_;<br>    <span class="hljs-type">bool</span> commit_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">User::AddFriend</span><span class="hljs-params">(User&amp; newFriend)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">VectorInserter <span class="hljs-title">ins</span><span class="hljs-params">(friends_, &amp;newFriend)</span></span>;<br>    pDB_-&gt;<span class="hljs-built_in">AddFriend</span>(<span class="hljs-built_in">GetName</span>(), newFriend.<span class="hljs-built_in">GetName</span>());<br>    <span class="hljs-comment">// Everything went fine, commit the vector insertion</span><br>    ins.<span class="hljs-built_in">Commit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这下我们通过引入<code>VectorInserter ins</code>这个局部变量来实现RAII，在代码末尾处我们通过执行<code>ins.Commit()</code>来设置其成员标记，使其在离开函数作用域之后析构之时，不去执行清理代码<code>container_.pop_back();</code>。而如果前面的代码抛出了异常，那么<code>ins.Commit();</code>将没有机会得到执行，此时<code>commit</code>就是初始值<code>false</code>，在函数作用域退出时依然会触发<code>ins</code>的析构，此时就执行了清理代码。</p><p>通过对RAII思想的利用，这下子<code>AddFriend</code>的异常安全逻辑编写变得简洁多了。但是，由于我们需要编写伴生的RAIIclass，从整体代码设计来看依然不够优雅。另一方面，在C++中想要设计一个功能完备又正确的类可没这么简单，像是上面的<code>VectorInserter</code>，如何优雅的处理好BigFive，也是相当麻烦。</p><blockquote><p>注：Big Five并非C++官方的说法，它是指destructor, copy constructor,copy assignment, move constructor, moveassignment这五个类中非常重要的成员函数。这一说法最早它来源于台湾知名大神侯捷的译作，熟悉C++的老玩家自当会心一笑。</p></blockquote><h3 id="scopeguard-tool">ScopeGuard Tool</h3><p>RAII的思想没错，但是需要开发者自己设计伴生类代价太大了，我总不能为了每一段这样的逻辑都编写一个伴生类吧，那岂不是违背了初心又本末倒置。因此，我们需要对伴生类的实现尽量通用化，提供最精致的接口供开发者使用。考虑到资源清理的手段多种多样，比如最通用的手法是调用某个函数对象，为了可以面向具体手段做扩展，<code>ScopeGuard</code>在设计上可以将类拆分成层级结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeGuardImplBase</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dismiss</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; dismissed_ = <span class="hljs-literal">true</span>; &#125;<br>  <span class="hljs-keyword">protected</span>:<br>     <span class="hljs-built_in">ScopeGuardImplBase</span>(<span class="hljs-type">bool</span> dismissed = <span class="hljs-literal">false</span>) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">dismissed_</span>(dismissed) &#123;&#125;<br>  <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">bool</span> dismissed_;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> FunctionType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeGuardImpl</span> : <span class="hljs-keyword">public</span> ScopeGuardImplBase &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(FunctionType&amp; fn)</span> : function_(std::as_const(fn)) &#123;</span> &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionType&amp; fn)</span> : function_(fn) &#123;</span> &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(FunctionType&amp;&amp; fn)</span> : function_(std::move(fn)) &#123;</span> &#125;<br><br>    <span class="hljs-built_in">ScopeGuardImpl</span>(ScopeGuardImpl&amp;&amp; other) : <span class="hljs-built_in">function_</span>(std::<span class="hljs-built_in">move</span>(other.function_)) &#123;<br>      dismissed_ = std::<span class="hljs-built_in">exchange</span>(other.dismissed_, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">ScopeGuardImpl</span>() &#123;<br>      <span class="hljs-keyword">if</span> (!dismissed_) &#123;<br>        <span class="hljs-built_in">function_</span>();<br>      &#125;<br>    &#125;<br>  <br>  <span class="hljs-keyword">private</span>:<br>    FunctionType function_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>而对外提供的<code>makeGuard</code>可以封装一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F&gt;<br>ScopeGuardImpl&lt;std::<span class="hljs-type">decay_t</span>&lt;F&gt;&gt; <span class="hljs-built_in">makeGuard</span>(F&amp;&amp; f) &#123;<br>  <span class="hljs-keyword">return</span> ScopeGuardImpl&lt;std::<span class="hljs-type">decay_t</span>&lt;F&gt;&gt;(std::forward&lt;F&gt;(f));<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，看起来这样就成了，我们写个例子执行一下试试。</p><h4 id="风调雨顺岁月静好">风调雨顺，岁月静好</h4><p>当一切都朝着你期望的方向推进时，这代码简直泰裤辣：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unexpected</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;oops...&quot;</span>);&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expected</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;everything goes well&quot;</span> &lt;&lt; std::endl; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends)</span> </span>&#123;<br>  friends.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">auto</span> guard = <span class="hljs-built_in">makeGuard</span>([&amp;]()&#123;friends.<span class="hljs-built_in">pop_back</span>();&#125;);<br>  <span class="hljs-built_in">expected</span>();<br>  <span class="hljs-built_in">unexpected</span>(); <span class="hljs-comment">// 此处会抛出异常，导致下一行代码得不到执行</span><br>  guard.<span class="hljs-built_in">dismiss</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::vector&lt;<span class="hljs-type">int</span>&gt; friends;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">func</span>(friends);<br>  &#125;<span class="hljs-built_in">catch</span>(std::exception &amp;ex) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;exception: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>  &#125;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;size=&quot;</span> &lt;&lt; friends.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于<code>unexpected</code>在执行期间抛出了某个异常，最终<code>friends</code>中的成员<code>1</code>被清理。而当我们注释掉<code>unexpected</code>的调用后，清理工作不会执行，因为<code>guard</code>被成功<code>dismiss</code>了。</p><h4 id="异常还是异常">异常，还是异常</h4><p>这样就够了吗？不，ScopeGuard的真正实现远比上面的要复杂得多。</p><p>我们传递给<code>makeGuard</code>的是一个lambda对象，事实上，我们可以传递任意一个可调用对象，在C++中，它可以是一个函数、一个lambda、一个<code>std::function&lt;&gt;</code>、甚至是一个重载了<code>operator()</code>的<code>class/struct</code>。另一方面，<code>makeGuard</code>可以传入一个左值引用或是右值引用，于此同时，它还可以有CV限定(<code>const</code>,<code>volatile</code>)，以满足日常编程所有场景的需求。</p><p>上述实现代码中，面对lvalue reference、const lvalue reference和rvaluereference，各自实现了构造器(以下简称为ctor)。其中前两者会触发<code>FunctionType</code>的copyctor，而末者则会触发<code>FunctionType</code>的movector(如果有的话)。到此，就出现了第一个问题：如果<code>FunctionType</code>的copy/movector抛了异常，我们又该如何（一般来说，movector在设计上是不会抛异常的，但C++是自由的，它允许你发癫）？</p><p><code>makeGuard</code>能够保证垃圾被清理的前提，在于要成功构造出<code>ScopeGuardImpl</code>对象，而<code>FunctionType</code>的ctor一旦会抛异常，那么我们的构造就会失败，此时，垃圾清理函数当然得不到执行。</p><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Functor</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Functor</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends)</span> : friends_(friends) &#123;</span>&#125;<br><br>    <span class="hljs-built_in">Functor</span>(<span class="hljs-type">const</span> Functor &amp;rhs) : <span class="hljs-built_in">friends_</span>(rhs.friends_) &#123; <br>      <span class="hljs-comment">// 这里模拟一下，抛个异常</span><br>      <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;throw exception in Functor copy ctor...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123; friends_.<span class="hljs-built_in">pop_back</span>(); &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unexcepted</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;oops...&quot;</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;friends)</span> </span>&#123;<br>    friends.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-function">Functor <span class="hljs-title">f</span><span class="hljs-params">(friends)</span></span>;<br>    <span class="hljs-comment">// 实参是左值引用，此时会调用到Functor的copy ctor，触发异常</span><br>    <span class="hljs-keyword">auto</span> guard = <span class="hljs-built_in">makeGuard</span>(f);<br>    <span class="hljs-built_in">unexcepted</span>();<br>    guard.<span class="hljs-built_in">dismiss</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::vector&lt;<span class="hljs-type">int</span>&gt; friends;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">func</span>(friends);<br>  &#125;<span class="hljs-built_in">catch</span>(std::exception &amp;ex) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;exception: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>  &#125;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;size=&quot;</span> &lt;&lt; friends.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">exception: throw exception in Functor copy ctor...<br>size=1<br></code></pre></td></tr></table></figure></p><p>可以看到代码在执行过程中抛出了异常，但是垃圾并没有被回收。<strong>防不胜防啊，一个小小的copyctor异常就破了我们的招。</strong></p><h3 id="异常安全的scopeguard">异常安全的ScopeGuard</h3><p>那么，有没有什么办法可以兜住ctor的异常呢？答案是有，而且甚秒。</p><p>Folly库在实现ScopeGuardImpl时，引入了一个叫<code>makeFailsafe</code>的成员函数，它通过在构造<code>ScopeGuardImpl</code>A对象期间，嵌套构造另一个<code>ScopeGuardImpl</code>B对象，并借助模板元编程中一种叫做tag-dispatch的技术对可能会抛出异常的<code>FunctionType</code>用<code>std::reference_wrapper</code>做了二次包裹，利用<code>std::reference_wrapper</code>的<code>noexcept</code>ctor，确保了B在构造期间不会抛出异常，从而能够在构造A期间抛出异常的时刻，接管垃圾清理器。</p><p>这听起来就相当套娃，事实上它的实现更加复杂，我们来升级一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeGuardImplBase</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dismiss</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; dismissed_ = <span class="hljs-literal">true</span>; &#125;<br>  <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">ScopeGuardImplBase</span>(<span class="hljs-type">bool</span> dismissed = <span class="hljs-literal">false</span>) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">dismissed_</span>(dismissed) &#123;&#125;<br>      <br>    <span class="hljs-function"><span class="hljs-type">static</span> ScopeGuardImplBase <span class="hljs-title">makeEmptyScopeGuard</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> ScopeGuardImplBase&#123;&#125;;<br>    &#125;<br>  <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">bool</span> dismissed_;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> FunctionType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeGuardImpl</span> : <span class="hljs-keyword">public</span> ScopeGuardImplBase &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 利用trait做tag-dispatch</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(FunctionType&amp; fn)</span> </span><br><span class="hljs-function">      : ScopeGuardImpl(std::as_const(fn), makeFailsafe(std::is_nothrow_copy_constructible&lt;FunctionType&gt;&#123;</span>&#125;, &amp;fn)) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionType&amp; fn)</span></span><br><span class="hljs-function">      : ScopeGuardImpl(fn, makeFailsafe(std::is_nothrow_copy_constructible&lt;FunctionType&gt;&#123;</span>&#125;, &amp;fn)) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(FunctionType&amp;&amp; fn)</span> </span><br><span class="hljs-function">      : ScopeGuardImpl(std::move(fn), makeFailsafe(std::is_nothrow_move_constructbile&lt;FunctionType&gt;&#123;</span>&#125;, &amp;fn)) &#123; &#125;<br><br>    <span class="hljs-built_in">ScopeGuardImpl</span>(ScopeGuardImpl&amp;&amp; other) : <span class="hljs-built_in">function_</span>(std::<span class="hljs-built_in">move</span>(other.function_)) &#123;<br>      dismissed_ = std::<span class="hljs-built_in">exchange</span>(other.dismissed_, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">ScopeGuardImpl</span>() &#123;<br>      <span class="hljs-keyword">if</span> (!dismissed_) &#123;<br>        <span class="hljs-built_in">function_</span>();<br>      &#125;<br>    &#125;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> ScopeGuardImplBase <span class="hljs-title">makeFailsafe</span><span class="hljs-params">(std::true_type, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">makeEmptyScopeGuard</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Fn&gt;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">makeFailsafe</span><span class="hljs-params">(std::false_type, Fn* fn)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">        -&gt; ScopeGuardImpl&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(std::ref(*fn))</span>&gt; </span>&#123;<br>      <span class="hljs-keyword">return</span> ScopeGuardImpl&lt;<span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">ref</span>(*fn))&gt;&#123;std::<span class="hljs-built_in">ref</span>(*fn)&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Fn&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(Fn&amp;&amp; fn, ScopeGuardImplBase&amp;&amp; failsafe)</span></span><br><span class="hljs-function">      : ScopeGuardImplBase&#123;</span>&#125;, <span class="hljs-built_in">function_</span>(std::forward&lt;Fn&gt;(fn)) &#123;<br>      failsafe.<span class="hljs-built_in">dismiss</span>();<br>    &#125;<br>  <span class="hljs-keyword">private</span>:<br>    FunctionType function_;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F&gt;<br>ScopeGuardImpl&lt;std::<span class="hljs-type">decay_t</span>&lt;F&gt;&gt; <span class="hljs-built_in">makeGuard</span>(F&amp;&amp; f) &#123;<br>  <span class="hljs-keyword">return</span> ScopeGuardImpl&lt;std::<span class="hljs-type">decay_t</span>&lt;F&gt;&gt;(std::forward&lt;F&gt;(f));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们对构造器进行了改造，若传入的是lvalue reference，则根据其copyctor是否会抛异常而调用不同的makeFailsafe，若传入的是rvaluereference，则根据其move ctor是否会抛异常而调用不同的makeFailsafe。makeFailsafe的设计是一种tag-dispatch的技巧，通过类型去match不同的重载函数，最终再经重载决议确定，也算是模板元编程里一种经典if-else手法了。</p><p>我们以传入左值作为例子，看一下在构造一个<code>ScopeGuardImpl</code>对象时，经历的path：</p><p>对于不会抛出异常的copy ctor，流程是一目了然的：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">=&gt; 匹配构造器：<span class="hljs-constructor">ScopeGuardImpl(<span class="hljs-params">const</span> FunctionType&amp; <span class="hljs-params">fn</span>)</span> : <span class="hljs-constructor">ScopeGuardImpl(<span class="hljs-params">fn</span>, <span class="hljs-params">makeFailsafe</span>(<span class="hljs-params">std</span>::<span class="hljs-params">is_nothrow_copy_constructible</span>&lt;FunctionType&gt;&#123;&#125;, &amp;<span class="hljs-params">fn</span>)</span>) &#123; &#125;<br>    =&gt; 转发到<span class="hljs-keyword">private</span>构造器：template&lt;typename Fn&gt; <span class="hljs-constructor">ScopeGuardImpl(Fn<span class="hljs-operator">&amp;&amp;</span> <span class="hljs-params">fn</span>, ScopeGuardImplBase<span class="hljs-operator">&amp;&amp;</span> <span class="hljs-params">failsafe</span>)</span>，其中fn是转发引用，failsafe是右值引用<br>    =&gt; 由于makeFailsafe匹配到std::true_type的版本，返回一个默认构造的ScopeGuardImplBase&#123;&#125;临时对象，作为failsafe参数传递<br>    =&gt; 此时Fn类型被推导为const FunctionType&amp;，形参fn由于引用折叠也被推导为const FunctionType&amp;<br>      =&gt; : ScopeGuardImplBase&#123;&#125;, <span class="hljs-keyword">function</span><span class="hljs-constructor">_(<span class="hljs-params">std</span>::<span class="hljs-params">forward</span>&lt;Fn&gt;(<span class="hljs-params">fn</span>)</span>) &#123;failsafe.dismiss<span class="hljs-literal">()</span>;&#125;<br>      =&gt; 成员初始化列表：基类默认构造，function_成员通过完美转发接收fn，此时会触发FunctionType的copy ctor来初始化对象<br>      =&gt; 构造出的临时对象failsafe调用dismiss<span class="hljs-literal">()</span>，避免析构时执行execute<br>    =&gt; ScopeGuardImpl对象构建完毕，大功告成<br></code></pre></td></tr></table></figure><p>而对于可能会抛出异常的copy ctor，则要复杂得多：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ruby">=&gt; 匹配构造器：<span class="hljs-title class_">ScopeGuardImpl</span>(const <span class="hljs-title class_">FunctionType</span>&amp; fn) : <span class="hljs-title class_">ScopeGuardImpl</span>(fn, makeFailsafe(std::is_nothrow_copy_constructible&lt;<span class="hljs-title class_">FunctionType</span>&gt;&#123;&#125;, &amp;fn)) &#123; &#125;<br>  =&gt; 转发到private构造器：template&lt;typename <span class="hljs-title class_">Fn</span>&gt; <span class="hljs-title class_">ScopeGuardImpl</span>(<span class="hljs-title class_">Fn</span>&amp;&amp; fn, <span class="hljs-title class_">ScopeGuardImplBase</span>&amp;&amp; failsafe)，其中fn是转发引用，failsafe是右值引用<br>  =&gt; 由于makeFailsafe会匹配到std::false_type的版本，返回的是另一个全新构建的<span class="hljs-title class_">ScopeGuardImpl</span>临时对象：<br>  =&gt; return <span class="hljs-title class_">ScopeGuardImpl</span>&lt;decltype(std::ref(*fn))&gt;&#123;std::ref(*fn)&#125;;<br>    =&gt; 通过std::ref包裹*fn，来构建出一个std::reference_wrapper&lt;<span class="hljs-title class_">FunctionType</span>&gt;临时对象<br>    =&gt; 使用该临时对象显式实例化构建另一个<span class="hljs-title class_">ScopeGuardImpl</span>&lt;std::reference_wrapper&lt;<span class="hljs-title class_">FunctionType</span>&gt;&gt;对象<br>      =&gt; 匹配调用的是右值引用版本的ctor：<span class="hljs-title class_">ScopeGuardImpl</span>(<span class="hljs-title class_">FunctionType</span>&amp;&amp; fn) : <span class="hljs-title class_">ScopeGuardImpl</span>(std::move_if_noexcept(fn), makeFailsafe(std::is_nothrow_move_constructbile&lt;<span class="hljs-title class_">FunctionType</span>&gt;)&#123;&#125;, &amp;fn) &#123; &#125;<br>      =&gt; 此时的<span class="hljs-title class_">ScopeGuardImpl</span>类模板实例化的是一个全新版本，其模板参数为std::reference_wrapper&lt;原始<span class="hljs-title class_">FunctionType</span>&gt;<br>      =&gt; 由于std::reference_wrapper的移动构造器在设计上已标记成了nothrow，因此，当再进行构造器转发时，makeFailsafe匹配的就是std::true_type的版本：<br>        =&gt; 转发到private构造器：template&lt;typename <span class="hljs-title class_">Fn</span>&gt; <span class="hljs-title class_">ScopeGuardImpl</span>(<span class="hljs-title class_">Fn</span>&amp;&amp; fn, <span class="hljs-title class_">ScopeGuardImplBase</span>&amp;&amp; failsafe)，其中fn是转发引用，failsafe是右值引用<br>          =&gt; failsafe又是一个默认构造的<span class="hljs-title class_">ScopeGuardImplBase</span>&#123;&#125;临时对象<br>          =&gt; <span class="hljs-title class_">Fn</span>被推导为std::reference_wrapper&lt;原始<span class="hljs-title class_">FunctionType</span>&gt;，参数fn被推导为std::reference_wrapper&lt;原始<span class="hljs-title class_">FunctionType</span>&gt;&amp;&amp;右值引用型<br>          =&gt; : <span class="hljs-title class_">ScopeGuardImplBase</span>&#123;&#125;, function_(std::forward&lt;<span class="hljs-title class_">Fn</span>&gt;(fn)) &#123;failsafe.dismiss();&#125;<br>            =&gt; 此时的function_实际上是一个std::reference_wrapper&lt;原始<span class="hljs-title class_">FunctionType</span>&gt;类型，这里经过std::reference_wrapper的move ctor最终构造了一个接收了包裹原始<span class="hljs-title class_">Functor</span>的std::reference_wrapper<br>            =&gt; 临时对象failsafe（此时是一个<span class="hljs-title class_">ScopeGuardImplBase</span>）调用dismiss()，避免析构时执行execute<br>  =&gt; 到此，临时对象<span class="hljs-title class_">ScopeGuardImpl</span>&lt;std::reference_wrapper&lt;<span class="hljs-title class_">FunctionType</span>&gt;&gt;构建完毕，并返回给上游作为failsafe参数<br>  =&gt; 用fn和临时对象调用private构造器：<br>    =&gt; template&lt;typename <span class="hljs-title class_">Fn</span>&gt; <span class="hljs-title class_">ScopeGuardImpl</span>(<span class="hljs-title class_">Fn</span>&amp;&amp; fn, <span class="hljs-title class_">ScopeGuardImplBase</span>&amp;&amp; failsafe) : <span class="hljs-title class_">ScopeGuardImplBase</span>&#123;&#125;, function_(std::forward&lt;<span class="hljs-title class_">Fn</span>&gt;(fn)) &#123; failsafe.dismiss(); &#125;<br>    =&gt; 此时的<span class="hljs-title class_">Fn</span>被推导为原始<span class="hljs-title class_">FunctionType</span>，fn是const <span class="hljs-title class_">FunctionType</span> &amp;, failsafe是包裹了<span class="hljs-title class_">Functor</span>对象的临时对象。<br>    =&gt; 若function_(std::forward&lt;<span class="hljs-title class_">Fn</span>&gt;(fn))在执行时没有抛异常，则临时对象的使命完成，它会调用到failsafe.dismiss()，即在其析构时不会调用我们的<span class="hljs-title class_">Functor</span>对象。<br>      =&gt; 此时<span class="hljs-title class_">Functor</span>是否要调用的权利，正式交棒给了外层对象<span class="hljs-title class_">ScopeGuardImpl</span>&lt;<span class="hljs-title class_">FunctionType</span>&gt;。<br>    =&gt; 若function_(std::forward&lt;<span class="hljs-title class_">Fn</span>&gt;(fn))在执行时其copy ctor确实抛了异常，那么最外层的<span class="hljs-title class_">ScopeGuardImpl</span>&lt;<span class="hljs-title class_">FunctionType</span>&gt;对象就不会构造成功，构造器内的failsafe.dismiss()也得不到执行。<br>      =&gt; 此时，尽管我们并没能成功构造出<span class="hljs-title class_">ScopeGuardImpl</span>&lt;<span class="hljs-title class_">FunctionType</span>&gt;对象，但最开始传入的<span class="hljs-title class_">Functor</span>还是能够被执行。<br>      =&gt; 这是由于没能执行failsafe.dismiss()操作的内层临时对象的dismiss_仍然是false，而在其析构时<span class="hljs-title class_">Functor</span>依然得到了执行。<br></code></pre></td></tr></table></figure><p>可以看到代码的实现非常的绕，但实际上核心思想就是借助<code>std::reference_wrapper</code>这个引用包裹器具有nothrow的movector这一特点来处理那些原本有可能会抛异常的copy/movector的<code>FunctionType</code>。</p><h4 id="log补齐代码">log补齐代码：</h4><p>我们打印一些log，并分别用左值和右值两个案例来测试一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// scope.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_name.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeGuardImplBase</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dismiss</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; dismissed_ = <span class="hljs-literal">true</span>; &#125;<br>  <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">ScopeGuardImplBase</span>(<span class="hljs-type">bool</span> dismissed = <span class="hljs-literal">false</span>) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">dismissed_</span>(dismissed) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;construct ScopeGuardImplBase, dismissed: &quot;</span> &lt;&lt; dismissed &lt;&lt; std::endl;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> ScopeGuardImplBase <span class="hljs-title">makeEmptyScopeGuard</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> ScopeGuardImplBase&#123;&#125;;<br>    &#125;<br>  <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">bool</span> dismissed_;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> FunctionType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeGuardImpl</span> : <span class="hljs-keyword">public</span> ScopeGuardImplBase &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(FunctionType&amp; fn)</span></span><br><span class="hljs-function">        : ScopeGuardImpl(std::as_const(fn), makeFailsafe(std::is_nothrow_copy_constructible&lt;FunctionType&gt;&#123;</span>&#125;, &amp;fn)) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;const lvalue ref ctor, FunctionType: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;FunctionType&gt;() &lt;&lt; <span class="hljs-string">&quot;, fn type: &quot;</span><br>                &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(fn)&gt;() &lt;&lt; std::endl;<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionType&amp; fn)</span></span><br><span class="hljs-function">        : ScopeGuardImpl(fn, makeFailsafe(std::is_nothrow_copy_constructible&lt;FunctionType&gt;&#123;</span>&#125;, &amp;fn)) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;lvalue ref ctor, FunctionType: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;FunctionType&gt;() &lt;&lt; <span class="hljs-string">&quot;, fn type: &quot;</span><br>                &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(fn)&gt;() &lt;&lt; std::endl;<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(FunctionType&amp;&amp; fn)</span></span><br><span class="hljs-function">        : ScopeGuardImpl(std::move(fn), makeFailsafe(std::is_nothrow_move_constructible&lt;FunctionType&gt;&#123;</span>&#125;, &amp;fn)) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;rvalue ref ctor, FunctionType: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;FunctionType&gt;() &lt;&lt; <span class="hljs-string">&quot;, fn type: &quot;</span><br>                &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(fn)&gt;() &lt;&lt; std::endl;<br>        &#125;<br><br>    <span class="hljs-built_in">ScopeGuardImpl</span>(ScopeGuardImpl&amp;&amp; other) : <span class="hljs-built_in">function_</span>(std::<span class="hljs-built_in">move</span>(other.function_)) &#123;<br>      dismissed_ = std::<span class="hljs-built_in">exchange</span>(other.dismissed_, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">ScopeGuardImpl</span>() &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;dtor, FunctionType: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;FunctionType&gt;() &lt;&lt; <span class="hljs-string">&quot;, function_ type: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(function_)&gt;() &lt;&lt; std::endl;<br>      <span class="hljs-keyword">if</span> (!dismissed_) &#123;<br>        <span class="hljs-built_in">function_</span>();<br>      &#125;<br>    &#125;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> ScopeGuardImplBase <span class="hljs-title">makeFailsafe</span><span class="hljs-params">(std::true_type, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;true_type makeFailsafe&quot;</span> &lt;&lt; std::endl;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">makeEmptyScopeGuard</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Fn&gt;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">makeFailsafe</span><span class="hljs-params">(std::false_type, Fn* fn)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">        -&gt; ScopeGuardImpl&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(std::ref(*fn))</span>&gt; </span>&#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;false_type makeFailsafe, Fn type: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;Fn&gt;() &lt;&lt; <span class="hljs-string">&quot;, fn type: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(fn)&gt;() &lt;&lt; std::endl;<br>      <span class="hljs-keyword">return</span> ScopeGuardImpl&lt;<span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">ref</span>(*fn))&gt;&#123;std::<span class="hljs-built_in">ref</span>(*fn)&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Fn&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(Fn&amp;&amp; fn, ScopeGuardImplBase&amp;&amp; failsafe)</span></span><br><span class="hljs-function">      : ScopeGuardImplBase&#123;</span>&#125;, <span class="hljs-built_in">function_</span>(std::forward&lt;Fn&gt;(fn)) &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;private ctor, Fn type: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;Fn&gt;() &lt;&lt; <span class="hljs-string">&quot;, fn type: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(fn)&gt;() &lt;&lt; std::endl;<br>      failsafe.<span class="hljs-built_in">dismiss</span>();<br>    &#125;<br>  <span class="hljs-keyword">private</span>:<br>    FunctionType function_;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F&gt;<br>ScopeGuardImpl&lt;std::<span class="hljs-type">decay_t</span>&lt;F&gt;&gt; <span class="hljs-built_in">makeGuard</span>(F&amp;&amp; f) &#123;<br>  <span class="hljs-keyword">return</span> ScopeGuardImpl&lt;std::<span class="hljs-type">decay_t</span>&lt;F&gt;&gt;(std::forward&lt;F&gt;(f));<br>&#125;<br><br><span class="hljs-comment">// type_name.h</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span><br><span class="hljs-function">std::string_view</span><br><span class="hljs-function"><span class="hljs-title">type_name</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __clang__</span><br>    string_view p = __PRETTY_FUNCTION__;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">34</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">34</span> - <span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(__GNUC__)</span><br>    string_view p = __PRETTY_FUNCTION__;<br><span class="hljs-meta">#  <span class="hljs-keyword">if</span> __cplusplus &lt; 201402</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">36</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">36</span> - <span class="hljs-number">1</span>);<br><span class="hljs-meta">#  <span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">49</span>, p.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;;&#x27;</span>, <span class="hljs-number">49</span>) - <span class="hljs-number">49</span>);<br><span class="hljs-meta">#  <span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>    string_view p = __FUNCSIG__;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">84</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">84</span> - <span class="hljs-number">7</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里附带一个C++最好用的类型名称打印器：<code>type_name</code></p><h4 id="用例1左值引用">用例1：左值引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;scope.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Functor</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Functor</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends)</span> : friends_(friends) &#123;</span>&#125;<br><br>    <span class="hljs-built_in">Functor</span>(<span class="hljs-type">const</span> Functor &amp;rhs) : <span class="hljs-built_in">friends_</span>(rhs.friends_) &#123; <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;throw exception in Functor copy ctor...&quot;</span>); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123; friends_.<span class="hljs-built_in">pop_back</span>(); &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;friends)</span> </span>&#123;<br>    friends.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-function">Functor <span class="hljs-title">f</span><span class="hljs-params">(friends)</span></span>;<br>    <span class="hljs-keyword">auto</span> guard = <span class="hljs-built_in">makeGuard</span>(f);<br>    <span class="hljs-comment">// some code that will not throw ...</span><br>    guard.<span class="hljs-built_in">dismiss</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::vector&lt;<span class="hljs-type">int</span>&gt; friends;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">func</span>(friends);<br>  &#125;<span class="hljs-built_in">catch</span>(std::exception &amp;ex) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;exception: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>  &#125;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;size=&quot;</span> &lt;&lt; friends.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">false_type makeFailsafe, Fn type: Functor, fn type: Functor *<br>true_type makeFailsafe<br>construct ScopeGuardImplBase, dismissed: 0<br>construct ScopeGuardImplBase, dismissed: 0<br>private ctor, Fn type: std::reference_wrapper&lt;Functor&gt;, fn type: std::reference_wrapper&lt;Functor&gt; &amp;&amp;<br>rvalue ref ctor, FunctionType: std::reference_wrapper&lt;Functor&gt;, fn type: std::reference_wrapper&lt;Functor&gt; &amp;&amp;<br>construct ScopeGuardImplBase, dismissed: 0<br>dtor, FunctionType: std::reference_wrapper&lt;Functor&gt;, function_ type: std::reference_wrapper&lt;Functor&gt;<br>exception: throw exception in Functor copy ctor...<br>size=0<br></code></pre></td></tr></table></figure><p>可以看到结果完全符合预期，我们的copyctor在runtime期间确实抛出了异常，在构造外层的<code>ScopeGuardImpl&lt;Functor&gt;</code>对象时遭到了异常，但由于内层<code>ScopeGuardmpl&lt;std::reference_wrapper&lt;Functor&gt;&gt;</code>对象的析构还是成功执行了垃圾清理。</p><p>我们把拷贝构造器抛出的异常干掉，但依然让其保持默认的<code>noexcept(false)</code>，再看看执行log：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Functor</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Functor</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends)</span> : friends_(friends) &#123;</span>&#125;<br><br>    <span class="hljs-built_in">Functor</span>(<span class="hljs-type">const</span> Functor &amp;rhs) : <span class="hljs-built_in">friends_</span>(rhs.friends_) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123; friends_.<span class="hljs-built_in">pop_back</span>(); &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;friends)</span> </span>&#123;<br>    friends.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-function">Functor <span class="hljs-title">f</span><span class="hljs-params">(friends)</span></span>;<br>    <span class="hljs-keyword">auto</span> guard = <span class="hljs-built_in">makeGuard</span>(f);<br>    <span class="hljs-comment">// some code that will not throw ...</span><br>    guard.<span class="hljs-built_in">dismiss</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">false_type makeFailsafe, Fn type: Functor, fn type: Functor *<br>true_type makeFailsafe<br>construct ScopeGuardImplBase, dismissed: 0<br>construct ScopeGuardImplBase, dismissed: 0<br>private ctor, Fn type: std::reference_wrapper&lt;Functor&gt;, fn type: std::reference_wrapper&lt;Functor&gt; &amp;&amp;<br>rvalue ref ctor, FunctionType: std::reference_wrapper&lt;Functor&gt;, fn type: std::reference_wrapper&lt;Functor&gt; &amp;&amp;<br>construct ScopeGuardImplBase, dismissed: 0<br>private ctor, Fn type: const Functor &amp;, fn type: const Functor &amp;<br>dtor, FunctionType: std::reference_wrapper&lt;Functor&gt;, function_ type: std::reference_wrapper&lt;Functor&gt;<br>const lvalue ref ctor, FunctionType: Functor, fn type: Functor &amp;<br>dtor, FunctionType: Functor, function_ type: Functor<br>size=1<br></code></pre></td></tr></table></figure><p>此时可以看到成功构造出了两个<code>ScopeGuardImpl</code>对象，一个模板实参为<code>Functor</code>，一个模板实参为<code>std::reference_wrapper&lt;Functor&gt;</code>。由于我们的代码在执行期间没有抛异常，故垃圾清理函数没有被执行，符合预期。</p><p>我们再让执行期间随便抛一个异常来试试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Functor</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Functor</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends)</span> : friends_(friends) &#123;</span>&#125;<br><br>    <span class="hljs-built_in">Functor</span>(<span class="hljs-type">const</span> Functor &amp;rhs) : <span class="hljs-built_in">friends_</span>(rhs.friends_) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123; friends_.<span class="hljs-built_in">pop_back</span>(); &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unexcepted</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;oops...&quot;</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;friends)</span> </span>&#123;<br>    friends.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-function">Functor <span class="hljs-title">f</span><span class="hljs-params">(friends)</span></span>;<br>    <span class="hljs-keyword">auto</span> guard = <span class="hljs-built_in">makeGuard</span>(f);<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;oops...&quot;</span>);<br>    guard.<span class="hljs-built_in">dismiss</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">false_type makeFailsafe, Fn type: Functor, fn type: Functor *<br>true_type makeFailsafe<br>construct ScopeGuardImplBase, dismissed: 0<br>construct ScopeGuardImplBase, dismissed: 0<br>private ctor, Fn type: std::reference_wrapper&lt;Functor&gt;, fn type: std::reference_wrapper&lt;Functor&gt; &amp;&amp;<br>rvalue ref ctor, FunctionType: std::reference_wrapper&lt;Functor&gt;, fn type: std::reference_wrapper&lt;Functor&gt; &amp;&amp;<br>construct ScopeGuardImplBase, dismissed: 0<br>private ctor, Fn type: const Functor &amp;, fn type: const Functor &amp;<br>dtor, FunctionType: std::reference_wrapper&lt;Functor&gt;, function_ type: std::reference_wrapper&lt;Functor&gt;<br>const lvalue ref ctor, FunctionType: Functor, fn type: Functor &amp;<br>dtor, FunctionType: Functor, function_ type: Functor<br>exception: oops...<br>size=0<br></code></pre></td></tr></table></figure><p>垃圾函数还是得到了正确的执行，此时如果在dtor中打印<code>dismissed_</code>字段，就会发现是<code>ScopeGuardImpl&lt;Functor&gt;</code>的析构函数执行了垃圾清理。</p><p>我们把<code>Functor</code>的copyctor标记为<code>noexcept</code>试试： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Functor</span>(<span class="hljs-type">const</span> Functor &amp;rhs) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">friends_</span>(rhs.friends_) &#123; &#125;<span class="hljs-comment">//throw std::runtime_error(&quot;throw exception in Functor copy ctor...&quot;); &#125;</span><br></code></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">true_type makeFailsafe<br>construct ScopeGuardImplBase, dismissed: 0<br>construct ScopeGuardImplBase, dismissed: 0<br>private ctor, Fn type: const Functor &amp;, fn type: const Functor &amp;<br>const lvalue ref ctor, FunctionType: Functor, fn type: Functor &amp;<br>dtor, FunctionType: Functor, function_ type: Functor<br>exception: oops...<br>size=0<br></code></pre></td></tr></table></figure><p>通过log可以看出，此时走得就是简单路线，匹配的依然是const lvaluereference参数版本的ctor。</p><h4 id="用例2右值引用">用例2：右值引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Functor</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Functor</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends)</span> : friends_(friends) &#123;</span>&#125;<br><br>    <span class="hljs-built_in">Functor</span>(<span class="hljs-type">const</span> Functor &amp;rhs) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">friends_</span>(rhs.friends_) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Functor copy ctor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-built_in">Functor</span>(Functor &amp;&amp;rhs) : <span class="hljs-built_in">friends_</span>(rhs.friends_) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Functor move ctor&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;oops, runtime error in Functor move ctor&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123; friends_.<span class="hljs-built_in">pop_back</span>(); &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;friends)</span> </span>&#123;<br>    friends.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-function">Functor <span class="hljs-title">f</span><span class="hljs-params">(friends)</span></span>;<br>    <span class="hljs-keyword">auto</span> guard = <span class="hljs-built_in">makeGuard</span>(std::<span class="hljs-built_in">move</span>(f));<br>    guard.<span class="hljs-built_in">dismiss</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::vector&lt;<span class="hljs-type">int</span>&gt; friends;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">func</span>(friends);<br>  &#125;<span class="hljs-built_in">catch</span>(std::exception &amp;ex) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;exception: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>  &#125;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;size=&quot;</span> &lt;&lt; friends.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行log：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">false_type makeFailsafe, Fn type: Functor, fn type: Functor *<br>true_type makeFailsafe<br>construct ScopeGuardImplBase, dismissed: 0<br>construct ScopeGuardImplBase, dismissed: 0<br>private ctor, Fn type: std::reference_wrapper&lt;Functor&gt;, fn type: std::reference_wrapper&lt;Functor&gt; &amp;&amp;<br>rvalue ref ctor, FunctionType: std::reference_wrapper&lt;Functor&gt;, fn type: std::reference_wrapper&lt;Functor&gt; &amp;&amp;<br>construct ScopeGuardImplBase, dismissed: 0<br>Functor move ctor<br>dtor, FunctionType: std::reference_wrapper&lt;Functor&gt;, function_ type: std::reference_wrapper&lt;Functor&gt;<br>exception: oops, runtime error in Functor move ctor<br>size=0<br></code></pre></td></tr></table></figure><p>在构造外层<code>ScopeGuardImpl</code>对象时，由于<code>Functor</code>的movector抛出了异常，最终垃圾清理函数实际上是内层的<code>ScopeGuardImpl</code>对象所执行。</p><p>若移除movector的异常，且标记为noexcept，则最终走的是情景一的简单路径：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Functor</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Functor</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends)</span> : friends_(friends) &#123;</span>&#125;<br><br>    <span class="hljs-built_in">Functor</span>(<span class="hljs-type">const</span> Functor &amp;rhs) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">friends_</span>(rhs.friends_) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Functor copy ctor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-built_in">Functor</span>(Functor &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">friends_</span>(rhs.friends_) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Functor move ctor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123; friends_.<span class="hljs-built_in">pop_back</span>(); &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unexcepted</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;oops...&quot;</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;friends)</span> </span>&#123;<br>    friends.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-function">Functor <span class="hljs-title">f</span><span class="hljs-params">(friends)</span></span>;<br>    <span class="hljs-keyword">auto</span> guard = <span class="hljs-built_in">makeGuard</span>(std::<span class="hljs-built_in">move</span>(f));<br>    <span class="hljs-built_in">unexcepted</span>();<br>    guard.<span class="hljs-built_in">dismiss</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行log：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">true_type makeFailsafe<br>construct ScopeGuardImplBase, dismissed: 0<br>construct ScopeGuardImplBase, dismissed: 0<br>Functor move ctor<br>private ctor, Fn type: Functor, fn type: Functor &amp;&amp;<br>rvalue ref ctor, FunctionType: Functor, fn type: Functor &amp;&amp;<br>dtor, FunctionType: Functor, function_ type: Functor<br>exception: oops...<br>size=0<br></code></pre></td></tr></table></figure><h3 id="登峰造极精益求精">登峰造极，精益求精</h3><p>到此，<code>ScopeGuard</code>的改良已经解决了我们的第一个顽疾，现在我们要面对第二个问题：如果垃圾清理器在执行过程中可能会抛出异常，我们应该怎么办？</p><p>其实这个问题反倒好处理，因为这单纯就是一个设计问题，毕竟我们总不能一直递归套娃下去。Folly库给出的解法也非常简单：概不负责，自行买单！</p><p>尽管是自行买单，但Folly在设计上为了精优化性能，还是允许用户传递一个非类型模板参数<code>InvokeNoexcept</code>给到<code>ScopeGuardImpl</code>，若其为true，则表示用户已承诺绝不会抛出异常，此时，如果清理器还是执行中抛了异常，那么会在程序终止之前，打印一些关键的错误信息，以示友好。</p><blockquote><p>C++的noexcept只是个标记，他告诉编译期它不会抛异常，但不代表它真的不会抛异常，只不过它一旦抛了异常，就会导致进程终止。</p></blockquote><p>另一方面，为了精优化性能，我们还可以选择性的设计各个成员函数的noexcept标记：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_name.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeGuardImplBase</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dismiss</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; dismissed_ = <span class="hljs-literal">true</span>; &#125;<br>  <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">ScopeGuardImplBase</span>(<span class="hljs-type">bool</span> dismissed = <span class="hljs-literal">false</span>) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">dismissed_</span>(dismissed) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">terminate</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>      std::ios_base::Init ioInit;<br>      std::cerr &lt;&lt; <span class="hljs-string">&quot;This program will now terminate because a ScopeGuard callback threw an \nexception.\n&quot;</span>;<br>      std::<span class="hljs-built_in">rethrow_exception</span>(std::<span class="hljs-built_in">current_exception</span>());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> ScopeGuardImplBase <span class="hljs-title">makeEmptyScopeGuard</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> ScopeGuardImplBase&#123;&#125;;<br>    &#125;<br>  <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">bool</span> dismissed_;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> FunctionType, <span class="hljs-type">bool</span> InvokeNoexcept&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeGuardImpl</span> : <span class="hljs-keyword">public</span> ScopeGuardImplBase &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(FunctionType&amp; fn)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(std::is_nothrow_copy_constructible&lt;FunctionType&gt;::value)</span></span><br><span class="hljs-function">        : ScopeGuardImpl(std::as_const(fn), makeFailsafe(std::is_nothrow_copy_constructible&lt;FunctionType&gt;&#123;</span>&#125;, &amp;fn)) &#123;<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionType&amp; fn)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(std::is_nothrow_copy_constructible&lt;FunctionType&gt;::value)</span></span><br><span class="hljs-function">        : ScopeGuardImpl(fn, makeFailsafe(std::is_nothrow_copy_constructible&lt;FunctionType&gt;&#123;</span>&#125;, &amp;fn)) &#123;<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(FunctionType&amp;&amp; fn)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(std::is_nothrow_move_constructible&lt;FunctionType&gt;::value)</span></span><br><span class="hljs-function">        : ScopeGuardImpl(std::move_if_noexcept(fn), makeFailsafe(std::is_nothrow_move_constructible&lt;FunctionType&gt;&#123;</span>&#125;, &amp;fn)) &#123;<br>        &#125;<br><br>    <span class="hljs-built_in">ScopeGuardImpl</span>(ScopeGuardImpl&amp;&amp; other) <span class="hljs-built_in">noexcept</span>(std::is_nothrow_move_constructible&lt;FunctionType&gt;::value)<br>        : <span class="hljs-built_in">function_</span>(std::<span class="hljs-built_in">move_if_noexcept</span>(other.function_)) &#123;<br>      dismissed_ = std::<span class="hljs-built_in">exchange</span>(other.dismissed_, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">ScopeGuardImpl</span>() <span class="hljs-built_in">noexcept</span>(InvokeNoexcept) &#123;<br>      <span class="hljs-keyword">if</span> (!dismissed_) &#123;<br>        <span class="hljs-built_in">execute</span>();<br>      &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> ScopeGuardImplBase <span class="hljs-title">makeFailsafe</span><span class="hljs-params">(std::true_type, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">makeEmptyScopeGuard</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Fn&gt;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">makeFailsafe</span><span class="hljs-params">(std::false_type, Fn* fn)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">        -&gt; ScopeGuardImpl&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(std::ref(*fn))</span>, InvokeNoexcept&gt; </span>&#123;<br>      <span class="hljs-keyword">return</span> ScopeGuardImpl&lt;<span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">ref</span>(*fn)), InvokeNoexcept&gt;&#123;std::<span class="hljs-built_in">ref</span>(*fn)&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Fn&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(Fn&amp;&amp; fn, ScopeGuardImplBase&amp;&amp; failsafe)</span></span><br><span class="hljs-function">      : ScopeGuardImplBase&#123;</span>&#125;, <span class="hljs-built_in">function_</span>(std::forward&lt;Fn&gt;(fn)) &#123;<br>      failsafe.<span class="hljs-built_in">dismiss</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(InvokeNoexcept)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (InvokeNoexcept) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-built_in">function_</span>();<br>        &#125; <span class="hljs-built_in">catch</span>(std::exception &amp;e) &#123;<br>          <span class="hljs-built_in">terminate</span>();<br>        &#125;<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">function_</span>();<br>      &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    FunctionType function_;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-type">bool</span> INE&gt;<br><span class="hljs-keyword">using</span> ScopeGuardImplDecay = ScopeGuardImpl&lt;std::<span class="hljs-type">decay_t</span>&lt;F&gt;, INE&gt;;<br><br><span class="hljs-comment">// makeGuard在设计上使用InvokeNoexcept=true，这也符合使用者的期望</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F&gt;<br><span class="hljs-function">ScopeGuardImplDecay&lt;F, <span class="hljs-literal">true</span>&gt; <span class="hljs-title">makeGuard</span><span class="hljs-params">(F&amp;&amp; f)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">noexcept</span>(ScopeGuardImplDecay&lt;F, <span class="hljs-literal">true</span>&gt;(</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">static_cast</span>&lt;F&amp;&amp;&gt;(f))))</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ScopeGuardImplDecay&lt;std::<span class="hljs-type">decay_t</span>&lt;F&gt;, <span class="hljs-literal">true</span>&gt;(std::forward&lt;F&gt;(f));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到代码里又补充了很多细节调优，诸如对<code>noexcept</code>的处理、将<code>std::move</code>换成更保守的<code>std::move_if_noexcept</code>等等。</p><p>现在让我们来当一次猪比，故意传一个会抛异常的清理器进去：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Functor</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Functor</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends)</span> : friends_(friends) &#123;</span>&#125;<br><br>    <span class="hljs-built_in">Functor</span>(<span class="hljs-type">const</span> Functor &amp;rhs) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">friends_</span>(rhs.friends_) &#123;<br>    &#125;<br>    <span class="hljs-built_in">Functor</span>(Functor &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">friends_</span>(rhs.friends_) &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123; friends_.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;oops, runtime error in cleaner...&quot;</span>); &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; friends_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unexcepted</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;oops...&quot;</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;friends)</span> </span>&#123;<br>    friends.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-function">Functor <span class="hljs-title">f</span><span class="hljs-params">(friends)</span></span>;<br>    <span class="hljs-keyword">auto</span> guard = <span class="hljs-built_in">makeGuard</span>(std::<span class="hljs-built_in">move</span>(f));<br>    <span class="hljs-built_in">unexcepted</span>();<br>    guard.<span class="hljs-built_in">dismiss</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::vector&lt;<span class="hljs-type">int</span>&gt; friends;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">func</span>(friends);<br>  &#125;<span class="hljs-built_in">catch</span>(std::exception &amp;ex) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;exception: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>  &#125;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;size=&quot;</span> &lt;&lt; friends.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>执行结果： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">This program will now terminate because a ScopeGuard callback threw an<br>exception.<br>libc++abi: terminating due to uncaught exception of type std::runtime_error: oops, runtime error in cleaner...<br>[<span class="hljs-number">1</span>]    <span class="hljs-number">11720</span> abort      ./scope<br></code></pre></td></tr></table></figure></p><p>可以看到进程确实终止了，也如愿打印了<code>terminate()</code>中的友好信息。</p><h2 id="倒行逆施makedismissedguard">倒行逆施：makeDismissedGuard</h2><p>我们还可以对当前的设计做一些补充，比如支持反向操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ScopeGuardDismissed</span> &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeGuardImplBase</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dismiss</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; dismissed_ = <span class="hljs-literal">true</span>; &#125;<br>  <span class="hljs-comment">// 增加一个rehire函数，和dismiss作用相反</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rehire</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; dismissed_ = <span class="hljs-literal">false</span>; &#125;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-built_in">ScopeGuardImplBase</span>(<span class="hljs-type">bool</span> dismissed = <span class="hljs-literal">false</span>) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">dismissed_</span>(dismissed) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">static</span> ScopeGuardImplBase <span class="hljs-title">makeEmptyScopeGuard</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ScopeGuardImplBase&#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-type">bool</span> dismissed_;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> FunctionType, <span class="hljs-type">bool</span> InvokeNoexcept&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeGuardImpl</span> : <span class="hljs-keyword">public</span> ScopeGuardImplBase &#123; <br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">// 增加一个构造器，初始化dismissed_=true</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardImpl</span><span class="hljs-params">(FunctionType&amp;&amp; fn, ScopeGuardDismissed)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      std::is_nothrow_move_constructible&lt;FunctionType&gt;::value)</span></span><br><span class="hljs-function">      : ScopeGuardImplBase&#123;</span><span class="hljs-literal">true</span>&#125;, <span class="hljs-built_in">function_</span>(std::forward&lt;FunctionType&gt;(fn)) &#123;&#125;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F&gt;<br><span class="hljs-function">ScopeGuardImplDecay&lt;F, <span class="hljs-literal">true</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">makeDismissedGuard</span><span class="hljs-params">(F&amp;&amp; f)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">noexcept</span>(ScopeGuardImplDecay&lt;F, <span class="hljs-literal">true</span>&gt;(std::forward&lt;F&gt;(f), ScopeGuardDismissed&#123;&#125;)))</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ScopeGuardImplDecay</span>&lt;F, <span class="hljs-literal">true</span>&gt;(std::forward&lt;F&gt;(f), ScopeGuardDismissed&#123;&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>配合<code>rehire</code>接口，<code>makeDismissedGuard</code>就可以实现反向操作：如果遭遇了异常，则不执行传入的Functor；若一切顺利，反而会执行。</p><h2 id="defer优雅永不过时">defer：优雅，永不过时</h2><p><code>makeGuard()</code>+<code>dismiss()</code>和<code>makeDismissedGuard()</code>+<code>rehire()</code>的结对编程法已经很漂亮了，但Folly库的实现还不止于此，我们还可以用ScopeGuard来实现类似golang的defer：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//  Example: </span><br><span class="hljs-comment">/* open scope */</span> &#123;<br>  <span class="hljs-type">some_resource_t</span> resource;<br>  <span class="hljs-built_in">some_resource_init</span>(resource);<br>  SCOPE_EXIT &#123; <span class="hljs-built_in">some_resource_fini</span>(resource); &#125;;<br>  <span class="hljs-comment">// 执行过SOPE_EXIT宏过后，无论后面的语句是否会抛出异常，在离开末尾作用域后都会执行后接的块语句</span><br>  <span class="hljs-keyword">if</span> (!cond)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// the cleanup happens at end of the scope</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// the cleanup happens at end of the scope</span><br><br>  <span class="hljs-built_in">use_some_resource</span>(resource); <span class="hljs-comment">// may throw; cleanup will happen</span><br>&#125; <span class="hljs-comment">/* close scope */</span><br></code></pre></td></tr></table></figure><p>怎样设计才能实现这一自制语法糖呢？且看Folly的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> detail &#123;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">ScopeGuardOnExit</span> &#123;&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> FunctionType&gt;<br>ScopeGuardImpl&lt;std::<span class="hljs-type">decay_t</span>&lt;FunctionType&gt;, <span class="hljs-literal">true</span>&gt; <span class="hljs-keyword">operator</span>+(ScopeGuardOnExit, FunctionType&amp;&amp; fn) &#123;<br>  <span class="hljs-keyword">return</span> ScopeGuardImpl&lt;std::<span class="hljs-type">decay_t</span>&lt;FunctionType&gt;, <span class="hljs-literal">true</span>&gt;(std::forward&lt;FunctionType&gt;(fn));<br>&#125;<br>&#125; <span class="hljs-comment">// namespace detail</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONCATENATE_IMPL(s1, s2) s1##s2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONCATENATE(s1, s2) CONCATENATE_IMPL(s1, s2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANONYMOUS_VARIABLE(str) \</span><br><span class="hljs-meta">  CONCATENATE(CONCATENATE(CONCATENATE(str, __COUNTER__), _), __LINE__)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCOPE_EXIT      \</span><br><span class="hljs-meta">  auto ANONYMOUS_VARIABLE(SCOPE_EXIT_STATE) = \</span><br><span class="hljs-meta">    detail::ScopeGuardOnExit() + [&amp;]() noexcept</span><br></code></pre></td></tr></table></figure><p>可以看到<code>SCOPE_EXIT</code>宏的实现借用了运算符重载，通过在内部定义一个新类型<code>ScopeGuardOnExit</code>并重载它的<code>operator+</code>操作符，用右操作数<code>fn</code>来最终构造出<code>ScopeGuardImpl</code>对象。而右操作数实际上是一个lambda对象，它使用引用捕获，示例代码中编写的花括号体实际上是这个匿名lambda对象的body。实际上这里重载哪个运算符是自由的，不一定非要选择<code>operator+</code>，只要能和宏定义衔接上即可。</p><p>另一方面，SCOPE_EXIT可以有复数个，也可以嵌套定义。对于前者来说，由于离开作用域后局部变量对象的析构顺序与定义时是逆序的，因此它也达成了像是go中多个defer的逆序执行效果；对于后者来说，嵌套本身就是支持的，因为局部变量的生命期只和它所在的外层作用域绑定。</p><h3 id="其他的变种实现">其他的变种实现</h3><p>略加变化，我们还可以实现其他变种，比如<code>SCOPE_FAIL</code>,<code>SCOPE_SUCCESS</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//  SCOPE_FAIL</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  May be useful in situations where the caller requests a resource where</span><br><span class="hljs-comment">//  initializations of the resource is multi-step and may fail.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Example:</span><br><span class="hljs-comment">// </span><br>&#123;<br>      <span class="hljs-type">some_resource_t</span> resource;<br>      <span class="hljs-built_in">some_resource_init</span>(resource);<br>      SCOPE_FAIL &#123; <span class="hljs-built_in">some_resource_fini</span>(resource); &#125;;<br><br>      <span class="hljs-keyword">if</span> (do_throw)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// the cleanup happens at the end of the scope</span><br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> resource; <span class="hljs-comment">// the cleanup does not happen</span><br>&#125;<br><br><span class="hljs-comment">//  SCOPE_SUCCESS</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  In a sense, the opposite of SCOPE_FAIL.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Example:</span><br><span class="hljs-comment">//</span><br>&#123;<br>      folly::stop_watch&lt;&gt; watch;<br>      SCOPE_FAIL &#123; <span class="hljs-built_in">log_failure</span>(watch.<span class="hljs-built_in">elapsed</span>(); &#125;;<br>      SCOPE_SUCCESS &#123; <span class="hljs-built_in">log_success</span>(watch.<span class="hljs-built_in">elapsed</span>(); &#125;;<br><br>      <span class="hljs-keyword">if</span> (do_throw)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// the cleanup does not happen; log failure</span><br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// the cleanup happens at the end of the scope; log success</span><br>&#125;<br></code></pre></td></tr></table></figure><p>相比于<code>makeGuard()</code>+<code>dismiss()</code>和<code>makeDismissedGuard()</code>+<code>rehire()</code>的结对编程，这两位更是极尽优雅。</p><p>在实现上也与<code>SCOPE_EXIT</code>类似，只不过它需要额外捕获当前上下文内exception处理的状态，这是<code>ScopeGuardImpl</code>所不具备的能力，因此需要再封装一层：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> detail &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ScopeGuard used for executing a function when leaving the current scope</span><br><span class="hljs-comment"> * depending on the presence of a new uncaught exception.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If the executeOnException template parameter is true, the function is</span><br><span class="hljs-comment"> * executed if a new uncaught exception is present at the end of the scope.</span><br><span class="hljs-comment"> * If the parameter is false, then the function is executed if no new uncaught</span><br><span class="hljs-comment"> * exceptions are present at the end of the scope.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Used to implement SCOPE_FAIL and SCOPE_SUCCESS below.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> FunctionType, <span class="hljs-type">bool</span> ExecuteOnException&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeGuardForNewException</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardForNewException</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionType&amp; fn)</span> : guard_(fn) &#123;</span>&#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ScopeGuardForNewException</span><span class="hljs-params">(FunctionType&amp;&amp; fn)</span></span><br><span class="hljs-function">      : guard_(std::move(fn)) &#123;</span>&#125;<br><br>  <span class="hljs-built_in">ScopeGuardForNewException</span>(ScopeGuardForNewException&amp;&amp; other) = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-comment">// 在dtor中对比初始化期间和当前的异常处理情况，来决定是否对组合的ScopeGuardImpl对象执行dismiss</span><br>  <span class="hljs-comment">// ExecuteOnException是个mask</span><br>  ~<span class="hljs-built_in">ScopeGuardForNewException</span>() <span class="hljs-built_in">noexcept</span>(ExecuteOnException) &#123;<br>    <span class="hljs-keyword">if</span> (ExecuteOnException != (exceptionCounter_ &lt; std::<span class="hljs-built_in">uncaught_exceptions</span>())) &#123;<br>      guard_.<span class="hljs-built_in">dismiss</span>();<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span> </span>= <span class="hljs-keyword">delete</span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> </span>= <span class="hljs-keyword">delete</span>;<br><br>  ScopeGuardImpl&lt;FunctionType, ExecuteOnException&gt; guard_;<br>  <span class="hljs-type">int</span> exceptionCounter_&#123;std::<span class="hljs-built_in">uncaught_exceptions</span>()&#125;;<br>&#125;;<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">ScopeGuardOnFail</span> &#123;&#125;;<br><br><span class="hljs-comment">// 设置mask：ExecuteOnException = true</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> FunctionType&gt;<br>ScopeGuardForNewException&lt;std::<span class="hljs-type">decay_t</span>&lt;FunctionType&gt;, <span class="hljs-literal">true</span>&gt;<br><span class="hljs-keyword">operator</span>+(detail::ScopeGuardOnFail, FunctionType&amp;&amp; fn) &#123;<br>  <span class="hljs-keyword">return</span> ScopeGuardForNewException&lt;<br>      <span class="hljs-keyword">typename</span> std::decay&lt;FunctionType&gt;::type,<br>      <span class="hljs-literal">true</span>&gt;(std::forward&lt;FunctionType&gt;(fn));<br>&#125;<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">ScopeGuardOnSuccess</span> &#123;&#125;;<br><br><span class="hljs-comment">// 设置mask：ExecuteOnException = false</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> FunctionType&gt;<br>ScopeGuardForNewException&lt;std::<span class="hljs-type">decay_t</span>&lt;FunctionType&gt;, <span class="hljs-literal">false</span>&gt;<br><span class="hljs-keyword">operator</span>+(ScopeGuardOnSuccess, FunctionType&amp;&amp; fn) &#123;<br>  <span class="hljs-keyword">return</span> ScopeGuardForNewException&lt;<br>      std::<span class="hljs-type">decay_t</span>&lt;FunctionType&gt;,<br>      <span class="hljs-literal">false</span>&gt;(std::forward&lt;FunctionType&gt;(fn));<br>&#125;<br><br>&#125; <span class="hljs-comment">// namespace detail</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCOPE_FAIL                               \</span><br><span class="hljs-meta">  auto ANONYMOUS_VARIABLE(SCOPE_FAIL_STATE) = \</span><br><span class="hljs-meta">      detail::ScopeGuardOnFail() + [&amp;]() noexcept</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCOPE_SUCCESS                               \</span><br><span class="hljs-meta">  auto ANONYMOUS_VARIABLE(SCOPE_SUCCESS_STATE) = \</span><br><span class="hljs-meta">      detail::ScopeGuardOnSuccess() + [&amp;]()</span><br></code></pre></td></tr></table></figure><p>一目了然的设计，伟大，无需多言。</p><p>注：在<code>ScopeGuardForNewException</code>设计中还可以看到设计者删除了operatornew/delete的接口，这也是一个细节，因为ScopeGuardImpl在使用上就是作为一个栈空间临时变量对象而存在，它本就不应该被分配在堆空间上，为了避免误用，也就删除了这两个运算符。实际上，在ScopeGuardImpl的源代码里也做了一样的操作，只是前文中为了更紧凑的叙述才没写而已。</p><h2 id="总结">总结</h2><p>到此，ScopeGuard源码的剖析就圆满结束了，奇怪的知识又增加了！值得注意的是：行文中的代码和Folly源代码的实现会有些细微差别，一些平台/语言标准版本的兼容代码也被我简化了，一些细节处也统一用了C++17的惯用法。</p><p>拜读大师级作品，掌握C++黑魔法，<del>以雷霆、击碎黑暗！</del></p><h2 id="参考链接">参考链接</h2><ul><li><a href="https://github.com/facebook/folly">facebook/folly</a></li><li><a href="http://drdobbs.com/184403758">Generic: Change the Way YouWrite Exception-Safe Code — Forever</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>cpp-templates</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>还在嘴硬？Trie树没你想得那么简单</title>
    <link href="/2023/11/01/%E8%BF%98%E5%9C%A8%E5%98%B4%E7%A1%AC%EF%BC%9FTrie%E6%A0%91%E6%B2%A1%E4%BD%A0%E6%83%B3%E5%BE%97%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95/"/>
    <url>/2023/11/01/%E8%BF%98%E5%9C%A8%E5%98%B4%E7%A1%AC%EF%BC%9FTrie%E6%A0%91%E6%B2%A1%E4%BD%A0%E6%83%B3%E5%BE%97%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<p>Trie树，又称前缀树或字典树，在数据结构领域赫赫有名。相信多数人认识Trie的机缘，要么是通过OI，要么是在工作中遇到过Trie发光发热的场景。传统Trie结构并不复杂，但其实现与变种却是八仙过海各显神通。本文从Trie讲起，紧紧抓住核心的性能与空间占用，对Trie主流的几种实现进行了阐述，同时自己也真实地跑一遍benchmark，对各家吹逼的论文去伪存真。</p><span id="more"></span><h1id="还在嘴硬trie树没你想得那么简单">还在嘴硬？Trie树没你想得那么简单</h1><p>Trie树，又称前缀树或字典树，相信对于大部分业界同仁来说并不陌生。尽管Trie树在数据结构领域称得上赫赫有名，但科班教材却鲜有提及，相信多数人认识Trie的机缘，要么是通过OI，要么是在工作中遇到过Trie发光发热的场景。</p><p>对Trie有一定了解的同学，往往会觉着：“不就是一种简单易懂的数据结构吗，有啥好长篇大论的？”实话实说，作为端茶倒水型OI老混子，我也一度这样认为。然而，最近工作中在研究搜索联想词(suggestion)背后的各种索引时，意外的发现Trie大有门道，它的工业级实现也绝不像OI的模板那么随性（只是个演示demo，生产环境没人用）。</p><p>本文会从最基础的Trie谈起，围绕性能与空间占用，一步步抽丝剥茧层层递进，对业界知名的几种Trie实现进行详细展开，并尝试解读为什么会这样设计，知其然，并知其所以然。然后，再给出基于业界知名的开源Trie实现库所进行的benchmark数据，并进行分析。最后，对Trie的常见应用以及衍生的数据结构进行介绍。</p><h2 id="字典树前缀树trie">字典树/前缀树/Trie</h2><p>顾名思义，字典树，是一个像查字典一样的树形结构，一般来说，我们会选择字符串作为键(key)，并非像二叉搜索树那样直接保存到每一个树节点，在字典树中，键会被打散分布于一条树链上。</p><p>例如，我们用键集：<code>&#123;"romane","romanes","romanus","romulus","rubens","ruber","rubes","rubicon","rubicundus","rubric"&#125;</code>，构建一棵传统Trie：</p><p><img src="2023-11-01-19-31-00.png" /></p><p>如图所示，从根节点开始，任选一条到叶子结点的树链，这条路径上的字符所组成的字符串对应了集合中的特定键，此树一共有10个叶子节点，分别对应10个键。图中的叶子结点是个哨兵，它不存储任何字符，只是单纯代表字符串的终止。</p><p>Trie最基础的应用就是字符串的查找——判断某个字符串是否在字典中。当我们需要查找某个字符串是否存在于key集时，只需要逐字符match，层层递进，如果在遍历到最后一个字符时可以命中叶子节点，那么就代表它存在，否则在中途中任何一步没能match，就代表不存在。</p><blockquote><p>正因为这一典型应用，Trie又叫字典树。实际上，除了判断字符串是否存在，我们还可以在这个基础上，利用Trie做词频统计。只需要在每个叶子节点的值域存储一个计数器即可。词频统计正是Trie的常见应用场景之一。</p></blockquote><p>这样的结构就像是一棵K叉树，我们在检索字符串的过程中，途径每层都在做同一件事：判断当前的父节点是否存在待检索字符所对应的子节点，如果有就递归向下，没有就终止。我们可以发现，具有相同前缀的字符串，它们在树中会共享非叶子节点，相比于用哈希表去存储全量键集，Trie得益于共享前缀的特性，体积的缩小肉眼可见。</p><blockquote><p>哈希表当然可以完成判断字符串是否在字典中的任务，查询的时间复杂度是O(1)，这意味着它的查找很快，显然，这是用空间换来的。</p></blockquote><p>相比于哈希表，Trie的查询速度显然劣势，Trie牺牲了时间去换取了大量的空间节省，它的时间复杂度是<code>O(len)</code>，其中<code>len</code>表示查询字符串的长度。当然，时间复杂度反应的只是曲线随数据规模增长的快慢程度，真实的查询性能差异需要用具体的键集跑真实benchmark才能知晓。对于Trie树来说，真正影响查询速度的，实际上有很多因素。另一方面，我们总说相比于哈希表，Trie树更省空间，那么究竟能省多少呢？实际上，这又取决于Trie的具体实现。</p><h2 id="状态转移与dfa">状态转移与DFA</h2><p>实际上Trie的本质是一个DFA（确定有限状态自动机），拆分的键字符可以看作是边，而节点到子节点的过程就是一种状态转移（第i行第j列的值表示在状态i的情况下输入字符j的时候的目标状态）。比如，维基百科对Trie的几何描述图如下：</p><p><img src="2023-11-02-14-32-10.png" /></p><p>键标注在节点内，边上的字符表示状态的转移，右下角带有数字的节点表示这是一个终止节点（不同于哨兵节点的表达方式，在每个树节点可以用一个标记来代表他是否是终止节点）。另一方面，键实际上不需要显式地保存在树节点中，上图只是为了方便理解TrieDFA的本质而做的演示。</p><p>到此，我们就来到Trie树中最核心的问题：<strong>每个树节点要如何维护它可能存在的K个儿子呢？K的上限值又是多少呢？</strong></p><h3 id="k与字符集">K与字符集</h3><p>我们先来回答比较简单的第二个问题：K的上限值。</p><p>容易想到，K取决于键集中所有不重复字符的数量，因此，最终看的是构成键集的成分。比如，对于全部小写英文字符构成的键集，K就是26；扩展到ASCII，K的上限就是128（实际上很多控制字符一般不会出现）。</p><p>而日常需求中，比如搜索联想词场景，构成键集的都是一些中英文混杂字符串，汉字成千上万，如果我们维护万级别的状态转移表，不论采用何种表达方式，都无疑是一场灾难。那么退一步想想，我们平时存储这些中文字符串时，都是如何存储的呢？这取决于具体的编码方式。比如对于UTF8，不同的字符可能需要1~3个字节来进行编码，我们在构建Trie树时可以按字节作为步长来拆分键，如此，K的上限就是256。</p><p>举个例子，比如对于键<code>QQ号码</code>，它被UTF8编码为<code>0x51 0x51 0x53 0xf7 0x78 0x01</code>，字符<code>Q</code>占一个字节，编码为<code>0x51</code>，后面的汉字则各占两个字节。当我们构建Trie时，就会形成一条由6个节点构成的树链（不考虑哨兵）。</p><p>显然，我们通过编码解决了K可能过大的问题，而代价就是增加了树的深度，速度变慢。实际上，编码只是一种具体手段，它的本质是一种叫做“字母表缩减”的思想，通过控制字母表的大小来限制K的量级，在速度与量级上做tradeoff。</p><h3 id="转移矩阵与链式存储">转移矩阵与链式存储</h3><p>再回到第一个问题：树节点如何维护它的儿子。</p><p>DFA通常用转移矩阵来表示，行表示状态、列表示输入字符，行列共同表示状态的转移。这就意味着树上每个节点都要维护一个规模为K的数组，此时构成的Trie如下图：</p><p><img src="2023-11-02-15-28-49.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-comment">// array of 128 elements, null if there is no child for the ASCII letter.</span><br>    node* children[<span class="hljs-number">128</span>]; <br>&#125;;<br></code></pre></td></tr></table></figure><p>这种稀疏数组的实现方式查询效率很高，途径每个节点做查询都是<code>O(1)</code>的时间复杂度，但由于稀疏的现象，空间利用率很低。比如上图中的Trie，对于K=26的情况，仅仅索引4个单词，就消耗了肉眼可见的空间。</p><p>当然，我们也可以放弃稀疏数组，采用链式来表示状态转移：</p><p><img src="2023-11-02-15-33-13.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">char</span> symbol;<br>    node* first_child;<br>    node* next_sibiling;<br>&#125;;<br></code></pre></td></tr></table></figure><p>无需K规模数组，每个节点只需要保存两个指针即可：一个指向兄弟(sibling)、一个指向儿子(children)。这下彻底稠密了，空间利用没有丝毫的浪费，但代价就是每个节点的状态转移都需要做一轮线性查询，即<code>O(K)</code>的时间复杂度。此时，字典树的查询时间复杂度变成：<code>O(K*len)</code>。</p><p>我们从一个极端，步入了另一个极端（<del>我叫二极管(bushi)</del>）。</p><h2 id="trie空间优化之道">Trie空间优化之道</h2><p>那么，有没有什么折中的方案，让我们既能节省空间存储，又能兼顾速度呢？</p><p>答案当然是有的，而且是八仙过海，各显神通。</p><h3 id="字母表缩减大法">字母表缩减大法</h3><p>最容易想到的就是利用上一节中提到的<strong>字母表缩减</strong>大法：我们可以按比特来拆分，比如以4bit-16字符的字母表来替代8bit-256字符的字母表，空间存储变为了原本的1/16，代价是树的深度增加一倍，查询耗时变为原本的2倍。</p><p><strong>本质上来讲，这是基于转移矩阵方案，通过平衡字母表大小与树的深度来二者兼顾。</strong></p><h3 id="关联容器">关联容器</h3><p>另一种简单的方案是改用关联容器，把字母编码单元映射到一个子节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-comment">// C++</span><br>    <span class="hljs-comment">// Binary search tree</span><br>    std::map&lt;<span class="hljs-type">char</span>, node*&gt; children;<br>    <br>    <span class="hljs-comment">// Hash table</span><br>    <span class="hljs-comment">// std::unordered_map&lt;char, node*&gt; children;</span><br>    <br>    <span class="hljs-comment">// Sorted array</span><br>    <span class="hljs-comment">// boost::flat_map&lt;char, node*&gt; children;</span><br>    <br>    <br>    <span class="hljs-comment">// Java</span><br>    <span class="hljs-comment">// Binary search tree</span><br>    <span class="hljs-comment">// TreeMap&lt;char, node&gt; children;</span><br>    <br>    <span class="hljs-comment">// Hash table</span><br>    <span class="hljs-comment">// HashMap&lt;char, node&gt; children;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如此，每个节点只需要按需存储转移状态，减少稀疏。关联容器可以选择二叉搜索树、有序数组或是哈希表。</p><ul><li>比如<code>std::map</code>是一种平衡搜索树（红黑树，本质上是2-3-4树），查询时间复杂度为<code>O(logK)</code>（二分查找）。若选用std::map来存储状态转移路径，则字典树的查询时间复杂度为：<code>O(len*logK)</code>。</li><li>再如<code>std::unordered_map</code>是哈希表，查询时间复杂度为<code>O(1)</code>，相比于搜索树，它的性能是用空间的稀疏换来的。若选用<code>std::unordered_map</code>来存储状态转移路径，则字典树的查询时间复杂度为<code>O(len)</code>。</li></ul><p><strong>本质上来讲，这是通过在Trie节点的微观设计上，用关联容器取代顺序容器而做的平衡。</strong></p><h3 id="树链压缩">树链压缩</h3><p>前面的两种思路都是对单个节点的大小下功夫，我们可以换个角度，去尝试减少树的节点个数。观察一开始我们构建的Trie树：</p><p><img src="2023-11-01-19-31-00.png" /></p><p>可以发现其中有很多单一路径，既然是单一路径，那就可以应用链压的思想，对单一路径进行整合，变成：</p><p><img src="2023-11-02-17-21-09.png" /></p><p>核心思路也相当直观：</p><ul><li>懒生成：在构建Trie时，对于插入的字符无需新建节点，而是累积到现有的键上。</li><li>按需分裂：当插入时遇到了有多个儿子的情况，再分裂出两个儿子节点，改写键值。</li></ul><p><img src="2023-11-02-17-31-09.png" /></p><p>链压的思想非常广泛地应用于各种数据结构。而在Trie上的应用所产生的数据结构，一般被称为RadixTree，中文名叫基数树，它也叫压缩前缀树、基数特里树：</p><p><img src="2023-11-03-19-21-58.png" /></p><p>实际上基数树可以理解成一种广义Trie树，它的存储方式和传统的Trie不一样，我们在后文介绍特里树时会提到这种按bit来表达的存储方式。这里限于篇幅，就不对RadixTree继续展开。</p><h2 id="trie实现体的奇思妙想">Trie实现体的奇思妙想</h2><p>以上都是比较常规的优化手法，事实上，在Trie发展的历史长河中，还诞生了诸多奇思妙想的Trie实现手法及其变种。接下来，就让我们逐一欣赏大神们的设计。</p><h3 id="partricia树">Partricia树</h3><p>Patricia树，中文名叫特里树，是压缩二进制Trie的一种特殊实现，它在其表示中利用字符串键的二进制进行编码。树中每个节点都包含一个索引，称为“skipnumber”，它存储节点的分支索引，以避免遍历期间出现空子树。</p><p>例如，由<code>&#123;in,integer,interval,string,structure&#125;</code>构成的Partricia树如下所示：</p><p><img src="2023-11-02-19-16-43.png" /></p><p><img src="2023-11-02-19-17-05.png" /></p><p>与节点相邻的每个索引值代表"skipnumber"——即要决定分支的位的索引，比如<code>string,structure</code>的bit序列从<code>idx=1</code>开始与<code>int,integer,inteval</code>有所不同（前者是1而后者是0），故根节点(0号节点)记录"skip_number=1"，<code>string,structure</code>出现在右子树，<code>int,integer,inteval</code>出现在左子树。而对于1号节点，它的"skip_number=18"，这是因为从第18位开始，<code>in</code>和<code>interval,integer</code>有所区别，故在此处分道扬镳。</p><h4 id="critbit-trie">Critbit Trie</h4><p>CBTrie是Partricia树的Bitwise变种。Bitwise是一种特殊的Trie，可以携带一个bitmap，来高效的按位表示哪些分支是有效的。</p><p>Critbit Trie全名——Critical Bit Trie，criticalbit表示两个串的共同前缀分叉之处的比特。以下我们简称CBTrie。它包括两种类型的节点：</p><ul><li>中间节点：存储critical bit的位置，以及左右两个子树</li><li>叶子节点：存储整个串</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">void</span>* child[<span class="hljs-number">2</span>];     <span class="hljs-comment">// 对于中间节点，指向子节点；对于叶子结点，指向字符串。</span><br>    uint32 byte;        <span class="hljs-comment">// 当前节点匹配的长度</span><br>    uint8 otherbits;    <span class="hljs-comment">// 掩码，用来快速取得不同最高位，查询时用来做分支查找</span><br>                        <span class="hljs-comment">// newotherbits = p[newbyte]^ubytes[newbyte];</span><br>&#125;critbit0_node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">void</span>* root;         <span class="hljs-comment">// 根节点，作为入口</span><br>&#125;critbit0_tree;<br></code></pre></td></tr></table></figure><p>掩码的存在加速了分支的查找，可以通过<code>newotherbits = p[newbyte] ^ ubytes[newbyte];</code>来快速取得不同的最高位，最终决定是往左还是往右。</p><p>此外，如何知晓节点node是一个叶子节点，还是中间节点呢？CBTrie的设计上看起来并没有预留这样一个标志位。实际上，由于指针有按x字节(取决于处理器位数，32位是4，64位就是8)对齐的特性，因此指针的最低位一定是0，本着最大程度利用的原则，CBTrie在设计上用<code>child</code>的最低位来做标志，0表示叶子节点，1表示内部节点，比如，查找的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">critbit0_contains</span><span class="hljs-params">(critbit0_tree*t, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* u)</span> </span>&#123;<br>    <span class="hljs-type">const</span> uint8* ubytes= (<span class="hljs-type">void</span>*)u;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ulen= <span class="hljs-built_in">strlen</span>(u);<br>    uint8* p= t-&gt;root;<br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 内部节点？</span><br>    <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> &amp; (<span class="hljs-type">intptr_t</span>)p )&#123;             <br>        critbit0_node* q = (<span class="hljs-type">void</span>*)(p<span class="hljs-number">-1</span>);  <span class="hljs-comment">// 取得真正的指针</span><br>        uint8 c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(q-&gt;byte &lt; ulen) c = ubytes[q-&gt;byte];<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> direction= (<span class="hljs-number">1</span>+(q-&gt;otherbits|c))&gt;&gt;<span class="hljs-number">8</span>;<br>        p = q-&gt;child[direction];<br>    &#125;<br><span class="hljs-comment">// 叶子节点!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> == <span class="hljs-built_in">strcmp</span>(u, (<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)p);<br>&#125;<br></code></pre></td></tr></table></figure><p>CB Trie的更多内容可以关注：https://cr.yp.to/critbit.html</p><blockquote><p>除Critical Bit Trie外，还有一种与之类似的QPTrie，详见：https://dotat.at/prog/qp/README.html</p></blockquote><h3 id="burst-trie">Burst Trie</h3><p>BurstTrie严格意义上已经不是字典树了，它是字典树的变种（我更愿称之为混血）。它与字典树的主要区别在于，它的叶子结点和中间节点采用了完全不同的数据结构。中间节点依然是常规的Trie节点，但叶子节点被替换成了一个容器：</p><p><img src="2023-11-02-19-49-18.png" /></p><p>容器本身可以选择各种各样的实现方式，比如上图中使用了二叉搜索树（生产环境肯定是用具有平衡能力的搜索树，比如红黑树、AVL或者伸展树）。除了二叉搜索树以外，我们当然也可以用链表、哈希表来作为容器。无非就是在时间与空间上做平衡罢了。</p><p>那么问题来了，在BurstTrie的构建过程中，何时应该分裂出叶子节点和中间节点呢？</p><p>BurstTrie以一个空容器作为起始态，每当新元素插入时，容器的规模随之增长，直到容器被爆裂启发器(burstheuristic)判定为低效时，容器节点发生爆裂：容器节点先创建一个字典树中间节点，取代自己原本的位置，对于容器中的每个元素，以首字母作为新节点，除首字母外剩下的字符添加到新容器中，新容器作为新节点的子节点。如此，一个容器当触发启发器时，就会爆裂成多个容器，并生成一个新的中间节点。这个过程会递归下去，直到全部新容器都满足爆裂启发。</p><p><img src="2023-11-02-19-57-51.png" /></p><p>上图为增加单词romule触发了爆裂启发器后的爆裂过程。</p><p>既然是启发式策略，那么我们应该如何设计这一策略呢？一般来说，有三种常见手法：</p><ol type="1"><li>阈值：最为简单粗暴的手法，只要容器中元素个数超出了阈值，就发生爆裂。</li><li>比例：每个容器记录两个计数器，N表示容器被查询的次数，S表示命中容器中根节点的查询次数（也就是一发入魂，到访问到根节点即止）。当S/N低于某个阈值时，容器就会破裂。</li><li>趋势：创建容器时，分配给容器一个资源量C。每次成功访问时，都会修改资源量。如果访问是直接命中，则增加B作为奖励，否则减少M作为惩罚。当资源量达到0时，就发生爆发。</li></ol><blockquote><p>比例和趋势这两种策略，对于容器的数据结构选用像是伸展树(Splay树)时会更加契合，Splay树会将被频繁访问的节点上移到靠近root的位置，对于不均匀查询的业务场景，选择伸展树会非常有用。</p></blockquote><p>BurstTrie这类混血型数据结构，相当于解除了Trie本身结构的限制，彻底放飞自我，直接用不同的数据结构杂糅来做时间与空间上的tradeoff。</p><h4 id="hat-trie">HAT Trie</h4><p>HAT Trie是一种BurstTrie，它选择用数组型哈希表来作为容器节点的数据结构。</p><p>何为数组型哈希表呢？这个就要从哈希表的碰撞谈起。我们知道哈希表是把不同的元素通过哈希函数（比如，通过最简单的模运算(一般选用一个大质数)）分配到不同的桶当中，然而，总会有不同的键被哈希到相同的桶的情况，那么怎么解决碰撞冲突呢？虽然方法五花八门，但是在生产环境中最常见的解决方案就是——拉链法。即，每个哈希桶都包含一个链表，当发生碰撞时，将新元素插入到链表末尾。</p><blockquote><p>当然，哈希桶也可以用别的结构，比如Java最新的HashMap就用的红黑树。本质上也是时间与空间的tradeoff。</p></blockquote><p>这种简单的拉链法非常好用，但它的主要问题在于对cpucache不友好（链表中不同的节点它们在存储空间上未必连续，cacheline无法一次性装载）。比如C++的<code>std::unordered_map&lt;std::string, int&gt;</code>，当访问链表中的每个节点时，我们需要进行两次解引用操作：一次用来访问下一个节点，一次用来比较自身是否相等。</p><p>数组型哈希表则是在拉链法的基础上进行了改造，他把桶中的所有字符串统一存放在一个大数组当中，而不是由链式管理：</p><p><img src="2023-11-02-20-15-53.png" /></p><p>通过合理的元信息分隔符来管理每一个子串（比如上图中用长度来管理）。另一方面，这一设计也节省了<code>next</code>指针的空间，当然缺陷就是数组的规模会随着字符串的增加，而面临重新分配内存的需求。</p><p>此外，HATTrie对于爆裂的实现还有一些额外的补充：如上图所示，中间节点的不同字符可能存在相同的子容器节点。<code>e</code>和<code>i</code>都指向了同一个数组哈希表。出现这种现象是因为HATTrie的混合爆裂方案：</p><ul><li>容器节点有两种形态，一种是单一型，另一种是混合型。</li><li>混合容器节点可以拥有超过一个的父节点。<ul><li>当从单一节点创建多个混合节点时,需要寻找一个分隔字符，它能尽可能平均的把单一节点分为两部分：所有首字母小于分隔字符的字符串进入左边的混合节点，其他的进入右边的混合节点。</li><li>然后，父节点会对小于分隔字符的字母设置指针指向左侧混合节点，剩下的指向右侧混合节点。注意不同于单一节点,我们在容器中会保留原字符串的首字母，以便于分别出来自于哪个父节点.</li></ul></li></ul><p>HATTrie在设计上也是有明显缺陷的，它的问题在于元素只是近似有序，容器节点中的元素是无序的。这也就意味着，当我们在进行前缀查找时，可能会遭遇两种情况：</p><ol type="1"><li>当查询像是<code>ro</code>时，在向下遍历的过程中，<code>r</code>和<code>o</code>都有中间Trie节点，它的查找和Trie没有什么不同。甚至当我们需要拿到以<code>ro</code>为前缀的所有字符串时，效率上还会大大增加，因为<code>r-&gt;o</code>的容器子节点上的数组型哈希表里的所有元素，都是我们需要的结果，这就可以一次性打包返回。</li><li>而当我们需要查找<code>roma</code>时，在向下遍历的过程中就遇到了麻烦。由于Trie中间节点只到<code>r-&gt;o</code>就中断了，我们不得不在下面的容器节点里进行一次线性的遍历。这一时间复杂度则取决于哈希表的大小上限。</li></ol><p>总的来说，HATTrie在面对短查询前缀请求比较多的场景，在速度和内存占用方面有着相当的优势，在后文也可以看到我们进行的性能评测数据。</p><p>关于HATTrie的实现，可以参考：https://github.com/Tessil/array-hash</p><h3 id="double-array-trie">Double Array Trie</h3><p>回到一开始提到的Trie本质——DFA，而使用转移矩阵实现的Trie，尽管效率上非常优秀，但空间因其稀疏性造成极大浪费。那么有没有什么办法可以直接压缩这个转移矩阵呢？</p><p>事实上，早在1975年，Johnson前辈就提出了用4个数组(default,base,next,check)来表示DFA的方法，可以极大的减少空间浪费。而对Trie来说，可以精简到3个数组，此时，状态转移表的行以重叠的方式分配，使得空闲的单元能够被其他的状态利用，从而减少空间浪费。在1989年，研究者Aoe又提出了3数组表达方式的另一种改进，使得可以仅用两个数组(base,check)来表达Trie树。</p><h4 id="triple-array">Triple Array</h4><p>先来看三数组的Trie实现，三数组Trie由以下三个数组构成：</p><ol type="1"><li>base数组：每个元素都对应Trie中的一个节点。对Trie中任意节点<code>s</code>，<code>node[s]</code>表示该节点在next和check数组中的起始索引，该索引表示节点<code>s</code>在状态转移表中的行号。</li><li>next数组：与check数组协同。Trie中每个节点的状态转移向量存储于next数组中。</li><li>check数组：与next数组协同。用来标记next数组中的元素所属的Trie节点。</li></ol><p>next和check的关系如下：</p><ul><li>状态<code>s</code>在输入字符<code>c</code>时，目标状态为<code>t</code>，那么有:<ul><li><code>check[base[s]+c] = s</code></li><li><code>next[base[s]+c] = t</code></li></ul></li></ul><p>形成的关系如图所示：</p><p><img src="2023-11-03-10-39-05.png" /></p><p>可以看到base数组指向特定的next数组单元格，而next数组单元格存储的是一个基地址，配合偏移量<code>c</code>最终找到目标状态单元格，而该单元格内存储状态<code>t</code>。</p><blockquote><p>状态<code>s</code>不是字符"s"，它代表Trie中任意一个节点，也就是某一个前缀字符串。<code>t</code>同理。</p></blockquote><p>根据这样的关系，当我们在find过程中从<code>s</code>去找输入<code>c</code>后的下一个状态时，即可按部就班：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran">t := base[s] + c;<br><br><span class="hljs-keyword">if</span> check[t] = s <span class="hljs-keyword">then</span> <br>    next state := next[t] <br><span class="hljs-keyword">else</span> <br>    fail <br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>但是这种设计不得不面临一个问题：在建树过程中，每次遇到状态转移，都得保证<code>next[base[s]+c]</code>这个地址单元可用（即没被此前的操作占用）。如果地址可用，那么就可以心安理得的直接占用；但如果已经被占用了，那么就不得不进行一番腾挪：移动当前单元格所有的节点，或者对节点<code>s</code>的转移向量重新调整位置。具体执行哪一种操作，需要根据代价来权衡，在找到了空闲的新单元格后，还需要对转移向量重新计算，算法如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Procedure</span> Relocate(s : state; b : base_index)<br>// 先从base[s]开始向后线性查找，直到找到一个空闲格子的起始下标b<br>&#123; Move base for state s to a new place beginning at b &#125; <br>begin <br>    // 根据check[base[s] + c] = s的关系，可以遍历从状态s开始的每一个状态<br>    foreach input <span class="hljs-keyword">character</span> c for the state s <br>    &#123; i.e. foreach c such that check[base[s] + c] = s &#125; <br>    begin <br>    // 更新check数组，指向正确的父节点<br>    check[b + c] := s; &#123; mark owner &#125; <br>    // 数据从原本的next[base[s]+c]单元格，腾挪到新的next[b+c]单元格<br>    next[b + c] := next[base[s] + c]; &#123; copy <span class="hljs-keyword">data</span> &#125; <br>    // 释放原本check数组中base[s]+c的父节点指向关系<br>    check[base[s] + c] := <span class="hljs-keyword">none</span> &#123; free the cell &#125; <br>    <span class="hljs-keyword">end</span>; <br>    // 直到所有的转移状态都完成腾挪后，再更新base[s]指向的next数组下标<br>    base[s] := b<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><img src="2023-11-03-10-53-10.png" /></p><p>从本质上来讲，三数组表达方式，实际上是通过next和check的协同，来允许相邻的存储单元存储不同的节点。这一思想可以大大降低被浪费的单元格的占比，使得空间利用更加紧凑。当然，代价就是每次新增状态转移时，都可能和现有的内存布局发生冲突，此时就不得不花大力气腾挪。</p><h4 id="double-array">Double Array</h4><p>正如上文所述，日本研究者Jun-ichiAoe精益求精，在1989年提出了进一步的简化：双数组Trie树，简称DAT。</p><p>双数组结构中剔除了next数组，把next的功用直接合并到了base数组中，此时base和check数组平行。base和check的关系如下：</p><ul><li>对状态<code>s</code>，输入字符<code>c</code>，转移到目标状态<code>t</code>。有：<ul><li><code>check[base[s]+c] = s</code></li><li><code>base[s] + c = t</code></li></ul></li></ul><p>此时，base数组的value不再指向next数组，而是指向base自身其他的单元格：</p><p><img src="2023-11-03-11-11-07.png" /></p><blockquote><p>相比于三数组Trie，双数组Trie优化掉了对next数组索引的存储，next与base合为一体，不再对这一”缓冲池“的元信息加以记载，从而又节省了一大笔空间。</p></blockquote><p>根据这一关系，find操作的伪算法改写如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran">t := base[s] + c<br><br><span class="hljs-keyword">if</span> check[t] = s <span class="hljs-keyword">then</span><br>    next state := t<br><span class="hljs-keyword">else</span><br>    fail<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>当然，双数组Trie和三数组Trie一样，都会面临卡格子的问题。只不过，对于双数组结构来说，这回被卡主的格子在base数组中。解决的方法也与三数组结构如出一辙，无非是向后扫描+转移状态重定位罢了：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Procedure</span> Relocate(s : state, b : base_index)<br>&#123; Move base for state s to a new place beginning at b &#125;<br>begin<br>    foreach input <span class="hljs-keyword">character</span> c for the state s<br>    &#123; i.e. foreach c such that check[base[s] + c] = s &#125;<br>    begin<br>        check[b + c] := s;<br>        base[b + c] := base[base[s] + c];<br>        &#123; the node base[s] + c is to be moved to b + c; Hence, for <span class="hljs-built_in">any</span> i for which check[i] = base[s] + c, update check[i] to b + c &#125;<br>        foreach input <span class="hljs-keyword">character</span> d for the node base[s] + c<br>        begin<br>            check[base[base[s] + c] + d] := b + c <br>            check[base[s] + c] := <span class="hljs-keyword">none</span> <br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    base[s] := b <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>搬迁过程如图所示：</p><p><img src="2023-11-03-11-36-35.png" /></p><p>DAT的开源实现库有很多，最著名的是小日子依照DAT论文写的<ahref="https://github.com/s-yata/darts-clone/blob/master/doc/en/Introduction.md">darts-clone</a>，但darts-clone实际上只是个验证demo，并未达到工业级实现的标准。其中表现最优的是：<ahref="https://www.tkl.iis.u-tokyo.ac.jp/~ynaga/cedar/">cedar</a>，原作者在安利cedar时，也曾对主流的Trie开源库进行了性能评测，这些Trie的实现包罗了前文介绍的种种手法。</p><p>无序键集建Trie：</p><p><img src="2023-11-03-11-58-50.png" /></p><p>对有序键集建Trie：</p><p><img src="2023-11-03-12-03-17.png" /></p><p>可以看到在DAT的实现中，cedar实现的Double-array prefixtrie，在空间占用、构建时间和查询性能上有着最好的权衡。</p><h2 id="benchmark">Benchmark</h2><h3 id="实验组1">实验组1</h3><p>我挑选了工作当中联想词的一部分Query集合，共约720w，它们都是些中英文数字混杂的字符串，诸如：<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">朝阳区体育场占地面积<br>你为什么要当警察<br>巫师约伯<br>原神风神曈的分布<br>王战小说主角<br>6个月的狗咬人会得狂犬病吗<br>桉槎<br>醉鹿g65参数<br>美食大陆8王<br>算命的说我静不下来<br>拍打全身后放的屁特别多特别臭<br>沙县淘金山海拔<br><span class="hljs-meta prompt_">...</span><br></code></pre></td></tr></table></figure></p><p>我挑选了上述介绍的几种Trie实现库中，比较典型的三位：cedar的DAT、tsl的hat-trie以及critbit-trie。同时，我们还用标准库的<code>std::unordered_map</code>作为基石对比。</p><p>我编写了一个测试程序，用来输出这样三组信息：</p><ol type="1"><li>构建Trie的耗时以及空间占用（物理内存）</li><li>遍历精准查找所有720w queries的耗时。<ol type="1"><li>我设置了一个比例参数<code>rate</code>，按照比例来筛选出<code>n*rate</code>个queries参与构建Trie。</li><li>此举是为了模拟生产环境中，会有一定比例的字符串查无此人的情景。</li></ol></li><li>从720wqueries中挑选出1w条，按照UTF8字符做步长，分别切出5个前缀字符串。<ol type="1"><li>比如，对于"醉鹿g65参数"，得到"醉","醉鹿","醉鹿g","醉鹿g6","醉鹿g5"。</li><li>对这些前缀字符串执行”寻找以该字符串为前缀的所有字符串“操作（也就是find+travese）。</li><li>cedar和critbit的库实现上，对于这一操作支持截断，这里可以通过修改参数来设置截断上限。而tsl库返回的是一对头尾迭代器，可以自主后置截断。</li></ol></li></ol><p>以下是我设置了<code>rate=0.8</code>，<code>cut_number=1000</code>的运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@76b80d5150d5 ~/repository/test_trie]# ./test_trie -file=data/query.txt -rate=0.8 -size=7199259<br>LoadData begin to load data<br>LoadData[data/query.txt]count=7199259<br><br>[Memory Usage]VM: 539.875000 MB; RSS: 521.304688 MB<br>TestHashmap insert cost:2984ms<br>[Memory Usage]VM: 861.093750 MB; RSS: 842.554688 MB<br>TestHashmap find 7199259 queries totally cost:1586ms, finding 5759407 exist<br><br>TestCedar insert cost:5103ms<br>[Memory Usage]VM: 888.621094 MB; RSS: 831.753906 MB<br>TestCedar find 7199259 queries totally cost:4098ms, finding 5759407 exist<br><br>TestCedar match 50000 queries totally cost:3902ms<br><br>TestHAT insert cost:4047ms<br>[Memory Usage]VM: 762.640625 MB; RSS: 742.843750 MB<br>TestHAT find 7199259 queries totally cost:2375ms, finding 5759407 exist<br><br>TestHAT match 50000 queries totally cost:1487ms<br><br>TestCritbit insert cost:10966ms<br>[Memory Usage]VM: 960.542969 MB; RSS: 942.167969 MB<br>TestCritbit find 7199259 queries totally cost:14071ms, finding 5759407 exist<br><br>TestCritbit match 50000 queries totally cost:966ms<br><br></code></pre></td></tr></table></figure><table style="width:100%;"><thead><tr class="header"><th>索引库</th><th>索引量级</th><th>构建耗时(ms)</th><th>精准匹配耗时(ms)</th><th>前缀匹配耗时(ms)</th><th>物理内存占用MB</th></tr></thead><tbody><tr class="odd"><td>std::unordered_map</td><td>5,759,407</td><td>2984</td><td>1586</td><td>NA</td><td>321.25</td></tr><tr class="even"><td>cedar::da</td><td>5,759,407</td><td>5103</td><td>4098</td><td>3902</td><td>310.45</td></tr><tr class="odd"><td>tsl::htrie_map</td><td>5,759,407</td><td>4047</td><td>2375</td><td>1487</td><td>221.54</td></tr><tr class="even"><td>critbit0_tree</td><td>5,759,407</td><td>10966</td><td>14071</td><td>966</td><td>420.86</td></tr></tbody></table><p>注：这里每种数据结构的物理内存占用都抛除了用来保存原始query的<code>std::vector&lt;std::string&gt;</code>容器大小(521.30MB)。</p><p>从benchmark可以看出，<code>tsl::htrie_map</code>的性价比最高，他对空间的占用最省，且在精准匹配耗时和构建耗时上都很快。<code>critbit0_tree</code>在构建和精准匹配耗时上都非常慢，且内存占用最多，但它在前缀匹配耗时上表现最好(前提是按1000进行截断)。<code>cedar::da</code>则表现中规中矩，可以看到这种基于double-array实现的紧凑型Trie树，在时间和空间上都有不错的表现。另一方面，<code>tsl::htrie_map</code>的表现如此亮眼，这也和它本身的数据结构更加契合”短前缀查询“这一使用场景息息相关。</p><blockquote><p>700w的数据集说大不大，说小也不小，具体取决于业务。一般在大型分布式系统中，面对的都是十亿、百亿乃至千亿的数据量，当然实际生产环境也不会用单机去构建这么大量级的Trie索引，往往都会前置做分片操作（比如通过哈希函数将数据打散成几百个分片），至于每个分片上的数据量级，就要根据业务需求（比如对耗时的要求）和单机/容器配额的上限（CPU处理能力、内存大小）来权衡tradeoff。</p></blockquote><h3 id="实验组2">实验组2</h3><p>这次我们换成一个1kw左右的数据集，它们比较特别，全部由数字构成。我们通过这组query来模拟一个特殊的场景，数据样例如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">27897541646139819</span>_147<span class="hljs-number">22351_239543</span><br><span class="hljs-number">47490041659859081</span>_97239<span class="hljs-number">79_730746</span><br><span class="hljs-number">65013631639957850</span>_143<span class="hljs-number">74462_159765</span><br><span class="hljs-number">666345193978847003</span>_4609<span class="hljs-number">34532_303</span><br><span class="hljs-number">668349383982310458</span>_4<span class="hljs-number">57583284_129</span><br><span class="hljs-number">75167391682865485</span>_366108216<span class="hljs-number">82865485_53</span><br>...<br></code></pre></td></tr></table></figure><p>还是以<code>rate=0.8</code>，<code>cut_number=1000</code>来运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@76b80d5150d5 ~/repository/test_trie]# ./test_trie -file=data/pure_doc_id.txt -rate=0.8 -size=11000000<br>LoadData begin to load data<br>LoadData[data/pure_doc_id.txt]count=10083034<br><br>[Memory Usage]VM: 849.335938 MB; RSS: 830.855469 MB<br>TestHashmap insert cost:5198ms<br>[Memory Usage]VM: 1335.648438 MB; RSS: 1317.097656 MB<br>TestHashmap find 10083034 queries totally cost:2217ms, finding 8066427 exist<br><br>TestCedar insert cost:7347ms<br>[Memory Usage]VM: 1299.878906 MB; RSS: 1161.960938 MB<br>TestCedar find 10083034 queries totally cost:5896ms, finding 8066427 exist<br><br>TestCedar match 50000 queries totally cost:11721ms<br><br>TestHAT insert cost:8947ms<br>[Memory Usage]VM: 1171.359375 MB; RSS: 1151.476562 MB<br>TestHAT find 10083034 queries totally cost:4105ms, finding 8066427 exist<br><br>TestHAT match 50000 queries totally cost:32ms<br><br>TestCritbit insert cost:10571ms<br>[Memory Usage]VM: 1465.199219 MB; RSS: 1446.695312 MB<br>TestCritbit find 10083034 queries totally cost:13452ms, finding 8066427 exist<br><br>TestCritbit match 50000 queries totally cost:2042ms<br></code></pre></td></tr></table></figure><table style="width:100%;"><thead><tr class="header"><th>索引库</th><th>索引量级</th><th>构建耗时(ms)</th><th>精准匹配耗时(ms)</th><th>前缀匹配耗时(ms)</th><th>物理内存占用MB</th></tr></thead><tbody><tr class="odd"><td>std::unordered_map</td><td>8,066,427</td><td>5198</td><td>2217</td><td>NA</td><td>486.24</td></tr><tr class="even"><td>cedar::da</td><td>8,066,427</td><td>7347</td><td>5986</td><td>11721</td><td>331.11</td></tr><tr class="odd"><td>tsl::htrie_map</td><td>8,066,427</td><td>8947</td><td>4105</td><td>32</td><td>320.62</td></tr><tr class="even"><td>critbit0_tree</td><td>8,066,427</td><td>10571</td><td>13452</td><td>2042</td><td>615.84</td></tr></tbody></table><p>可以看到，对于这种字符集相当有限的键集来说，<code>tsl::htrie_map</code>和<code>cedar::da</code>在内存占用上都相当节省，所差无几，而<code>critbit0_tree</code>则依然非常臃肿。在精准匹配性能上，<code>tsl::htrie_map</code>和<code>cedar::da</code>都有不错的表现，<code>critbit0_tree</code>则效率比较低，而在前缀匹配性能上，<code>tsl::htrie_map</code>则快得离谱，这主要得益于键集的K较小且是都是短前缀查询（规避了扫表的操作），<code>critbit0_tree</code>在前缀匹配查询上也有不错的性能表现，结合实验1的数据我们不难发现，<code>critbit0_tree</code>更适合做有截断的前缀匹配查询操作。</p><h2 id="trie的应用及其扩展结构">Trie的应用及其扩展结构</h2><h3 id="应用场景">应用场景</h3><p>Trie具有相当多的应用场景，除了前文提到的全词匹配（比如黑名单命中查询）、词频统计以外，Trie还在很多其他场景有所应用，比如搜索场景的联想词，我们平时用的输入法，都会用到Trie结构来构建前缀索引。</p><p><img src="2023-11-03-19-14-29.png" /></p><p><img src="2023-11-03-19-14-35.png" /></p><p>再像是路由场景，比如DNS服务器会对域名和IP地址建Trie索引。linux的路由表、IDR也都是Trie数据结构的典型应用。</p><p><img src="2023-11-03-19-17-02.png" /></p><h3 id="扩展结构">扩展结构</h3><p>一般提到Trie结构时，往往还会提到另外两种数据结构：SuffixTree(后缀树)和AC自动机。</p><h4 id="后缀树">后缀树</h4><p>后缀树是另一种数据结构，他主要用来快速解决很多字符串的问题：</p><p><img src="2023-11-03-19-28-19.png" /></p><p>所谓后缀就是尾巴，把一个字符串的所有不同长度的尾巴串，全部用来建一颗Trie(严格来说是RadixTree，因为链压了后缀)，得到的就是后缀树。</p><p>后缀树可以用来解决回文字符串、两个字符串的LCA(Lowest CommonAncestor)、判断子字符串是否存在等字符串相关问题，在OI中比较常见，比如它可以解决一些用传统手段难以解决的问题：<ahref="https://codeforces.com/problemset/problem/235/C">CF235C CyclicalQuest</a>。</p><h4 id="ac自动机">AC自动机</h4><p>AC自动机是以Trie作为基础结构，利用KMP算法的思想来解决多模式匹配任务的数据结构。</p><p>建立一个AC自动机分成两步：</p><ol type="1"><li>所有模式串构建一棵基础Trie。</li><li>对Trie中每个节点构造失配指针。</li></ol><p>所谓的失配指针，就是用来辅助多模字符串匹配中出现fail时，完成向前回溯跳转。而失配指针应该指向哪里，就和KMP的next数组一样令人着迷。AC自动机可以看做是树形KMP：</p><p><img src="2023-11-03-19-38-57.png" /></p><h2 id="总结">总结</h2><p>经过这段时间的恶补，对Trie有了深刻的认知，以后又能嘴硬了(doge)。工作闲暇之余，把研读的相关资料按照自己的理解，萃取出核心思路整理成此文。本着实事求是的态度，也花了些力气自己折腾了benchmark的评测，不可谓不呕心沥血。</p><p>从业多年，随着接触的知识和领域越多，越发感觉很多知识背后的机理内核都似曾相识，仔细钻研俱是殊途同归。感到自身渺小的同时，不免心下戚戚然，暗叹一句：吾生也有涯，而知也无涯。以有涯随无涯，die已。</p><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://en.wikipedia.org/wiki/Trie#Compressed_tries">WIKIPEDIA-Trie</a></li><li><ahref="https://tessil.github.io/2017/06/22/hat-trie.html">HAT-trie, acache-conscious trie</a></li><li><a href="https://linux.thai.net/~thep/datrie/datrie.html">AnImplementation of Double-Array Trie</a></li><li><ahref="https://zhuanlan.zhihu.com/p/35193582">双数组前缀树（Double-ArrayTrie）</a></li><li><ahref="https://www.ffutop.com/posts/2021-01-24-darts/">双数组前缀树</a></li><li><ahref="http://jiangzhuti.me/posts/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8">字典树的几种实现方式以及应用</a></li><li><a href="https://www.tkl.iis.u-tokyo.ac.jp/~ynaga/cedar/">cedar -C++ implementation of efficiently-updatable double-array trie</a></li><li><a href="https://github.com/s-yata/darts-clone">Darts-clone: A cloneof Darts (Double-ARray Trie System)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data-structures</tag>
      
      <tag>algorithm</tag>
      
      <tag>Trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(二十六)——对称矩阵与正定性</title>
    <link href="/2023/10/27/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E5%85%AD)%E2%80%94%E2%80%94%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%AD%A3%E5%AE%9A%E6%80%A7/"/>
    <url>/2023/10/27/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E5%85%AD)%E2%80%94%E2%80%94%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%AD%A3%E5%AE%9A%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>这一节对对称矩阵下手，分解成特征值和特征向量的对角化，研究对称矩阵的性质，引出正定性。</p><span id="more"></span><h1 id="对称矩阵与正定性">对称矩阵与正定性</h1><p>对称矩阵有很多特殊的性质，它们满足：</p><ol type="1"><li><span class="math inline">\(A=A^T\)</span></li><li>能够找到彼此正交的特征向量。</li></ol><p>根据此前掌握的特征分解知识，我们知道对于不同的特征值，分解得到的对应特征向量都是线性无关的。而对于特征值相同的情况，对称矩阵总是可以在零空间中找到彼此垂直的特征向量。</p><h2 id="对称矩阵的对角化">对称矩阵的对角化</h2><p>根据上述两个性质，对称矩阵对角化便可拆解为：<spanclass="math inline">\(A=Q\Lambda Q^T\)</span>，<spanclass="math inline">\(Q\)</span>列向量也就是特征向量可以标准正交（模可标准化为1）。</p><blockquote><p>实际上，A的对称性可以通过<span class="math inline">\(Q\LambdaQ^T\)</span>看出，<span class="math inline">\((Q\LambdaQ^T)^T=(Q^T)^T\Lambda Q^T=Q\Lambda Q^T\)</span>。</p></blockquote><p>对称矩阵有一个非常重要的性质：<strong>对称矩阵的特征值都是实数</strong>。</p><p>可以用共轭来证明，由<span class="math inline">\(Ax=\lambdax\)</span>，取共轭得到<span class="math inline">\(A\bar x =\bar \lambda\bar x\)</span>（<spanclass="math inline">\(A\)</span>是实数矩阵故不变），两边同时取转置：<spanclass="math inline">\(\bar x^T A=\bar x^T\bar\lambda\)</span>，两边再同时乘上<spanclass="math inline">\(x\)</span>，得到: <span class="math display">\[\bar x^T A x=\bar x^T\bar \lambda x\]</span></p><p>将<span class="math inline">\(Ax=\lambda x\)</span>带入左侧，得到：<span class="math display">\[\bar x^T\lambda x=\bar x^T\bar \lambda x\]</span></p><p>因此，若<span class="math inline">\(\bar x^Tx \neq0\)</span>，则有<span class="math inline">\(\lambda = \bar\lambda\)</span>，即特征值均为实数。</p><p>那么有没有可能<span class="math inline">\(\bar x^Tx =0\)</span>呢？我们展开来看： <span class="math display">\[\bar{x}^T x=\left[\begin{array}{llll}\bar{x}_1 &amp; \bar{x}_2 &amp; \ldots &amp; \bar{x}_n\end{array}\right]\left[\begin{array}{c}x_1 \\x_2 \\\ldots \\x_n\end{array}\right]=\bar{x}_1 x_1+\bar{x}_2 x_2+\cdots+\bar{x}_n x_n\]</span></p><p>其中每一项<span class="math inline">\(\bar x_ix_i\)</span>都是<spanclass="math inline">\((a+bi)(a-bi)\)</span>，得到的都是大于0的实数，因此必有<spanclass="math inline">\(\bar x^Tx \neq 0\)</span>。</p><blockquote><p>同理，复数矩阵若满足<span class="math inline">\(\barA^T=A\)</span>，则特征值也都将是实数。</p></blockquote><h2 id="特征值的性质">特征值的性质</h2><p>特征值已经证实都是实数了，那么是否还有什么其他特殊性质呢？</p><p>实际上也是有的，这里先给结论：</p><ol type="1"><li>对称矩阵的主元正负个数，与特征值的正负个数一致。</li><li>对称矩阵的主元乘积等于特征值的乘积。它们都等于行列式的值。</li></ol><p>根据性质1，我们可以通过消元来快速确定特征值的正负值个数，无需解<spanclass="math inline">\(n\)</span>次方程。</p><h2 id="对称矩阵的另一个视角">对称矩阵的另一个视角</h2><p>对角化展开： <span class="math display">\[A=Q\Lambda Q^T=\begin{bmatrix}q_1&amp;q_2&amp;...&amp;q_n\end{bmatrix}\begin{bmatrix}\lambda_1&amp;0&amp;...&amp;0 \\0&amp;\lambda_2&amp;...&amp;0 \\...&amp;...&amp;...&amp;... \\0&amp;0&amp;...&amp;\lambda_n\end{bmatrix}\begin{bmatrix}q_1^T \\ q_2^T \\ ... \\ q_n^T\end{bmatrix}\]</span></p><p>由于<spanclass="math inline">\(q_i\)</span>相互正交，中间的对角矩阵就相当于每一项的系数，最终得到的是:<spanclass="math inline">\(A=\lambda_1 q_1q_1^T+\lambda_2q_2q_2^T+...+\lambda_n q_nq_n^T\)</span>。</p><p>由于<span class="math inline">\(q_iq_i^T\)</span>是单位向量，故<spanclass="math inline">\(q_i^Tq_i=1\)</span>，此时就可以将<spanclass="math inline">\(q_iq_i^T\)</span>改写成<spanclass="math inline">\(\frac{q_iq_i^T}{q_j^Tq_j}\)</span>，显然这是投影矩阵的形式，可以理解为是<spanclass="math inline">\(q_j\)</span>向<spanclass="math inline">\(q_i\)</span>方向的投影。</p><p>换个角度来说：<strong>每一个对称矩阵都是一些相互垂直的投影矩阵的线性组合。</strong></p><h2 id="正定矩阵">正定矩阵</h2><p>正定矩阵是指满足以下条件的一类矩阵：</p><ol type="1"><li>所有特征值都是正数。</li><li>所有主元都为正。</li><li>所有子行列式都为正。</li></ol><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570102985&amp;p=26&amp;autoplay=0" scrolling="no" width="100%" height="500" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B26%5D%20%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E5%8F%8A%E6%AD%A3%E5%AE%9A%E6%80%A7/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B026.pdf">对称矩阵及正定性</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(二十四)——马尔科夫矩阵,傅里叶级数</title>
    <link href="/2023/10/13/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E5%9B%9B)%E2%80%94%E2%80%94%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E7%9F%A9%E9%98%B5-%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0/"/>
    <url>/2023/10/13/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E5%9B%9B)%E2%80%94%E2%80%94%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E7%9F%A9%E9%98%B5-%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>本讲是第二部分的最后一讲，主要围绕马尔科夫矩阵和傅里叶级数，讲述了矩阵的对角化特征分解在其中发挥的作用。这两个案例只是做了浅显的介绍，重点是理解特征值与特征向量在其中扮演的角色以及其中千丝万缕的关联。</p><span id="more"></span><h1 id="马尔科夫矩阵傅里叶级数">马尔科夫矩阵，傅里叶级数</h1><h2 id="马尔科夫矩阵">马尔科夫矩阵</h2><p>马尔科夫矩阵是一种描述概率相关的矩阵，它满足以下两条性质的矩阵：</p><ol type="1"><li>每个元素均为非负数；</li><li>每列元素之和等于1；</li></ol><p>形如： <span class="math display">\[A=\begin{bmatrix}0.1&amp;0.01&amp;0.3 \\ 0.2&amp;0.99&amp;0.3 \\0.7&amp;0&amp;0.4\end{bmatrix}\]</span></p><p>根据马尔科夫矩阵的性质，我们很容易得到两个推论：</p><ol type="1"><li>马尔科夫矩阵必有一个特征值<spanclass="math inline">\(\lambda_1=1\)</span>；</li><li>除了特征值<spanclass="math inline">\(1\)</span>以外，其他特征值的绝对值皆小于<spanclass="math inline">\(1\)</span>；</li></ol><p>推论一是显而易见的，因为马尔科夫矩阵的每个列和都是1，因此，对于<spanclass="math inline">\(A-I\)</span>来说，每个列和就都是0，此时显然<spanclass="math inline">\(A-I\)</span>的行向量线性相关，即为奇异矩阵，行列式为0。</p><p>推论二的证明课上没有给出，我们暂用这一结论。</p><p>考虑此前差分方程的算式：<spanclass="math inline">\(u_k=A^ku_0=c_1\lambda_1^kx_1+c_2\lambda_2^kx_2+...+c_n\lambda_n^kx_n\)</span>，当<spanclass="math inline">\(A\)</span>为马尔科夫矩阵时，由于<spanclass="math inline">\(\lambda_1=1,|\lambda_i|&lt;1\)</span>，因此当<spanclass="math inline">\(k\)</span>趋于<spanclass="math inline">\(\infty\)</span>时，<spanclass="math inline">\(u_k\)</span>趋于稳态：<spanclass="math inline">\(c_1x_1\)</span>。</p><h3 id="马尔科夫矩阵的应用">马尔科夫矩阵的应用</h3><p>课上用二阶马尔科夫矩阵模拟了两地人口迁移的模型： <spanclass="math display">\[\begin{bmatrix}U_{ka} \\U_{ma}\end{bmatrix}_{t=k+1}=\begin{bmatrix}0.9&amp;0.2\\0.1&amp;0.8\end{bmatrix}\begin{bmatrix}U_{ka} \\U_{ma}\end{bmatrix}_{t=k}\]</span></p><p>马尔科夫矩阵<spanclass="math inline">\(A\)</span>可以解释为：每隔一个时间周期，会有90%的人口留在加州，10%的人口迁移到麻省；与此同时，会有80%的人口留在麻省，20%的人口迁移到加州。</p><p>假设初始状态：<span class="math inline">\(U_{t=0}=\begin{bmatrix}0 \\1000\end{bmatrix}\)</span>。对于这一模型，我们来分析一下稳态：计算求得马尔科夫矩阵的特征值为<spanclass="math inline">\(1\)</span>和<spanclass="math inline">\(0.7\)</span>，对应特征向量为：<spanclass="math inline">\(\begin{bmatrix}2 \\1\end{bmatrix},\begin{bmatrix}-1 \\ 1\end{bmatrix}\)</span>。</p><p>因此，通解为：<span class="math inline">\(U_t=c_1\begin{bmatrix}2 \\1\end{bmatrix}+c_2(0.7)^t\begin{bmatrix}-1 \\1\end{bmatrix}\)</span>。当<spanclass="math inline">\(t\)</span>趋于无穷时，第二项可以忽略，即最终稳态由第一项<spanclass="math inline">\(c_1\begin{bmatrix}2 \\1\end{bmatrix}\)</span>决定。</p><p>我们可以带入<span class="math inline">\(U_0\)</span>来求得<spanclass="math inline">\(c_1\)</span>和<spanclass="math inline">\(c_2\)</span>分别为<spanclass="math inline">\(\frac{1000}{3}\)</span>和<spanclass="math inline">\(\frac{2000}{3}\)</span>，因此最终的稳态是：<spanclass="math inline">\(\begin{bmatrix}\frac{2000}{3} \\\frac{1000}{3}\end{bmatrix}\)</span>。即，经过无穷多次人口迁移后，加州的人口趋近于<spanclass="math inline">\(\frac{2000}{3}\)</span>，麻省的人口趋近于<spanclass="math inline">\(\frac{1000}{3}\)</span>。</p><h2 id="傅里叶级数">傅里叶级数</h2><p>取<span class="math inline">\(n\)</span>维空间一组标准正交基：<spanclass="math inline">\(q_1,q_2,...,q_n\)</span>，它们可以表示空间中的任意向量<spanclass="math inline">\(v\)</span>: <span class="math display">\[v=x_1q_1+x_2q_2+...+x_nq_n\]</span></p><p>即<span class="math inline">\(Qx=v\)</span>，<spanclass="math inline">\(x=Q^{-1}v\)</span>。由于正交矩阵<spanclass="math inline">\(Q^T=Q^{-1}\)</span>，故<spanclass="math inline">\(x=Q^Tv\)</span>。</p><p>对应到<span class="math inline">\(x\)</span>的各个分量有：<spanclass="math inline">\(x_i=q_i^Tv\)</span>。</p><p>由此可见：用空间的一组标准正交基去点乘目标向量，就可以得到各个分量。</p><p>傅里叶级数就是在标准正交基的基础上构建的，我们可以对任意函数做傅里叶展开，得到表达式：<span class="math display">\[f(x)=a_0+a_1\cos x+b_1\sin x+a_2\cos 2x+b_2\sin 2x+...\]</span></p><p>傅里叶级数的展开最终是无限维，它的一组基是:<spanclass="math inline">\(1,\cos x,\sin x, \cos 2x, \sin 2x...\)</span>。</p><p>傅里叶级数能够这样展开，恰恰源于这些基之间两两正交。</p><p>然而，此前我们对于向量的理解，首先它们是离散的，向量的内积可以写成:<spanclass="math inline">\(v^w=v_1w_1+...+v_nw_n\)</span>。然而，傅里叶级数里的基却并非向量，而是一个连续的函数，那么对于连续的函数来说，内积是什么呢？</p><p><strong>答案就是对二者的乘法进行积分。</strong></p><p>此外，我们观察到，这些基函数都有周期为<spanclass="math inline">\(2\pi\)</span>的特性，所以我们只需要对<spanclass="math inline">\([0,2\pi]\)</span>区间进行积分即可： <spanclass="math display">\[\int_{0}^{2\pi}f(x)g(x)dx\]</span></p><p>我们任取一个<span class="math inline">\(g(x)\)</span>比如<spanclass="math inline">\(\cos x\)</span>来进行计算： <spanclass="math display">\[\int_{0}^{2\pi}(a_0+a_1\cos x+b_1\sin x+a_2\cos 2x+b_2\sin 2x)\cos xdx\\=0+\int_{0}^{2\pi}a_1\cos^2xdx+0+...+0\]</span></p><p>可以发现，除了原本在无限维空间中方向一致的<spanclass="math inline">\(\cosx\)</span>以外，其他项的积分结果都是0，因此，<spanclass="math inline">\(\cosx\)</span>和其他基向量正交。同理，也可以证的其他函数<spanclass="math inline">\(g(x)\)</span>均有此性质。</p><p>另一方面，经过积分求解，还可以求得每一个系数<spanclass="math inline">\(a_i\)</span>的表达式。例如：<spanclass="math inline">\(a_1=\frac{1}{\pi}\int_{0}^{2\pi}f(x)\cosxdx\)</span>。同理可以求得其他系数。</p><blockquote><p>所以从线性代数的角度来理解傅里叶级数，它本质上就是一种把函数展开到一组标准正交基上的手法。</p></blockquote><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570099925&amp;p=24&amp;autoplay=0" scrolling="no" width="100%" height="500" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B24%5D%20%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E7%9F%A9%E9%98%B5%3B.%E5%82%85%E7%AB%8B%E5%8F%B6%E7%BA%A7%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B024.pdf">马尔科夫矩阵；傅里叶级数</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(二十三)——微分方程</title>
    <link href="/2023/10/11/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%B8%89)%E2%80%94%E2%80%94%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    <url>/2023/10/11/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%B8%89)%E2%80%94%E2%80%94%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>一阶线性常微分方程可以通过矩阵的特征分解来求解，将微分方程抽象成矩阵，类似于上一讲差分方程的<spanclass="math inline">\(u_k=A^ku_0\)</span>，分解出对应系数而得到围绕<spanclass="math inline">\(e^{Ax}\)</span>的通解。</p><span id="more"></span><h1 id="微分方程">微分方程</h1><p>给定微分方程： <span class="math display">\[\begin{cases}\frac{\mathrm{d} u_1}{\mathrm{d} t}=-u_1+2u_2 \\\frac{\mathrm{d} u_2}{\mathrm{d} t}=u_1-2u_2  \end{cases}\]</span> 已知<span class="math inline">\(u(0)=\begin{bmatrix}1 \\0\end{bmatrix}\)</span>，求<spanclass="math inline">\(u(t)\)</span>。</p><h2 id="微分方程的矩阵解法">微分方程的矩阵解法</h2><p>方程写作<span class="math inline">\(\frac{\mathrm{d} u}{\mathrm{d}t}=Au\)</span>,其中<span class="math inline">\(A=\begin{bmatrix}-1&amp;2\\ 1&amp;-2\end{bmatrix}\)</span>。很明显<spanclass="math inline">\(A\)</span>是奇异矩阵，它的两个特征值分别是<spanclass="math inline">\(\lambda_1=0\)</span>和<spanclass="math inline">\(\lambda_2=-3\)</span>。</p><p>带入特征值求特征向量，易得<spanclass="math inline">\(x_1=\begin{bmatrix}2 \\1\end{bmatrix},x_2=\begin{bmatrix}1 \\ -1\end{bmatrix}\)</span>。</p><p>因此，方程组的通解为：<spanclass="math inline">\(u(t)=c_1e^{\lambda_1t}x_1+c_2e^{\lambda_2t}x_2\)</span>。</p><blockquote><p>这里是根据微分方程通解的形式，带入特征值和特征向量大胆猜测了二者之间的关系。我们可以带入原式来验证一下：<spanclass="math inline">\(取u=e^{\lambda_1t}x_1\)</span>带入<spanclass="math inline">\(\frac{\mathrm{d} u}{\mathrm{d}t}=Au\)</span>，得到<spanclass="math inline">\(\lambda_1e^{\lambda_1t}x_1=Ae^{\lambda_1t}x_1\)</span>，由于<spanclass="math inline">\(e^{\lambda_1t}\)</span>是个常数，因此化简后就是<spanclass="math inline">\(\lambda_1x_1=Ax_1\)</span>的形式。同理可以得到<spanclass="math inline">\(\lambda_2x_2=Ax_2\)</span>，带入得到的就是<spanclass="math inline">\(A\)</span>的特征方程，因此通解正是<spanclass="math inline">\(u(t)=c_1e^{\lambda_1t}x_1+c_2e^{\lambda_2t}x_2\)</span>。</p></blockquote><p>根据初始态<spanclass="math inline">\(u(0)\)</span>的值，我们带入可以求得系数<spanclass="math inline">\(c\)</span>，分别得到:<spanclass="math inline">\(c_1=\frac{1}{3},c_2=\frac{1}{3}\)</span>。</p><p>综上，该微分方程的通解为：<spanclass="math inline">\(u(t)=\frac{1}{3}\begin{bmatrix}2\\1\end{bmatrix}+\frac{1}{3}e^{-3t}\begin{bmatrix}1\\-1\end{bmatrix}\)</span>。</p><blockquote><p>观察该通解，可以发现随着时间<spanclass="math inline">\(t\)</span>的流逝，最终的<spanclass="math inline">\(u(t)\)</span>会无线趋近于<spanclass="math inline">\(\frac{1}{3}\begin{bmatrix}2\\1\end{bmatrix}\)</span>。这一现象我们称之为趋于稳态。实际上，在做特征值分解时我们就可以观察到，由于<spanclass="math inline">\(A\)</span>是奇异矩阵，它的特征值其一是<spanclass="math inline">\(0\)</span>，此时<spanclass="math inline">\(e^{\lambda_1t}\)</span>始终为1，而另一个特征值是小于<spanclass="math inline">\(0\)</span>的，此时<spanclass="math inline">\(e^{\lambda_2t}\)</span>随着<spanclass="math inline">\(t\)</span>增大而无线趋近于<spanclass="math inline">\(0\)</span>。</p></blockquote><blockquote><p><span class="math inline">\(u(0)\)</span>一开始，<spanclass="math inline">\(u_1=1,u_2=0\)</span>，该微分方程的物理意义在于，随着时间的流逝，<spanclass="math inline">\(u_1\)</span>逐渐减少直到趋近于<spanclass="math inline">\(\frac{2}{3}\)</span>，<spanclass="math inline">\(u_2\)</span>逐渐增加直到趋近于<spanclass="math inline">\(\frac{1}{3}\)</span>，<spanclass="math inline">\(u_1\)</span>的值在朝着<spanclass="math inline">\(u_2\)</span>流去，此消彼涨。</p></blockquote><h3 id="特征值与状态的关系">特征值与状态的关系</h3><p>根据微分方程通解的形式，我们总结出以下结论：</p><ul><li>当特征值的实部全都是负数时，<spanclass="math inline">\(u(t)\)</span>将趋于<spanclass="math inline">\(0\)</span>。这里值得注意的是，对于复数特征值<spanclass="math inline">\(a+bi\)</span>的形式，只有实数部分会影响<spanclass="math inline">\(u(t)\)</span>的走势，虚数部分并不会影响。<ul><li>比如<span class="math inline">\(\lambda=-3+6i\)</span>，计算<spanclass="math inline">\(|e^{(-3+6i)t}|\)</span>，其中<spanclass="math inline">\(e^{6it}\)</span>部分是<spanclass="math inline">\(|\cos6t+i\sin6t|=1\)</span>，这个虚部不管是什么值，他始终在复平面的单位圆上转圈。</li></ul></li><li>如果有一个为<spanclass="math inline">\(0\)</span>的特征值，且其他特征值的实部皆小于<spanclass="math inline">\(0\)</span>，则最终<spanclass="math inline">\(u(t)\)</span>会收敛到一个特定值。</li><li>如果存在某个实部大于<spanclass="math inline">\(0\)</span>的特征值，那么最终<spanclass="math inline">\(u(t)\)</span>是发散的。</li></ul><h2 id="解耦与eat">解耦与<spanclass="math inline">\(e^{At}\)</span></h2><p>对于上述特征方程，原方程组的两个函数<spanclass="math inline">\(u_1\)</span>和<spanclass="math inline">\(u_2\)</span>相互耦合，矩阵对角化分解的解法实际上就是对二者进行解耦，得到特征值和特征向量。我们将<spanclass="math inline">\(u\)</span>表示为特征向量的线性组合，写作：<spanclass="math inline">\(u=Sv\)</span>，代入原方程得到：<spanclass="math inline">\(S\frac{\mathrm{d} v}{\mathrm{d}t}=S^{-1}ASv=\Lambda v\)</span>，而<spanclass="math inline">\(\Lambda\)</span>是对角化矩阵，此时方程可以展开成：<span class="math display">\[\begin{cases}\frac{\mathrm{d} v_1}{\mathrm{d} t}=\lambda_1v_1 \\\frac{\mathrm{d} v_2}{\mathrm{d} t}=\lambda_2v_2 \\... \\\frac{\mathrm{d} v_n}{\mathrm{d} t}=\lambda_nv_n \\\end{cases}\]</span></p><p>此时，新方程组的各个<spanclass="math inline">\(v_i\)</span>之间就不再耦合，其一般解形式为：<spanclass="math inline">\(v(t)=e^{\Lambda t}v(0)\)</span>。</p><p>因此，<span class="math inline">\(u(t)=e^{At}u(0)=Se^{\Lambdat}S^{-1}u(0)\)</span></p><h3 id="指数矩阵eat">指数矩阵<spanclass="math inline">\(e^{At}\)</span></h3><p>这里<span class="math inline">\(e^{At}\)</span>为什么等于<spanclass="math inline">\(Se^{\Lambdat}S^{-1}\)</span>呢？我们可以按泰勒级数进行展开： <spanclass="math display">\[e^{A t}=I+A t+\frac{(A t)^2}{2}+\frac{(A t)^3}{6}+\cdots+\frac{(At)^n}{n !}+\cdots\]</span></p><p>而另一方面根据<span class="math inline">\(A=S\LambdaS^{-1}\)</span>： <span class="math display">\[e^{A t}=S S^{-1}+S \Lambda S^{-1} t+\frac{S \Lambda^2 S^{-1}}{2}t^2+\frac{S \Lambda^3 S^{-1}}{6} t^3+\cdots+\frac{S \Lambda^n S^{-1}}{n!} t^n+\cdots\]</span></p><p>提出<span class="math inline">\(S\)</span>和<spanclass="math inline">\(S^{-1}\)</span>得到： <spanclass="math display">\[S\left(I+\Lambda t+\frac{\Lambda^2 t^2}{2}+\frac{\Lambda^3t^3}{3}+\cdots+\frac{\Lambda^n t^n}{n}+\cdots\right) S^{-1} e^{A t}\]</span></p><p>故<span class="math inline">\(e^{At}=Se^{\Lambdat}S^{-1}\)</span>。</p><p>最后，来看看<span class="math inline">\(e^{\Lambdat}\)</span>展开的形状： <span class="math display">\[e^{\Lambda t}=\left[\begin{array}{cccc}e^{\lambda_1 t} &amp; 0 &amp; \cdots &amp; 0 \\0 &amp; e^{\lambda_2 t} &amp; \cdots &amp; 0 \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\0 &amp; 0 &amp; \cdots &amp; e^{\lambda_n t}\end{array}\right]\]</span></p><blockquote><p>实际上看到这里，就会发现最终判断收敛与发散的就是这个矩阵里的特征值，只不过对于微分方程来说，对角线上的元素不是<spanclass="math inline">\(\lambda_i^t\)</span>，而是<spanclass="math inline">\(e^{\lambda_it}\)</span>。</p></blockquote><h2 id="二阶微分方程">二阶微分方程</h2><p>对于二阶微分方程来说，可以利用上一节应付斐波那契数列的构造法，将：<spanclass="math inline">\(y&#39;&#39;+by&#39;+ky=0\)</span>处理成： <spanclass="math display">\[u&#39;=\begin{bmatrix}y&#39;&#39; \\y&#39;\end{bmatrix}=\begin{bmatrix}-b &amp; -k \\ 1 &amp;0\end{bmatrix}\begin{bmatrix}y&#39; \\y\end{bmatrix}，(u=\begin{bmatrix}y&#39; \\ y\end{bmatrix})\]</span></p><p>按照此法可以也可以推广到高阶，比如对5阶就转成一个<spanclass="math inline">\(5\times5\)</span>的矩阵对角化分解特征值、特征向量的问题。 <spanclass="math display">\[\left[\begin{array}{l}y^{\prime \prime \prime \prime \prime \prime} \\y^{\prime \prime \prime \prime} \\y^{\prime \prime \prime} \\y^{\prime \prime} \\y^{\prime}\end{array}\right]=\left[\begin{array}{ccccc}-b &amp; -c &amp; -d &amp; -e &amp; -f \\1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\end{array}\right]\left[\begin{array}{l}y^{\prime \prime \prime \prime} \\y^{\prime \prime \prime} \\y^{\prime \prime} \\y^{\prime} \\y\end{array}\right]\]</span></p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570099813&amp;p=23&amp;autoplay=0" scrolling="no" width="100%" height="500" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B23%5D%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8Cexp(At)/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B023.pdf">微分方程和exp(At)</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(二十二)——对角化与A的幂</title>
    <link href="/2023/10/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%BA%8C)%E2%80%94%E2%80%94%E5%AF%B9%E8%A7%92%E5%8C%96%E4%B8%8EA%E7%9A%84%E5%B9%82/"/>
    <url>/2023/10/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%BA%8C)%E2%80%94%E2%80%94%E5%AF%B9%E8%A7%92%E5%8C%96%E4%B8%8EA%E7%9A%84%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<p>书接上回，对分解出的特征值和特征向量加以利用，利用特征向量构成的可逆矩阵<spanclass="math inline">\(S\)</span>对矩阵<spanclass="math inline">\(A\)</span>做对角化，抽离出特征值和特征向量矩阵。这一手法在研究矩阵的幂时非常有用，我们可以惊奇的发现对角化之后，矩阵的幂仅仅改变的是特征值，特征向量却没有发生变化。利用这一手法，我们可以构造对角矩阵来解决很多问题，比如：差分方程、斐波那契数列。</p><span id="more"></span><h1 id="对角化和a的幂">对角化和A的幂</h1><p>我们此前学过很多种矩阵<spanclass="math inline">\(A\)</span>的分解，比如<spanclass="math inline">\(LU\)</span>分解，<spanclass="math inline">\(QR\)</span>分解，它们都在特定的场景发挥作用。在我们学习了特征值与特征向量以后，还可以对矩阵<spanclass="math inline">\(A\)</span>进行对角化分解。</p><h2 id="对角化">对角化</h2><p>过程如下：</p><ol type="1"><li>首先要求<span class="math inline">\(A\)</span>有<spanclass="math inline">\(n\)</span>个线性无关的特征向量，用它们构成矩阵<spanclass="math inline">\(S=\begin{bmatrix}x_1&amp;x_2&amp;...&amp;x_n\end{bmatrix}\)</span>，我们称<spanclass="math inline">\(S\)</span>为特征向量矩阵。</li><li>构造<spanclass="math inline">\(AS=A\begin{bmatrix}x_1&amp;x_2&amp;...&amp;x_n\end{bmatrix}\)</span>，根据特征值的定义，得到：<spanclass="math inline">\(A\begin{bmatrix}x_1&amp;x_2&amp;...&amp;x_n\end{bmatrix}=\begin{bmatrix}\lambda_1x_1&amp;\lambda_2x_2&amp;...&amp;\lambda_nx_n\end{bmatrix}\)</span>。这一方程相当于把每一个<spanclass="math inline">\(Ax_i=\lambda_i x_i\)</span>组合起来。</li><li><spanclass="math inline">\(\begin{bmatrix}\lambda_1x_1&amp;\lambda_2x_2&amp;...&amp;\lambda_nx_n\end{bmatrix}\)</span>可以展开成：<spanclass="math inline">\(\begin{bmatrix}x_1&amp;x_2&amp;...&amp;x_n\end{bmatrix}\begin{bmatrix}\lambda_1&amp;0&amp;...&amp;0\\0&amp;\lambda_2&amp;...&amp;0\\ ...&amp;...&amp;...&amp;...\\0&amp;0&amp;...&amp;\lambda_n\end{bmatrix}\)</span>，我们把这个由特征值构成的矩阵记为<spanclass="math inline">\(\Lambda\)</span>，于是有：<spanclass="math inline">\(AS=S\Lambda\)</span>。</li><li><spanclass="math inline">\(S\)</span>的各列向量（也就是特征向量）都是线性无关的，因此<spanclass="math inline">\(S\)</span>可逆，故：<spanclass="math inline">\(S^{-1}AS=\Lambda\)</span>；同理，翻转可得：<spanclass="math inline">\(A=S\Lambda S^{-1}\)</span>。</li></ol><p>如此，我们就得到了矩阵<spanclass="math inline">\(A\)</span>的一种新型分解方式，根据这一分解手法，我们可以看出矩阵<spanclass="math inline">\(A\)</span>与其特征向量、特征值的关联。由于特征值构成的<spanclass="math inline">\(\Lambda\)</span>矩阵只有对角线有值（且为特征值），故这一分解过程被称之为——对角化。</p><h2 id="a的幂">A的幂</h2><p>对角化的分解方式有什么用呢？仔细观察<spanclass="math inline">\(A=S\LambdaS^{-1}\)</span>的形式，我们可以发现在计算<spanclass="math inline">\(A\)</span>的幂时这一分解非常好用：</p><ul><li>考虑<span class="math inline">\(A^2\)</span>，有：<spanclass="math inline">\(A^2=S\Lambda S^{-1}S\LambdaS^{-1}=S\Lambda^2S^{-1}\)</span>，这意味着进行幂运算的前后，特征向量没有发生改变，而特征值进行了幂运算。</li><li>推广到<span class="math inline">\(A^n\)</span>，不难得到<spanclass="math inline">\(A^n=S\Lambda^nS^{-1}\)</span>。</li></ul><blockquote><p>这与上一节我们观察得到的：<span class="math inline">\(A^2x=A\lambdax=\lambda^2x\)</span>如出一辙。</p></blockquote><h3 id="性质延展">性质延展</h3><p>根据这一性质，我们可以解答这样一个问题：什么条件下，能够让矩阵<spanclass="math inline">\(A\)</span>的幂<spanclass="math inline">\(A^k\)</span>，在<spanclass="math inline">\(k\)</span>趋于<spanclass="math inline">\(\infty\)</span>时，趋近于<spanclass="math inline">\(0\)</span>？</p><p>根据这一分解，答案也就显而易见了：所有的特征值都满足<spanclass="math inline">\(|\lambda_i|&lt;1\)</span>时。</p><p>当然，这里的<span class="math inline">\(A\)</span>需要有<spanclass="math inline">\(n\)</span>个线性无关的特征向量，这个是前提。</p><p>正如上一节的提醒：<spanclass="math inline">\(n\)</span>阶矩阵能否成功对角化分解取决于是否有<spanclass="math inline">\(n\)</span>个线性无关的特征向量，而特征向量与特征值之间有着紧密的关系：</p><ul><li>若矩阵<spanclass="math inline">\(A\)</span>没有重复的特征值，那么就一定有<spanclass="math inline">\(n\)</span>个线性无关的特征向量（不同的特征值对应的特征向量线性无关）。</li><li>若有重复的特征值，则矩阵是否有<spanclass="math inline">\(n\)</span>个线性无关的特征向量尚待考究。</li></ul><blockquote><p>本节不对拥有重复特征值的<spanclass="math inline">\(A\)</span>做展开，那是另一个更加深入的话题。</p></blockquote><h3 id="差分方程">差分方程</h3><p>今有向量<spanclass="math inline">\(u_{k+1}=Au_k\)</span>，通项易得：<spanclass="math inline">\(u_k=A^ku_0\)</span>。这是一个一阶差分方程组。</p><p>想要求解这一方程，需要将向量<spanclass="math inline">\(u_0\)</span>拆解成矩阵<spanclass="math inline">\(A\)</span>的线性无关的<spanclass="math inline">\(n\)</span>个特征向量的线性组合： <spanclass="math display">\[u_0=c_1x_1+c_2x_2+...+c_nx_n=\begin{bmatrix}x_1&amp;x_2&amp;...&amp;x_n\end{bmatrix}\begin{bmatrix}c_1\\ c_2\\ ...\\ c_n\end{bmatrix}=Sc\]</span></p><p>我们把每一个系数构成的向量记为<spanclass="math inline">\(c\)</span>。</p><p>根据特征方程： <span class="math display">\[Au_0=c_1Ax_1+c_2Ax_2+...+c_nAx_n=c_1\lambda_1x_1+c_2\lambda_2x_2+...+c_n\lambda_nx_n\]</span></p><p>上式展开成矩阵乘法写作： <span class="math display">\[Au_0=\begin{bmatrix}x_1&amp;x_2&amp;...&amp;x_n\end{bmatrix}\begin{bmatrix}\lambda_1&amp;0&amp;...&amp;0 \\0&amp;\lambda_2&amp;...&amp;0 \\...&amp;...&amp;...&amp;... \\0&amp;0&amp;...&amp;\lambda_n\end{bmatrix}\begin{bmatrix}c_1 \\c_2 \\... \\c_n\end{bmatrix}=S\Lambda c\]</span></p><blockquote><p>相当于用对角化分解直接带入：<span class="math inline">\(Au_0=S\LambdaS^{-1}u_0=S\Lambda S^{-1}Sc=S\Lambdac\)</span>，只不过上述的展开更加立体。</p></blockquote><p>因此，对于<span class="math inline">\(u_k\)</span>，只需要将<spanclass="math inline">\(\lambda\)</span>做幂运算，保持<spanclass="math inline">\(c\)</span>和特征向量矩阵<spanclass="math inline">\(S\)</span>不变，即可得到。即：<spanclass="math inline">\(u_k=A^{k}u_0=S\Lambda^kc=c_1\lambda_1^kx_1+c_2\lambda_2^kx_2+...+c_n\lambda_n^kx_n\)</span>。</p><h3 id="斐波那契数列">斐波那契数列</h3><p>借助差分方程的通项计算方法，我们可以通过构造矩阵<spanclass="math inline">\(A\)</span>来求解斐波那契数列的通项。</p><p>对<spanclass="math inline">\(F_{k+2}=F_{k}+F_{k+1}\)</span>，我们需要把他转化成<spanclass="math inline">\(u_{k+1}=Au_k\)</span>的形式。怎么操作呢？可以借助这样一个小技巧：<span class="math display">\[令u_k=\begin{bmatrix}F_{k+1}\\ F_{k}\end{bmatrix}\]</span></p><p>追加一个方程组成方程组： <span class="math display">\[\begin{cases}F_{k+2}=F_{k}+F_{k+1} \\F_{k+1}=F_{k+1}\end{cases}\]</span></p><p>对于上述方程组，我们可以这样表达： <span class="math display">\[\begin{bmatrix}F_{k+2} \\ F_{k+1}\end{bmatrix}=\begin{bmatrix}1&amp;1 \\1&amp;0\end{bmatrix}\begin{bmatrix}F_{k+1} \\ F_{k}\end{bmatrix}\]</span></p><p>即转化为<spanclass="math inline">\(u_{k+1}=Au_k\)</span>的形式，其中<spanclass="math inline">\(A=\begin{bmatrix}1&amp;1 \\1&amp;0\end{bmatrix}\)</span>。</p><blockquote><p>本质上是把二阶差分方程改造成一阶向量方程组。</p></blockquote><p>矩阵<spanclass="math inline">\(A\)</span>是对称阵，它的特征值都是实数，利用迹与行列式可以求解得到特征值<spanclass="math inline">\(\lambda_1=\frac{1+\sqrt{5}}{2},\lambda_2=\frac{1-\sqrt{5}}{2}\)</span>。代回特征方程得到特征向量<spanclass="math inline">\(x_1=\begin{bmatrix}\frac{1+\sqrt{5}}{2} \\1\end{bmatrix}, x_2=\begin{bmatrix}\frac{1-\sqrt{5}}{2} \\1\end{bmatrix}\)</span>。</p><blockquote><p>特征方程求解<spanclass="math inline">\(\lambda^2-\lambda-1=0\)</span>本质上就是<spanclass="math inline">\(F_{k+2}-F_{k+1}-F_{k}=0\)</span>。</p></blockquote><p>再根据<span class="math inline">\(u_0=\begin{bmatrix}F_1 \\F_0\end{bmatrix}=\begin{bmatrix}1 \\0\end{bmatrix}=Sc=c_1x_1+c_2x_2\)</span>，容易求得系数<spanclass="math inline">\(c_1=\frac{\sqrt{5}}{5},c_2=-\frac{\sqrt{5}}{5}\)</span>。</p><p>最终代入<spanclass="math inline">\(u_k=S\Lambda^kc\)</span>，就可以求得任意通项。比如，我们希望预估斐波那契数列的第100项的值：<span class="math display">\[u_{99}=\left[\begin{array}{c}F_{100} \\F_{99}\end{array}\right]=\left[\begin{array}{cc}\frac{1+\sqrt{5}}{2} &amp; \frac{1-\sqrt{5}}{2} \\1 &amp; 1\end{array}\right]\left[\begin{array}{cc}\left(\frac{1+\sqrt{5}}{2}\right)^{99} &amp; 0 \\0 &amp; \left(\frac{1-\sqrt{5}}{2}\right)^{99}\end{array}\right]\left[\begin{array}{c}\frac{\sqrt{5}}{5} \\-\frac{\sqrt{5}}{5}\end{array}\right]=\left[\begin{array}{c}c_1 \lambda_1^{100}+c_2 \lambda_2^{100} \\c_1 \lambda_1^{99}+c_2 \lambda_2^{99}\end{array}\right]\]</span></p><p>得通项公式：<spanclass="math inline">\(F_k=c_1\lambda_1^k+c_2\lambda_2^k\)</span>。</p><p>此外，由于特征值<spanclass="math inline">\(\lambda_2\approx-0.618\)</span>，在幂增长过程中趋近于<spanclass="math inline">\(0\)</span>，预估时可以忽略。因此斐波那契数列的增长速度可以按照<spanclass="math inline">\(\lambda_1\)</span>来评估，增长速度大约为<spanclass="math inline">\(1.618\)</span>。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570099395&amp;p=22&amp;autoplay=0" scrolling="no" width="100%" height="500" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B22%5D%20%E5%AF%B9%E8%A7%92%E5%8C%96%E5%92%8C%20A%20%E7%9A%84%E5%B9%82/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B022.pdf">对角化和A的幂</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(二十一)——特征方程</title>
    <link href="/2023/10/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%B8%80)%E2%80%94%E2%80%94%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"/>
    <url>/2023/10/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%B8%80)%E2%80%94%E2%80%94%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>本节讨论了线性代数中非常重要的两个概念：特征值与特征向量。</p><span id="more"></span><h1 id="特征方程">特征方程</h1><p>对于<spanclass="math inline">\(Ax=b\)</span>我们往往做这样的解读：矩阵<spanclass="math inline">\(A\)</span>乘以向量<spanclass="math inline">\(x\)</span>，实际上是让<spanclass="math inline">\(A\)</span>作用到向量<spanclass="math inline">\(x\)</span>上，得到新的向量<spanclass="math inline">\(b\)</span>。这里的<spanclass="math inline">\(A\)</span>像是一个函数，<spanclass="math inline">\(x\)</span>作为输入，<spanclass="math inline">\(b\)</span>作为输出。在诸多<spanclass="math inline">\(Ax\)</span>当中，我们尤其对这样的一类特殊群体感兴趣：<span class="math display">\[Ax=\lambda x\]</span></p><p>对非零向量<span class="math inline">\(x\)</span>来说，上式意味着<spanclass="math inline">\(A\)</span>发生作用之后，<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(Ax\)</span>依然保持同一方向。<strong>此时，我们把满足这个条件的非零向量<spanclass="math inline">\(x\)</span>称为<spanclass="math inline">\(A\)</span>的特征向量，<spanclass="math inline">\(\lambda\)</span>称为<spanclass="math inline">\(A\)</span>的特征值。而上式则被称为特征方程。</strong></p><h2 id="特征值lambda0">特征值<spanclass="math inline">\(\lambda=0\)</span></h2><p>对特征方程来说，这里有个比较特殊的case：当<spanclass="math inline">\(\lambda\)</span>为<spanclass="math inline">\(0\)</span>时，易得<spanclass="math inline">\(Ax=0\)</span>，即特征值为0的特征向量<spanclass="math inline">\(x\)</span>位于<spanclass="math inline">\(A\)</span>的零空间中。显然，对于奇异矩阵来说，必然存在非零向量满足<spanclass="math inline">\(Ax=0\)</span>，这也就意味着：若矩阵<spanclass="math inline">\(A\)</span>是奇异矩阵，那么它必有一个<spanclass="math inline">\(\lambda=0\)</span>的特征值。</p><h2 id="投影矩阵">投影矩阵</h2><p>若矩阵<span class="math inline">\(A\)</span>是一个投影矩阵（<spanclass="math inline">\(P=A(A^TA)^{-1}A^T\)</span>），那么它的特征值有哪些呢？</p><p>我们取比较特殊的向量：</p><ul><li>对于向量<span class="math inline">\(b\)</span>在<spanclass="math inline">\(P\)</span>上做投影，当且仅当<spanclass="math inline">\(b\)</span>本身已经处于投影空间中时（也就是<spanclass="math inline">\(P\)</span>的列空间），<spanclass="math inline">\(Pb\)</span>才和<spanclass="math inline">\(b\)</span>方向相同。因此，投影空间中的所有向量都是投影矩阵的特征向量，它们的特征值都是<spanclass="math inline">\(1\)</span>。</li><li>对于垂直于投影空间的法向量<spanclass="math inline">\(e\)</span>，有<spanclass="math inline">\(Pe=0\)</span>，因此投影空间的所有法向量（即<spanclass="math inline">\(P\)</span>的左零空间）都是投影矩阵的特征向量，它们的特征值都是<spanclass="math inline">\(0\)</span>。</li></ul><h2 id="二阶置换矩阵">二阶置换矩阵</h2><p>二阶置换矩阵<span class="math inline">\(A=\begin{bmatrix}0&amp;1\\1&amp;0\end{bmatrix}\)</span>，它的作用是交换二维向量<spanclass="math inline">\(x\)</span>的两个元素。根据特征值和特征向量的定义，使用瞪眼法可以看出：</p><ul><li><span class="math inline">\(A\)</span>有特征值为<spanclass="math inline">\(1\)</span>的特征向量，<spanclass="math inline">\(x_1=\begin{bmatrix}1\\1\end{bmatrix}\)</span>。</li><li><span class="math inline">\(A\)</span>有特征值为<spanclass="math inline">\(-1\)</span>的特征向量，<spanclass="math inline">\(x_2=\begin{bmatrix}-1\\1\end{bmatrix}\)</span></li></ul><h2 id="特征方程求解">特征方程求解</h2><p>通用的求解方法可以对特征方程进行转化：<spanclass="math inline">\((A-\lambda I)x=0\)</span>，若<spanclass="math inline">\(x\)</span>有非零解，则意味着<spanclass="math inline">\(A-\lambda I\)</span>是奇异矩阵，故<spanclass="math inline">\(\det(A-\lambda I)=0\)</span>。</p><p>根据行列式展开生成的代数余子式，我们知道它是个<spanclass="math inline">\(\lambda\)</span>的<spanclass="math inline">\(n\)</span>次方程，因此<spanclass="math inline">\(n\)</span>阶矩阵应有<spanclass="math inline">\(n\)</span>个特征值，它们之中可能有相同的值，其中可能有实数，也可能有虚数。</p><h3 id="示例">示例</h3><p>比如有矩阵<span class="math inline">\(A=\begin{bmatrix}3&amp;1 \\1&amp;3\end{bmatrix}\)</span>，求特征值和特征向量。</p><p>解：</p><p>构造矩阵<span class="math inline">\(\begin{bmatrix}3-\lambda &amp;1\\ 1&amp;3-\lambda \end{bmatrix}\)</span>，其行列式带入化简得：<spanclass="math inline">\(\lambda ^2-6\lambda +8=0\)</span>。</p><p>求得两个特征值<span class="math inline">\(\lambda_1=4,\lambda_2=2\)</span>。带入求解特征向量分别为：<spanclass="math inline">\(x_1=\begin{bmatrix}1\\1\end{bmatrix}\)</span>，<spanclass="math inline">\(x_2=\begin{bmatrix}-1\\1\end{bmatrix}\)</span>。</p><p>另一方面，我们也发现该矩阵和二阶置换矩阵相比，两个特征向量完全相同，只是特征值发生了偏移（全部增加了3个单位）。事实上，这其中有着这样的规律，考虑：<spanclass="math inline">\(A=\begin{bmatrix}0&amp;1\\1&amp;0\end{bmatrix}+3I\)</span>，原方程变为：<spanclass="math inline">\((A+3I)x=\lambdax+3x=(\lambda+3)x\)</span>，这里可以看出<spanclass="math inline">\(x\)</span>前后是没有变化的，即特征向量不变，但新的特征值变为了<spanclass="math inline">\(\lambda+3\)</span>。</p><blockquote><p>但是这一推理对于加一般矩阵<spanclass="math inline">\(B\)</span>来说是不成立的，这是因为你无法保证<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>有同样的特征向量<spanclass="math inline">\(x\)</span>，我们无法得出<spanclass="math inline">\((A+B)x=(\lambda+\alpha)x\)</span>的结论，这是因为本质上<spanclass="math inline">\(x\)</span>有差异(应该写作<spanclass="math inline">\(Ax=\lambda x, By=\alpha y\)</span>)。</p></blockquote><h3 id="特征值的性质">特征值的性质</h3><p>上面的例子其实也能看出，特征值的和与积有着一些明显特性：</p><ul><li>矩阵的特征值之和等于矩阵的迹。</li><li>矩阵的特征值之积等于矩阵的行列式。</li></ul><p>这两个性质的证明比较繁琐，但其本质就是韦达定理，这里限于篇幅不做展开论证。</p><p><img src="2023-10-09-19-47-38.png" /></p><h3 id="旋转矩阵">旋转矩阵</h3><p>对于旋转矩阵<spanclass="math inline">\(Q=\begin{bmatrix}\cos90^\circ&amp;-sin90^\circ\\sin90^\circ&amp;cos90^\circ\end{bmatrix}=\begin{bmatrix}0&amp;-1\\1&amp;0\end{bmatrix}\)</span>，作用到<spanclass="math inline">\(x\)</span>可以让向量旋转<spanclass="math inline">\(90^\circ\)</span>，利用特征值的性质，我们得到方程：<span class="math display">\[\begin{cases}\lambda_1+\lambda_2=0 \\\lambda_1\cdot\lambda_2=1\end{cases}\]</span></p><p>得到特征值<spanclass="math inline">\(\lambda_1=i,\lambda_2=-i\)</span>。尽管矩阵全部都是实数，但得到的两个特征值却是虚数。</p><blockquote><p>实际上，矩阵如果是对称的，那么特征值一定都是实数。越接近对称，特征值就越可能是实数，相反，越不对称，比如像上例中的反对称矩阵(<spanclass="math inline">\(A^T=-A\)</span>)，其特征值往往是虚数。实数特征值让特征向量伸缩，而虚数则让其旋转。</p></blockquote><h3 id="上三角阵">上三角阵</h3><p>上三角阵的情况更糟糕，有<spanclass="math inline">\(A=\begin{bmatrix}3&amp;1 \\0&amp;3\end{bmatrix}\)</span>，求特征值和特征向量。</p><p>带入<span class="math inline">\(\det(A-\lambdaI)=0\)</span>，得到<spanclass="math inline">\(\lambda_1=\lambda_2=3\)</span>，此时两个特征值相等。将特征值带入求<spanclass="math inline">\(A-3I\)</span>的零空间，零空间是一维的，这意味着他们有着相同的特征向量：<spanclass="math inline">\(x=\begin{bmatrix}1\\0\end{bmatrix}\)</span>。<strong>我们无法再找出更多的线性无关的特征向量。</strong></p><p>对于这种二阶退化矩阵，我们只能找到一个方向上的特征向量而非两个。推广到高阶，对特化矩阵而言，重复的特征值会导致特征向量的缺失。</p><blockquote><p>如果特征值不同，那么一定有线性无关的特征向量；但如果特征值相同，却并不能说明一定不存在线性无关的多个特征向量。例如对于<spanclass="math inline">\(10\times 10\)</span>的单位矩阵，它只有10个为<spanclass="math inline">\(1\)</span>的特征值，但却可以轻易取得10个线性无关的特征向量，因为任意向量都是特征值为<spanclass="math inline">\(1\)</span>的特征向量。</p></blockquote><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570098690&amp;p=21&amp;autoplay=0" scrolling="no" width="100%" height="500" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B21%5D%20%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B021.pdf">特征值和特征向量</a></li><li><ahref="https://rqtn.github.io/2019/09/01/LA-Lec21/">特征值和特征向量</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(二十)——行列式应用</title>
    <link href="/2023/10/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81)%E2%80%94%E2%80%94%E8%A1%8C%E5%88%97%E5%BC%8F%E5%BA%94%E7%94%A8/"/>
    <url>/2023/10/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81)%E2%80%94%E2%80%94%E8%A1%8C%E5%88%97%E5%BC%8F%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>这一节从行列式的性质出发，对行列式三个方面的应用进行描述：求逆矩阵、克莱姆法则和体积。</p><span id="more"></span><h1 id="行列式应用">行列式应用</h1><h2 id="求逆矩阵">求逆矩阵</h2><p>我们已经学过了用高斯-若尔当求逆矩阵的方法，尽管从实用角度出发高斯若尔当求逆法相当好用，但毕竟不够直观。而借助行列式，我们可以给出一个更直观的求逆矩阵的代数表达式：</p><p><span class="math display">\[A^{-1}=\frac{1}{|A|}C^T\]</span></p><p>这里的<spanclass="math inline">\(C\)</span>被称作代数余子式矩阵，矩阵的每个元素是由<spanclass="math inline">\(A\)</span>中对应位置元素的代数余子式组成，其转置矩阵一般也称其为伴随矩阵，记为<spanclass="math inline">\(C^T\)</span>。</p><p>这一代数表达式的证明也很简单，两边同时左乘<spanclass="math inline">\(A\)</span>，则问题转化为证明：<spanclass="math inline">\(AC^T=|A|I\)</span>，展开观察： <spanclass="math display">\[AC^T=\begin{bmatrix}a_{11}&amp;...&amp;a_{1n} \\...&amp;...&amp;...\\a_{n1}&amp;...&amp;a_{nn}\end{bmatrix}\begin{bmatrix}C_{11}&amp;...&amp;C_{n1}\\ ...&amp;...&amp;...\\C_{1n}&amp;...&amp;C_{nn}\end{bmatrix}\]</span></p><p>根据乘法运算，可以发现<spanclass="math inline">\(A\)</span>中每一个行向量与<spanclass="math inline">\(C^T\)</span>中对应列向量做内积后得到的正是<spanclass="math inline">\(\det(A)\)</span>（使用上一节的代数余子式计算行列式公式得到）。举个例子，第1行与第1列内积得到<spanclass="math inline">\(\det(A)\)</span>，第2行与第2列内积也得到<spanclass="math inline">\(\det(A)\)</span>，以此类推。因此，乘法运算得到的最终矩阵中主对角线上的元素都是<spanclass="math inline">\(\det(A)\)</span>：</p><p><span class="math display">\[\begin{bmatrix}a_{11}&amp;...&amp;a_{1n} \\...&amp;...&amp;...\\a_{n1}&amp;...&amp;a_{nn}\end{bmatrix}\begin{bmatrix}C_{11}&amp;...&amp;C_{n1}\\ ...&amp;...&amp;...\\C_{1n}&amp;...&amp;C_{nn}\end{bmatrix}=\begin{bmatrix}|A|&amp;...&amp;...\\ ...&amp;|A|&amp;...\\...&amp;...&amp;|A|\end{bmatrix}\]</span></p><p>再来观察其他位置，比如我们观察<spanclass="math inline">\(i=1,j=2\)</span>的元素，它是第1行与第2列的内积：<spanclass="math inline">\(a_{11}C_{21}+a_{12}C_{22}+...+a_{1n}C_{2n}\)</span>，类似主对角线的元素，思考一下：什么样的矩阵的行列式的代数余子式公式会这样展开呢？答案很简单：<span class="math display">\[\begin{bmatrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1n}\\a_{11}&amp;a_{12}&amp;...&amp;a_{1n}\\a_{31}&amp;a_{32}&amp;...&amp;a_{3n}\\...&amp;...&amp;...\\a_{n1}&amp;a_{n2}&amp;...&amp;a_{nn}\end{bmatrix}\]</span></p><p>对于上式展开形式，只需要将原本的矩阵<spanclass="math inline">\(A\)</span>中第二行全部换成第一行，再去求行列式，就刚好可写作<spanclass="math inline">\(a_{11}C_{21}+a_{12}C_{22}+...+a_{1n}C_{2n}\)</span>。另一方面，我们知道有相同两行的矩阵行列式值为0，因此，<spanclass="math inline">\(a_{11}C_{21}+a_{12}C_{22}+...+a_{1n}C_{2n}=0\)</span>。</p><p>故最终的乘积矩阵中，主对角线元素皆为<spanclass="math inline">\(\det(A)\)</span>，其他元素皆为<spanclass="math inline">\(0\)</span>： <span class="math display">\[\begin{bmatrix}|A|&amp;0&amp;...&amp;0\\ 0&amp;|A|&amp;...&amp;0\\...&amp;...&amp;...&amp;...\\ 0&amp;0&amp;...&amp;|A|\end{bmatrix}\]</span></p><p>综上，原式<spanclass="math inline">\(A^{-1}=\frac{1}{|A|}C^T\)</span>得证。根据逆矩阵公式，可以看到：当改变原矩阵中的元素时会给逆矩阵带来怎样的变化，具体表现为：<spanclass="math inline">\(det(A)\)</span>发生了改变、<spanclass="math inline">\(C^T\)</span>也发生了改变。</p><h2 id="克莱姆法则">克莱姆法则</h2><p>使用上述求逆矩阵公式，对于方程<spanclass="math inline">\(Ax=b\)</span>我们也可以不必使用消元法，而是换成逆矩阵公式来求解：<span class="math display">\[x=A^{-1}b=\frac{1}{|A|}C^Tb\]</span></p><p>这里的<spanclass="math inline">\(C^Tb\)</span>展开就是每一个代数余子式<spanclass="math inline">\(C\)</span>乘<spanclass="math inline">\(b\)</span>的各个分量。余子式乘数字的形式是不是很眼熟？这不就是某个矩阵的行列式计算公式嘛。那么什么样的矩阵可以展开成这样的行列式计算式呢？这次从列的视角出发，我们将矩阵<spanclass="math inline">\(A\)</span>中<spanclass="math inline">\(C_i\)</span>对应列<spanclass="math inline">\(A_i\)</span>替换为<spanclass="math inline">\(b\)</span>，即可得到这样的计算式展开，我们将替换后的矩阵记为<spanclass="math inline">\(B_i\)</span>，于是有： <spanclass="math display">\[x_1=\frac{|B_1|}{|A|}, x_2=\frac{|B_2|}{|A|},x_3=\frac{|B_3|}{|A|}...,x_n=\frac{|B_n|}{|A|}\]</span></p><p><span class="math inline">\(x\)</span>的每个分量都是对应的<spanclass="math inline">\(C_i^Tb\)</span>得到，因此，若想要求得每个分量的值，只需要构造矩阵<spanclass="math inline">\(B_i\)</span>并计算其行列式值即可。 <spanclass="math display">\[B_1=\begin{bmatrix}b_1&amp;a_{12}&amp;...&amp;a_{1n}\\b_2&amp;a_{22}&amp;...&amp;a_{2n}\\b_3&amp;a_{32}&amp;...&amp;a_{3n}\\...&amp;...&amp;...&amp;...\\b_n&amp;a_{n2}&amp;...&amp;a_{nn}\end{bmatrix}\]</span></p><p>按第一列展开成代数余子式公式：即第一个分量<spanclass="math inline">\(x_1=\frac{C_1^Tb}{|A|}\)</span>，其中<spanclass="math inline">\(|B_1|=C_1^Tb\)</span>。即：<spanclass="math inline">\(|B_1|=b_1C_{11}+b_2C_{21}+...+b_nC_{n1}\)</span>。</p><p>克莱姆法则很漂亮，但是并不实用。相对于消元法，如果使用克莱姆法则来求解<spanclass="math inline">\(Ax=b\)</span>，那么就需要求出共计<spanclass="math inline">\(n+1\)</span>个矩阵的行列式，这个计算量对人类来说太大了，但这种代数表达式的表示法可能对于计算机算法来说却更加友好，也更加具体。</p><h2 id="体积">体积</h2><p>对3阶矩阵<spanclass="math inline">\(A\)</span>，其行列式的绝对值<spanclass="math inline">\(|det(A)|\)</span>就是以矩阵<spanclass="math inline">\(A\)</span>行（列）向量为边所构成的平行六面体的体积。行列式的符号对应左手系和右手系。</p><p><img src="2023-10-09-14-21-48.png" /></p><p>行列式的绝对值为什么等于体积呢？我们知道三大基础性质定义了行列式，因此如果我们能够证明体积也具有这三大性质，那么就可以知道体积一定等于行列式。</p><h3 id="性质1">性质1</h3><p>对单位阵<span class="math inline">\(I\)</span>来说，体积就是<spanclass="math inline">\(1\)</span>，这是显而易见的。</p><h3 id="性质2">性质2</h3><p>交换两行并不会改变空间六面体，绝对值也不变。</p><h3 id="性质3a">性质3a</h3><p>相当于对其中的某一边进行缩放，体积当然也跟着缩放系数进行缩放，这一点显然。</p><h3 id="性质3b">性质3b</h3><p>这个性质不太好证明，为了便捷我们这里在2阶矩阵上验证。</p><p>对于二阶矩阵，行列式就是两条边组成的平行四边形的面积。</p><p><img src="2023-10-09-15-14-10.png" /></p><p>从二维图像上可以看出，<spanclass="math inline">\((a+a&#39;,b+b&#39;)\)</span>与<spanclass="math inline">\((c,d)\)</span>围成的平行四边形的面积刚好就是<spanclass="math inline">\((a,b),(c,d)\)</span>围成的四边形与<spanclass="math inline">\((a&#39;,b&#39;),(c,d)\)</span>围成的四边形的总和。即：<span class="math display">\[\begin{vmatrix}a+a&#39;&amp;b+b&#39;\\c&amp;d\end{vmatrix}=\begin{vmatrix}a&amp;b\\ c&amp;d\end{vmatrix}+\begin{vmatrix}a&#39;&amp;b&#39;\\ c&amp;d\end{vmatrix}\]</span></p><p>高维空间与此类似，本质上都是等价替换。</p><h3 id="求三角形的面积">求三角形的面积</h3><p>受此启发，对平面任意三点<spanclass="math inline">\((x_1,y_1),(x_2,y_2),(x_3,y_3)\)</span>构成的三角形围成的面积就是：<spanclass="math inline">\(\frac{1}{2}\begin{vmatrix}x_1&amp;y_1&amp;1\\x_2&amp;y_2&amp;1\\ x_3&amp;y_3&amp;1\end{vmatrix}\)</span>。</p><blockquote><p>第三列全为1相当于把平面投影到三维空间，而三点共面。</p></blockquote><p>再根据行列式性质令行2和行3减去行1，使得第三列除了首个元素外全归0，此时按代数余子式展开，得到面积值为：<spanclass="math inline">\(\frac{1}{2}((x_2-x_1)(y_3-y_1)-(x_3-x_1)(y_2-y_1))\)</span>。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570093614&amp;p=20&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B20%5D%20%E5%85%8B%E8%8E%B1%E5%A7%86%E6%B3%95%E5%88%99%E3%80%81%E9%80%86%E7%9F%A9%E9%98%B5%E3%80%81%E4%BD%93%E7%A7%AF/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B020.pdf">克莱姆法则、逆矩阵、体积</a></li><li><ahref="https://rqtn.github.io/2019/08/31/LA-Lec20/">克拉默法则、逆矩阵、体积</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十九)——行列式公式</title>
    <link href="/2023/09/28/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B9%9D)%E2%80%94%E2%80%94%E8%A1%8C%E5%88%97%E5%BC%8F%E5%85%AC%E5%BC%8F/"/>
    <url>/2023/09/28/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B9%9D)%E2%80%94%E2%80%94%E8%A1%8C%E5%88%97%E5%BC%8F%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>通过上一讲掌握的行列式10大特性，我们可以推导出行列式的一般求解公式。本讲从已知特性着手，深入讲解了行列式一般求解公式。</p><span id="more"></span><h1 id="行列式公式">行列式公式</h1><h2 id="二阶行列式公式">二阶行列式公式</h2><p>上一讲我们有提到对于二阶行列式：<spanclass="math inline">\(\begin{vmatrix}a&amp;b\\c&amp;d\end{vmatrix}=ad-bc\)</span>，它可以根据行列式的性质来得到：<span class="math display">\[\begin{vmatrix}a&amp;b \\c&amp;d\end{vmatrix}=\begin{vmatrix}a&amp;0 \\c&amp;d\end{vmatrix}+\begin{vmatrix}0&amp;b \\c&amp;d\end{vmatrix}=\begin{vmatrix}a&amp;0 \\c&amp;0\end{vmatrix}+\begin{vmatrix}a&amp;0 \\0&amp;d\end{vmatrix}+\begin{vmatrix}0&amp;b \\c&amp;0\end{vmatrix}+\begin{vmatrix}0&amp;b \\0&amp;d\end{vmatrix}\]</span></p><p>根据性质3分解出<span class="math inline">\(2\times2\)</span>个行列式，其中第一项和第四项由于存在全零列，故值为0。第二项根据性质7可知值为<spanclass="math inline">\(ad\)</span>，第三项根据性质2和7可知值为<spanclass="math inline">\(-bc\)</span>，因此<spanclass="math inline">\(\begin{vmatrix}a&amp;b\\c&amp;d\end{vmatrix}=ad-bc\)</span>。</p><h2 id="从二阶到三阶">从二阶到三阶</h2><p>采用同样的手法，我们也可以拆分三阶行列式：先保持2、3行不变，对第1行进行拆分，得到3个行列式，再对这3个行列式的第2行进行拆分，共得到<spanclass="math inline">\(3\times3\)</span>个行列式，再接着拆分这9个行列式的第3行，最终得到<spanclass="math inline">\(3\times 3\times3\)</span>个行列式，我们忽略存在全零列的行列式，最终得到6个行列式加和：<span class="math display">\[\begin{vmatrix}a_{11}&amp;a_{12}&amp;a_{13} \\a_{21}&amp;a_{22}&amp;a_{23} \\a_{31}&amp;a_{32}&amp;a_{33}\end{vmatrix}=\begin{vmatrix}a_{11}&amp;0&amp;0 \\0&amp;a_{22}&amp;0 \\0&amp;0&amp;a_{33}\end{vmatrix}+\begin{vmatrix}a_{11}&amp;0&amp;0 \\0&amp;0&amp;a_{23} \\0&amp;a_{32}&amp;0\end{vmatrix}+\begin{vmatrix}0&amp;a_{12}&amp;0 \\a_{21}&amp;0&amp;0 \\0&amp;0&amp;a_{33}\end{vmatrix}+\begin{vmatrix}0&amp;a_{12}&amp;0 \\0&amp;0&amp;a_{23} \\a_{31}&amp;0&amp;0\end{vmatrix}+\begin{vmatrix}0&amp;0&amp;a_{13} \\a_{21}&amp;0&amp;0 \\0&amp;a_{32}&amp;0\end{vmatrix}+\begin{vmatrix}0&amp;0&amp;a_{13} \\0&amp;a_{22}&amp;0 \\a_{31}&amp;0&amp;0\end{vmatrix}\]</span></p><p>行列式<spanclass="math inline">\(=a_{11}a_{22}a_{33}-a_{11}a_{23}a_{32}-a_{12}a_{21}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{13}a_{22}a_{31}\)</span>。</p><p>根据排列组合思想，可以得出<spanclass="math inline">\(n\)</span>阶行列式分解可以得到<spanclass="math inline">\(n!\)</span>个非零行列式，故一般公式可以写作：<span class="math display">\[\det A=\sum_{n!}\pm a_{1\alpha}a_{2\beta}a_{3\gamma}...a_{n\omega},(\alpha, \beta, \gamma, ..., \omega)=P_{n}^{n}\]</span></p><p><strong>前面的正负号，要取决于行列式转为三角阵所需行交换的步数，若步数为偶数，那么符号为正；若步数为奇数，则符号为负。</strong></p><p>有一个比较优雅的算法来判断非零行列式的符号：统计数列的逆序数，逆序数就是从左到右遍历当前排列中的每一个数，统计它的右侧有几个数比自己小，最终加和求得。比如对于排列<spanclass="math inline">\((4,3,2,1)\)</span>来说，它的逆序数就是<spanclass="math inline">\(3+2+1=6\)</span>，逆序数为偶数故为偶排列，否则就是奇排列。偶排列符号取正，奇排列符号取负。</p><h2 id="代数余子式">代数余子式</h2><p>将三阶行列式的一般公式做一下合并同类项： <spanclass="math display">\[a_{11}(a_{22}a_{33}-a{23}a{32})+a_{12}(-a_{21}a_{33}+a_{23}a_{32})+a_{13}(a_{21}a_{32}-a_{22}a_{31})\]</span></p><p>合并后，我们发现上式可以看成： <span class="math display">\[\begin{vmatrix}a_{11}&amp;0&amp;0 \\0&amp;a_{22}&amp;a_{23}\\0&amp;a_{32}&amp;a_{33}\end{vmatrix}+\begin{vmatrix}0&amp;a_{12}&amp;0 \\a_{21}&amp;0&amp;a_{23}\\a_{31}&amp;0&amp;a_{33}\end{vmatrix}+\begin{vmatrix}0&amp;0&amp;a_{13} \\a_{21}&amp;a_{22}&amp;0 \\a_{31}&amp;a_{32}&amp;0\end{vmatrix}\]</span></p><p>也就是： <span class="math display">\[a_{11}(\begin{vmatrix}a_{22}&amp;a_{23} \\a_{32}&amp;a_{33}\end{vmatrix})+a_{12}(-\begin{vmatrix}a_{21}&amp;a_{23} \\a_{31}&amp;a_{33}\end{vmatrix})+a_{13}(\begin{vmatrix}a_{21}&amp;a_{22} \\a_{31}&amp;a_{32}\end{vmatrix})\]</span></p><p>这就表明，3阶行列式由多个2阶行列式组成。由此递推，<spanclass="math inline">\(n\)</span>阶行列式就是由多个<spanclass="math inline">\(n-1\)</span>阶行列式组成。由此，我们就找出了自顶向下的递归关系。</p><p>实际上，括号里的部分我们称作代数余子式，比如<spanclass="math inline">\((a_{22}a_{33}-a{23}a{32})\)</span>就是<spanclass="math inline">\(a_{11}\)</span>的代数余子式。对于选定元素<spanclass="math inline">\(a_{ij}\)</span>，其代数余子式为：将原行列式的第<spanclass="math inline">\(i\)</span>行与第<spanclass="math inline">\(j\)</span>列元素全部抹去，剩余的<spanclass="math inline">\(n-1\)</span>阶行列式再取正负，得到的算式就是代数余子式，一般记为<spanclass="math inline">\(C_{ij}\)</span>。那么这个正负要怎么判断呢？可以根据<spanclass="math inline">\(i,j\)</span>来判定： <span class="math display">\[C_{ij}=(-1)^{i+j}\cdot \det(去掉i行j列的n-1阶方阵)\]</span></p><p>使用代数余子式可以将一般计算公式简写作：<spanclass="math inline">\(\detA=a_{11}C_{11}+a_{12}C_{12}+...+a_{1n}C_{1n}\)</span>。</p><blockquote><p>代数余子式的计算方式相比于借助行列式的特性、消元成三角阵求主元乘积的方法来说其实更麻烦一些。但是这里之所以探索一般公式，主要是为了挖掘<spanclass="math inline">\(n\)</span>阶行列式与<spanclass="math inline">\(n-1\)</span>阶行列式之间的关系，由此而递归下去。</p></blockquote><h3 id="有趣的示例">有趣的示例</h3><p>现有:<span class="math inline">\(A_1=1\)</span>，<spanclass="math inline">\(A_2=\begin{vmatrix}1&amp;1 \\ 1&amp;1\end{vmatrix}\)</span>, <spanclass="math inline">\(A_3=\begin{vmatrix}1&amp;1&amp;0 \\ 1&amp;1&amp;1\\ 0&amp;1&amp;1\end{vmatrix}\)</span>, <spanclass="math inline">\(A_4=\begin{vmatrix}1&amp;1&amp;0&amp;0\\1&amp;1&amp;1&amp;0\\ 0&amp;1&amp;1&amp;1\\0&amp;0&amp;1&amp;1\end{vmatrix}\)</span>。寻找行列式之间的规律。</p><p>容易求得<spanclass="math inline">\(A_1=1,A_2=0,A_3=-1\)</span>。我们可以发现<spanclass="math inline">\(A_4\)</span>的方阵按第一行展开，由于只有<spanclass="math inline">\(a_{11}和a_{12}\)</span>非零，故拆分成代数余子式的形式有：<span class="math display">\[A_4=1*\begin{vmatrix}1&amp;1&amp;0 \\1&amp;1&amp;1 \\0&amp;1&amp;1\end{vmatrix}+(-1)*\begin{vmatrix}1&amp;1&amp;0 \\0&amp;1&amp;1 \\0&amp;1&amp;1\end{vmatrix}\]</span></p><p>其中第二项我们发现第一列只有1个元素非零，也就是说如果继续拆分到<spanclass="math inline">\(A_2\)</span>的组合，非零项只有1个，故上式相当于：<spanclass="math inline">\(A_4=A_3-A_2\)</span>，因此求得<spanclass="math inline">\(A_4=-1\)</span>。</p><blockquote><p>实际上，这个矩阵十分特殊，它存在着这样的规律：<spanclass="math inline">\(A_n=A_{n-1}-A_{n-2}\)</span>，行列式对应的值是一个数列：<spanclass="math inline">\(1,0,-1,-1,0,1\)</span>，以6为周期。</p></blockquote><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570094031&amp;p=19&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B18%2C19%5D%20%E8%A1%8C%E5%88%97%E5%BC%8F%E4%BB%8B%E7%BB%8D/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B018%2C19.pdf">行列式介绍</a></li><li><ahref="https://rqtn.github.io/2019/08/12/LA-Lec19/">行列式公式和代数余子式</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十八)——行列式及其性质</title>
    <link href="/2023/09/27/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%85%AB)%E2%80%94%E2%80%94%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/"/>
    <url>/2023/09/27/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%85%AB)%E2%80%94%E2%80%94%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<p>从本讲开始进入线性代数的第二部分：行列式与特征值。许多国内教材都是把行列式放在第一章，这对于理解线性代数这门语言来说是非常离谱的操作。行列式因方阵而生，它的值与特性与方阵息息相关，在求解特征值过程中行列式发挥了极大的作用。我们要着重于理解其背后的机理、探索本质，而不是死记硬背几个公式或是掌握一些trick手法解几道算术题。</p><span id="more"></span><h1 id="行列式及其性质">行列式及其性质</h1><p>每个方阵都有行列式，行列式是跟该方阵有关的一个数字，行列式的值隐含了该方阵的许多特性，例如，行列式为<spanclass="math inline">\(0\)</span>的方阵一定不可逆，可逆的方阵行列式值一定不为<spanclass="math inline">\(0\)</span>。</p><p>行列式数学上写作<spanclass="math inline">\(\begin{vmatrix}A\end{vmatrix}\)</span>，一般记为<spanclass="math inline">\(\det A\)</span>。</p><h2 id="行列式的三大基础特性">行列式的三大基础特性</h2><ul><li>性质1：单位阵 <span class="math inline">\(\det I=1\)</span>。</li><li>性质2：交换任意两行后，行列式值的符号取反。</li><li>性质3：<ul><li>a: 行列式可以按行提取矩阵的系数，即:<spanclass="math inline">\(\begin{vmatrix}ta&amp;tb \\ c&amp;d \\\end{vmatrix}=t\begin{vmatrix}a&amp;b \\c&amp;d\end{vmatrix}\)</span>。</li><li>b: 行列式的行具有线性，即：<spanclass="math inline">\(\begin{vmatrix} a+a&#39;&amp;b+b&#39; \\ c&amp;d\\ \end{vmatrix}=\begin{vmatrix} a&amp;b \\c&amp;d\end{vmatrix}+\begin{vmatrix} a&#39;&amp;b&#39; \\c&amp;d\end{vmatrix}\)</span></li></ul></li></ul><blockquote><p>注意3b里的线性是指行的线性，而非行列式具有线性。</p></blockquote><h2 id="衍生推导特性">衍生推导特性</h2><p>其他的特性都可以根据三大基础特性来进行推导，它们也十分重要，在我们计算行列式和推导其他特性的过程中常常用到。</p><ul><li>性质4：如果存在相等的两行，则行列式为<spanclass="math inline">\(0\)</span>。可以用性质2来证明，交换相等的两行，行列式的值会取反，但此时方阵并没有任何改变，因此只有行列式为<spanclass="math inline">\(0\)</span>值才能满足性质2。</li><li>性质5：从<span class="math inline">\(k\)</span>行中减去<spanclass="math inline">\(i\)</span>行的<spanclass="math inline">\(l\)</span>倍，行列式不发生改变。<strong>换言之，行列式不因矩阵消元而改变。</strong>这一性质对列变换也同样生效（相当于先转置，行变换后再转置回来，就是列变换）。根据性质3，可知： <span class="math display">\[\begin{vmatrix}a&amp;b \\c-la&amp;d-lb\end{vmatrix}=\begin{vmatrix}a&amp;b \\c&amp;d\end{vmatrix}-l\begin{vmatrix}a&amp;b \\a&amp;b\end{vmatrix}\]</span> 再根据刚推导的性质4，等号右边第二项行列式为<spanclass="math inline">\(0\)</span>，性质5得证。</li><li>性质6：如果方阵的某一行全为<spanclass="math inline">\(0\)</span>，则行列式为<spanclass="math inline">\(0\)</span>。 由性质3或性质5推理显然。</li><li>性质7：上三角<spanclass="math inline">\(U\)</span>方阵的行列式值等于对角线上元素的乘积。<spanclass="math inline">\(\det U=d_1d_2\cdot d_n\)</span>： <spanclass="math display">\[U=\begin{vmatrix}d_1&amp;*&amp;...&amp;* \\0&amp;d_2&amp;...&amp;* \\...&amp;...&amp;...&amp;... \\0&amp;0&amp;...&amp;d_n\end{vmatrix}\]</span>由性质5，从最后一行开始，将对角线元素上方的非零元素依次变为<spanclass="math inline">\(0\)</span>，行列式值不变。此时可以得到只有对角线元素的对角阵<spanclass="math inline">\(D\)</span>。再根据性质3a，提取所有的对角线元素<spanclass="math inline">\(d_i\)</span>华为单位阵，结合性质1得证。</li><li>性质8：当且仅当<spanclass="math inline">\(A\)</span>是奇异矩阵时（不可逆），<spanclass="math inline">\(\det A=0\)</span>。 由性质7，如果<spanclass="math inline">\(A\)</span>是可逆，那么消元得到的上三角<spanclass="math inline">\(U\)</span>对角线上的各行都有主元，行列式必不为<spanclass="math inline">\(0\)</span>。反之，消元后会出现全零行，有性质6可知行列式为<spanclass="math inline">\(0\)</span>。</li><li>性质9：<span class="math inline">\(\det AB=\det A \cdot \detB\)</span>，行列式具备乘法性质。 由性质5，可以把<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>通过行变换最终转为对角阵<spanclass="math inline">\(A&#39;,B&#39;\)</span>，此时<spanclass="math inline">\(\det A&#39;=\det A, \det B&#39;=\detB\)</span>。而两个对角矩阵相乘的结果显而易见： <spanclass="math display">\[\begin{bmatrix}a_1&amp;0&amp;...&amp;0 \\0&amp;a_2&amp;...&amp;0 \\...&amp;...&amp;...&amp;...\\0&amp;0&amp;...&amp;a_n\end{bmatrix}\begin{bmatrix}b_1&amp;0&amp;...&amp;0 \\0&amp;b_2&amp;...&amp;0 \\...&amp;...&amp;...&amp;...\\0&amp;0&amp;...&amp;b_n\end{bmatrix}=\begin{bmatrix}a_1b_1&amp;0&amp;...&amp;0 \\0&amp;a_2b_2&amp;...&amp;0 \\...&amp;...&amp;...&amp;...\\0&amp;0&amp;...&amp;a_nb_n\end{bmatrix}\]</span> 由性质7可知<span class="math inline">\(\detA&#39;B&#39;=(a_1\cdot a_2\cdot ...\cdot a_n)(b_1\cdot b_2\cdot ...\cdotb_n)\)</span>，故<span class="math inline">\(\det A&#39;B&#39;=\detA&#39; \det B&#39;\)</span>。另一方面，<spanclass="math inline">\(AB\)</span>转为<spanclass="math inline">\(A&#39;B&#39;\)</span>的过程实际上就是分别左乘一个矩阵对<spanclass="math inline">\(A\)</span>做行变换，再右乘一个矩阵对<spanclass="math inline">\(B\)</span>做列变换，得到<spanclass="math inline">\(A&#39;B&#39;\)</span>，由性质5可知<spanclass="math inline">\(\det AB=\det A&#39;B&#39;\)</span>，故<spanclass="math inline">\(\det AB = \det A \det B\)</span>。</li></ul><blockquote><p>根据性质9，可以轻松求得<spanclass="math inline">\(A\)</span>逆矩阵的行列式，因为<spanclass="math inline">\(\det I=\det A^{-1} \cdot \detA=1\)</span>，所以行列式互为倒数（如果<spanclass="math inline">\(A\)</span>不可逆，可以看出式子也不成立）。此外还可以看出<spanclass="math inline">\(\det A^2=(\det A)^2\)</span>。</p></blockquote><ul><li>性质10：<span class="math inline">\(\det A^T=\det A\)</span>。 <spanclass="math inline">\(A=LU\)</span>，可知<spanclass="math inline">\(A^T=U^TL^T\)</span>，根据性质9：<spanclass="math inline">\(\det A^T=\det U^T \det L^T, \det A=\det U \detL\)</span>，且已知三角阵转置后还是三角阵，故<spanclass="math inline">\(\det U=\det U^T, \det L^T=\detL\)</span>，因此<span class="math inline">\(\det A^T=\detA\)</span>。</li></ul><h2 id="二阶方阵的行列式">二阶方阵的行列式</h2><p>根据上述的性质，我们可以很容易推出二阶方阵：<spanclass="math inline">\(\begin{vmatrix}a&amp;b\\ c&amp;d\end{vmatrix}\)</span>的行列式为<spanclass="math inline">\(ad-bc\)</span>。</p><p>熟练掌握这些行列式的特性，不仅可以让我们快速求解行列式，还可以看出矩阵的变换与行列式变化的联动关系。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570090316&amp;p=18&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B18%2C19%5D%20%E8%A1%8C%E5%88%97%E5%BC%8F%E4%BB%8B%E7%BB%8D/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B018%2C19.pdf">行列式介绍</a></li><li><ahref="https://rqtn.github.io/2019/08/12/LA-Lec18/">行列式及其性质</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十七)——正交矩阵和Gram-Schmidt正交化</title>
    <link href="/2023/09/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%83)%E2%80%94%E2%80%94%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E5%92%8CGram-Schmidt%E6%AD%A3%E4%BA%A4%E5%8C%96/"/>
    <url>/2023/09/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%83)%E2%80%94%E2%80%94%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E5%92%8CGram-Schmidt%E6%AD%A3%E4%BA%A4%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>书接上一回标准正交基，讲述了该正交向量组的特性与优势，并介绍了一种将一组向量标准化为标准正交向量组的重要方法：Gram-Schmidt正交化。</p><span id="more"></span><h1 id="正交矩阵和gram-schmidt正交化">正交矩阵和Gram-Schmidt正交化</h1><h2 id="标准正交基">标准正交基</h2><p>标准正交向量组构成的空间基被称为标准正交基，它有两个特性：对标准正交向量组中任意向量<spanclass="math inline">\(q\)</span>，有： <span class="math display">\[\begin{cases}q_i^Tq_j=0 \space (i\neq j) \\q_i^Tq_j=1 \space (i=j)\end{cases}\]</span></p><p>即：向量彼此垂直，模均为<span class="math inline">\(1\)</span>。</p><h2 id="标准正交矩阵">标准正交矩阵</h2><p>将标准正交向量组中的<spanclass="math inline">\(q_1,q_2,...,q_n\)</span>组成的矩阵<spanclass="math inline">\(Q\)</span>被称为正交矩阵： <spanclass="math display">\[Q=\begin{bmatrix}q_1&amp; q_2&amp; q_3&amp; ...&amp; q_n\end{bmatrix}\]</span></p><p>显然，正交矩阵<spanclass="math inline">\(Q\)</span>具有一个良好的性质：<spanclass="math inline">\(Q^TQ=I\)</span> <span class="math display">\[Q^TQ=\begin{bmatrix}q_1\\ q_2\\ q_3\\ ...\\q_n\end{bmatrix}\begin{bmatrix}q_1&amp; q_2&amp; q_3&amp; ...&amp;q_n\end{bmatrix}=\begin{bmatrix}1&amp; 0&amp; ...&amp; 0&amp;0\\ 0&amp;1&amp; ...&amp; 0&amp; 0\\ ...&amp; ...&amp; ...&amp; ...&amp; ...\\0&amp; 0&amp; ...&amp; 1&amp; 0\\ 0&amp; 0&amp; ...&amp; 0&amp;1\end{bmatrix}=I\]</span></p><h3 id="正交矩阵">正交矩阵</h3><p><strong>特别地，当<spanclass="math inline">\(Q\)</span>为方阵时，我们称这样的<spanclass="math inline">\(Q\)</span>为正交矩阵。</strong></p><p>正交矩阵有更丰富的性质，此时的方阵<spanclass="math inline">\(Q\)</span>有逆矩阵，由<spanclass="math inline">\(Q^TQ=I\)</span>可知，<spanclass="math inline">\(Q^{-1}=Q^T\)</span>。</p><blockquote><p>置换矩阵就是个经典案例。</p></blockquote><h3 id="标准正交矩阵的应用">标准正交矩阵的应用</h3><p>标准正交矩阵可以应用到投影矩阵上，我们知道：<spanclass="math inline">\(P=A(A^TA)^{-1}A^T\)</span>，当<spanclass="math inline">\(A\)</span>是标准正交矩阵时，有：<spanclass="math inline">\(Q(Q^TQ)^{-1}Q^T=QQ^T\)</span>。特别地，若<spanclass="math inline">\(Q\)</span>为方阵，此时<spanclass="math inline">\(QQ^T=QQ^{-1}=I\)</span>。（说明此时投影矩阵就是单位阵<spanclass="math inline">\(I\)</span>）</p><p><spanclass="math inline">\(P\)</span>的计算得到了极大的简化，对于<spanclass="math inline">\(P=QQ^T\)</span>，根据前面几讲的知识，我们知道<spanclass="math inline">\(QQ^T\)</span>有着一些特性：</p><ul><li>是对称阵，即<span class="math inline">\(P=P^T\)</span></li><li>乘方不变性，即<span class="math inline">\(P^2=P\)</span></li></ul><p>此外，对于前两讲中的拟合方程：<span class="math inline">\(A^TA\hatx=A^Tb\)</span>，若<spanclass="math inline">\(A\)</span>为标准正交矩阵，那么方程就变成了<spanclass="math inline">\(\hat x=Q^Tb\)</span>。<spanclass="math inline">\(\hat x\)</span>的每个分量<spanclass="math inline">\(\hat x_i=q_i^Tb\)</span>，即都是<spanclass="math inline">\(Q\)</span>中对应列向量与<spanclass="math inline">\(b\)</span>的内积。</p><blockquote><p>这个式子的物理意义就是：对已知标准正交基，向量<spanclass="math inline">\(b\)</span>在第<spanclass="math inline">\(i\)</span>个基上的投影就是对应基向量<spanclass="math inline">\(q_i^Tb\)</span>。</p></blockquote><p>因此，如果我们选择标准正交向量组作为基时，投影矩阵相关公式中的诸多计算都得到了极大的简化。</p><h2 id="gram-schmidt正交化">Gram-Schmidt正交化</h2><p>在标准正交矩阵的应用中我们可以看到，如果能够在实际运算中采用标准正交向量组，那就可以简化相当多的运算量。然而实际情况是，我们往往拿到的都只是一组线性无关的向量，它们恰好构成标准正交基的可能性微乎其微。那么有没有一种方法，可以将任意的线性无关向量组转换为标准正交基呢？</p><p><strong>答案是肯定的，这种方法就是”Gram-Schmidt正交化“。</strong></p><p>Gram-Schmidt正交化的过程很简单： <span class="math display">\[线性无关向量a,b\rightarrow 正交向量A,B\rightarrow标准正交向量q_1=\frac{A}{||A||}, q_2=\frac{B}{||B||}\]</span></p><blockquote><p>第一步转为正交向量的过程被称作Graham，第二步标准化为模1的过程被称作Schmidt。</p></blockquote><p>第二步标准化的过程很好理解，对每个分量除以模量即可，正交化的过程关键在于第一步，怎么找到<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>。</p><p>以不共线的两个<spanclass="math inline">\(a,b\)</span>向量为例，怎么转换成正交基呢？这就要用到投影：</p><p><img src="2023-09-26-16-02-58.png" /></p><p>我们先将<span class="math inline">\(a\)</span>向量固定，设为<spanclass="math inline">\(A\)</span>，然后将<spanclass="math inline">\(b\)</span>向量投影到<spanclass="math inline">\(A\)</span>上得到<spanclass="math inline">\(p\)</span>，此时误差向量<spanclass="math inline">\(e=b-p\)</span>所在直线的方向实际上就是另一个基向量<spanclass="math inline">\(B\)</span>的方向，取投影长度为<spanclass="math inline">\(B\)</span>的长度。于是有： <spanclass="math display">\[B=b-\frac{AA^Tb}{A^TA}\]</span></p><p>式子里<span class="math inline">\(A^Tb\)</span>和<spanclass="math inline">\(A^TA\)</span>都是内积标量值，因此上式一般写作：<spanclass="math inline">\(B=b-\frac{A^Tb}{A^TA}A\)</span>的形式。</p><p>得到<spanclass="math inline">\(A,B\)</span>之后，第二步就是做标准化了：<spanclass="math inline">\(q_1=\frac{A}{||A||},q_2=\frac{B}{||B||}\)</span>。</p><p>延展到三维空间，对于向量<spanclass="math inline">\(a,b,c\)</span>要怎么做正交化呢？我们可以如法炮制，首先<spanclass="math inline">\(A,B\)</span>的寻找方法不变： <spanclass="math display">\[A=a,B=b-\frac{AA^Tb}{A^TA}\]</span></p><p><span class="math inline">\(C\)</span>的计算如出一辙，我们分别让<spanclass="math inline">\(c\)</span>在<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>上进行投影，然后再减去投影得到的两个向量即为<spanclass="math inline">\(C\)</span>： <span class="math display">\[C=c-\frac{A^Tc}{A^TA}A-\frac{B^Tc}{B^TB}B\]</span></p><p>最后再对<span class="math inline">\(A,B,C\)</span>标准化即可。</p><h3 id="示例">示例</h3><p>有<span class="math inline">\(a=\begin{bmatrix}1\\ 1\\1\end{bmatrix}, b=\begin{bmatrix}1\\ 0\\2\end{bmatrix}\)</span>，求标准正交矩阵<spanclass="math inline">\(Q\)</span>。</p><p>解：</p><p>先固定<span class="math inline">\(A=a=\begin{bmatrix}1\\ 1\\1\end{bmatrix}\)</span>，用<span class="math inline">\(b\)</span>在<spanclass="math inline">\(A\)</span>上投影，差值即为: <spanclass="math display">\[B=b-\frac{A^Tb}{A^TA}A=\begin{bmatrix}1\\ 0\\2\end{bmatrix}-\frac{3}{3}\begin{bmatrix}1\\ 1\\1\end{bmatrix}=\begin{bmatrix}0\\ -1\\ 1\end{bmatrix}\]</span></p><p>标准化后得到： <span class="math display">\[Q=\begin{bmatrix}\frac{1}{\sqrt{3}}&amp; 0\\ \frac{1}{\sqrt{3}}&amp;-\frac{1}{\sqrt{2}}\\ \frac{1}{\sqrt{3}}&amp;\frac{1}{\sqrt{2}}\end{bmatrix}\]</span></p><h2 id="引申矩阵的qr分解">引申：矩阵的QR分解</h2><p>用消元法视角来看<spanclass="math inline">\(A\)</span>的分解，可以看做<spanclass="math inline">\(A=LU\)</span>，<spanclass="math inline">\(L\)</span>是进行行变换的下三角阵，<spanclass="math inline">\(U\)</span>是上三角阵。</p><p>以同样的眼光来看Gram-Schmidt正交化，有<spanclass="math inline">\(A=QR\)</span>，其中<spanclass="math inline">\(Q\)</span>为标准正交化阵，<spanclass="math inline">\(R\)</span>是一个上三角阵。 <spanclass="math display">\[\begin{bmatrix}a_1&amp; a_2\end{bmatrix}=\begin{bmatrix}q_1&amp;q_2\end{bmatrix}\begin{bmatrix}a_1^Tq_1&amp; a_2^Tq_1\\ a_1^Tq_2&amp;a_2^Tq_2\end{bmatrix}\]</span></p><p>显然左下角<span class="math inline">\(a_1^Tq_2=0\)</span>(<spanclass="math inline">\(a1是A方向，\)</span>q2<spanclass="math inline">\(是\)</span>B<spanclass="math inline">\(方向\)</span>)，拓展到高维会发现下三角都是<spanclass="math inline">\(0\)</span>，因为后构造的向量总是垂直于前面的向量。这也是Gram-Schmidt正交化的一个性质。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570089959&amp;p=17&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B17%5D%20%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E5%92%8CGram-Schmidt%20%E6%AD%A3%E4%BA%A4%E5%8C%96/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B017.pdf">正交矩阵和Gram-Schmidt正交化</a></li><li><a href="https://rqtn.github.io/2019/08/12/LA-Lec17/">Lec17 -正交矩阵和 Gram-Schmidt 正交化</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十六)——投影矩阵和最小二乘</title>
    <link href="/2023/09/25/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%85%AD)%E2%80%94%E2%80%94%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/"/>
    <url>/2023/09/25/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%85%AD)%E2%80%94%E2%80%94%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<p>在上一讲的基础上继续深度展开。</p><span id="more"></span><h1 id="投影矩阵和最小二乘">投影矩阵和最小二乘</h1><p>上一讲已经渗透了投影矩阵的概念，并以简单的线性回归作为示例，对最小二乘法和投影矩阵加以联系。</p><h2 id="投影矩阵">投影矩阵</h2><p>投影矩阵<spanclass="math inline">\(P=A(A^TA)^{-1}A^T\)</span>，其物理意义是将向量<spanclass="math inline">\(b\)</span>投影到<spanclass="math inline">\(A\)</span>的列空间中。</p><p>投影有两种极限情况：</p><ul><li>如果<span class="math inline">\(b\)</span>本身就在<spanclass="math inline">\(A\)</span>的列空间中，那么<spanclass="math inline">\(Pb=b\)</span>，此时<spanclass="math inline">\(P=I\)</span>。</li><li>如果<span class="math inline">\(b\)</span>垂直于<spanclass="math inline">\(A\)</span>列空间，此时<spanclass="math inline">\(Pb=0\)</span>，根据正交补的概念，<spanclass="math inline">\(b\)</span>是<spanclass="math inline">\(A\)</span>左零空间的向量，有<spanclass="math inline">\(A^Tb=0\)</span>。</li></ul><p><strong>综上可以归纳：任意向量<spanclass="math inline">\(b\)</span>都可以拆解成两个分量，一个分量<spanclass="math inline">\(p\)</span>在<spanclass="math inline">\(A\)</span>的列空间中，另一分量<spanclass="math inline">\(e\)</span>在<spanclass="math inline">\(A\)</span>的左零空间中。</strong></p><p><img src="2023-09-25-16-19-32.png" /></p><p><span class="math inline">\(p\)</span>是投影矩阵<spanclass="math inline">\(P\)</span>作用于<spanclass="math inline">\(b\)</span>在<spanclass="math inline">\(A\)</span>列空间的投影得到的分量，同理，如果想要投影到左零空间，那么投影矩阵就应该是<spanclass="math inline">\(I-P\)</span>。</p><blockquote><p>因为<span class="math inline">\(p=Pb, e=b-p\)</span>，所以<spanclass="math inline">\(e=b-Pb=(I-P)b\)</span>。</p></blockquote><h2 id="再探最小二乘">再探最小二乘</h2><p>还是回到例题：平面上三个点<span class="math inline">\((1,1), (2,2),(3,2)\)</span>做线性回归。</p><p><img src="2023-09-26-12-02-09.png" /></p><p>上一节我们分别通过微积分和投影矩阵两种方法进行了拟合，最终发现所求解的方程完全一致。实际上，在微积分求解法中，我们本质上算的是误差向量<spanclass="math inline">\(e1,e2,e3\)</span>模的平方和，为了让平方和最小，通过求导数找极值的方式列出了求解方程。而在投影法中，投影的本质其实就是将向量<spanclass="math inline">\(b\)</span>投影到<spanclass="math inline">\(A\)</span>列空间中最近的一点，换句话说，就是把<spanclass="math inline">\(p1,p2,p3\)</span>分别投影到所需求解的直线上去。</p><p><strong>因此，微积分算最小二乘(leastsquare)和投影矩阵具有相同的内核，也就不难理解为何二者最终需求解的解方程组殊途同归了。</strong></p><p>最终我们求得<spanclass="math inline">\(y=\frac{1}{2}x+\frac{2}{3}\)</span>，得到: <spanclass="math display">\[b=\begin{bmatrix}1\\ 2\\ 2\end{bmatrix}, p=\begin{bmatrix}\frac{7}{6}\\\frac{10}{6} \\\frac{13}{6}\end{bmatrix},e=\begin{bmatrix}-\frac{1}{6}\\ \frac{2}{6}\\-\frac{1}{6}\end{bmatrix}\]</span></p><p>简单验证一下，可以发现<span class="math inline">\(e\)</span>与<spanclass="math inline">\(p\)</span>垂直。</p><h2 id="标准正交基">标准正交基</h2><p>互相垂直的各列一定是线性无关的。于是，我们可以找到空间里的一组基，它们彼此相互垂直，这组基我们称之为正交基。</p><p>参考三维直角坐标系，我们常常选用<spanclass="math inline">\(\begin{bmatrix}1\\ 0\\0\end{bmatrix},\begin{bmatrix}0\\ 1\\ 0\end{bmatrix},\begin{bmatrix}0\\0\\ 1\end{bmatrix}\)</span>作为标准基，也就是对应<spanclass="math inline">\(x,y,z\)</span>三个轴。</p><ul><li>由于彼此相互垂直，故为一组正交基。</li><li>由于每个基向量都是单位向量，故称作标准正交基。</li></ul><p>当然，标准正交基不止这一种，例如二维空间的标准正交基还可以是：<spanclass="math inline">\(\begin{bmatrix}\cos\theta\\\sin\theta\end{bmatrix},\begin{bmatrix}-\sin\theta\\\cos\theta\end{bmatrix}\)</span>。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570095287&amp;p=16&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B16%5D%20%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B016.pdf">投影矩阵和最小二乘</a></li><li><a href="https://rqtn.github.io/2019/08/12/LA-Lec16/">Lec16 -投影矩阵和最小二乘法</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十五)——子空间投影</title>
    <link href="/2023/09/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%94)%E2%80%94%E2%80%94%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8A%95%E5%BD%B1/"/>
    <url>/2023/09/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%94)%E2%80%94%E2%80%94%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8A%95%E5%BD%B1/</url>
    
    <content type="html"><![CDATA[<p>这一讲从向量的投影入手，从二维延展到高维空间，将投影用矩阵形式表示出来。然后回到上一节的遗留的话题：<spanclass="math inline">\(A^TA\hatx=A^Tb\)</span>常在工程中被用来求解最优近似解，但并没有解释该解为何为最优，这一节会对此做出解释。</p><span id="more"></span><h1 id="子空间投影">子空间投影</h1><h2 id="二维空间投影">二维空间投影</h2><p><img src="2023-09-25-10-59-35.png" /></p><p>如图所示，在二维空间中，向量<spanclass="math inline">\(p\)</span>就是<spanclass="math inline">\(b\)</span>在<spanclass="math inline">\(a\)</span>上的投影，即<spanclass="math inline">\(p=xa\)</span>，显然他们的差值是<spanclass="math inline">\(b-p=e\)</span>，<spanclass="math inline">\(e\)</span>与<spanclass="math inline">\(a\)</span>垂直： <span class="math display">\[a^Te=a^T(b-p)=a^T(b-ax)=0\]</span></p><p>代入<span class="math inline">\(p=xa\)</span>，得到<spanclass="math inline">\(p=a\frac{a^Tb}{a^Ta}\)</span>。</p><p>可以看到<spanclass="math inline">\(p\)</span>的形式中，分母是一个值，而分子中包含了<spanclass="math inline">\(b\)</span>，这也就表明投影得到的<spanclass="math inline">\(p\)</span>向量是通过前面的系数矩阵作用到<spanclass="math inline">\(b\)</span>上完成的，形式上写作：<spanclass="math inline">\(p=Pb\)</span>，其中这个系数矩阵<spanclass="math inline">\(P\)</span>我们称之为投影矩阵，即<spanclass="math inline">\(P=a\frac{a^T}{a^Tb}\)</span>。</p><p>这个<span class="math inline">\(P\)</span>矩阵有两个有取的性质：</p><ol type="1"><li>由前面课程所学的知识，我们知道<spanclass="math inline">\(P\)</span>是个对称阵，因此有<spanclass="math inline">\(P^T=P\)</span>。</li><li><span class="math inline">\(P^2=P\)</span>。<ol type="1"><li>由<spanclass="math inline">\(P^2=\frac{a(a^Ta)a^T}{(a^Ta)^2}\)</span>，而<spanclass="math inline">\(a^Ta\)</span>是内积，化简得到<spanclass="math inline">\(P\)</span>。</li><li>这一点很容易看出来，<spanclass="math inline">\(P^2\)</span>相当于对<spanclass="math inline">\(b\)</span>在<spanclass="math inline">\(a\)</span>上投影得到的<spanclass="math inline">\(p\)</span>继续再做一次投影，显然<spanclass="math inline">\(p\)</span>在<spanclass="math inline">\(a\)</span>上的投影是它本身。</li></ol></li></ol><h3 id="投影的意义">投影的意义</h3><p>为什么要做投影呢？回到上一节的<spanclass="math inline">\(Ax=b\)</span>问题，我们知道<spanclass="math inline">\(Ax\)</span>总是在<spanclass="math inline">\(A\)</span>的列空间中，但是<spanclass="math inline">\(b\)</span>不一定。那么退而求其次，什么样的<spanclass="math inline">\(x\)</span>可以最逼近<spanclass="math inline">\(b\)</span>呢？换言之，就是让<spanclass="math inline">\(b\)</span>的变化能够最小，而变化最小恰恰是通过投影来实现（所以<spanclass="math inline">\(e\)</span>被视为误差），投影得到的<spanclass="math inline">\(p\)</span>就是<spanclass="math inline">\(A\)</span>列空间中最接近<spanclass="math inline">\(b\)</span>的那一个。</p><h2 id="三维空间投影">三维空间投影</h2><p><img src="2023-09-25-11-42-06.png" /></p><p>延展到三维也并无二致，如图所示，<spanclass="math inline">\(a_1\)</span>和<spanclass="math inline">\(a_2\)</span>是构成平面的一组基，<spanclass="math inline">\(p\)</span>是<spanclass="math inline">\(b\)</span>在平面上的投影，<spanclass="math inline">\(p\)</span>可以表示为分别投影在这组基的每个向量上的投影和：<spanclass="math inline">\(p=\hat x_1a_1+\hat x_2a_2\)</span>，矩阵形式写作：<span class="math display">\[p=A\hat x, 其中A=\begin{bmatrix}a1&amp;a2\end{bmatrix}, \hatx=\begin{bmatrix}\hat x_1\\ \hat x_2\end{bmatrix}\]</span></p><p>此平面即为矩阵<spanclass="math inline">\(A\)</span>的列空间，由于<spanclass="math inline">\(b\)</span>不在平面上，因此<spanclass="math inline">\(Ax=b\)</span>无解，<spanclass="math inline">\(A\hat x=p\)</span>中的<spanclass="math inline">\(\hat x\)</span>就是最优解。</p><p>同样地，有<span class="math inline">\(e=b-p=b-A\hatx\)</span>与平面垂直(<spanclass="math inline">\(A\)</span>的列空间)，因此<spanclass="math inline">\(A^Te=0\)</span>： <span class="math display">\[\begin{bmatrix}a_1^T\\ a_2^T\end{bmatrix}(b-A\hat x)=\begin{bmatrix}0\\0\end{bmatrix}\]</span></p><blockquote><p>这与二维投影的<spanclass="math inline">\(a^T(b-xa)=0\)</span>并不差别，只不过二维空间的<spanclass="math inline">\(A^T\)</span>只有一列罢了。</p></blockquote><blockquote><p>由<spanclass="math inline">\(A^Te=0\)</span>可知，由于列空间与左零空间正交，e一定在<spanclass="math inline">\(A\)</span>的左零空间。</p></blockquote><p><strong>化简上式，可得：<span class="math inline">\(A^TA\hatx=A^Tb\)</span>，而这恰恰就是上一节我们谈及为了解决<spanclass="math inline">\(Ax=b\)</span>无解时的工程惯用法式子。至此，我们总算理解了同时左乘<spanclass="math inline">\(A^T\)</span>的物理意义。</strong></p><p>继续求解，当且仅当<spanclass="math inline">\(A^TA\)</span>可逆时，我们可以求出最优解：<spanclass="math inline">\(\hatx=(A^TA)^{-1}A^Tb\)</span>。而在上一讲的最后，我们推理出如果<spanclass="math inline">\(A\)</span>的各列线性无关，那么<spanclass="math inline">\(A^TA\)</span>可逆。</p><blockquote><p>相比于求解<span class="math inline">\(Ax=b\)</span>，只有当<spanclass="math inline">\(A\)</span>可逆时，<spanclass="math inline">\(x\)</span>才有解。而在对<spanclass="math inline">\(b\)</span>进行了在<spanclass="math inline">\(A\)</span>列空间的投影后，求解<spanclass="math inline">\(\hatx\)</span>的条件得到了适当的放宽，此时只要求<spanclass="math inline">\(A\)</span>的列向量线性无关即可。在实际工程项目中，我们测量得到的<spanclass="math inline">\(m\times n\)</span>矩阵常常<spanclass="math inline">\(m\)</span>很大，<spanclass="math inline">\(n\)</span>很小，因此容易保证。</p></blockquote><p>因此，投影向量<span class="math inline">\(p=A\hatx=A(A^TA)^{-1}A^Tb\)</span>，投影矩阵为<spanclass="math inline">\(A(A^TA)^{-1}A^T\)</span>（二维空间得<spanclass="math inline">\(\frac{aa^T}{a^Ta}\)</span>）。</p><blockquote><p>若<span class="math inline">\(A\)</span>本身可逆，投影矩阵<spanclass="math inline">\(A(A^TA)^{-1}A^T\)</span>就可进一步化简，此时<spanclass="math inline">\((A^TA)^{-1}\)</span>就可以拆成<spanclass="math inline">\(A^{-1}(A^T)^{-1}\)</span>，此时<spanclass="math inline">\(A(A^TA)^{-1}A^T=AA^{-1}(A^T)^{-1}A^T=I\)</span>，即得到单位阵。这一结论显然，因为<spanclass="math inline">\(A\)</span>若本身可逆，那么<spanclass="math inline">\(Ax=b\)</span>就有解，<spanclass="math inline">\(b\)</span>本身就在<spanclass="math inline">\(A\)</span>的列空间，投影<spanclass="math inline">\(b\)</span>到<spanclass="math inline">\(A\)</span>的列空间当然得到其本身，此时投影矩阵可不就是单位阵。</p></blockquote><h2 id="最小二乘法">最小二乘法</h2><p>前面也已经提到，投影的方式让我们得到了最优近似解，而<spanclass="math inline">\(e\)</span>向量就是其中的误差。实际上这一思想与我们做线性回归时，使用最小二乘法拟合直线的理论基础不谋而合。</p><p><img src="2023-09-25-14-56-45.png" /></p><p>对上述直线，我们想通过三个点来拟合一条直线<spanclass="math inline">\(y=Cx+D\)</span>，我们将已知的三个点<spanclass="math inline">\((1,1),(2,2),(3,2)\)</span>带入方程： <spanclass="math display">\[\begin{cases}C+D=1\\ 2C+D=2\\ 3C+D=2\end{cases}\]</span></p><p>写作矩阵形式为： <span class="math display">\[Ax=\begin{bmatrix}1&amp;1\\ 2&amp;1\\3&amp;1\end{bmatrix}\begin{bmatrix}C\\ D\end{bmatrix}=\begin{bmatrix}1\\ 2\\ 2\end{bmatrix}\]</span></p><p>显然<spanclass="math inline">\(x\)</span>无解，三点根本不共线，于是利用投影找最优近似解。由于<spanclass="math inline">\(A\)</span>中各列线性无关，所以<spanclass="math inline">\(A^TA\hat x=b\)</span>有解，展开写作： <spanclass="math display">\[\begin{bmatrix}1&amp;2&amp;3\\1&amp;1&amp;1\end{bmatrix}\begin{bmatrix}1&amp;1\\ 2&amp;1\\3&amp;1\end{bmatrix}\begin{bmatrix}C\\ D\end{bmatrix}=\begin{bmatrix}1&amp;2&amp;3\\1&amp;1&amp;1\end{bmatrix}\begin{bmatrix}1\\ 2\\ 2\end{bmatrix}\]</span></p><p>矩阵乘法运算得： <span class="math display">\[\begin{bmatrix}14&amp;6\\ 6&amp;3\end{bmatrix}\begin{bmatrix}C\\ D\end{bmatrix}=\begin{bmatrix}11\\ 5\end{bmatrix}\]</span></p><p>亦即： <span class="math display">\[\begin{cases}14C+6D=11\\ 6C+3D=5\end{cases}\]</span></p><p>求得：<span class="math inline">\(C=\frac{1}{2},D=\frac{2}{3}\)</span>。</p><h3 id="微积分解法与投影矩阵的联系">微积分解法与投影矩阵的联系</h3><p>如果用传统微积分来解最小二乘，就需要对误差方程：<spanclass="math inline">\(E=(C+D-1)^2+(2C+D-2)^2+(3C+D-2)^2\)</span>求最小值，方程有两个未知数，分别对<spanclass="math inline">\(C\)</span>和<spanclass="math inline">\(D\)</span>计算偏导的零值： <spanclass="math display">\[\begin{cases}2C+2(D-1)+8C+4(D-2)+18C+6(D-2)=0\\2D+2(C-1)+2D+2(2C-2)+2D+2(3C-2)=0\end{cases}\]</span></p><p>化简得到： <span class="math display">\[\begin{cases}14C+6D=11\\ 6C+3D=5\end{cases}\]</span></p><p>可以看出这里的两个式子其实和投影矩阵法得到的两个方程一模一样。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570093730&amp;p=15&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B15%5D%20%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8A%95%E5%BD%B1/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B015.pdf">子空间投影</a></li><li><a href="https://rqtn.github.io/2019/08/12/LA-Lec15/">Lec15 -子空间投影</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十四)——正交向量与子空间</title>
    <link href="/2023/09/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%9B%9B)%E2%80%94%E2%80%94%E6%AD%A3%E4%BA%A4%E5%90%91%E9%87%8F%E4%B8%8E%E5%AD%90%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/09/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%9B%9B)%E2%80%94%E2%80%94%E6%AD%A3%E4%BA%A4%E5%90%91%E9%87%8F%E4%B8%8E%E5%AD%90%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>这一讲从正交的角度来探讨四个子空间具有的性质。</p><span id="more"></span><h1 id="正交向量与子空间">正交向量与子空间</h1><p>一图胜千言：</p><p><img src="2023-09-21-14-59-27.png" /></p><p>本节的所有内容都在阐释上面这张图。</p><h2 id="正交">正交</h2><p>何为正交？从空间角度来看，正交就是垂直。无论是两个向量之间的正交，还是空间的正交，它们在线性代数中都意味着：垂直。</p><h3 id="向量正交">向量正交</h3><p><img src="2023-09-21-15-01-50.png" /></p><p>如图，<span class="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>两个向量相互垂直，根据中学知识，我们知道两个向量垂直则意味着这两个向量的内积为0，即：<spanclass="math inline">\(x^Ty=0\)</span>。</p><p>这一结论可以用勾股定理来证明： <span class="math display">\[\begin{aligned}|x|^2+|y|^2=|x+y|^2 \\x^Tx+y^Ty = (x+y)^T(x+y) \\0 = x^Ty+y^Tx \\易知x^Ty = y^Tx，故：2x^Ty=0 \\得到：x^Ty=0\end{aligned}\]</span></p><p>进一步，如果两个向量中其中某一个是零向量，那这两个向量一定正交。</p><h3 id="空间正交">空间正交</h3><p>所谓空间的正交，就是：一个空间中的任意一个向量，都与另一个空间中的任意一个向量正交。</p><p>直觉上，我们可能会误以为三维直角坐标系中如<spanclass="math inline">\(xy\)</span>平面<spanclass="math inline">\(xz\)</span>平面正交，但实际上它们并不正交。这一点很容易证伪，我们选择两个平面交线<spanclass="math inline">\(x\)</span>轴上的向量，任取两个，显然它们并不垂直。</p><blockquote><p>反过来，这一事实也意味着：如果两个平面在某个非零向量处相交，那么它们一定不正交。</p></blockquote><p>那么怎么样的两个空间可能会正交呢？我们先从<spanclass="math inline">\(R^2\)</span>的子空间来分析，一个平面上的子空间有：</p><ul><li>整个平面<span class="math inline">\(P\)</span></li><li>平面<span class="math inline">\(P\)</span>上任意过原点的直线<spanclass="math inline">\(L\)</span></li><li>原点零向量</li></ul><p><span class="math inline">\(P\)</span>与<spanclass="math inline">\(L\)</span>永远不可能正交；当<spanclass="math inline">\(L1\)</span>与<spanclass="math inline">\(L2\)</span>在原点处垂直时，<spanclass="math inline">\(L1\)</span>和<spanclass="math inline">\(L2\)</span>正交；<spanclass="math inline">\(L\)</span>与<spanclass="math inline">\(0\)</span>永远正交。</p><p>高维空间也可以由此继续做推理。</p><h3 id="矩阵子空间的正交">矩阵子空间的正交</h3><p>回归到矩阵，为什么我们可以笃定零空间和行空间是正交的呢？实际上我们只需要从行视角和零空间视角分别来看<spanclass="math inline">\(Ax=0\)</span>即可窥得端倪：</p><p><span class="math display">\[Ax=\begin{bmatrix}row_1 of A\\ row_2 of A\\ row_3 of A\\ ...\\ row_m ofA\end{bmatrix}\begin{bmatrix}x_1\\ x_2\\ x_3\\ ...\\x_n\end{bmatrix}=\begin{bmatrix}row_1 of A \cdot x\\ row_2 of A \cdot x\\row_3 of A \cdot x\\ ... \\row_n of A \cdot x\end{bmatrix}=\begin{bmatrix}0\\ 0\\ 0\\ ...\\ 0\end{bmatrix}\]</span></p><p>从行视角看，<spanclass="math inline">\(A\)</span>中每个行向量与向量<spanclass="math inline">\(x\)</span>的内积都是<spanclass="math inline">\(0\)</span>，而从零空间视角看，<spanclass="math inline">\(x\)</span>可以是零空间任意一个向量，因此，这就意味着<spanclass="math inline">\(A\)</span>中的每个行向量都与零空间的任意向量垂直。此外，行空间的所有向量都是由<spanclass="math inline">\(A\)</span>中行向量线性组合得到，因此无论怎么组合，都无非表示成诸如<spanclass="math inline">\(c\cdot row_1 + d\cdot row_2 + ... + z\cdotrow_m\)</span>，结果依然是<span class="math inline">\(0\)</span>。</p><p><strong>由此证得矩阵的行空间与零空间正交。同理，我们对矩阵进行转置，可以得到列空间与左零空间正交。</strong></p><p>此外，行空间和零空间的关系，更像是把一个空间一分为二所得到的两个子空间：</p><ul><li>行空间与零空间的维数之和是<span class="math inline">\(n\)</span>。<ul><li>行空间维数是<spanclass="math inline">\(r\)</span>，零空间维数是<spanclass="math inline">\(n-r\)</span>。</li><li>它们都是<span class="math inline">\(R^n\)</span>的子空间。</li></ul></li><li>列空间与左零空间的维数之和是<span class="math inline">\(m\)</span>。<ul><li>列空间维数是<spanclass="math inline">\(r\)</span>，左零空间维数是<spanclass="math inline">\(m-r\)</span>。</li><li>它们都是<span class="math inline">\(R^m\)</span>的子空间。</li></ul></li></ul><p>进一步，我们把行空间和零空间称作为<spanclass="math inline">\(R^n\)</span>中的正交补，列空间和左零空间称为<spanclass="math inline">\(R^m\)</span>中的正交补。</p><blockquote><p>所谓正交补，就是指对于一个空间<spanclass="math inline">\(S\)</span>，另一个空间<spanclass="math inline">\(T\)</span>囊括了所有垂直于<spanclass="math inline">\(S\)</span>的向量而不是局部，这里的一分为二描述的是一种彻底程度。</p></blockquote><h2 id="无解方程的最优解">无解方程的最优解</h2><p>现实世界中，矩阵的数据源于测量，测量就难免有误差甚至错误，从而导致<spanclass="math inline">\(Ax=b\)</span>无解。</p><p>什么样的<spanclass="math inline">\(Ax=b\)</span>有解呢？我们知道<spanclass="math inline">\(A\)</span>得是可逆的，当<spanclass="math inline">\(m\)</span>很大，<spanclass="math inline">\(n\)</span>很小时，我们可以通过不断的移除某些行，丢弃这些坏数据，让方程有解。这听上去是个合理的方法，但实际上却难以执行。为什么呢？因为我们根本无法判断究竟哪些行是脏数据。</p><p>对于这一困难，工程上常常会进行妥协：我们可以去求近似的最优解，类似于一种拟合。</p><p>怎么求近似解呢？在已知<spanclass="math inline">\(Ax=b\)</span>无解的前提下，我们可以尝试在方程两侧同时左乘<spanclass="math inline">\(A^T\)</span>，无解方程就变成<spanclass="math inline">\(A^TA\hat x=A^Tb\)</span>。</p><blockquote><p>这里的<span class="math inline">\(\hat x\)</span>不是解<spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(x\)</span>已经是无解的了，这里只是尝试找到一个近似解。</p></blockquote><p>通过前面课程的学习，我们知道<spanclass="math inline">\(A^TA\)</span>矩阵是一种对称方阵，此时如果<spanclass="math inline">\(A^TA\)</span>可逆，那么解<spanclass="math inline">\(\hat x\)</span>就容易求得。</p><p>然而<spanclass="math inline">\(A^TA\)</span>也不见得就可逆，怎么去判断<spanclass="math inline">\(A^TA\)</span>是否可逆呢？先说结论：当<spanclass="math inline">\(A\)</span>中各列线性相关时，<spanclass="math inline">\(A^TA\)</span>不可逆。</p><p>为了证明这一点，需要先得到两个性质：</p><ol type="1"><li><spanclass="math inline">\(N(A^TA)=N(A)\)</span>：二者具有相同的零空间。<ol type="1"><li>对于<span class="math inline">\(A^TAx=0\)</span>有：<spanclass="math inline">\(x^TA^TAx=(Ax)^T(Ax)=0\)</span>，因此<spanclass="math inline">\(Ax=0\)</span></li></ol></li><li>rank(A^TA)=rank(A)：二者具有相同的秩。<ol type="1"><li>由性质1可知二者零空间维数相同，且二者具有相同的列数，因此秩相等。</li></ol></li></ol><p>而<span class="math inline">\(A^TA\)</span>若可逆，则意味着<spanclass="math inline">\(N(A^TA)\)</span>只有零向量，既然<spanclass="math inline">\(N(A)\)</span>与<spanclass="math inline">\(N(A^TA)\)</span>相同，也就意味着<spanclass="math inline">\(N(A)\)</span>中也只能有零向量，此时，<spanclass="math inline">\(A\)</span>中各列线性无关。证毕。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570087382&amp;p=14&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B14%5D%20%E6%AD%A3%E4%BA%A4%E5%90%91%E9%87%8F%E4%B8%8E%E5%AD%90%E7%A9%BA%E9%97%B4/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B014.pdf">正交向量与子空间</a></li><li><a href="https://rqtn.github.io/2019/08/12/LA-Lec14/">Lec14 -正交向量与子空间</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格物致知(2)——语言千百，殊途同归</title>
    <link href="/2023/06/13/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(2)%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%8D%83%E7%99%BE%EF%BC%8C%E6%AE%8A%E9%80%94%E5%90%8C%E5%BD%92/"/>
    <url>/2023/06/13/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(2)%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%8D%83%E7%99%BE%EF%BC%8C%E6%AE%8A%E9%80%94%E5%90%8C%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<p>开局一个段子，经典咏流传：你什么语言？我什么语言？我用Go写需求、我就算写出10个bug也能按期交付，你写C++、随便一个ABI问题都能卡你一整天。在座的这些老司机，哪个不是写Go、写Java、写Python的？你写C++，难怪你加班。什么C艹神教教父分父？真不熟！别笑我厌旧，你来你也臭，这就是现代编程语言带给我的自信(doge)~</p><p>我笑不出来，因为我写C++。</p><span id="more"></span><h1 id="语言千百殊途同归">语言千百，殊途同归</h1><p>计算机最终执行的是机器码，机器码由二进制序列组成，它们的花式排列组合实现各种算术与逻辑运算、数据存储与寻址跳转操作，复杂的操作借由简单的指令组合而最终得以实现。每一种特定ISA(InstructionSet Architecture,指令集架构)都包含了基本数据类型、指令集、寄存器、寻址模式、存储体系、中断与异常处理以及外部I/O，它们是计算机体系结构中与程序设计息息相关的部分。不同的处理器家族有着不同的指令集架构。计算机历史长河（虽然也不怎么长）诞生过相当多的指令集架构，如Mips、PowerPC等（常见于一些嵌入式系统，比如我早年做路由器的时候就用过Mips架构），然时过境迁，大浪淘沙，如今主流的指令集架构主要有三大家族：x86-64、ARM和RISC-V。</p><p><img src="2023-06-19-19-57-33.png" /></p><p>x86-64可谓耳熟能详了，Intel发展至今大成之作，从奔腾到酷睿i9，在PC市场上奠定了绝对的榜首位置。而Intel和AMD的故事也历来在业界津津乐道，AMD山寨货的喧宾夺主逼得Intel不得不妥协直到最后哥俩好到穿一条裤子（生意场上只有永远的利益），Intel系列架构的指令集在设计上被称作CISC，意为复杂指令集，专项专利的设计在很长一段时间几乎垄断了市场CPU，可谓赚到盆满钵满。而ARM架构诞生也相当早（现在都v9了），和Intel系列架构不同，它采用的是一种RISC指令集，意为精简指令集（ARM正是AdvancedRISCMachine的缩写）。ARM广泛用于嵌入式系统，主要设计目标就在于：低成本、高效能、低功耗。ARM和Intel在ISA扮演的角色身份恰如Linux和Windows，ARM的架构设计公司授权给其他公司去使用、实现具体的ARM架构（代表厂商比如Apple,Google,IBM,华为），开发自主的SoC(system-on-module)。我们平常用的手机、平板、路由器，ARM架构有着相当高的占比。至于RISC-V，见名知意，它也是一种RISC指令集，该架构起步相对较晚，但发展很快，基于RISC-V指令集架构可以设计服务器CPU，家用电器CPU，工控CPU和用在比指头小的传感器中的CPU（未来之星，智能穿戴，泰裤辣）。</p><p>ISA制定的是软硬件之间的一纸合同，其具体的实现方式我们一般称作“微架构(Mircoarchitecture)”，标准的定义向来简练，但落地往往一地鸡毛，这其中涉及的流水线级数、缓存设计无一不是门复杂的学问。有了具体的微架构以后，我们的机器码才能被送到CPU执行，至此，我们步入编程的世界。正如《系统漫游》一讲中所述：由于机器码过于抽象，不适合直接作为一种语言来直接编写，故开发者先驱在机器码的基础上进行了翻译，给出汇编助记符并最终演化成汇编语言。尽管汇编语言已经可以完成复杂程序的编写，但相比自然语言来说依然高度抽象、对开发者极不友好，于是，在经过了漫长发展史的今天，越来越多的编程语言应运而生，它们的亲和性越来越高、上手门槛越来越低，而这些语言，我们通常把它们归类为“高级编程语言”，时至今日，“编程语言”这一概念在大部分上下文中都指代高级编程语言。</p><h2 id="编程语言的本质">编程语言的本质</h2><p>刚入门的小伙伴，在对眼花缭乱的编程语言望洋兴叹之时，往往也会有一个大大的疑问：为什么会有这么多的编程语言呢？难道每一种语言都要学会才能掌握编程吗？</p><p>显然不是，想想我们每天都在用的自然语言，对大部分国人来说，掌握的可能只有普通话这门母语（不同地域还可能有各种方言，但他们都算在中文体系），受教育程度高的群体一般还会掌握英语这门国际语，而只有少数人掌握了三门以上的语言（比如日语、韩语、法语、德语）。然而归根结底，掌握自然语言的用途是为了与其他人交流，在中国当然说中国话，但在和外国人交流时，则因母语差异往往需要通过通用的国际语——英语来沟通。</p><p>实际上编程语言也不外如是，只不过它不受限于你出生的地域，你可以凭自己的喜好来选择第一门语言入坑来作为母语，但就像自然语言那样，不同语言的使用者之间存在着沟通壁垒，比如你让C语言使用者去跟Pythoner交流指针的使用艺术，完全是鸡同鸭讲。然而，还是有着一点关键性的差异：编程语言是用来和机器打交道的，你编写的程序就好比你说出去的话，最终是交由计算机来执行，由于计算机只认识自己的指令集，所以每一种语言的背后都有着强大的翻译团队，或提前打好腹稿、或同声传译，把由高级语言编写的程序的意图传达给机器（详见第零讲：《系统漫游》）。因此，和自然语言不同的是，开发者最低限度只需要掌握任意一门语言（好歹得是正经语言）就可以和机器沟通了，但至于这门语言能不能搞事情、能搞多大的动静出来，就取决于其设计之初的定位和生态丰富程度了。</p><p>有个叫<ahref="https://www.tiobe.com/tiobe-index/">TIOBE</a>的项目会定期更新编程语言流行度的排行榜：</p><p><img src="2023-06-21-11-50-09.png" /></p><blockquote><p>不同语言因其天然的特性与设计以及生态环境，在不同领域与场景的契合度不尽相同，语言本身谈不上高低优劣，关键在于机师的操作水平。</p></blockquote><blockquote><p>你说的都对，但我单方面宣布PHP是世界上最牛逼的语言(doge)~</p></blockquote><p>编程语言的本质就是和计算机交流，每一门编程语言都有它自己的审美和设计哲学，通过规范化一套自己的词法、语法、语义来完成“指令驱动数据”的最终目的。编程语言，也叫程序设计语言，按照wikipedia对这一规范化的组成拆分，主要包括以下四点：</p><ul><li>数据和数据结构</li><li>指令与流程控制</li><li>引用机制和重用</li><li>设计哲学</li></ul><h3 id="数据和数据结构">数据和数据结构</h3><h4 id="动态类型与静态类型">动态类型与静态类型</h4><p>程序中专门处理数据的系统被称作型别系统(typesystem)，语言依次可分成两大类：静态类型（如C/C++、Java、Go）和动态类型(如Lisp，Javascript，Python)。二者的根本性差异在于类型被确定的时机，对于静态类型语言来说，其数据类型在编译或者更准确的说是在运行之前就确定的，而动态类型语言则是在运行时(RT)才确定变量的类型。</p><p>比如下面这段C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>) &lt;&lt; std::endl;<br>    <span class="hljs-comment">// std::cout &lt;&lt; add(&quot;3&quot;, &quot;5&quot;) &lt;&lt; std::endl; // 编译不通过，add的参数是int型，不能传const char*</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在编译阶段就已经知道了a和b的类型是int，而对于像Python这种动态类型语言来说则不然：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))     <span class="hljs-comment"># 两者都是int型，输出8</span><br><span class="hljs-built_in">print</span>(add(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>))  <span class="hljs-comment"># 两者都是str型，输出&quot;35&quot;</span><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">3</span>, <span class="hljs-number">4.0</span>))   <span class="hljs-comment"># 传入int和float型，最终返回的是float型，输出7.0</span><br><span class="hljs-comment">#print(add(3,&quot;5&quot;))   # 运行时抛异常，TypeError: unsupported operand type(s) for +: &#x27;int&#x27; and &#x27;str&#x27;</span><br></code></pre></td></tr></table></figure><p>执行到square的时候，才知道传进来的<code>a</code>和<code>b</code>究竟是什么类型。</p><p>通过上面的例子，初学者可能会认为：动态类型好清爽，不需要在定义/声明变量的同时标注类型，不仅书写简单，用起来还灵活，你看，C++的add函数就只支持传<code>int</code>型，但python版本的则尽可能支持所有能做加法的一到两种类型。真的是这样吗？实际上这种认知并不完全正确，这里的能力实际上叫做泛型，动态类型确实让语句更短显得更干练，其RT绑定变量类型的机制也天然支持了这种泛型能力，但静态类型语言在设计上同样也可以后天弥补这种能力，对于C++来说，我们可以改造一下上述代码，通过使用函数模板来支持参数类型的泛化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T1 a, T2 b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl;    <span class="hljs-comment">// 返回的是int型，输出8</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;3&quot;</span>), std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;5&quot;</span>)) &lt;&lt; std::endl;  <span class="hljs-comment">// 返回的是std::string类型，输出&quot;35&quot;</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5.1</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// 返回的是double型，输出8.1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++中的泛型通过模板得以实现，其他像是Java，C#等静态类型语言也有相似的设计，当然也存在一些并不具备泛型能力的语言，此时可能就需要用诸如函数重载、抽象interface做类内wrapper、甚至干脆定义多个版本的<code>addXXX</code>来迂回支持。</p><blockquote><p>动态类型很大程度上提升了代码编写的灵活性，给于开发者极大的脑洞同时也是把双刃剑，灵活性的不合理运用生产了大量的屎山代码，不得不经常面对重构。故而江湖流传着这么句话：动态类型一时爽，代码重构火葬场！</p></blockquote><h4 id="强类型与弱类型">强类型与弱类型</h4><p>与动态类型和静态类型一起时常被提起的，还有一组被叫做强类型(Java,C#,Python,go,Rust...)与弱类型(C,Javascript,Perl,PHP...)语言的区分。强弱类型的核心差异在于：不同类型的变量是否允许隐式转化。不少误人子弟的网文都把强弱类型与动静态类型混为一谈，实际上这两组概念毫不相干。像Go是静态类型语言，同时它也是强类型语言，我们在编写Go程序时，甚至不能将int32隐式转换成int型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-type">int32</span> = <span class="hljs-number">100</span><br>    <span class="hljs-comment">// var b int = a    // 编译错误：cannot use a (variable of type int32) as type int in variable declaration</span><br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-type">int</span>(a)  <span class="hljs-comment">// 强制类型转换可以</span><br>    fmt.Println(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>尽管在32位机器上，int32和int尺寸相同，但对于强类型语言来说，它不支持隐式转换，哪怕你所有的上下文都将线索指向了这两种类型没有任何本质的区别。</p><blockquote><p>强弱类型这个概念直到2004才被一篇微软研究院的集大成论文《TypeSystems》所盖棺定论。在这之前往往和动静态类型混为一谈，比如Ritchie说C语言是“强类型但是弱检查”，Guido强调Python不是弱类型而是运行时类型，这才造就了后世的混淆。Strongly checked language: A language where no forbidden errors canoccur at run time (depending on the definition of forbidden error).Weakly checked language: A language that is statically checked butprovides no clear guarantee of absence of execution errors.这一定义较为抽象，它是基于对untrappederrors的容忍程度来区分强弱，由于大部分untrappederrors是由隐式类型转换而导致，所以后来逐渐演变成：以是否支持隐式转换来界定强弱类型。</p></blockquote><p>Python是动态类型语言，同时主流社区也认为它是强类型语言，为什么没有完全达成共识呢？这主要是因为Python类型转换上的一些外在表现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-built_in">print</span>(a, <span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">id</span>(a)) <span class="hljs-comment"># test &lt;class &#x27;str&#x27;&gt; 93997654303728</span><br>a = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(a, <span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">id</span>(a)) <span class="hljs-comment"># 1 &lt;class &#x27;int&#x27;&gt; 93997648968296</span><br>a += <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(a, <span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">id</span>(a)) <span class="hljs-comment"># 3 &lt;class &#x27;int&#x27;&gt; 93997648968360</span><br>a += <span class="hljs-number">5.0</span><br><span class="hljs-built_in">print</span>(a, <span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">id</span>(a)) <span class="hljs-comment"># 8.0 &lt;class &#x27;float&#x27;&gt; 94765439680288</span><br></code></pre></td></tr></table></figure><p><code>a</code>一开始是个<code>str</code>类型，在执行到<code>a = 1</code>时，表面上看是把<code>int</code>型的<code>1</code>隐式转换给<code>str</code>类型的变量<code>a</code>，但其实这种认知是错误的。Python的类型并不是和变量<code>a</code>绑定，而是和值(准确的说、是右值)绑定，<code>a</code>只是个变量名，它只是绑定到实际变量的标签，表面上看<code>a</code>的赋值操作用到了隐式转化，但实际上程序执行过程中只是更换了它的标签，让<code>a</code>重新绑定到了另一个<code>str</code>类型的变量而已。这段代码其实最隐晦的在于最后一句<code>a += 5.0</code>，看起来是对<code>int</code>和<code>float</code>做了计算，那么按照常理就势必涉及到了类似C/C++这种向上转型的隐式转换，然而python并没有做这样的隐式转换，python的一切基础类型也都是内置的<code>class</code>型（注意<code>type</code>打印的结果，前面是不是都有个<code>class</code>~），<code>class</code>型有自己的内置<code>__add__()</code>方法，不同类型的相加实际上是<code>__add__()</code>来完成的（python万物皆对象，数值类型也不例外）。</p><p>C是比较标准的弱类型语言，它支持的隐式转换相当丰富：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">double</span> b = <span class="hljs-number">4.0</span>;<br>    a = b;              <span class="hljs-comment">// 隐式转换double-&gt;int，产出右值4</span><br>    <span class="hljs-type">double</span> c = a + b;   <span class="hljs-comment">// a是int型，b是double型，按照数值计算的向上转型规则，int会转成double再做计算</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d, b=%lf, c=%lf&quot;</span>, a, b, c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然这里给的都是中规中矩不会搞出问题的模范示例，实际上C代码的bug有相当一部分恰好源于各种不合规的隐式转换（型别溢出、指针步长、越界访问...）。</p><blockquote><p>C++诞生于C，它背负了太多C的历史设计包袱，与ModernC++(11标准之后)的诸多设计显得格格不入但又因为历史债务而无法割舍。C++严格上来讲也是弱类型语言，但在强弱类型这块儿的表现却不伦不类。</p></blockquote><p>而像是Javascript这种就更魔幻了，由于它本身是动态类型，再加上隐式转换的能力，所以你在JS里经常能看到那种anti-human的案例，比如：表达式<code>"1000"+1</code>在JS里最终是<code>string</code>型，而<code>"1000"-1</code>则是<code>number</code>型，怎么样，神奇吧。Javascript这门语言能够带来震撼的case太多了，我甚至有很长一段时间以此为乐(doge)。</p><blockquote><p>Python和Javascript在设计上都过于天马行空，初学者上手容易，但越学越偏执，有那么点邪魔歪道的意思。</p></blockquote><h4 id="数据结构">数据结构</h4><p>另一个重要的组成部分就是数据结构了，很多理工科的专业本科都会开设这么一个课程，相信也是很多非科班出身小伙伴的噩梦。数据结构(DataStructure)是计算机用来存储、组织数据的方式，它利用编程语言所提供的数据类型、引用等其他操作加以实现，联合组成某种存储结构并对访问方法加以封装。不同的数据结构用来解决特定的问题，例如最常用的线性表(LinearList)（数组（Array）（也叫顺序表(Sequence List)）、链表(LinkedList)）用来组织存储同质化的多个数据、栈(Stack)这种LIFO的特性让它可以方便的维护函数调用栈帧、二叉搜索树(BinarySearchTree)可以最高效的支持基于比较操作的元素集合查找能力、又矮又胖的B+树适合在磁盘上按索引存储大量数据等等。</p><p>业内有着这么一句行话口口相传：程序 = 数据结构 +算法。这句话始源于一本古书的名字：</p><p><img src="2023-06-20-10-47-22.png" /></p><p>这本书发行于1976年，在起名这方面的才能可以说即使放在当下亦是不遑多让，这本书传授的是经典数据结构的知识，而书名的影响程度甚至超过了作者的想象（对于OIer倒是完美契合）。我们课上学习的数组、链表、栈、队列、哈希表、树等等可以看做是狭义的数据结构，它们是解决某类问题的最小结构化数据的demo，而我们真正在写程序的时候，往往会将各种数据结构与基本型、自定义类型按需求做组合封装，定义出新的自定义类型，这可以看作是广义的数据结构。</p><blockquote><p>至于Algorithms又是另一个打击面相当大的泛用词了，理工科课上的算法一般指的是传统的用来解决某一类问题的基础算法，比如二分查找、八大比较排序，研究生阶段还会上一门更具有体系的课：算法设计与分析，按照解决问题的思想大体可以拆分为枚举、模拟、递归、递推、贪心等策略，各种算法无非就是这些核心思想的应用（有过OI经验的同学一定深谙此道，刷笔试题简直是虐菜游戏）。而现如今业界火热的算法岗则指的是做MachineLearning, DeepLearning的AI算法岗，算是另一个领域的知识。尽管如此，我们去学习机器学习时，依然会发现那些经典算法的核心思想也还是这些，无非是在组合数学的基础上，施加了统计学的魔法罢了（要么说万物皆数学）。</p></blockquote><p>越是后现代的编程语言，往往本身对常用数据结构的支持越深入骨髓。像是老牌语言比如C，语法特性与标准库相当精简，仅仅天然支持数组。在C语言中，我们可以通过<code>int v[100];</code>来定义一个长度为100的定长<code>int</code>型数组，它可以在内存连续存放100个<code>int</code>型数据。当我们需要各种复杂的数据结构时，往往就需要自己去实现一套或者干脆找成品第三方库（C开发者可以说是最喜欢重复造轮子的群体，这与语言标准生态的贫瘠息息相关）。而像是后续较新的一些语言，比如C++,Java，往往其标准库更加庞大，里面集成了各种常用的数据结构，比如C++的<code>std::vector&lt;&gt;</code>（动态变长数组）,<code>std::map&lt;&gt;</code>（红黑树，平衡二叉搜索树的一种妥协实现体，本质上是2-3树）,<code>std::unordered_map&lt;&gt;</code>（哈希表、也称散列表），<code>std::tuple&lt;&gt;</code>（元组，支持存放任意多种不同类型的数据）。再到后现代的编程语言，比如Python,Go，它们甚至在语言特性本身就支持各种丰富的数据结构（比如Python的list,dict，Go的slice,map都有适配的语法糖）。</p><p>我们在编写程序时，往往会合理搭配使用各种数据结构和基础类型，封装出程序所需要的自定义类型，比如我们在C++中可以封装一个学生的结构，里面放置它的学号、姓名和分数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Subject</span> &#123;Chinese,English,Math&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-type">int64_t</span> id_;<br>  std::string name_;<br>  std::map&lt;Subject, <span class="hljs-type">int32_t</span>&gt; score_;<br>  <span class="hljs-comment">// for extend here ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>当然，这里展示的只是个toy，真实工程里的数据结构往往有着复杂的组合嵌套关系，能否良好的设计各种数据结构非常吃开发者对系统的理解和经验加成。</p></blockquote><h3 id="指令与流程控制">指令与流程控制</h3><p>还记得上面的那本书吗，如果是从宏大叙事上来讲，我心中的算法其实指的就是指令与流程控制。以cooking来比喻programming的话，如果说数据是预加工好的食材，那么流程控制就是炒菜的工序。一旦数据被确定，机器必须被告知如何对这些数据进行处理。尽管编程语言的设计风格千奇百怪，但都可以归纳为以下三种结构：顺序、分支、循环，这三种结构可以表达所有的计算机程序逻辑，</p><p><img src="2023-06-20-11-49-03.png" /></p><h4 id="顺序">顺序</h4><p>这个没什么好说的，你书写的代码一行一行从上到下依次执行，这本身就是一种结构，我们叫它顺序结构。顺序结构尽管简单但却最为常用，只要按照解决问题的顺序写出相应的语句即可。</p><h4 id="分支">分支</h4><p>分支结构也叫选择结构，无非就是根据特定条件，选择执行A or B or...代码块。语句格式为（这里采用伪代码）：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">if（条件1） </span><span class="hljs-template-variable">&#123;分支1&#125;</span><span class="language-xml">；</span><br><span class="language-xml">else if（条件2） </span><span class="hljs-template-variable">&#123;分支2&#125;</span><span class="language-xml"></span><br><span class="language-xml">else if（条件3） </span><span class="hljs-template-variable">&#123;分支3&#125;</span><span class="language-xml"></span><br><span class="language-xml">...</span><br><span class="language-xml">else if（条件n） </span><span class="hljs-template-variable">&#123;分支n&#125;</span><span class="language-xml"></span><br><span class="language-xml">else </span><span class="hljs-template-variable">&#123;分支n+1&#125;</span><br></code></pre></td></tr></table></figure><p>最简单的分支结构是单分支，即只在满足条件时执行分支语句，简化为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span>（条件<span class="hljs-number">1</span>）&#123;分支<span class="hljs-number">1</span>&#125;；<br></code></pre></td></tr></table></figure><p>分支不仅支持多分支，还可以做层级嵌套，形如：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">if</span> (条件<span class="hljs-number">1</span>) &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (条件<span class="hljs-number">1</span>A) &#123;分支<span class="hljs-number">1</span>A&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(条件<span class="hljs-number">1</span>B)</span> </span>&#123;分支<span class="hljs-number">1</span>B&#125;<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(条件<span class="hljs-number">1</span>N)</span> </span>&#123;分支<span class="hljs-number">1</span>N&#125;<br>    <span class="hljs-keyword">else</span> &#123;分支<span class="hljs-number">1</span>N+<span class="hljs-number">1</span>&#125;<br>&#125; <br><span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(条件<span class="hljs-number">2</span>)</span> </span>&#123;分支<span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>（条件n） &#123;分支n&#125;<br><span class="hljs-keyword">else</span> &#123;分支n+<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>此处允许套娃，套、都给我尽情的套！</p><p>大部分语言对分支结构的支持，都有着最基础的if-else语句，比如让我们来写一个判断某个用户输入的整数是奇数还是偶数的例子，在C++中，我们可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> number;<br>    cin &gt;&gt; number;<br><br>    <span class="hljs-keyword">if</span> (number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;偶数&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;奇数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到C++的if-else语句和伪代码相当相似，其他的一些语言也大同小异，比如同样的功能，我们在Go可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> number <span class="hljs-type">int</span><br>fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;number)<br>    <br>    <span class="hljs-keyword">if</span> number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;偶数&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;奇数&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而在以语法简练著称的Python中则写作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">number = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><br><span class="hljs-keyword">if</span> number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;偶数&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;奇数&quot;</span>)<br></code></pre></td></tr></table></figure><p>除了if-else语句外，一些语言还提供了switch语句，switch语句形如：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">switch</span> (表达式) &#123;<br>    <span class="hljs-keyword">case</span> (值<span class="hljs-number">1</span>): &#123;代码块&#125;<br>    <span class="hljs-keyword">case</span> (值<span class="hljs-number">2</span>): &#123;代码块&#125;<br>    ...<br>    <span class="hljs-keyword">default</span>: &#123;默认代码块&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>switch是对表达式的值进行枚举，按照匹配情况去执行其中某一个具体的case的代码块，对于全部不匹配的情况，会走最后一个兜底的default逻辑。switch适合那种枚举值范围较小、且case较多的情况，switch相比if-else在翻译成底层汇编指令时是有所差别的，if-else直接应对的就是指令集中的条件跳转指令，比如Intelx86汇编的<code>je</code>,<code>jne</code>,<code>ja</code>,<code>jb</code>等等，而switch则可以根据具体情况在翻译阶段优化成”offset索引+跳转表“的底层指令，if-else的多重分支的判断次数和分支数成正比，但switch则与case数量无关。</p><p>比如我们在C++中写这样一个例子：用户输入一年中第1天是星期几（0代表星期日，1~6代表星期一到星期六）以及一年中的第N天，我们输出第N天是星期几。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> first, n;<br>    cin &gt;&gt; first &gt;&gt; n;<br><br>    <span class="hljs-keyword">switch</span> (n%<span class="hljs-number">7</span>+first<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期日&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期一&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期二&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期三&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期四&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期五&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期六&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:    <span class="hljs-comment">// never through here</span><br>            <span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这里<code>default</code>分支永远不会命中，但对每个switch都书写<code>default</code>是个编程的好习惯。另外在C++里每个<code>case</code>需要一个<code>break</code>语句来跳出，如果不写<code>break</code>的话则会产生穿透(FallThrough)到下一个case继续执行的效果。C++的<code>switch</code>只能对有限的几种类型做枚举，一些其他语言比如Go则更加强大一些，Go不仅支持更丰富的类型值枚举，还可以在一个case里匹配复数个值，上面的代码用Go来写一版：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>        first <span class="hljs-type">int</span><br>        n <span class="hljs-type">int</span><br>    )<br>    fmt.Scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;first, &amp;n)<br><br>    <span class="hljs-keyword">switch</span> n%<span class="hljs-number">7</span>+first<span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            fmt.Printf(<span class="hljs-string">&quot;星期日\n&quot;</span>);dd<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>:<br>            fmt.Printf(<span class="hljs-string">&quot;星期%d\n&quot;</span>, n%<span class="hljs-number">7</span>+first<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">// never through here</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这段代码只是为了展示switch的能力，实际上单以这个需求而论有更优雅的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>        first <span class="hljs-type">int</span><br>        n <span class="hljs-type">int</span><br>    )<br>    fmt.Scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;first, &amp;n)<br><br>    desc := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;日&quot;</span>, <span class="hljs-string">&quot;一&quot;</span>, <span class="hljs-string">&quot;二&quot;</span>, <span class="hljs-string">&quot;三&quot;</span>, <span class="hljs-string">&quot;四&quot;</span>, <span class="hljs-string">&quot;五&quot;</span>, <span class="hljs-string">&quot;六&quot;</span>&#125;<br>    fmt.Printf(<span class="hljs-string">&quot;星期%s\n&quot;</span>, desc[n%<span class="hljs-number">7</span>+first<span class="hljs-number">-1</span>])<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可别小看这段代码，实际上这就是江湖上赫赫有名的表驱动设计的本质。</p></blockquote><p>一些语言在设计上没有switch语句，比如Python，一方面是switch的设计从美学上来讲与Python倡导的灵活性背道而驰，另一个重要的方面在于底层实现的优化不好做（类似C对switch的offset+跳转表的优化）。当然了，我们其实也可以用其他语法去模拟switch语句，比如<ahref="https://www.freecodecamp.org/news/python-switch-statement-switch-case-example/">PythonSwitch Statement – Switch Case Example</a>的举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">switch</span>(<span class="hljs-params">lang</span>):<br>    <span class="hljs-keyword">if</span> lang == <span class="hljs-string">&quot;JavaScript&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;You can become a web developer.&quot;</span><br>    <span class="hljs-keyword">elif</span> lang == <span class="hljs-string">&quot;PHP&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;You can become a backend developer.&quot;</span><br>    <span class="hljs-keyword">elif</span> lang == <span class="hljs-string">&quot;Python&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;You can become a Data Scientist&quot;</span><br>    <span class="hljs-keyword">elif</span> lang == <span class="hljs-string">&quot;Solidity&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;You can become a Blockchain developer.&quot;</span><br>    <span class="hljs-keyword">elif</span> lang == <span class="hljs-string">&quot;Java&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;You can become a mobile app developer&quot;</span><br><br><span class="hljs-built_in">print</span>(switch(<span class="hljs-string">&quot;JavaScript&quot;</span>))   <br><span class="hljs-built_in">print</span>(switch(<span class="hljs-string">&quot;PHP&quot;</span>))   <br><span class="hljs-built_in">print</span>(switch(<span class="hljs-string">&quot;Java&quot;</span>))  <br></code></pre></td></tr></table></figure><blockquote><p>Python3.10引入了新的match-case语句，与switch类似，但更像是Rust这种语言所支持的一种match表达式。</p></blockquote><h4 id="循环">循环</h4><p>循环结构由循环变量、循环体和终止条件构成，可以视作条件判断与回跳语句的组合。根据条件判断执行的位置，循环结构可以分成两类：当型循环和直到型循环。</p><ul><li>当型循环：先判断所给条件p是否成立，若p成立，则执行A（步骤）；再判断条件p是否成立；若p成立，则又执行A，若此反复，直到某一次条件p不成立时为止。</li><li>直到型循环：先执行A，再判断所给条件p是否成立，若p不成立，则再执行A，如此反复，直到p成立，该循环过程结束。</li></ul><p><img src="2023-06-21-10-14-00.png" /></p><p>当型循环的语句格式为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">for</span> (条件) <br>    &#123;执行体&#125;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>直到型则形如：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">repeat</span><br>    &#123;执行体&#125;<br><span class="hljs-keyword">until</span> (条件)<br></code></pre></td></tr></table></figure><p>大部分编程语言在循环语句的设计上大同小异，最常见的便是for和while语句，比如C++中最常见的for循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// init-expression: 在 for 语句的任何其他元素之前，init-expression 仅执行一次。 控制权然后传递给 cond-expression。</span><br><span class="hljs-comment">// cond-expression: 在执行 statement 的每次迭代之前，包括第一次迭代。 statement 只在 cond-expression 的计算结果为 true（非零）时执行。</span><br><span class="hljs-comment">// loop-expression: 在 statement 的每次迭代结束时。 执行 loop-expression 后，将计算 cond-expression。</span><br><span class="hljs-keyword">for</span> ( init-expression ; cond-expression ; loop-expression ) &#123;<br>    statement<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>for中的条件由三段式构成，每一段都可以省略，其中init-expression通常用来初始化循环索引，cond-expression通常用于测试循环终止的条件，loop-expression则通常用来控制循环变量的变化。比如最简单的示例，我们来计算1~10的数字之和，可以通过for语句实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">10</span>; ++i) &#123;<br>    sum += i;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一种常见的循环语句是while语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// expression: 每次执行循环体前进行判断，条件满足则执行循环体，否则终止循环</span><br><span class="hljs-keyword">while</span> ( expression ) &#123;<br>    statement<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>while相比for语句更简洁，它的条件判断只有一个表达式，比如上面的代码也可以用while来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>( i&lt;=<span class="hljs-number">10</span> ) &#123;<br>    sum += i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++的直到型循环则是使用do-while语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">do</span> &#123;<br>   statement<br>   ...<br>&#125; <span class="hljs-keyword">while</span> ( expression );<br></code></pre></td></tr></table></figure><p>终止条件的判定下一到了执行体执行过后判定，这对于某些场景来说采用这种实现更加优雅。</p><p>Java对循环的支持也有for,while,do-while这三种语句，它们甚至在语法上和C++都如出一辙，上面的C++代码在Java里甚至可以完全照抄（可以说在这方面两种语言有着同样的审美）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// for version </span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ++i) &#123;<br>    sum += i;<br>&#125;<br><br><span class="hljs-comment">// while version</span><br><span class="hljs-type">int</span> i=<span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;=<span class="hljs-number">10</span>) &#123;<br>    sum += i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>而像是Go语言，它在设计上只有for语句而没有while或是do-while，事实上for的能力是足够的，且Go的for有三种结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 和C++,Java的for一致</span><br><span class="hljs-keyword">for</span> init; condition; post &#123; &#125;<br><br><span class="hljs-comment">// 类似C++,Java的while</span><br><span class="hljs-keyword">for</span> condition &#123; &#125;<br><br><span class="hljs-comment">// infinite loop，只能靠内部的break语句终止，类似C++,Java的for(;;)&#123;&#125;</span><br><span class="hljs-keyword">for</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>再像是Python，它虽然有for也有while，但它的for循环实际上是另一种迭代器的形态（此for非彼for，我们稍后介绍），while则如出一辙：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> 判断条件(condition)：<br>    执行语句(statements)<br>    ...<br></code></pre></td></tr></table></figure><p>上面所举例的各种语言中的for,while语句，其本质上判断的条件都是一个表达式，实际上除了这种基于条件判断做循环的设计以外，还有另一种更常用的需求：遍历集合，对每个集合元素进行迭代。主流的现代编程语言大都支持这种迭代型循环语句，像是Python的for语句就是迭代型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">// sequence是一个可迭代对象<br>// iterating_var从前往后每次执行循环体都从sequence取单一成员<br><span class="hljs-keyword">for</span> iterating_var <span class="hljs-keyword">in</span> sequence:<br>   statements(s)<br></code></pre></td></tr></table></figure><p>比如我们想打印数组中所有成员：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&#x27;banana&#x27;</span>,<span class="hljs-string">&#x27;apple&#x27;</span>,<span class="hljs-string">&#x27;mango&#x27;</span>,<span class="hljs-string">&#x27;orange&#x27;</span>]<br><span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> fruits: <br>    <span class="hljs-built_in">print</span>(fruit)<br></code></pre></td></tr></table></figure><p>C++也支持这种迭代型循环，同样通过for语句来完成，只不过语法设计上有所差异：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; fruits&#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;mango&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; fruit : fruits) &#123;<br>    cout &lt;&lt; fruit &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>C++直到11标准才引入这种迭代型循环，在C++11之前，我们只能通过笨重的for语句配合迭代器来完成。形如<code>for(vector&lt;string&gt;::iterator iter=fruits.begin(); iter!=fruits.end(); ++iter)</code>，对于可以按下标枚举的可以简化写成<code>for(size_t i=0; i&lt;fruits.size(); ++i)</code>，相比于迭代型，不论哪种都尽显笨重。</p></blockquote><p>Java对迭代型循环的支持和C++又是如出一辙（这和两种语言在语法设计上的高度一致有关系）,Java派系一般称之为增强型for循环，也叫foreach循环。我个人认为这个foreach名称特别贴切，能够体现出逐元素迭代的语义，而foreach这个名词在C#语言中就被选取为关键字以支持迭代型循环:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">Span&lt;<span class="hljs-built_in">string</span>&gt; fruits = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123;<span class="hljs-string">&quot;banana&quot;</span>,<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;mango&quot;</span>,<span class="hljs-string">&quot;orange&quot;</span>&#125;;<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">ref</span> <span class="hljs-built_in">string</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;fruit&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Go语言对迭代型循环的支持采用的则是for-range语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">fruits := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;banana&quot;</span>,<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;mango&quot;</span>,<span class="hljs-string">&quot;orange&quot;</span>&#125;<br><span class="hljs-keyword">for</span> fruit := <span class="hljs-keyword">range</span> fruits &#123;<br>    fmt.Println(fruit)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="练习">练习</h4><p>最后让我们来利用这三种结构编写一个猜数游戏：提前想好一个100以内的数字，由用户来猜测，如果用户猜错了，就告诉用户猜测的数字是大了还是小了，重试直到猜对；如果用户猜对了就输出“Bingo”并退出。</p><p>我们简单的做一下需求分析：显然这段程序需要循环读取用户的输入，并对用户输入的数字进行条件判断，执行两个分支。当用户猜对的情况，直接打印Bingo并终止循环退出程序接口；当用户猜错的情况，就需要重头来过并提示用户数字大了还是小了。显然，这里用直到型循环书写起来更优雅。至于提前想好的数字要怎么生成呢，我们让程序随机生成一个就好。我这里用C++来实现一个版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">101</span>;<br>    <span class="hljs-type">int</span> input;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        cin &gt;&gt; input;<br>        <span class="hljs-keyword">if</span> (input == n) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Bingo!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (input &gt; n) &#123;<br>                cout &lt;&lt; input &lt;&lt; <span class="hljs-string">&quot; is larger than n.&quot;</span> &lt;&lt; endl;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; input &lt;&lt; <span class="hljs-string">&quot; is smaller than n.&quot;</span> &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Quit...&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="2023-06-21-11-27-29.png" /></p><p>如果你也有些许的编程经验，可以使用你喜欢的语言，也来写一个猜数游戏，正所谓“纸上得来终觉浅，绝知此事要躬行”。</p><h3 id="引用机制和重用">引用机制和重用</h3><h3 id="设计哲学">设计哲学</h3><p>这两部分一起讨论，承上启下、息息相关。</p><p>所谓的引用机制和重用，概念看上去很抽象，但翻译成大白话就两个字：复用。我们给变量取名是为了复用，你可以在上下文的多个地方通过名称来引用它；我们封装可调用对象也是为了复用，同一个代码片段功能体可能会反复执行多次，为了避免重复copy大段的代码，就需要对这段代码进行抽象和封装，大部分语言都会使用函数或者方法来支持这一能力，在这基础之上，又是八仙过海、各显神通。</p><h4 id="编程范式">编程范式</h4><p>然而语言千百，殊途同归，所有的编程语言所涉及的程序设计方法都可以归类到具体的编程范式(ProgrammingParadigm)。所谓编程范式，就是一类典型的编程风格，常见的编程范式有：指令式编程(ImperativeProgramming)、面向过程式设计(Oriented ProcessDesign)、面相对象式设计(Oriented ObjectDesign，简称OO)、函数式编程(Functional Programming)。</p><p>指令式编程就是最古老的直接操纵机器指令的汇编语言所用的范式，随着高级语言的诞生，面相过程语言大行其道，像是C语言这种古老的面向过程型语言，设计上高度自由（开放大世界玩法），语言本身仅仅提供结构体、函数和宏这三种抽象能力，你想怎么DIY都随你喜欢。</p><p>随着编程语言的发展，另一种面向对象型语言风靡业界，OO语言的核心思想是：万物皆对象。以Java这种最具代表性（Java是一门纯粹的OO语言）的语言对OO的答案是：抽象出“类”的概念，认为万物皆可封装成特定的类，而类与类之间有着继承(Inheritance)关系（也就是父子），每个类可以定义它自己的成员变量、成员函数(方法)，在这基础上还可以设定开放权限。另一方面，继承类可以直接继承父类的某些方法，对于不满意的，也可以通过重写(Override)的方式来DIY自己的专属版本。外部对象访问时，通过多态(Polymorphism)的机制来达到父类指针(引用)访问不同的子类对象的能力（实际上OO的本质就是为了解决Polymorphism这个元问题）。类继承与传统的组合(Composition)搭配使用，发生了强烈的化学反应，先驱者应对各类需求场景归纳出了各种设计上的定式，而这就是大名鼎鼎的“设计模式”。</p><blockquote><p>设计模式也算是面试八股文的重灾区了，说实话我到现在都不会画UML，我是低手。</p></blockquote><blockquote><p>OO只是C++语言能力的一个子集，也不是非用不可。事实上C++是所有语言中自由度最高的、也是能力最大而全的（但也因历史问题形成了严重的割裂感），只是对机师的操作要求太高，我至今没见过谁敢在简历上写“精通C++”，即使是经验丰富的老司机，谈到C++，也只敢说略懂、略懂。</p></blockquote><p><strong>领域驱动设计</strong></p><p>面对OO思想，近些年大家逐渐意识到以Java为代表的“类继承”编程范式并不是唯一解，更不是什么最优解（面向需求开发本就没什么最优解，不要想着一招鲜吃遍天）。大量的继承使用并没有降低系统的复杂性，甚至反而会增加理解整个系统的成本，表面看起来我们编写的代码变少了，但本质上这只是一种压缩而非抽象。我们在设计类的时候，都会有一个预先设定好的先决条件：如果一个对象的类型是X，那么它的行为模式Y能且只能是Z。但面对现实的需求调整，对象的行为模式不仅与其类型绑定，还会受使用者（即如何被使用）影响。横看成岭侧成峰，远近高低各不同。站在不同使用者的视角，行为模式也需要根据上下文来调整。类继承无法察觉使用者的变化，这就导致代码越写越臃肿，设计一个子类还得处理很多根本没必要参与的模式代码。</p><p>最新的一些编程语言在设计上已经开始嫌弃“类继承”这种手法了，比如Go采用的是“数据与行为分离”的思想，它的struct只定义数据、不定义行为；interface只对行为进行抽象、不涉及数据。行为就是行为，数据就是数据，当你需要它们之间产生联系时，再去编写<code>X.Y()</code>的具体代码也不迟。</p><p>随着传统类继承OO设计的没落，一种名为领域驱动设计(Domain-DrivenDesign,简称DDD)的手法异军突起：由领域模型驱动软件设计，用代码来实现该领域模型。DDD实际上就是从“类继承”所面对的困境出发，因为需求千奇八怪没有银弹，所以我们限定领域模型（任何系统的问题都是有限个领域的结合）；因为行为模式受使用者影响，所以我们抽象出有限界上下文。</p><blockquote><p>翻译成白话就是：特定领域的系统设计交给特定的业务专家，小工只需要在大神的领域按部就班即可。团队统一语言来描述概念，但每个概念都要结合上下文去理解，比如你说的apple到底是指水果还是品牌。</p></blockquote><p>DDD主要用于解决大型项目的复杂问题，尤其是面向那种成百上千开发者的情景能够有效的降低破窗风险，拉长项目可维护的生命期。诚然DDD目前鲜有成功的大型系统案例，对大部分开发者来说也完全是玄学。</p><blockquote><p>DDD始源于领域驱动设计之父Eric Evans的一本书：Domain-Driven Design:Tackling Complexity in the Heart ofSoftware，但这本书玄之又玄我真理解不上去，我这里推荐一篇通俗易懂讲人话的DDD介绍文章：https://tonydeng.github.io/2022/11/06/domain-driven-design/</p></blockquote><p><strong>函数式编程</strong></p><p>另一种常见的编程范式被称作函数式编程，它是一种面向数学的抽象，将计算描述为一种表达式求值，函数式程序本身就是一个数学表达式。在这种范式中函数与其他数据类型一样，都被视作一等公民，地位平等，函数可以赋值给变量、也可以作为参数传递、或者作为函数的返回值（所谓的高阶函数）。函数式编程关心数据的映射，而命令式编程则关心解决问题的步骤。</p><p>最经典的函数式编程语言是LISP，近现代的Haskell,Erlang等也是较为纯粹的函数式编程语言。像是C++,Rust,Python,Javascript等也或多或少提供了必要的函数式编程语法糖，只不过迂回的提供方式让函数式编程范式的一些特性（诸如高阶函数、柯里化、闭包、惰性求值）没有那么鲜明。</p><blockquote><p>这里推荐一个C++函数式编程的tutorial：https://github.com/polossk/Zero-Kara-FCPP</p></blockquote><p>函数式编程有着70年的历史，在业界历来小众，但随着硬件爹的升级换代、多核时代的到来，与并发控制格格不入（数据和操作绑定导致锁开销极大）的OO型语言遭受到越来越多开发者的质疑（实际上是反Java式类继承），而函数式编程对并发控制的编写天然友好，于是又逐渐回归到大众视线。</p><h2 id="通往异世界之旅">通往异世界之旅</h2><p>格物致知系列——编程导论的三大篇到此就全部结束了，不论你是刚刚入门的小白，还是已经有了一定编程基础的门徒，相信看到这里都能有不一样的感悟。语言千百、殊途同归，不论投身于何门何派，都要记着老祖宗的箴言：学而不思则罔，思而不学则殆。</p><p align="right">by 玉涵，完稿于2023年6月21日夜</p>]]></content>
    
    
    <categories>
      
      <category>编程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>格物致知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格物致知(1)——你什么进制？我什么进制？</title>
    <link href="/2023/05/06/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(1)%E2%80%94%E2%80%94%E4%BD%A0%E4%BB%80%E4%B9%88%E8%BF%9B%E5%88%B6%EF%BC%9F%E6%88%91%E4%BB%80%E4%B9%88%E8%BF%9B%E5%88%B6%EF%BC%9F/"/>
    <url>/2023/05/06/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(1)%E2%80%94%E2%80%94%E4%BD%A0%E4%BB%80%E4%B9%88%E8%BF%9B%E5%88%B6%EF%BC%9F%E6%88%91%E4%BB%80%E4%B9%88%E8%BF%9B%E5%88%B6%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>在我入坑之前就时长听大佬说：计算机的世界是二进制的，所有的信息都用0和1来表达。这对习惯于使用十进制的人脑来说显得捉摸不透：为什么要用二进制，十进制不香吗？另外啥叫信息？计算机为啥要表达？它要表达啥？不知道年轻的你有没有此等困惑，今天就让我们来揭开遮掩的幕布，看破这背后的戏法与魔术。</p><span id="more"></span><h1 id="你什么进制我什么进制">你什么进制？我什么进制？</h1><p>在研究计算机为什么是二进制之前，我们先抛开先入为主的偏见，思考一下：为什么人脑习惯用十进制，阿拉伯数字为啥用10当做基数来设计？这个问题很简单，掰掰我们的手指，数一数一共有几根，答案也就呼之欲出了。得益于我们的手指数量，最早的计数方式便选择10作为基数，而随着智慧的启蒙与时代的发展，阿拉伯人设计出以10作为基数的阿拉伯数字，推动了数字革命，终而家喻户晓、流传沿用至今。幼儿园老师教我们加减法运算时，其核心就在于凑10，当我们掌握了凑10技巧以后（也就是明白了进制的意义），就可以口算相当大规模的数字加减运算了。</p><p>而在计算机的世界则流行的是一种二进制运算，为什么是2而不是10呢，这是因为二值信号更容易被表示、传输和存储，2这个数字很有power，他可以表示两种极端对立的特性，比如：有和无、阴与阳、光与暗、高和低、顺时针和逆时针等等。对二值信号进行存储和计算的电子线路简单可靠、易于设计，制造商可以在一个单独的硅片上集成数百万乃至数十亿个这样的电路。</p><p>正所谓太极生两仪、两仪生四象、四象生八卦，单个二值信息本身作用有限，但是当把多个二值信息排成队、通过排列组合就可以一生万物，正如我们在第零讲中反复提到的核心思想：对抽象的事物赋予特定的语义。对连续二值信息的排列组合可以让我们对任何有限集合赋予语义，比如字符编码、CPU指令，再比如今天要讲的主角：数值信息的表达与存储。</p><h2 id="初识二进制">初识二进制</h2><p>二进制运算法则和十进制没什么区别，不过是逢2进位罢了，这里介绍一个简单的口算进制转换技巧：我们按照从低到高，记住一连串的二进制位为1的实际值，比如<code>B11111111</code>从低位到高位分别是1、2、4、8、16、32、64、128，当我们有一个十进制数为69，想要转换成二进制来表示的话，就用这些数字来凑：<spanclass="math inline">\(69=64+4+1\)</span>，亦即第0、2、6位为1（计算机的世界下标往往从0开始），其余位为0，最终写成<code>B01000101</code>。这里的前缀B表示二进制，是英文binary首字母的缩写。</p><blockquote><p>你可能还见过其他的二进制表示法，不同语言的写法可能不同，比如python里是用0b作为前缀，但这些都不重要，他只是为了区分其他进制而携带的标记，我们只需要知道它表示二进制就行。</p></blockquote><p>好，看到这里相信你已经学会怎么口算了，那么留一个问题给读者：250用二进制表示要怎么写呢？</p><h2 id="超量召唤十六进制">超量召唤：十六进制</h2><p>有的同学可能注意到，为啥69的二进制最高位在第6位，我却在最高位前面补了个0凑成8位呢？这是因为大多数计算机存储的最小单元是字节(Byte)，一个字节=8个位(bit)，常常写作1B(yte)=8b(its)，故而常常以8作为分组。因此，一个字节表达的范围就是<code>B00000000~B11111111</code>，换算到十进制就是<code>0~255</code>，由于使用二进制书写显得格外不方便，大家就对2进行了折叠，选择<code>2^4=16</code>来作为基数（<del>二进制的怪兽有四只，要上了，欧巴类、xyz召唤：十六进制</del>），用十六进制来表示（使用数字<code>0~9,A~F</code>来表示每个位值，也就是从0到15，其中<code>A~F</code>大小写均可）。如此，一个字节就只需要两个十六进制数来表示，大大缩减了书写长度，此时值域区间为<code>0x00~0xFF</code>（这里的<code>0x</code>是用户表示十六进制的前缀，可能还有<code>0xFFH、FFH</code>的写法，H是十六进制——Hex的缩写）。</p><p><img src="2023-05-11-19-53-30.png" /></p><p>所以十六进制只是二进制的折叠，本质上没有什么区别，那么十六进制怎么口算呢？很简单，我们通过展开十六进制数、转成二进制格式，在此前二进制口算窍门的基础上，再做一层映射即可：</p><p><img src="2023-05-12-09-36-50.png" /></p><p>让我们来试试：十进制的250，对应的十六进制数怎么表示呢？首先我们把250拆分成：<spanclass="math inline">\(128+64+32+16+8+2\)</span>，也就是对第1、3、4、5、6、7位置1、其余置0，二进制写作<code>B11111010</code>，进一步，每4位做一下折叠，最终得到：<code>0xFB</code>。</p><p>当然了，在我们熟悉十六进制数字之后，可以跳过二进制转换这一层，直接使用十六进制数来口算：比如<code>250=15*16+10</code>，15就是<code>F</code>、10就是<code>B</code>，也可以得到<code>0xFB</code>的结果。</p><blockquote><p>实际上我们只需要掌握十六进制数的阅读方法即可，如果口算不是为了装B，那就毫无意义(doge）。</p></blockquote><h2 id="数值类型与尺寸">数值类型与尺寸</h2><p>我们上中学的时候，对数字的划分一般都是采用自然数、实数、复数等概念来进行划分，但在计算机的世界，划分规则却迥然不同。各大编程语言往往都会定义各种各样的数据类型，它们作用不同、长短不一，但总体而言，数值在大分类上可以被归类成这两种：整型数和浮点型数。在这两大类的基础上，编程语言一般会在设计上根据尺寸长短（也就是确定数值范围、即多少个字节），将整型和浮点型细分成多种类型。另一方面，由于数值有正负之分，为了便于日常开发者的使用，在一些编程语言里还对每一种类型再进一步拆分成有符号和无符号型（比如C、C++）。</p><p>整型数就是整数，不管他的尺寸有多大，哪怕你定义成64个字节的超大范围，它能表示的数值也仅限于整数。比如我们定义一个<code>uint8_t</code>的类型，长度为1个字节，那么它所能表示的数值范围就是<code>0~255</code>，假如我们想让这个范围能表示负数，那么不妨再设计一个<code>sint8_t</code>型，长度依然是1个字节，此时数值范围就是<code>-128~127</code>。对于无符号数来说，如何使用单字节来存储<code>0~255</code>显得非常直接，0就存储为<code>0x00</code>、1就存储为<code>0x01</code>、240就存储为<code>0xF0</code>、255就存储为<code>0xFF</code>，这和十六进制表示数值的设计是完全统一的，我们姑且也把这叫做一种编码（尽管这层转换什么都没做）。但是负数要怎么存储呢？目前并没有一个单独的信息位来告诉我们这个数是positive还是negative呀。</p><h3 id="麻烦的符号">麻烦的符号</h3><p>看来简单的一比一编码行不通，一旦涉及了正负的概念，还是得考虑编码规则。考虑到正负本身无非也是一种信息，且恰好就是个二值信息，所以如果我们在原有尺寸的基础上，让出最高位、作为正负符号的表示，其余位仍然代表数值，看起来就可以解决这个case。比如对于此前我们设计的<code>sint8_t</code>，它一共有8个bits，我们让最高位（第7位）为0时代表正、为1时代表负，那么它所能表示的范围就变成了<code>-127~127</code>。此时B11111111在作为<code>sint8_t</code>的时候，它的值就是-127，而作为<code>uint8_t</code>时，它的值是255。</p><p>这种简单粗暴的设计看起来很美好，但实际上却经不起推敲：比如我们考虑对-4和+8做加法运算，二进制写作B10000100和B00001000，正常的结果应该是+4，当计算机操作二进制数按位计算时，答案却是错误的B10001100，也就是-12：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">-4:<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>0<br> 8:<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<br>+=:<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>0<br></code></pre></td></tr></table></figure><p>经过分析，我们发现这里第一个问题就在于符号位是不能直接进行加法运算的，因为我们在计算时并不知道最终结果应该是正还是负。此外，第二个问题在于正数和负数的加法运算，其实相当于是减法，这里的计算逻辑实际上忽略了这一事实，而是进行简单的4+8，所以最终才得出了-12的结果。</p><p>尽管我们经过分析，或许能够梳理出一套正确计算的逻辑，但从计算机来说，这就显得太过于复杂了，对于计算机来说，它只能做加法运算，至于你这些数字的背后代表了哪些数值，它是丝毫不关心的。因此，我们需要精心设计一个编码机制，使得它能够在计算机的世界对正负数的加减法操作（计算机只能做加法，减法也是加法（与负数相加））得到一个正确结果的相应编码值。</p><h3 id="整型数编码">整型数编码</h3><h4 id="无符号数">无符号数</h4><p>对于无符号数来说，完全可以沿用最自然的编码规则：</p><p><img src="2023-05-15-10-22-21.png" /></p><p>长度为w的0、1串映射到无符号整数，比如：</p><p><img src="2023-05-15-10-23-23.png" /></p><p>显得既直观又简单。由于无符号数不涉及减法，也没有符号，所以计算机的加法运算无论对于哪两个数操作，结果都是正确的。</p><h4 id="有符号数">有符号数</h4><p>而对于有符号数，最常见的一种编码方式叫做补码(two'scomplement)。在这个定义中，将字的最高有效位解释为负权(negativeweight)，类似无符号数，使用函数来定义：</p><p><img src="2023-05-15-10-26-28.png" /></p><p>最高位<spanclass="math inline">\(-x_{w-1}\)</span>也叫符号位，它的权重为<spanclass="math inline">\(-2^{w-1}\)</span>，当该符号位为时表示负数（值为负），为0时表示整数（值为非负，也就是正数+0），这么说比较抽象，还是展开看看几个例子：</p><p><img src="2023-05-15-10-54-08.png" /></p><p>为什么要设计这个权重呢，实际上它是对减法运算的一种模拟，对于负数来说，它最终用于表达的二进制值是权重作用后的结果，如此，当我们对复数进行加法运算时，这个权重就发挥了作用。</p><p><img src="2023-05-15-10-55-17.png" /></p><p>比如重新考虑<code>-8+4</code>，对<code>sint8_t</code>类型，-8的补码是B11111000，4的补码是B00000100，二者相加：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">-8:<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<br> 4:<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>0<br>+=:<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>0 =&gt; -4的补码<br></code></pre></td></tr></table></figure><p>通过计算机的加法运算后，得到的正好就是-4的补码。</p><p>再比如<code>-4+8</code>：-4的补码是B11111100，8的补码是B00001000，二者相加：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">-4:    <span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>0<br> 8:    <span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<br>+=: (1)<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>0 =&gt; 产生进位，丢弃溢出位，最终结果是4的补码<br></code></pre></td></tr></table></figure><p>由于尺寸限制，这里的加法运算产生了溢出，最终溢出位被丢弃，而最高位（符号位）刚好因为进位而变成0（语义上代表非负数），这一巧合实际上就是我们精心设计的补码编码规则而产生的。</p><h4 id="补码反码与原码">补码、反码与原码</h4><p>各版本大学计算机基础的教材往往都会提到这么几个概念，补码我们已经知道了，那么啥叫反码和原码呢？</p><p>反码和原码是另外两种表示有符号数的标准方法：原码(Sign-Magnitude)：最高有效位是符号位，用来确定剩下的位应该取负权还是正权：</p><p><img src="2023-05-15-11-28-20.png" /></p><p>反码(Ones' Complement)：除了最高有效位的权是<spanclass="math inline">\(-(2^{w-1}-1)\)</span>而不是<spanclass="math inline">\(-2^{w-1}\)</span>，它和补码完全一样：</p><p><img src="2023-05-15-11-27-27.png" /></p><p>对于原码和反码来说，它们对数字0的编码都有两种：<code>B00000000</code>被解释成<spanclass="math inline">\(+0\)</span>，在原码编码中<code>B10000000</code>被解释成<spanclass="math inline">\(-0\)</span>、反码编码中<code>B11111111</code>被解释成<spanclass="math inline">\(-0\)</span>。反码和原码相对于补码是截然不同的编码方式，只可惜大部分教科书混淆了三者之间的关系，从字面值上看，正数的补码和原码一致，而负数的补码则是“反码+1”（毕竟权重里多了个-1），这种取巧的办法更适合我们人类去计算有符号数的补码编码值，但实际上它们之间没什么关系，每种编码方式本身都是内部闭环的。所以坊间总流传这么一个说法：正数的补码是它的原码、负数的补码是它的反码+1。久而久之，我们只学会了怎么计算有符号数的补码编码值，却根本没搞懂补码的设计奥义，当真是买椟还珠。</p><blockquote><p>虽然上古时代曾生产过基于反码表示的机器，但现代机器都一致使用补码来编码有符号数。</p></blockquote><h3 id="c语言中的数值类型">C语言中的数值类型</h3><p>上面的<code>sint8_t</code>,<code>uint8_t</code>是我杜撰的，我们找个真实的编程语言来举例。比如，在C语言中，有着以下的常见类型：</p><p><img src="2023-05-12-17-47-18.png" /></p><p>注意到C在设计上针对整型数分成了<code>short、int、long、int32_t、int64_t</code>这几种，它们的尺寸单调非递减，且在不同位数的机器架构里长度不同。<code>char</code>是一个比较特殊的类型，它只有单个字节，常用来表示ASCII字符，但本质上存储的只是个数字罢了，它具体是什么取决于你怎么用它。<code>char</code>这种设计放在现代来看显得小家子气（比如go直接定义<code>byte</code>型），这主要是因为C诞生年代太过久远，和现代编程语言的设计相当脱轨。</p><blockquote><p>实际上x64（64位）机器也可以编译x86(32位)的C程序，此时类型尺寸按32位的标准生效。</p></blockquote><h4 id="有符号数和无符号数的转换">有符号数和无符号数的转换</h4><p>截止到目前，我们对有符号数和无符号数可以说是区别对待，可是在实际生产环境中，我们很可能会遇到两种类型数混用甚至需要进行计算的场合，那怎么办呢？大部分区分了符号数的语言往往都提供了它们之间的转换方法，比如在C语言中就有显式强制类型转换和隐式类型转换这两种。然而语言层面往往只是提供能力，二者进行计算最终得到的值，归根结底取决于你对它的解读方式。</p><p>举个例子，比如下面的C代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> v = <span class="hljs-number">-12345</span>;   <span class="hljs-comment">// 16位大小有符号数，表达范围是 -32768 ~ 32767</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> uv = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)v;  <span class="hljs-comment">// 这里进行了强制类型转换</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v=%hd, uv=%hu\n&quot;</span>, v, uv); <span class="hljs-comment">// %hd是按有符号数打印unsigned short，%hu是按无符号数打印short</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用x86-64 gcc13.1编译，最终输出的结果是：<code>v=-12345, uv=53191</code>。为什么<code>uv</code>的值是53191而不是直觉上的12345呢？这就是因为<code>-12345</code>底层存储的值是<code>B1100111111000111</code>，采用的是补码存储，而当我们把他看做是一个无符号数时，它的编码解读方式就发生了变化，最高位的符号位不再代表符号位，而是代表了<spanclass="math inline">\(2^15\)</span>这个值，不妨按照无符号数的编码方式计算一下，就会发现<code>B1100111111000111</code>对应的值正是<spanclass="math inline">\(2^{15}+2^{14}+2^{11}+2^{10}+2^9+2^8+2^7+2^6+2^2+2^1+2^0=53191\)</span>。</p><p>因此，对于上一段C代码来说，<code>unsigned short uv = (unsigned short)v</code>只不过是使用强制类型转换将<code>v</code>底层存储的编码值赋值给了<code>uv</code>，仅此而已。实际上，我们将上面的代码改写一下，完全不需要copy一份<code>v</code>，只需要对<code>v</code>使用不同的format来打印，亦会得到相同的结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> v = <span class="hljs-number">-12345</span>;   <span class="hljs-comment">// 16位大小有符号数，表达范围是 -32768 ~ 32767</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v=%hd, uv=%hu\n&quot;</span>, v, v); <span class="hljs-comment">// 依然输出v=-12345, uv=53191</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于大多数语言的无符号和有符号数类型的转换，原则都和C一样：数值可能会变，但是位模式不变。因此，当开发者对有符号数和无符号数进行混淆计算时，一定要确保非预期的结果产出，对于大部分语言来说，这都是一个存在风险且不推荐的操作。</p></blockquote><h4 id="扩展与截断">扩展与截断</h4><p>另一个常见的转换场景是不同字长的整数之间进行转换。我们原则上希望这样的转换可以保持原有数值的不变，这对于扩展来说（也就是从小尺寸转成大尺寸），可以通过设置扩展的规则来保证，但对于截断来说，显然是不可能的（你那点空间容不下人家的熵）。</p><p>对于无符号的扩展来说，只需要在扩展的高位全部填0即可，这一法则被称作无符号数的零扩展，其原理直接遵循了无符号数编码的定义。而对于有符号数来说，补码需要执行符号扩展：高位填充最高有效位的值，简单来说，就是负数用1填充，非负数用0填充。</p><p>我们还是以C语言为例，将上面的代码做一下调整：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> v = <span class="hljs-number">-12345</span>;   <span class="hljs-comment">// 16位大小有符号数，十六进制对应0xCFC7</span><br>    <span class="hljs-type">int</span> wv = v;     <span class="hljs-comment">// 16位扩展到32位，高位用符号位1来填充，扩展为0xFFFFCFC7</span><br>    <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> uv = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span>)v;  <span class="hljs-comment">// 0xCFC7，此时解码视作53191 </span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> wuv = uv;  <span class="hljs-comment">// 无符号数用零扩展，0x0000CFC7，依然是53191</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v=%hd, uv=%hu\n&quot;</span>, v, uv);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wv=%d, wuv=%u\n&quot;</span>, wv, wuv);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">v</span>=-12345, <span class="hljs-attribute">uv</span>=53191<br><span class="hljs-attribute">wv</span>=-12345, <span class="hljs-attribute">wuv</span>=53191<br></code></pre></td></tr></table></figure><p>扩展的规则易于理解，那么怎么截断呢？既然截断可能会导致原始数值的丢失，所以我们也不用有那么多顾忌，不管是无符号数还是有符号数的补码，我们都干脆把高位丢弃就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> v = <span class="hljs-number">53191</span>;                  <span class="hljs-comment">// 0x0000CFC7</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> sv = (<span class="hljs-type">short</span> <span class="hljs-type">int</span>)v;    <span class="hljs-comment">// 丢弃最高位后变成0xCFC7，此时最高位1作为符号位值为1，整个值变成了-12345</span><br><br>    <span class="hljs-type">int</span> v2 = <span class="hljs-number">0x0001CFC7</span>;            <span class="hljs-comment">// 直接用十六进制书写了，十进制为118727</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> sv2 = (<span class="hljs-type">short</span> <span class="hljs-type">int</span>)v2;  <span class="hljs-comment">// 还是0xCFC7，-12345</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sv=%hd, v=%d\n&quot;</span>, sv, v);     <span class="hljs-comment">// 输出-12345,53191</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sv2=%hd, v2=%d\n&quot;</span>, sv2, v2); <span class="hljs-comment">// 输出-12345,118727</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以截断这个操作在编程时也是个高度危险的操作，这很可能会因为熵信息丢失导致出现非预期的问题，甚至会产生一些可被黑客利用的漏洞。</p><blockquote><p>纵观历史长河，因类型转换、扩展截断而导致的漏洞数不胜数，比如CSAPP在2.2.8的旁注中给出了一个经典的开源系统FreeBSDgetpeername的设计缺陷案例。早期的语言设计诸如C/C++对类型的分类和处理比较宽松，想要写出bugfree的代码需要开发者有较深的理解且务必仔细，这种环境天然助长了大量漏洞的滋生，这也间接导致此后数十年间、二进制安全的世界精彩纷呈，各种漏洞利用手法叹为观止。</p></blockquote><blockquote><p>既然无符号数和有符号数之间混用势必产生一地鸡毛，所以一些编程语言在设计时移除了对无符号数的支持，比如Java仅支持有符号整数，大刀阔斧，魄力相当。</p></blockquote><h3 id="整型数运算">整型数运算</h3><h4 id="加法与减法">加法与减法</h4><p>由于尺寸固定的整型数类型范围受限，所以当进行加法操作时，会遇到一种在计算机世界中非常常见的现象：溢出(Overflow)。对于无符号来说，这一点显而易见，我们依然使用C语言来做测试，使用unsignedshort来溢出一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> v = <span class="hljs-number">65535</span>;             <span class="hljs-comment">// 所能表示的最大数，B1111 1111 1111 1111</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> overflow = v + <span class="hljs-number">1</span>;      <span class="hljs-comment">// 此时overflow是B(1) 0000 0000 0000 0000，最高位进位后溢出被丢弃，最终结果为0。   </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;overflow=%hu\n&quot;</span>, overflow);   <span class="hljs-comment">// 输出overflow=0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于有符号数来说，其实也没什么不同，计算机依然是墨守成规的对每个位进行相加，按需进位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">short</span> v = <span class="hljs-number">32767</span>;                        <span class="hljs-comment">// 所能表示的最大正数，B0111 1111 1111 1111</span><br>    <span class="hljs-type">short</span> overflow = v + <span class="hljs-number">1</span>;                 <span class="hljs-comment">// 此时overflow是B1000 0000 0000 0000，次高位进位后导致符号位变成1，该值为-32768的补码   </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;overflow=%hd\n&quot;</span>, overflow);     <span class="hljs-comment">// 输出overflow=-32768</span><br><br>    v = <span class="hljs-number">-32768</span>;                             <span class="hljs-comment">// 所能表示的最小负数，B1000 0000 0000 0000</span><br>    overflow = v - <span class="hljs-number">1</span>;                       <span class="hljs-comment">// 相当于v + (-1), -1的补码是B1111 1111 1111 1111，相加后最高位溢出，得到B(1) 0111 1111 1111 1111</span><br>                                            <span class="hljs-comment">// 最高位丢弃，值为32767</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;overflow=%hd\n&quot;</span>, overflow);     <span class="hljs-comment">// 输出overflow=32767</span><br>&#125;<br></code></pre></td></tr></table></figure><p>减法相当于是对负数做加法，而加法运算也同样是老老实实的按位操作，在中央处理器眼里从来都没有什么符号位，更没有什么负权。我们可以发现一个规律，向上溢出（正溢出）和向下溢出（负溢出）形成了一个周期环，所有的值都在<spanclass="math inline">\(-2^w~2^{w-1}\)</span>之间反复横跳、周而复始。</p><p><img src="2023-05-15-22-48-15.png" /></p><h4 id="乘法与除法">乘法与除法</h4><p>我们知道乘法实际上就是多次的加法运算，尽管自近现代以来，流行处理器都支持独立的乘法指令（如Intelx86系列的MUL,IMUL），然而这些乘法指令相当慢，相比于其他整数运算指令诸如：加法、减法、位运算(与、或、非、异或)、移位，要花费数十倍以上的时钟周期。现代编译器在编译程序时往往都会对乘法运算进行优化，其核心思想就是利用位移指令+加减法指令配合完成原本的乘法运算，取代费时费力的乘法指令。</p><blockquote><p>这里的优化是编译器针对于变量x常量的case，变量x变量由于无法提前预知两个值中的任意一个，所以只能使用乘法指令IMUL,MUL。而常量*常量则在编译期就已经可以计算出结果了，根本不经过CPU做runtime的乘法计算。</p></blockquote><p>首先我们得前置介绍一些位移指令，位移指令其实很简单，它分为左移和右移：前者就是将每个二进制位都想左侧的高位移动K位，低位用0补齐；而后者则相反，将每个二进制位都向右移动K位，低位丢弃、至于最高位嘛，则分两种情况，一种叫逻辑右移、另一种叫算数右移，逻辑右移很简单，就是在高位补K个0，但算数右移则根据最高位进行补齐，也就是说，如果右移前，最高位是1，那么就用1来补齐位移后的最高K个位。</p><p>可别小瞧这位移指令，举个例子，我们对<code>B0001</code>(十进制等于1)进行左移操作，移动2位，结果就是B0100（十进制等于4），其效果相当于是乘以2的某个幂数，移动K位，就是乘以<spanclass="math inline">\(2^k\)</span>。聪明的编译器根据一些数学上的技巧可以把复杂的与2的幂数对不齐的乘法转换为某个K位左移操作，进而再通过加减法进行补足。比如语句<code>n = num * 63;</code>的x86汇编指令可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ecx, dword ptr [num]; 把num初始值赋值给ecx寄存器<br>shl ecx, 6              ; 对ecx左移6位，相当于乘上2^6=64，此时ecx值为num*64                 <br>sub ecx, dword ptr [num]; 对ecx进行减法操作，减去一个num，相当于ecx=num*64-num，即ecx最终值为num * 63<br>...                     ; 其他指令，将ecx结果赋值给变量n<br></code></pre></td></tr></table></figure><p>考虑到这一技巧较为复杂，且和入门二进制关系不大，我们暂且按下不表，留待日后研讨。</p><p>除法相比乘法更加复杂、执行速度也更慢，类似乘法的左移优化，除法也有围绕2的幂数通过右移来加速的技巧。</p><h3 id="浮点数">浮点数</h3><p>浮点数就是我们平时经常说的小数，这类数有个比较明显的特点：有效位数可能相当之多，即使在日常生活中，我们计算小数时，也大都选择保留小数点后有限的几位，采用四舍五入或者干脆进一的方法。在计算机的世界也类似，比起数字精准度来说，制造商更care运算的速度，但相比我们日常的计算，各种浮点数的标准还是有着相对较高的要求。</p><p>小数的十进制表示法可以写成如下形式：<spanclass="math inline">\(d_md_{m-1}...d_1d_0.d_{-1}d_{-2}...d_{-n}\)</span>，每个十进制数<spanclass="math inline">\(d_i\)</span>的取值范围是<spanclass="math inline">\(0\sim9\)</span>，d可以按如下定义：</p><p><span class="math display">\[d = \sum_{i=-n}^{m}10^i \times d_i\]</span></p><p>小数点左边的数字的权是10的正幂，右边的则是负幂，例如<spanclass="math inline">\(12.34\)</span>可以表示为<spanclass="math inline">\(1 \times 10^1 + 2 \times 10^0 + 3 \times 10^{-1} +4 \times 10^{-2} = 12\tfrac{34}{100}\)</span>。</p><p>二进制表示法则与十进制类似，我们以2作为基底，可以写成：</p><p><span class="math display">\[b = \sum_{i=-n}^{m}2^i \times b_i\]</span></p><p>此时<spanclass="math inline">\(.\)</span>也是二进制的点，左边的位的权是2的正幂，右边位的权是2的负幂。例如，<spanclass="math inline">\(101.11_2\)</span>可以表示为：<spanclass="math inline">\(1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 + 1\times 2^{-1} + 1 \times 2^{-2} = 4 + 0 + 1 + \frac{1}{2} + \frac{1}{4}= 5\tfrac{3}{4}\)</span>。</p><p><img src="2023-05-16-19-43-12.png" /></p><p>如果我们仅考虑受限长度的编码，那么对十进制表示法来说，像是<spanclass="math inline">\(\frac{1}{3}\)</span>和<spanclass="math inline">\(\frac{5}{7}\)</span>这样的数是无法精确表示的，同样的，对于二进制表示法来说，我们能够精确表示的只有那些能够被写成<spanclass="math inline">\(x \times2^y\)</span>的数，其他值只能近似表示，我们唯一能做的就是尽量增加二进制表示的长度，长度越长，能够表达的精度就越高。</p><p>目前最流行的浮点数标准是IEEE(电气和电子工程师协会)制定的，它规定了浮点数中每个数字要如何表示和舍入的规范，相对于整型数的编码规范来说，浮点数的编码法则相当晦涩难懂，但其核心设计原理就在于用<spanclass="math inline">\(V=(-1)^s \times M \times2^E\)</span>来编码表示一个浮点数，通过将bits分成符号位、阶码和尾数三段来确定其中s,M和E的值（有各自的计算法则），与前文的表示法呼应起来了。</p><p><img src="2023-05-17-14-55-00.png" /></p><p>不过好在浮点数的编码对于绝大部分程序开发者来说并不是必要的知识储备，因此对于想要入门编程的同学，我们就暂止于此。</p><blockquote><p>对于现代处理器来说，浮点数运算一般有自己的指令集，通过集成到CPU的一种叫做浮点运算器FPU的处理单元来计算。FPU对浮点数的运算做了一些特化设计，不仅支持复杂的运算指令，还可以加速运算过程。当然，也不是说没有FPU就算不了浮点数，这就好比你没有GPU一样能打开显示器一样。</p></blockquote><p align="right">by 玉涵，完稿于2023年5月16日夜</p>]]></content>
    
    
    <categories>
      
      <category>编程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>格物致知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格物致知(0)——系统漫游</title>
    <link href="/2023/04/13/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(0)%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <url>/2023/04/13/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(0)%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>对于想要学习编程的新人来说，当下无疑是最好的时节，编程语言发展至今，新生代的语言在诞生之初往往伴随着强大的生态附属以及友好的语法特性，这大大降低了上手门槛，使得新手也可以轻松地完成任务而不必陷于囹圄。当下也是最坏的时节，现代编程语言高高在上，屏蔽了太多细节与原理，这鸿沟天堑阻绝了新人知其所以然的机会，却又如何技进于道？本系列将以CSAPP(ComputerSystems: A Programmer'sPerspective，中译本为《深入理解计算机系统》)上半为蓝本，接轨当下，让我们格物致知，打通认知体系的奇经八脉。</p><span id="more"></span><h1 id="系统漫游">系统漫游</h1><p>众所周知，计算机系统是由硬件和软件组成的，不论是超级计算机、集群服务器，还是家用电脑、移动端设备(平板、手机)、IoT设备（如路由器、摄像头）应皆如是。硬件五花八门、各司其职，对于非特定领域开发者来说，我们只需要了解两个核心硬件：中央处理器(CPU)和内存(主存，一般称RAM)即可。</p><blockquote><p>除了CPU以外，还有一种叫图形显示器(GPU)的东西，这东西在当下可是大展身手，无出其右（同学，便宜的矿卡来一块不？都是锻炼过的，GPT用了都说好）。机械硬盘(SATA)、固态硬盘(SSD)对于一台主机来说很重要，但站在程序开发者视角来说则没那么重要。至于显示器、鼠标、键盘等等都属于外设，如果不是为了打游戏，那么研究它们毫无意义(doge)</p></blockquote><p>硬件虽然服务于软件，但硬件才是大爹。事实上，互联网的崛起、从单点到分布式，以及历年的技术革命：诸如大数据、云计算、区块链再到当前潜在商业价值巨大的GPT，之所以能够surfing在浪潮之巅，根本上都是因为硬件的迭代升级。硬件的能力突破了某个瓶颈以后（算力、造价、效率等等...），业界大能才能把此前仅限于理论可行的方案落地，开辟出当前欣欣向荣的生态大环境。</p><p>那么硬件和软件是怎么沟通的呢？不同硬件厂商繁多，标准规格大相径庭，如果将这些都暴露给软件开发者，那简直是一场噩梦。事实上在上古时代，编程就是这样一件不可思议的狠活，程序开发者需要去理解使用的硬件，对着它的规格书使用原生接口来完成自己的工作。随着软件的发展，先驱者抽象出中间层（在软件开发领域，没有什么事是一个中间层搞不定的，如果有，就再加一个中间层），让它负责对接所有硬件，开发者只需要和这个中间层打交道即可。那么这个中间层是什么呢？它的真身就是我们常常说的操作系统(OS,OperatingSystem)，操作系统实际上也经历了漫长的发展历史长河，一直到现在我们耳熟能详的Windows,Linux, Mac OS, Android,IOS等。时至今日，我们更愿意称它们为“现代操作系统”，“现代”这一限定词可谓意义非凡，它浓缩了这一路上面对重重困境披荆斩棘的解决之道，并最终沉淀成标准，任岁月打磨。</p><blockquote><p>即使是家喻户晓的Windows，实际上也有着漫长的历史，严格来说，Windows不是具体的某个系统，而是一种徽章，从最古老的DOS到Windows9x再到Windows NT，底层的变化翻天覆地，而Win7（前身是赫赫有名的失败品Vista）之后历经Win 8、Win 10再到“内测”的Win11，安全加固、系统生态等方方面面都愈发成熟。</p></blockquote><blockquote><p>如果说Windows是自立门户、自成标准，那么像Linux, Mac OS, FreeBSD,Solaris都算作类Unix系统，它们有着相当多的共同点，比如遵守POSIX标准，集成了GNU套件。</p></blockquote><p>操作系统实际上也是软件，事实上，它就是我们开机以后第一个运行的体量最大的软件，OS提供了其他软件运行的土壤。现代操作系统整体分为两大部分：内核(kernel)和外壳(shell)，内核负责决策、调度和资源管理，里面住着的都是一等公民（常驻的内核代码：进程管理、内存管理、文件设备I/O、中断），外壳则面向开发者与用户进行交互：你只能通过使用我开放的接口、组合成你想实现的功能。通过这些接口（即系统API）我们可以编写各种程序，进而完成各种各样的软件，只不过受制于人（你得看具体OS厂商的脸色），能做的事儿有限。</p><p><img src="2023-04-13-19-19-46.png" /></p><blockquote><p>你可能会问：为啥现代操作系统要分层呢？大家写的程序都和OS内核平起平坐，功能岂不是更丰富？嗯，上古时期DOS就是这么干的，所以那个年代病毒满天飞，挡都挡不住。</p></blockquote><p>因此，在现代操作系统中，生态环境被分成了两部分：内核态与用户态。</p><ul><li>与硬件打交道的代码通通运行在内核层，各类硬件设备分门别类一般有着业界统一标准或是自定义标准，OS通过设备驱动来与它们交互，它们以插件的形式，或先天集成在OS内核里，或后天装载插入；</li><li>我们日常所用的大部分软件，诸如chrome浏览器、QQ音乐、Steam等它们之中的大部分工作在用户态；</li><li>像是一些防护软件比如火绒、360、QQ电脑管家等则兼具用户与内核态，为什么说是兼具呢？因为用户态有功能局限性，防护软件要和那些无孔不入的恶意程序对抗，那势必要下沉到内核去获取更高的权限与更强大的power。实际上，操作系统并不仅仅提供用户态的接口，内核层往往也会提供，而除了少量做设备驱动和二进制安全研究的人士，大部分开发者是用不到它们的。</li></ul><blockquote><p>内核态与用户态是现代操作系统的概念，在很多上下文中会等价于Ring0/3态，后者是站在CPU的视角来看的，虽然二者有一定区别，但基本绑定。</p></blockquote><blockquote><p>在我尚未学习内核/驱动编程的时候，总觉着写内核态程序的高人一等，直到上下求索、建立一定的知识体系后才明白：写程序就是写程序，本没有什么优劣，不过是所在的层与生态环境不同罢了。</p></blockquote><p>操作系统作为中间层，其常驻的内核代码会控制CPU与内存的调度与分配，我们知道程序无非就是代码+数据（代码其实也是数据，嗯，这就是二进制安全的关键），每一行代码的执行都由CPU来完成，而数据则放置于内存。对于CPU来说，各厂商的指令集迥然不同，在CPU的世界里，一切都是二进制的，它的眼里只有0和1，对于一连串的0101...0011，不同厂商对他们进行了特有的定义，比如通过规定指令集定长，其中1100表示功能A、0011表示功能B、1010表示功能C等等。那么，按照这样的设计，当我们使用不同的CPU编写程序（包括编写操作系统）时，就需要去对着厂商的手册，一点一点手码0101吗？啊，这。。。</p><p>当下显然不会，这就要说起编程语言的发展历程了~</p><h2 id="编程语言简史">编程语言简史</h2><h3 id="机器语言">机器语言</h3><p>CPU按架构会有自己的指令集，它们的背后也确实就是0101，只不过厂商赋予了语义并在硬件上实现了相应的功能。上古时期的编程确实就是直接写0101（这个时候的CPU还称不上是CPU）来完成的，彼时我们称其为机器语言，显然，机器语言对机器绝对友好，但对程序员绝对不友好，它的缺点肉眼可见：难记难改难纠错、费时费力费树脂（卧槽，原！）。痛，太痛了！</p><blockquote><p>世界上的第一个程序媛叫Ada，头像参考二进制安全必备神器：IDA Pro~</p></blockquote><p>业界把机器语言称为“第一代计算机语言”。</p><h3 id="汇编语言">汇编语言</h3><p>为了克服机器语言不说人话的问题，大佬们给CPU聘请了翻译(诶，您给翻译翻译什么叫0101？什么他么的叫0101？什么他么的叫他么的0101？)，而这就产生了第二代计算机语言：汇编语言。简单来说，汇编语言就是将机器码翻译成与实际意义相关的英文+数字缩写助记符（所以汇编指令也叫机器码助记符），比如<code>mov eax, 3</code>表示把数值<code>3</code>赋值给寄存器<code>eax</code>（至于什么是寄存器，这个学到的时候再说）。汇编语言的好处就在于相比于机器语言，编写起来没那么男的女的折磨，我们先用汇编助记符来编写程序，编写完成后经过翻译再变成机器码给到CPU去执行，而这个负责翻译的模块则被称作：汇编器。</p><p>汇编语言是一种低级语言（这里的低级不含贬义，只是说它所在的层级较低，与底层更近），它和具体的CPU指令集绑定，因此并不通用，尽管相对机器语言书写上舒服了很多，但编写门槛依然较高无法让人满意。</p><h3 id="高级语言">高级语言</h3><p>还记得前面讲操作系统时我们曾遇到的困境吗？不只是CPU，其他硬件的不同厂商标准规格都可能千差万别，如果需要开发者每一个都掌握，那属实crazy。这一点对于编程语言来说也一样，既然汇编难用又不通用，我们何不再架上一层中间层，搞一个统一的语言出来，再多安排几个翻译员，每个人专门负责从统一语言到某一个特定汇编语言的翻译工作。通过这一中间层的屏蔽，开发者只需要掌握这门统一语言即可编写在任何CPU指令集上运行的程序，而无需了解特定的指令集。（你看，我就说没什么困难是一个中间层搞不定的吧~）而且，在设计上我们也可以让这门统一语言尽量说人话，从而降低编写的难度与维护的成本。</p><p>而这，其实就是第三代编程语言：高级语言的由来。只不过，在漫长的历史长河中，有太多大能都达成了此共识，其结果就是高级编程语言如雨后春笋般，甚至直到2023的现在还在源源不断的涌现，从古早的BASIC、PASCAL、C、FORTRAN到现在的Go、Rust，它们都是高级编程语言，随着时代的进步，其中难免有一些被环境所淘汰，但也有一些历久弥新，每个不同的高级语言都蕴含了作者独特的审美与对环境生态、软件开发的理解，伴随着社区、使用群体的发展各自开宗立派、培养着自家忠实的拥趸。</p><p>高级语言在设计上大体分为两派：编译型和解释型。前者（比如C、C++）主张对编写的源代码进行前置处理：通过一种叫“编译”的方式把它变成汇编语言，再由汇编器变成机器码，最终在机器上执行，它的核心要点在于：所有代码在一开始就要全部翻译成最终的机器码，运行时直接执行；而后者（比如Ruby，Python、Javascript）则主张后置处理：在运行时通过解释器来一步一步地、当我执行到具体的某一行时，让同声传译把它变成机器码执行，每说一句就翻译一句原地执行。显然，前者把一些重活放在了编译期，得到的好处就是运行时更快，但后者则因为实时处理的模式往往在语法上可以更加灵活。而在高级语言发展过程中，这两派逐渐水乳交融、佛道双修，比如像Java、C#，它们都是半编译、半解释型，再像是Javascript、Python这种一开始做成解释型的，为了能够针对热点代码提速或是公共代码复用，也陆续引入了JIT、预编译的能力。</p><p>总之，高级语言在设计上与自然语言（英语）更接近（可别跟我提易语言，真不熟……），而与硬件功能相分离，便于开发者掌控而屏蔽底层差异。高级语言的优点在于：通用性强、兼容性好、便于移植，但同样的，天下没有免费的晚餐，相比直接写汇编来说其生成的代码更加臃肿，性能上也有所差距。因此像操作系统这种对性能要求苛刻的程序会经常在高级语言里内联汇编代码（通俗理解就是：高级语言的局部嵌入汇编代码，这需要高级语言的支持）来提速。</p><blockquote><p>但另一方面，在2023的今天，现代编译器已今非昔比可谓十分强大，在现代的一些架构上已然抹平甚至超越了使用汇编语言来编写的程序性能（编译器比我聪明系列）。</p></blockquote><h2 id="缘起hello-world">缘起"Hello, world"</h2><p>“Hello,world”之于编程，就好比“衬衫的价格是”之于英语听力。不管你是何门何派、哪个语种，入门的第一站都是"Hello,world"，经久不衰。这一切，都要从此说起：我们意兴盎然的选择了某门语言，开始修炼本门功法，不同门派的功法各有千秋：有些功法小巧精妙(C)，有些功法直捣黄龙(go)，有些功法艰深晦涩(C++)，有些功法必先自宫(Rust)，有些功法大开大阖(Java)，有些功法乱七八糟(你猜我说的是谁？)。</p><p>然而不管我们选择了哪一派，从它变成母语的那一天开始，我们就被深深地打上了相应的烙印。尽管在修炼过程中我们能够解决越来越多的问题，但与此同时它所植入的灵魂烙印也把我们的解题思维牢牢限制在本家系统之内。直到皇天不负有心人，本家功夫大成，我们得以窥探别门别派的心法口诀，坐而悟道。而本门功夫，修炼周期各有长短，这期间一旦受其他门派影响，轻则自我怀疑，重则道心破碎。</p><blockquote><p>有些选择了C语言的小伙伴，学了一年也不会做任何酷炫的app，只会在黑框框里跑四则运算，看到邻家8岁的小男孩都用python写AI画图了，顿时道心破碎，弃C如敝履。</p></blockquote><p>我们现在分别使用C、Java和Python来写一个Hello, world：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, world\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, world&quot;</span>)<br></code></pre></td></tr></table></figure><p>嗯，按照各家功法所述，我们应该分别保存成hello.c, hello.java,hello.py。还记得功法让我们怎么称呼它们吗？对，源文件！这些文件里的内容就是源代码，它们都是文本文件。那么源文件怎么执行起来输出“Hello,world”呢？这个时候，各家功法就有所分歧了.</p><h3 id="c">C</h3><p>C是一门编译型语言，使用C语言编写的hello.c需要经过预处理器、编译器、汇编器、链接器来一步一步处理，最终生成二进制可执行文件，不同平台都制定了可执行文件组织结构的标准，比如在Windows里叫PE(PortableExecutable)，像是我们平时双击的xxx.exe就是典型的PE可执行文件（实际上.sys,.dll也都是PE，前者是内核态所运行的驱动程序、后者是用于共享的动态链接库），而在大部分类Unix系统里用ELF(Executableand LinkingFormat)），它们往往没有后缀名。实际上后缀名只是一种浮于表面的印记，通过盖戳的方式让人类更容易分辨它是一个什么文件，真正决定文件制式的是它的内容信息，图片、视频、文本、可执行文件，他们各有各的标准结构。</p><blockquote><p>既然后缀名只是印记，那岂不是可以用来诱骗？早年的恶意软件、病毒可不就是充分利用了此种手段，整个Windows乌烟瘴气。用户也可以利用这一小手段：比如我上小学的时候，隐藏文件早就不用系统提供的方法了，我会把他的后缀改成其他资源的类型，诶嘿，你打不开了吧！后来到了中学，懂得套路又多了一些，这次就直接打开二进制编辑器，偷偷改掉某某视频的文件头~</p></blockquote><blockquote><p>Mac OS逼格比较高，它的可执行文件格式叫Mach-O（Mach Object FileFormat），是一种类似ELF的制式，iOS也是这套。</p></blockquote><p>也就是说，我们的源代码经过了重重流水线关卡，最终变成可执行文件。现在我来问你，这每道关卡都在折腾啥？相信这个问题应该难不倒有一年以上C编程经验的同学，毕竟C派重视基础，门徒大都喜欢刨根问底。</p><p><img src="2023-04-14-17-16-42.png" /></p><p>一言以蔽之：预处理器负责展开头文件、处理宏；编译器负责将加工后的源文件翻译成汇编语言源代码；汇编器再将汇编语言转化成机器码、生成可重定向的目标程序；最终由链接器整合所有目标程序，按照可执行文件的制式整合成可执行文件。整个过程说起来简单，但其实每一步展开都是宏篇巨幅。作为编程导论，我们暂不去深入了解每一步都是怎么做的，我们的疑问是：为什么需要这几步？如果上面的内容你有认真看过并思考过，那么这个问题的答案是显而易见的：我们需要在设计上分层，每一层各司其职，邻层相濡、隔层相忘。上图的中间部分，从C源代码编译成汇编、再从汇编到机器码这一过程相信通过上文你已经十分理解了，那么剩下的头尾各有什么作用呢？</p><p>先说头部的预处理器：预处理器这一步实际上是C语言特有的，它在设计上有一个头文件和源文件的区分，头文件做公开声明，源文件做内隐实现，你在写代码的时候可以引用别人的代码库，比如hello.c中的printf函数，它在前面通过<code>#include</code>宏引入的<code>stdio.h</code>中声明，作用就是在标准输出按照C-format制式打印字符串。此外，C语言还支持一种被称为宏(macro)的强大功能（宏和指针可谓是C的两大神器，一旦掌握了这两个东西，写起C来可谓运斤成风），宏代码的替换也是在预处理器中完成的，而具体怎么操作，等我们深入学习C语言时再做展开。</p><p>再说尾部的链接器：实际上我们生成的hello.o只包含了在hello.c中书写的单个文件的那部分代码，而对于整个工程项目来说，我们可能会写出一大堆源文件，且除了自己写的代码，可能还需要引用别人的生成代码（标准库或是第三方库，比如例子里的printf.o就是标准库所提供的），而把这些.o文件组织成最终的单一可执行文件，就是链接器的工作。</p><blockquote><p>【进阶】实际上在C语言里，上图的printf函数默认情况下并不是直接通过链接printf.o来使用，C标准库默认以动态链接库的形式存在，在程序被加载器吊起到内存时会挂载所需的动态链接库。当然，这是后话，新人不必急于理解。至于加载器，唔，可执行文件在磁盘里躺着的时候和被加载到内存去执行的时候，结构上还是有些差异的，需要个引导者来做初始化操作。</p></blockquote><p>我们来看看，经过编译器编译之后，生成的汇编源代码长什么样，这里我们选取最新的gcc12.2，先看看在Intel x86-64架构下的生成物：</p><p><img src="2023-04-18-11-52-29.png" /></p><p>当他链接成.o的时候，我们看到的则一般被称为反汇编码：</p><p><img src="2023-04-18-11-47-44.png" /></p><p>相比后者，提供给汇编器的前者一般会有一些脚手架，用来辅助编写汇编程序，比如<code>.LC0</code>部分的数据段，而后者则是CPU在真实执行时的汇编指令，或者这里叫机器指令更合适。每行汇编指令的上面还显示了对应的机器码，这里使用的是十六进制（只是二进制的一种简化写法，相对来说更加友好）显式。这些机器码就是CPU执行时真正的指令，不同的数字就是0和1的排列组合，表示了不同的功能。</p><p>好，让我们换个架构，比如从Intel x86-64换到ARM64，再编译链接一下：</p><p><img src="2023-04-18-11-48-16.png" /></p><p>不同的处理器架构指令集的设计千奇百怪，但是对于编写hello.c的开发者来说，我们完全可以不必理解它们，因为这些工作已经由翻译们（编译器）完成了。</p><h3 id="python">Python</h3><p>Python是一门解释型语言，前面也提到过，解释型语言是聘请了个同声传译，在代码运行时实时翻译成所在架构的机器码，而这个同声传译在这类语言里一般被称为虚拟机(VM,VirtualMachine)或是执行引擎（比如Javascript的V8引擎）。当我们在终端执行pythonhello.py时，会直接在终端打印出"Hello,world"，他不需要像C语言那样要先编译再执行本体："gcc hello.c -o hello&amp;&amp;./hello"，而是直接把.py文件作为参数传给python解释器，python解释器会先把<code>print('Hello, world')</code>翻译成字节码(Opcode，也叫操作码，在Python的世界里指<code>PyCodeObject</code>)，再由VM解析字节码实时变成机器码。</p><blockquote><p>字节码不是机器码，它是一些解释型语言在更上层制定的语法规则，它们一般类似机器码也有着像汇编那样的助记符，但所有平台通用（相当于也是个中间层，字节码到机器码的翻译交给了平台上具体的虚拟机）。</p></blockquote><blockquote><p>【进阶】Python代码执行一般来说经过以下四步：1.将源代码解析为解析树(ParserTree)；2.将解析树转换为抽象语法树(Abstract SyntaxTree)；3.将抽象语法树转换到控制流图(Control FlowGraph)；4.根据流图将字节码(bytecode) 发送给虚拟机(VM)。</p></blockquote><p>我们看下hello.py在执行时首先被翻译成的字节码：</p><p><img src="2023-04-18-16-34-08.png" /></p><p>是不是和汇编助记符很像？其实本质上都是一个思想，只是所处的层级不同罢了。</p><p>还记得解释型语言相比编译型语言的劣势吗？没错，运行时速度慢！毕竟你同声传译再强，也打不过提前抄标准答案的作弊狗（2023的今天，这话其实也不绝对了，解释型甚至也可以进行实时优化，根据运行时更丰富的信息生成更高效的代码，性能甚至超越编译型）。</p><blockquote><p>Python其实一开始被作者设计出来的时候，仅仅只是当做一个玩具，万万没想到的是，其简约极致的风格收获了大批粉丝，无数大佬先辈把python社区经营的如日中天，随着历史发展，python的语言生态逐渐丰富起来，就像是滚雪球一样，python最终承受了他原本不该承受的国之重任。</p></blockquote><p>就像C可以引用公共库一样，python也有公共库，只不过在python的世界里这叫做“包（package）”，当你需要使用其他人的函数方法时，只需要在文件头去<code>import xxxx</code>即可，这就和C的<code>#include &lt;xxx.h&gt;</code>有异曲同工之妙。为了能够提速，python把可以复用的包在首次执行时翻译生成的字节码转储(dump)到同名的<code>.pyc</code>后缀文件里，嗯，这里面涉及了工程的另一个思想本质：缓存、空间换时间。</p><p>所以你看，解释型和编译型的界限在2023的今天已经不是那么泾渭分明，虽然python是一门解释型语言，但到处都有编译型的影子。</p><h3 id="java">Java</h3><p>Java相比Python，从一开始的设计上就显得更理直气壮了：老子就是半编译、半解释型，你能咋地？Java也使用虚拟机（大名鼎鼎的JVM,Java VirtualMachine）和字节码的概念，我们编写的hello.java源文件首先会经过编译(<code>javac hello.java</code>)，生成完整的字节码，它被转储到文件<code>.class</code>后缀同名文件，Java编译过程并不会直接生成可执行文件，而是在运行时通过<code>java hello</code>来去自动加载所需的<code>.class</code>并通过JVM去解释opcode，最终转换成特定平台的机器码。</p><p><img src="2023-04-18-17-01-09.png" /></p><p>比如上图是一个可视化的Java字节码，它以二进制的形式存储到<code>.class</code>中。</p><p>所以Java在江湖上有一句经典口号：一次编译，到处运行！实际上，这就得益于其半编译、半解释的设计，我们在任何平台上都可以先运行编译器把它转成字节码，然后你可以随便拷贝到任何架构上，让特定的架构的JVM充当同声传译，把字节码转成相应的机器码（话虽如此，但也有水土不服的情况，毕竟理想很丰满，厂商很骨感）。</p><h3 id="小结">小结</h3><p>实际上所有的高级语言设计上都可以抽象成这样一个模型：</p><p>Source code ---&gt; |Compiler| ---Mid code---&gt; |Runtime| &lt;---Lib</p><p>只不过不同语言各有取舍，每一环节的任务或轻或重罢了。</p><h2 id="文本文件二进制文件">文本文件？二进制文件？</h2><p>上面我们曾频频提起文本文件和二进制文件，比如我们说源代码都是文本文件、生成的可执行文件、转储的字节码文件则都是二进制文件。那么二者到底是什么，又有何区别呢？不急，我们先思考这样一个问题：你编写的这些源代码，它们是怎么存放在存储媒介（比如硬盘）的呢？计算机的世界都是0和1，那么每一个字符、每一个汉字都是怎么对应到具体的0和1呢？</p><p>如果你理解了前文，那么相信聪明的你已经想到了答案：如法炮制，无非也是制定一个规则，给每个字符都映射一个0和1的排列组合嘛！没错，实际上，这一思想应用在这里，就叫做：“编码”。</p><h3 id="编码从ascii到utf8">编码：从ASCII到UTF8</h3><p>计算机是美国人发明的，美国人说英语，他们在设计之初为了满足自身使用需求，搞了一套如今广为流传的ASCII（AmericanStandard Code for Information Interchange,美国信息交换标准代码）码。</p><p><img src="2023-04-19-11-28-24.png" /></p><p>整张映射表对128个字符进行了编码，这其中包括了阿拉伯数字、26个英语字母的大小写、各种普通符号以及一些不可见的控制字符。比如大写字母A对应的ASCII码是65（二进制表示为B0100001），阿拉伯数字0的ASCII码是48（二进制表示为0110000），其他像是空格(SP)、换行(LF)等普通符号与不可见字符也有对应的映射码，它们在表中以大写名称标注。</p><blockquote><p>【维基百科】:ASCII由电报码发展而来。第一版标准发布于1963年，1967年经历了一次主要修订，最后一次更新则是在1986年，至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符。用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。</p></blockquote><p>由于一共是128个字符，这个量级刚好是2的7次方，换算成2进制的话也就是说至多需要7个二进制位（也叫bit），从B0000000一直到B1111111（这个B前缀是用于表示二进制binary）。为了方便说明，人们一般从低位到高位把每一位进行标号，对应到上图就是b7~b0。</p><p>随着计算机在世界范围的普及，ASCII的128个字符就显得捉襟见肘，在流传到一些西欧国家后，大家开始了整活儿，既然128个不够用，那我就扩展一下，加个倍，变成256个总够了吧。嗯，人性都是狭隘且自私的，愚蠢的西方人于是搞了一套EASCII(ExtendedASCII)出来，在ASCII的基础上又新增了128个字符（从B10000000到B11111111）用于表示西欧语言的特有字符，包括表格符号、计算符号、希腊字母和特殊的拉丁符号。虽然EASCII解决了部分西欧语言的显示问题，但世界可不止你西欧和北美。一旦把视角切到古老的东方，这些狭隘的编码手法在浩如烟海的象形文字面前显得是那么脆弱，那么的不堪一用。于是乎，在这段历史长河的至暗时刻，大大小小的国际组织、国家都在ASCII的基础上衍化出自己的编码标准，因编码不同而导致的水土不服问题频出。</p><p>比如在中国，先后曾衍生出GB2312、GBK、GB18030的编码，这类编码的设计思想就在于：基于128个ASCII，向上扩展到2个字节来表示中文、数学符号、罗马希腊字母、日文假名等等，而128个ASCII则原封不动还是用1个字节来表示，而这就是输入法常提示的全角与半角的由来。</p><p>终于，美国人意识到了ASCII设计之初的狭隘，几经辗转，有一个在加州的组织制定了全球统一的编码规则——Unicode(中文名称为统一码，又译作万国码、统一字元码、统一字符编码)。现在的软件系统大多采用Unicode，如XML（ExtensibleMarkupLanguage，可扩展置标语言）、Java都默认采用Unicode，Unicode不是一种特定的编码，而是更上一层的编码规则，向下有多种具体的编码格式，如今最常用的就是向下兼容ASCII的UTF-8以及和UCS-2兼容的UTF-16。</p><blockquote><p>Unicode一经问世，备受认可，为ISO纳入国际标准，成为通用字符集，即ISO/IEC10646（ISO老白嫖怪了，经典操作：方案是你的，但标准我来制定，谁叫你Unicode组织只是个商业机构呢）。</p></blockquote><p>纵观历史长河，我们发现ASCII编码的核心问题在于表示每个字符的bit位太少，所以各种扩展编码都进行了加倍甚至超级加倍的动作，只不过大家的映射表都是自制，因此可能同一个字符在不同编码映射表里的值并不相同，所以当鸡同鸭讲时、鸭听到的全是乱码，这是任由扩展而带来的衍生问题。Unicode大一统后，一概使用一致的字集编码。Unicode默认采用的编码是UCS-2，它采用16位的编码空间（也就是每个字符占用2Bytes，最多可表示2^16=65536个字符），事实上6w+的字符量已经足以cover全球主要语言的大多数字符，但unicode还是提供了一个扩展机制，允许表示一百多万个字符（还能怎样，2个字节不够，那就3个，3个不够就4个）。</p><p>为了能够兼容ASCII，像是英文字母“A”，它的ASCII值是65（十六进制表示是0x41,0x是十六进制hex的前缀），用unicode编码时我们保证其值不发生改变，由于UCS-2是16位，那么高位就用0填充，写成：U+0041。值是相同的，唯一的区别在于，从1个字节变成了2个字节，体积膨胀了一倍。至于各种其他乌七八糟的字符，我们预先按区间划分做dispatch即可，比如中文“一”对应的值是U+4e00（十进制就是19968），舒服了。</p><p>UCS-2在设计上和ASCII一样，都是定长编码，其带来的问题就在于对于那些一个Byte（8bit）就足以表达的字符，我们不得不用两个Bytes来存储，这会导致存储上的冗余（存了太多不必要的0x00）。而另一方面，由于像是ASCII囊括的那些字符，往往在日常工作中都是高频出现，这就会进一步加剧存储上的冗余。</p><blockquote><p>现代存储单元的最小单位一般是Byte(字节)。</p></blockquote><p>那么怎么办呢？我们发现罪魁祸首在于UCS-2是定长的，如果我们能设计一种变长的编码，也就是可长可短的编码方式，这个空间浪费问题不就迎刃而解了吗？</p><p>但是使用变长又会引入新的问题：我怎么知道这一次解码时，是该取长度1还是长度2呢？所以我们需要制定一种规则，让解码的时候有迹可循。比如，我们设计这样一系列规则：</p><ul><li>对于单Byte字符，8bit位中最高位必须等于0（ASCII只有128个嘛，这点可以办到）</li><li>对于需要N Bytes的字符：<ul><li>首个Byte：<ul><li>高位前N位为<code>1</code></li><li>第N位为<code>0</code></li></ul></li><li>其余Byte：<ul><li>高位以<code>10</code>开头</li></ul></li><li>未提及的位使用对应的unicode补充，不足的在高位用0补充</li></ul></li></ul><p>实际上这就是UTF-8编码，文字说起来很抽象，用图表展示会更直观：</p><p><img src="2023-04-19-15-40-11.png" /></p><p>经过这种方式，我们在解码时就可以根据第一个Byte的控制头来识别到底是要连续读入几个Byte，又要怎么把他们还原成原始code。那么现在我有个问题留给你思考：为啥其余Byte也要安排个<code>10</code>控制头呢？</p><p>经过UTF-8编码，我们的字符就变成了这样：</p><p><img src="2023-04-19-15-41-03.png" /></p><blockquote><p>除了UTF-8以外，还有其他的编码方式，比如UTF-16（2或4字节变长）、UTF-32（4字节定长）。</p></blockquote><p>细心的读者可能会发现这样一个问题：变长编码虽然解决了单字节变双字节存储冗余的问题，但由于控制字符的存在也引入了额外成本，一些字符可不仅仅是2个字节，而是3个甚至是4个（比如汉字通通都是3个），而这对比UCS-2或者是像中文的GB2312,GBK,GB18030来说，对于存储汉字实际上也是会造成冗余的。</p><p>UTF-8确实有着这一问题，但其设计实际上是早期互联网传输的带宽限制与国际字符互通的双向妥协（彼时本地存储的价格已经被降得很低，不再成为瓶颈）。因此，在2023的今天，你可能还能找到一些使用GBK等中文字符集的场景（比如MySQL），甚至可能还会有C语言遗老跟你讲strlen和中文字符长短的故事。毕竟对于包含大量中文的文本文件，使用GBK编码相比UTF-8确实能省近乎1/3的存储空间。</p><h3 id="文本文件">文本文件</h3><p>使用各种编码编写的文本，存储到文件里，这个文件就被称作“文本文件”。我们平时使用编辑器去展示和修改文本内容，实际上这一过程都是经过编解码处理的（你书写的字符经过编码存储到底层文件，编辑器把文件里的数据解码成字符显示出来）。一些常用编辑器乃至IDE(IntegratedDevelopment Environment,集成开发环境)都有选择使用何种编码的功能，即使是Windows的记事本也有着多种编码供你选择（其中就包括UTF-8）。</p><p>如果我们使用二进制编辑器打开编写的hello.c，就会看到磁盘里存储的实际上正是编码后的01序列。</p><p><img src="2023-04-19-17-28-53.png" /></p><h3 id="二进制文件">二进制文件</h3><p>除了文本文件以外，其他文件都是二进制文件。实际上二者本质并没有什么不同，你完全可以把文本文件当成一种特殊的二进制文件，业界之所以有这样的流行概念来加以区分，无非是因为很多标准、API的设计木已成舟，比如C标准库和POSIX的文件接口设计，就有着针对二者的区分。</p><p>每种不同的二进制文件都有着自己的格式，比如前文所讲的：hello.c编译链接生成的二进制可执行文件就有着自己的格式。</p><p><img src="2023-04-19-17-32-11.png" /></p><p>二进制编辑器毕竟不是可视化的，对于不同种类的二进制文件一般需要特定的编辑器才能可视化，比如图片也是二进制文件，但像是PhotoShop、美图秀秀这类可视化编辑软件却可以呈现图片的内容，这一过程本质上和文本编辑器打开文本文件没有什么区别。我们用二进制编辑器打开上面的图片，看看它里面的数据：</p><p><img src="2023-04-19-17-33-41.png" /></p><p>肉眼根本无法理解，我们没办法直接从这些二进制数据在脑海中还原出它是怎样的一张图，只能隐约看到一些“性状特征”：比如有个png字符躺在最前面，它其实是png类型文件的标志头。</p><blockquote><p>电影《黑客帝国》的大佬可是手改二进制，大脑里自动还原成小电影的哦，恐怖如斯！</p></blockquote><h2 id="机器码执行简述">机器码执行简述</h2><p>一个经典的硬件系统组成结构如图：</p><p><img src="2023-04-20-11-58-13.png" /></p><p>我们的程序被操作系统加载到内存之后，最终的机器码是交由CPU来一条条执行的。这些机器码在可执行文件中也以数据的形式存在（遵循冯诺依曼架构）。CPU内部被拆分成控制单元、运算/逻辑单元(ALU)和寄存器(Register)，ALU负责计算、寄存器负责暂存数据、控制器负责在内存、总线和寄存器之间传递数据。内存是一种临时的存储设备，关机之后它的数据会全部丢失，而我们的程序字节码平时是躺在可执行文件中寄放在硬盘上的，硬盘是一种持久化的数据存储，关机并不会擦除已经写入的数据。因此，在计算机运行期间，加载器把可执行文件加载到内存（当你双击打开exe的时候），里面的机器码通过总线送到CPU的ALU，然后一条条指令执行下去。</p><blockquote><p>【维基百科】冯·诺伊曼结构（英语：Von Neumannarchitecture），也称冯·诺伊曼模型（Von Neumannmodel）或普林斯顿结构（Princetonarchitecture），是一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构。存储程序计算机在体系结构上主要特点有：1.以运算单元为中心2.采用存储程序原理 3.存储器是按地址访问、线性编址的空间4.控制流由指令流产生 5.指令由操作码和地址码组成 6.数据以二进制编码</p></blockquote><blockquote><p>为什么内存不做成持久化的呢？一方面是成本问题，另一方面则是没有必要。内存相比机械硬盘哪怕是固态它的速度完全不在一个量级上，像我们的PC，硬盘动不动就1TB、2TB，但内存可能只有16GB、32GB。DRAM的随机读取要比你SATA的随机读取快上1000倍。</p></blockquote><p>那么为什么需要寄存器呢？答案很简单：要提速。尽管内存相比硬盘，它的速度快上了好几个量级，但是对于以纳秒为量纲的现代处理器来说，完全不在一个次元。因此CPU会设计出或多或少的寄存器在内存和ALU之间传话（如果说ALU是皇帝，内存是大臣，那么寄存器就是太监），不同的CPU架构有着不同数量的寄存器，每个寄存器都有它自己的用途，而寄存器的大小则取决于总线的宽度（也就是你一次性最多能传输多少bit数据），比如对于64位系统来说，寄存器的存储空间就是64bit=8Bytes大小。寄存器相比从内存读取数据还要再快上100倍（在2023年的今天，可能远远不止100倍了），但寄存器毕竟存储量级受限于总线宽度与个数，从制作成本和设计上来讲，想要完全通过寄存器来满足针对内存使用上的提速是远远不够的。那怎么办呢？既然寄存器造价太高，我们何不找个折中的法子：做一个中间缓存层，挑一种比DRAM更快且比寄存器更能吃的硬件如何？而这就是现代处理中颇为重要的一个概念：高速缓存。</p><p>高速缓存采用的是一种叫SRAM的存储媒介，相比DRAM它的速度更快但相应的造价也更高。而这一中间层能够起到高额的缓存命中率，本质上的原因在于：我们CPU去执行的指令或者取的数据往往都具有局部连续性，比如一大段机器指令是加载到连续的一段内存，所以在CPU通过总线去取某一条指令的时候，实际上会一次性批量把连续的内存数据（此时就是连续的机器指令）全部拿到并置入高速缓存，等到我们需要继续执行下一条机器码指令时，缓存直接命中进而达成提速的效果。</p><p>实际上现代处理器不仅有缓存，甚至是多级缓存，比如经典的三级缓存模型：</p><p><img src="2023-04-20-15-39-36.png" /></p><p>自顶向下容量逐渐增大，访问速度也逐渐降低。当缓存未命中时，缓存系统会向更底层的层次搜索。</p><ul><li>L1 Cache：在CPU核心内部，分为指令缓存和数据缓存，分开存放CPU使用的指令和数据；</li><li>L2 Cache： 在CPU核心内部，尺寸比L1更大；</li><li>L3 Cache： 在CPU核心外部，所有CPU核心共享同一个L3缓存。</li></ul><p>越顶层的缓存为了提升命中率，功能分类会越细致，层层漏斗下去，最终走到内存。整个计算机系统的存储设备可以组织成一个金字塔型：</p><p><img src="2023-04-20-15-49-24.png" /></p><p>这一张图可谓是把工程实践中“分层”与“缓存”的概念发挥得淋漓尽致。</p><h2 id="操作系统眼里的程序">操作系统眼里的程序</h2><p>一个程序从编写到执行的整个过程，目前就仅剩一个环节就可以完整的自顶向下串起来了，那就是：程序从磁盘上加载到内存的过程。这一步骤由操作系统的加载器完成，它会把躺在硬盘上的可执行文件加载映射到内存中，作为一个独立的进程存在，拥有着自己独立的虚拟内存地址空间。</p><h3 id="进程process">进程(Process)</h3><p>这里就提到了一个在操作系统中非常重要的概念：进程。我们在学操作系统这门课时，老师往往要求熟读并背诵这样两个概念：进程是资源分配的基本单位；线程是任务调度和执行的基本单位。这两句真言本身并没有错，但对于初学者来说确是难以理解的学术派黑话。什么他么资源分配、任务调度，究竟到底什么是进程？</p><p>我们来打个比方：可执行文件躺在硬盘里的时候，你可以把它看成是一种被冻结的生命模板，而在加载到内存后，模板被唤醒克隆出一个新的生命。每个生命体都是一个进程，进程在操作系统里有着唯一的ID标识，同一个生命模板也可以被加载多次，但是它们每次克隆出的都是新生命，彼此隔离。进程实际上是操作系统对一个正在运行的有生命的程序的一种抽象，为什么说它是资源分配的基本单位呢？因为在现代操作系统中，每个进程都有独立的虚拟内存地址空间（当然，不止这一种资源），站在每个进程的第一人称视角来看，它都在独占硬件（处理器、内存和I/O设备），进程之间彼此隔离，谁也看不到谁，只有操作系统才知晓所有进程的存在。</p><p>但是我们知道，硬件设备是唯一的，内存需要大家共享，CPU即使有多核，它的核数也是先天锁定的（你总不能说我CPU就8核，那进程只能有8个吧）。当我们把视角从进程第一人称切到上帝（操作系统）视角来看，就会发现其实每个进程都在交错、并发执行（也就是说轮换着共用多个CPU核）。为什么说是既交错又并发呢？因为进程数往往是远超CPU核数的，所以当多个进程同时在运行的时候，操作系统就得通过某种策略去调度分配，比如我一共有8核，那么在t0时刻，就会有8个进程在同时运行，而等到t1时刻，可能相比t0发生了轮换，此时是另外8个进程同时运行（可能和t0的8个有重叠：可能是连续执行了完整的duration，也可能是被换出之后又换入）。</p><blockquote><p>简单来说，CPU有多少核，就支持同时执行多少条指令。虽然这样说并不严谨，毕竟现代CPU往往有线程超卖的设计，但不妨碍理解。</p></blockquote><blockquote><p>不同类型的操作系统有着迥然不同的调度策略，类型上一般是分为实时操作系统和分时操作系统。我们平时使用的大部分OS像是Windows，Linux都是分时操作系统，它们有时间片的概念，时间片到期或进程(线程)主动让出的时候会让给其他进程(线程)。</p></blockquote><p>而内存则一般是做了一层从物理内存到虚拟内存的映射，操作系统会欺骗每个进程：你们都在独立使用整块DRAM（甚至超卖，比如对32位系统来说有4GB大小的虚拟内存空间，但物理内存DRAM可能只有2G），而只有在进程真正去读写某一小块特定的地址时，操作系统才会真正把物理内存交给你使用。</p><h3 id="虚拟内存线性地址空间">虚拟内存：线性地址空间</h3><p>虚拟内存空间按地址进行索引，整片空间是连续线性的，而地址空间的大小取决于系统位数，对于32位机器来说，这个大小就是4GB，对于现如今最常见的64位机器来说，大小甚至达到了256TB。</p><p><img src="2023-04-20-19-36-33.png" /></p><p>比如上图是一个进程在32位Linux系统上的线性地址空间图，它被分割成了多段，每一段存放特定的资源，比如：代码段（也就是你程序编译链接后的机器码）、数据段、堆(Heap)、栈(Stack)等等。整个寻址空间有4GB的大小，地址范围从0x00000000到0xffffffff。</p><blockquote><p>【进阶】在32位Linux上默认情况下高1GB是内核空间，所有进程共享。低3GB才是进程在用户态可用的线性地址空间。Windows上则默认是高2GB为内核空间，嗯，Windows内核真大。</p></blockquote><h3 id="线程thread">线程(Thread)</h3><p>实际上并发执行并不仅限于多个进程，在现代操作系统中，每个进程内部其实也可以并行执行多个任务，而这，就引出了线程。进程可以管理多个线程，每个线程负责一条控制流，它们共享所属进程的同一片线性地址空间（也就是说彼此天然就看得见），但各自有着私有的资源（比如每个线程都有自己的Stack）。对于那些只有一条控制流的进程，进程或是线程的概念可能显得没那么重要，事实上进程和线程只是现代操作系统抽象出的概念，它们在不同的操作系统里的设计各有差异，在Windows中，进程和线程可以说是一板一眼，进程就是个空壳子，对于那些只有一个控制流的进程它们默认会有一个主线程。而在Linux中情况就比较复杂，进程和线程的概念受历史原因有过多次改版升级，所以并不像Windows那样纯粹。</p><blockquote><p>【进阶】Linux内核弱化了进程、线程的概念（不像Windows进程严格管理线程，调度单位只能是线程，弱化了进程父子关系，使得进程看起来可以通过CreateProcess凭空捏一个出来），内核都是task_struct统一管理，比如<code>vfork()</code>出来的轻量级进程甚至可以与其他进程共享线性地址空间（只不过有个额外标志）。由于历史原因，Linux也遵守了真香定律。以pthread的两种实现LinuxThread（Linux2.4以前）和NPTL（2.5以后）为例，早期内核是没有TGID的，只有PID，所以内核根本就没有线程的概念，在内核眼里都是进程，都是调度器调度的单元，而这就给LinuxThread的实现带来了难题——LinuxThread采用1:1模型，即每个线程都是LWP对应一个内核线程（这个线程的概念是从我们的视角出发的）。而NPTL时代，内核引入TGID，此时依然是1:1模型，但不是简单的LWP了，TGID把这些线程联系了起来，NPTL创建线程时传递一个特有的CLONE_THREAD标志，内核把TGID填写为调用者的PID，PID填写新线程号（原本的进程号）。</p></blockquote><p>为了便于理解，我们采用Windows的视角，统一把线程视为执行流，进程视为管理员。因此CPU核的切换实际上是发生在线程上的，那么线程1是怎么切换到线程2上的呢？我们之前说切换的动作需要内核代码来做，内核代码是运行在内核态的，而我们的代码运行在用户态，怎么就跑着跑着就丢了，就执行到内核的切换代码去了呢？</p><p>事实上，每一个用户态的进程在运行时都会经常进入到内核态，当我们调用了一些系统调用(systemcall)的时候，就会从用户态切换到内核态，比如我们的程序进行了文件I/O、网络I/O、各种资源申请等等操作（一般会引起阻塞）时都会发生这一切换，在内核态想要切换回用户态的前夕，根据操作系统的类型以及调度策略，会去判断是否要将当前所用的CPU核轮换给另一个嗷嗷待哺的线程（比如时间片过没过期啊，优先级啊等等）。</p><p><img src="2023-04-20-20-14-56.png" /></p><p>你可能会问，假如我写个死循环在那里空转，我绝对不自己触发系统调用，那我的CPU核不就没机会让出去了吗？虽然你的想法很危险，但这确实是一个好问题。实际上，现代操作系统内核里还有个特等公民：中断。中断优先级高于内核线程，一旦发生了中断那么一定得让出一个CPU核来立即响应（中断在内核态的地位就好比Linux系统里信号在用户态的地位）。中断处理告一段落后，才会返还给内核线程，此时就产生了线程切换的时点。中断有很多种，这其中用于保证现代操作系统能够进行线性调度的那位爷叫”时钟中断“，时钟中断会通过硬件定时产生，所以年轻人，躲得了初一、躲不了十五。</p><blockquote><p>还有个缺页异常(PageFault)中断也很重要，它是实现每个进程的虚拟内存地址空间的基石，日后我们讲具体的操作系统时再做展开。</p></blockquote><h3 id="通信与竞态">通信与竞态</h3><p>同一个进程下的多个线程彼此是看得见的，因此它们完全可以在用户态互通往来，A1看得见A2，A2也看得见A1，但是A1和A2都无法看见另一个进程B下的B1,B2...另一方面，并发相比单一执行流虽然效率上成倍增长，但也带来了一个新问题：竞态(RaceCondition，也程竞争条件、竞争冒险)，它旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。此词源自于两个信号试着彼此竞争，来影响谁先输出。当线程A1和线程A2同时试图修改一块内存，在没有并发控制的情况下，最后的结果依赖于两个进程的执行顺序与时机，并发访问冲突可能会导致最后的结果不符合预期。</p><p>那么怎么解决竞态问题呢？这就需要我们对共同访问的资源（一般被称为临界区）进行互斥保护，操作系统API乃至一些现代高级语言本身都提供了各种保护的手段，归纳来讲其实就两种思路：”上锁“和”执行不可打断“。锁的设计多种多样，它的思想就是：卫生间就一个，你先进去了就要锁门，防止别人在你答辩的时候误入。等你舒服了之后，锁才会被释放，其他人才有机会使用。而所谓的执行不可打断，就是指我整个过程一气呵成，从所有人的视角看整个动作都是一瞬间完成的，不会被中途打断，也就从根源上避免了竞态，我们一般称其为”原子操作“（这一命名较为古老，是取原子为最小单元不可再拆分之意）。</p><p>当然竞态不一定非要是多核环境下才能触发，即使你只有单核，但是由于CPU轮换调度机制，你的线程A1完全可能在临界区操作中途被打断，换给了A2，而A2又进入了临界区开始操作，此情此景亦会产生竞态。</p><p>实际上我们把镜头拉起，除了同一进程下的多个线程可能会发生竞态以外，即使是多个进程之间也可能会产生竞态。尽管进程之间彼此看不到（主要是看不到彼此的地址空间和独有资源），但它们可能会共同修改同一个磁盘上的文件，我们回过头思考：线程之间的竞态解决本质上是靠线程之间彼此的交互来达成的，这对于进程来说也是一样，但进程天然彼此隔离，所以就需要操作系统去提供一些通信的手段来让进程之间也能互通往来，而这就是大名鼎鼎的IPC（Inter-ProcessCommunication, 进程间通信(Inter-ProcessCommunication)）。进程通信手法多种多样，具体则视操作系统的实现，日后我们有机会讲某一个操作系统时再做展开。</p><blockquote><p>当然，进程通信并不只是为了解决竞态，它原本的目的就是通信本身。不同进程、或是相同程序的不同进程实例之间需要交流的场景非常繁杂，甚至并不局限于同一台机器，即使是两台机器之间，也可以通过网络I/O来达成RPC(RemoteProcedure Call,远端过程调用)。RPC这一概念在2023的今天相当流行，毕竟微服务盛行，服务与服务之间都是通过RPC请求来做server/client级联交互。</p></blockquote><blockquote><p>相对于RPC的是LPC(Local ProcedureCall，本地过程调用)，也就是同一台机器不同进程之间调用（A进程调用B进程的某个接口），只不过LPC的工作都是由IPC完成的（可以这样理解：LPC和RPC在概念上都属于上层，而IPC则是一种实现机制，是底层基础，甚至类Unix系统里都抛弃了LPC的概念，它们认为RPC是LPC能力的超集）。</p></blockquote><h3 id="协程coroutine">协程(Coroutine)</h3><p>协程（Coroutine，也称作微线程（micro-thread）、纤程(fiber)）是近些年才兴起的概念，简单来说，它是一种用户态的轻量级线程。线程是操作系统的概念，物理CPU的调度是在线程之间进行轮转切换，前面我们有提到：CPU在线程之间的切换需要有一个从用户态陷入到内核态的过程，而这个过程实际上是有较高的开销的。另一方面，尽管多线程可以成倍提速（比如对于服务器来说，每个请求进来我都开个线程单独处理），但因线程本身占用资源较多，在系统内受物理资源(CPU核数、内存)限制，数量并不是多多益善（像是服务器一般要做池化管理）。而协程相比线程来说，在面向高并发场景的服务器开发来说，其天然的特性得到了发挥，相比线程具有相当的优势。</p><p>在2023的今天，许多高级语言都内置了协程的能力，像是C++、Python，甚至像Go语言天然就基于协程来编程。</p><blockquote><p>C++在20标准通过了无栈协程coroutine，但仅仅包含了编译器需要实现的底层功能（语法上形如co_awaitbalabala...），通用API的实现Executors已确认会在23标准纳入，同时还会纳入networking库。</p></blockquote><blockquote><p>Python从最初的半协程：生成器yield到asyncio、async/await、asynico，协程的体系不断被完善。</p></blockquote><p>协程之间的切换在用户态完成，并不会陷入到内核，且协程本身占用资源较少，这在异步编程的场景中，极大地节省了开销、提高了性能，于此同时，在大部分编程语言中，协程由于其可以采用结构化并发的编程技法，使得相比传统编写异步代码的CallbackHell或是Promise/Future来说，编写得到了简化、代码可读性与维护性也更高。</p><p>当然协程本身的实现颇为复杂，想要对协程有深刻的理解需要具备相当的异步编程经验（常见于服务器后台网络编程），作为编程导论，我们浅尝辄止，留待日后专题展开。</p><h2 id="总结">总结</h2><p>系统漫游作为开篇第零章，旨在让每一位开发者对自己在用的计算机有一个宏观的、整体能够衔接上的理解。本文谈及的知识点涉及了计算机的基本组成、操作系统、编程语言等专题，通过抽丝剥茧、层层递进的方式带领读者步入编程世界的大门。我们在学习一门技法的同时，一定要养成思考的习惯，如此方能将杂糅零碎的知识点拼凑成完整的体系结构，知其所以然。一旦知识体系成型，日后对于新知识的吸纳将显得顺理成章、自然而然，疑难杂症的排查亦可心中有数、有迹可循。</p><p align="right">by 玉涵，完稿于2023年4月22日深夜，雨</p>]]></content>
    
    
    <categories>
      
      <category>编程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>格物致知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++模板从入门到劝退(2)——型别推导、万能引用与完美转发</title>
    <link href="/2022/06/07/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(2)%E2%80%94%E2%80%94%E5%9E%8B%E5%88%AB%E6%8E%A8%E5%AF%BC%E3%80%81%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    <url>/2022/06/07/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(2)%E2%80%94%E2%80%94%E5%9E%8B%E5%88%AB%E6%8E%A8%E5%AF%BC%E3%80%81%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述严谨性，按照笔者的归纳方式穿针引线，为痴迷于黑魔法而又始终不得其解的同学打通任督二脉。</p><p>本篇是走进模板世界的最后一道前菜，通过型别推导、万能引用与完美转发这三个C++11所引入的新机制，我们得以对模板的世界管中窥豹。</p><span id="more"></span><h1 id="型别推导万能引用与完美转发">型别推导、万能引用与完美转发</h1><p>上一讲的最后我们提到了一种特殊的引用类型：万能引用(UniversalReference)，万能引用虽然长得很像普通的右值引用，但二者却有着本质差别。万能引用是形如<code>T&amp;&amp;</code>的引用类型，当且仅当<code>T</code>的型别需要被直接推导时，万能引用的最终类型判定需要介入引用折叠规则，虽然上一讲我们有提到，但却浅尝辄止。而说到型别推导(TypeDeduction)，这是一个迷人且拥有非常复杂的判定规则的设定，在传统C++中，它始终和模板一起出现，因此传统的C++开发者即使对模板望而生畏、不了解型别推导也不会在日常开发工作中因此而困扰，而C++11引入了<code>auto</code>和<code>decltype</code>关键字，将型别推导的作用放大到开发者的日常中，至此，在现代C++开发中，开发者或多或少都需要亿点点型别推导的知识。</p><blockquote><p><code>auto</code>这个关键字早就存在（从C语言继承过来的legacy），但是在现代操作系统中这玩意毫无卵用，C++11罕见的废弃了<code>auto</code>原本的语义而重新定义了它，要知道，C++可是个相当保守的老顽固。</p></blockquote><h2 id="函数模板实参推导">函数模板实参推导</h2><p>回想一下传统C++中的函数模板实参推导(Function Template ArgumentDeduction)，一个函数模板想要实例化出具体的函数需要确定所有的模板实参，而这里的确定一般有两种手法：一种是显式地指定；另一种是让编译器根据上下文自行推断。实际上这两种手法也常常混用，即函数模板实参的确定由二者共同完成。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里只做了模板声明，省略了定义，这里只是为了做推导演示</span><br><span class="hljs-comment">// 但我们要知道：函数一旦需要执行的话，那么其定义是必不可少的</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> To, <span class="hljs-keyword">typename</span> From&gt;</span><br><span class="hljs-function">To <span class="hljs-title">convert</span><span class="hljs-params">(From f)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">int</span>&gt;(d);    <span class="hljs-comment">// 需要实例化出int convect&lt;int, double&gt;(double)&#123;...&#125;</span><br>    <span class="hljs-type">char</span> c = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">char</span>&gt;(d);  <span class="hljs-comment">// 需要实例化出int convert&lt;int, char&gt;(char)&#123;...&#125;</span><br>    <span class="hljs-built_in">int</span>(*ptr)(<span class="hljs-type">float</span>) = convert; <span class="hljs-comment">// 需要实例化出int convert&lt;int, float&gt;(float)&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这就是一个显式指定 +型别推导的例子，第一行我们仅指定了<code>To</code>为<code>int</code>型，<code>From</code>则根据传入的参数<code>d</code>被编译器推导成<code>double</code>型，它与<code>d</code>的类型一致。第二行与第一行类似，只不过显式指定的<code>To</code>类型是<code>char</code>。第三行则有些不同，它定义了一个型别为<code>int(*)(float)</code>的函数指针变量<code>ptr</code>，使其指向<code>convert</code>函数，这里<code>To</code>和<code>From</code>都需要编译器来做推导，根据函数指针类型，分别将<code>To</code>推导成<code>int</code>、<code>From</code>推导成<code>float</code>。<code>ptr</code>实际指向的是函数模板<code>convert</code>实例化出的形如<code>int convert&lt;int, float&gt;(float)&#123;...&#125;</code>的函数，而非<code>convert</code>本身，我们知道函数模板本身只是模板，是没有实体对象的。</p><blockquote><p>该例出自https://en.cppreference.com/w/cpp/language/template_argument_deduction，道行够深的同学一定要通读。</p></blockquote><p>如果将上例中的<code>To</code>和<code>From</code>顺序颠倒，会发生什么事呢？由于模板参数<code>To</code>并没有出现在函数的参数列表中，故某些情况编译器无法通过上下文来推导出<code>To</code>的类型，我们只好这样来写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> From, <span class="hljs-keyword">typename</span> To&gt;</span><br><span class="hljs-function">To <span class="hljs-title">convert</span><span class="hljs-params">(From f)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;(d);    <span class="hljs-comment">// 完全显式指定，编译器不再需要按参数d的类型做推导</span><br>    <span class="hljs-type">char</span> c = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">double</span>, <span class="hljs-type">char</span>&gt;(d);  <span class="hljs-comment">// 完全显式指定，编译器不再需要按参数d的类型做推导</span><br>    <span class="hljs-built_in">int</span>(*ptr)(<span class="hljs-type">float</span>) = convert;         <span class="hljs-comment">// 还是可以完成推导，需要实例化出int convert&lt;int, float&gt;(float)&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>顺序的调换导致我们前两行的自动推导失效，从而不得不完全显式地指定，代码也写成了“愚型”。而另一方面，我们也可以看出，对于函数模板来说，大多数情况的模板实参型别推导还是依赖于函数调用的参数列表，这其中出现了的模板参数往往可以进行推导。我们简单总结下，对于函数模板<code>template&lt;typename T&gt;void f(T param);</code>，编译器可以根据我们实际调用时传入的实参类型来进行推导(<code>f(argument);</code>)，得出模板参数<code>T</code>的类型和相应的参数列表(<code>T param</code>)。</p><p>然而这只是一种情况，也是最简单的情况。实际上，我们需要考虑的维度有三个：</p><ul><li>模板参数本身：<code>T</code></li><li>函数参数列表：不一定是<code>T param</code>，很可能对<code>T</code>做了CV限定或是引用/指针修饰，我们记为<code>ParamType</code></li><li>函数调用实参：<code>argument</code>这个表达式的型别可以千奇百怪</li></ul><p><code>T</code>型别的推导实际上是<code>ParamType</code>和<code>argument</code>的共同作用，从<code>ParamType</code>的视角来看，大抵有着四种情况：</p><ul><li><code>ParamType</code>既非指针也非引用</li><li><code>ParamType</code>是个指针</li><li><code>ParamType</code>是个左值引用</li><li><code>ParamType</code>是个万能引用</li></ul><h3id="paramtype既非指针也非引用"><code>ParamType</code>既非指针也非引用</h3><p>这是最简单的情况：按值传递。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;<br><br><span class="hljs-built_in">f</span>(argument);<br></code></pre></td></tr></table></figure><p>值传递的推导规则非常轻量：编译器在推导时会忽略掉<code>argument</code>的顶层CV限定和引用修饰。结合第一讲中的值语义，这一点其实非常好理解：值传递的形参本质上是实参的副本，所以实参的顶层<code>const</code>,<code>volatile</code>特性形参完全可以不care，拷贝以后就跟数据源头毫无瓜葛了，通俗的理解是”大可以我改我的，反正我又不影响你“。至于引用修饰，那就更没关系了，都值语义了，它只能影响从哪个源头拷贝而已。</p><p>此外还要注意，值传递推导所忽略的CV限定只有顶层(top)，底层(bottom)CV限定是不能被忽略的，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> ptr = <span class="hljs-string">&quot;Fun with pointers&quot;</span>;    <span class="hljs-comment">// ptr是个指向const对象的const指针</span><br><span class="hljs-built_in">f</span>(ptr); <span class="hljs-comment">// T被推导成const char*，底层const得以保留，也必须保留</span><br></code></pre></td></tr></table></figure><blockquote><p><code>const</code>是限定<code>char</code>还是限定pointer，要看它的位置在<code>*</code>的左边还是右边。</p></blockquote><p>其实这也很好理解，因为值语义拷贝的是个指针，指针本身的<code>const</code>限定可以被擦掉，但是它所指向的类型的<code>const</code>限定是绝对不可以擦掉的。</p><p>来看一些用例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// param类型和T类型始终一致</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    <span class="hljs-comment">// 打印T的型别和param的型别</span><br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);       <span class="hljs-comment">// 最简单的情景，T被推导为int</span><br>    <span class="hljs-built_in">f</span>(cx);      <span class="hljs-comment">// 由于const被忽略，T依然被推导为int</span><br>    <span class="hljs-built_in">f</span>(rx);      <span class="hljs-comment">// 先忽略掉引用、再忽略掉const，T还是被推导成int</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);      <span class="hljs-comment">// T被推导为int*</span><br>    <span class="hljs-built_in">f</span>(&amp;cx);     <span class="hljs-comment">// T被推导为const int*，底层const特性不能忽略</span><br>    <span class="hljs-built_in">f</span>(&amp;rx);     <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(pcx);     <span class="hljs-comment">// T被推导为const int*, 底层const特性不能忽略</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// 顶层const被忽略，T被推导为const int*</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">intint<br>intint<br>intint<br>int *int *<br>const int *const int *<br>const int *const int *<br>const int *const int *<br>const int *const int *<br></code></pre></td></tr></table></figure><p>C++标准库的<code>typeid</code>贼鸡儿难用，由于标准没有规定其<code>name</code>成员函数的输出结果，各大编译器花式整活，输出结果尽是些听不懂的“方言”，另一方面<code>typeid</code>也是运行期输出，没那个味儿。作为一名C++程序员，我们遇到困难，也不要怕，微笑着(bushi)……自己实现一个编译期类型计算的方法(当然，本鶸搬运的是so大神的实现)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span><br><span class="hljs-function">std::string_view</span><br><span class="hljs-function"><span class="hljs-title">type_name</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __clang__</span><br>    string_view p = __PRETTY_FUNCTION__;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">34</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">34</span> - <span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(__GNUC__)</span><br>    string_view p = __PRETTY_FUNCTION__;<br><span class="hljs-meta">#  <span class="hljs-keyword">if</span> __cplusplus &lt; 201402</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">36</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">36</span> - <span class="hljs-number">1</span>);<br><span class="hljs-meta">#  <span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">49</span>, p.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;;&#x27;</span>, <span class="hljs-number">49</span>) - <span class="hljs-number">49</span>);<br><span class="hljs-meta">#  <span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>    string_view p = __FUNCSIG__;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">84</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">84</span> - <span class="hljs-number">7</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>现阶段初学者还不需要理解这段代码，实际上他并没有做什么神奇的操作，只是对不同的编译器生成的函数签名中截取了想要的部分字符串而已。总之，现在只需要知道<code>type_name</code>这个函数模板可以输出任何模板参数<code>T</code>的类型。</p><h3 id="paramtype是个指针"><code>ParamType</code>是个指针</h3><p>模板形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T* param)</span></span>;  <br></code></pre></td></tr></table></figure><p>此时，形参<code>param</code>的类型已经被限制成必须是某个类型的指针型，指针型本质上也是按值传递（拷贝的是地址值，即指针型变量存储的value），推导规则就尝试将实参<code>argument</code>“适配”到形参上去，形参类型确定了，那么<code>T</code>的类型也就确定了，此时形参和<code>T</code>是不同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T* param)</span> </span>&#123;<br>    <span class="hljs-comment">// 输出T的类型和形参param的类型</span><br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">int</span>* px = &amp;x;<br>    <span class="hljs-type">int</span>*&amp; rpx = px;             <span class="hljs-comment">// 指针的引用，</span><br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* pcx = &amp;x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> pcpx = &amp;x; <span class="hljs-comment">// 当然了，像rpx,pcpx这种东西你日常编程基本遇不到，这里只是为了让例子尽量丰满</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);   <span class="hljs-comment">// T被推导为int, param被推导为int*</span><br>    <span class="hljs-built_in">f</span>(px);   <span class="hljs-comment">// 同上</span><br>    <span class="hljs-built_in">f</span>(rpx);  <span class="hljs-comment">// 同上</span><br>    <span class="hljs-built_in">f</span>(pcx);  <span class="hljs-comment">// T被推导为const int, param被推导为const int* </span><br>    <span class="hljs-built_in">f</span>(pcpx); <span class="hljs-comment">// T被推导为const int, param被推导为const int*</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zsh">intint *<br>intint *<br>intint *<br>const intconst int *<br>const intconst int *<br></code></pre></td></tr></table></figure><p>实际上，指针型的推导和第一种情况的值推导很相似，引用修饰和顶层const同样会被忽略，只不过<code>T</code>的类型和形参<code>param</code>的类型有所区别罢了。</p><h3 id="paramtype是左值引用"><code>ParamType</code>是左值引用</h3><p>模板形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;<br></code></pre></td></tr></table></figure><p>这种情况相当于限定了形参<code>param</code>的类型一定是某个类型的左值引用，这就意味着我们的传参方式是按引用传递(传址)，因此一方面实参<code>argument</code>的引用修饰会被忽略（因为不管是不是引用类型，最终推导出的形参都必须是个左值引用），另一方面其CV限定不会也不能被忽略，因为相比于值传递，我们此时传递的对象并不会拷贝一份，因此其<code>const</code>,<code>volatile</code>特性绝对不能忽略或者舍弃。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);       <span class="hljs-comment">// T被推导为int, param被推导为int&amp;</span><br>    <span class="hljs-built_in">f</span>(cx);      <span class="hljs-comment">// T被推导为const int, param被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(rx);      <span class="hljs-comment">// rx本身的reference会被忽略，因此和传递cx没什么两样</span><br><br>    <span class="hljs-comment">//f(&amp;x);    // 这三个都不能通过编译，因为param是左值引用必须绑定到左值上</span><br>    <span class="hljs-comment">//f(&amp;cx);   // 取地址符表达式是prvalue，不能被lvalue reference绑定</span><br>    <span class="hljs-comment">//f(&amp;rx);</span><br><br>    <span class="hljs-built_in">f</span>(pcx);     <span class="hljs-comment">// T被推导为const int*, param被推导为const int*&amp;</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// T被推导为const int* const, param被推导为const int* const&amp;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zsh">intint &amp;<br>const intconst int &amp;<br>const intconst int &amp;<br>const int *const int *&amp;<br>const int *constconst int *const &amp;<br></code></pre></td></tr></table></figure><p>而说到左值引用，就不得不提到C++中的万金油：const左值引用，试想如果我们前置地对<code>param</code>型别增加一个<code>const</code>限定会如何呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);   <span class="hljs-comment">// T被推导为int, param被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(cx);  <span class="hljs-comment">// T被推导为int, param被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(rx);  <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);  <span class="hljs-comment">// const左值引用也可以绑定到右值上，因此编译通过。T被推导为int*，param被推导为const int*&amp;</span><br>    <span class="hljs-built_in">f</span>(&amp;cx); <span class="hljs-comment">// T被推导为const int*，param被推导为const int* const &amp;</span><br>    <span class="hljs-built_in">f</span>(&amp;rx); <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(pcx); <span class="hljs-comment">// pcx是左值，T被推导为const int*, param绑定其上，本身追加const限定，因此被推导为const int* const&amp;</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// 同上，不管T本身是否有顶层const, param都会具有顶层const</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">intconst int &amp;<br>intconst int &amp;<br>intconst int &amp;<br>int *int *const &amp;<br>const int *const int *const &amp;<br>const int *const int *const &amp;<br>const int *const int *const &amp;<br>const int *const int *const &amp;<br></code></pre></td></tr></table></figure><p>这些例子看起来很绕，但实际上，如果你搞懂了基于值语义和引用语义的型别推导原则，它们都是显而易见的。</p><h3 id="paramtype是万能引用"><code>ParamType</code>是万能引用</h3><p>这里就和上一讲的结尾接轨了，它是C++11引入右值引用后，自然而然演化出的产物。我将C++标准对万能引用的定义翻译成白话：万能引用是一种特殊的引用类型，它所引用的类型需要被推导，且携带了用于型别推导的实参的值分类信息，使得其可以被<code>std::forward</code>完美转发。我们先忽略最后半句，通过函数模板参数来理解一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123; <span class="hljs-comment">// 此时T&amp;&amp;是个万能引用，不论类型如何，我们知道param一定是引用，所以是按引用传递</span><br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);       <span class="hljs-comment">// x是左值，按引用传递就视为左值引用，这和你用x作为实参去调用一个形参为int&amp;的函数没什么区别</span><br>                <span class="hljs-comment">// 因此T被推导成int&amp;, param也被推导成int&amp;（此时发生了引用折叠）</span><br>    <span class="hljs-built_in">f</span>(cx);      <span class="hljs-comment">// cx也是左值，但因为按引用传递，const特性必须保留</span><br>                <span class="hljs-comment">// 因此T被推导成const int&amp;, param也被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(rx);      <span class="hljs-comment">// 同上，是否按引用传递取决于形参有没有reference修饰，这一点跟实参本身是不是reference没关系</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);      <span class="hljs-comment">// &amp;x是右值，只有右值引用才能绑定到右值上，因此param只能被推导成int* &amp;&amp;(int指针型的右值引用)</span><br>                <span class="hljs-comment">// 此时T被推导为int*</span><br>    <span class="hljs-built_in">f</span>(&amp;cx);     <span class="hljs-comment">// 同上</span><br>    <span class="hljs-built_in">f</span>(&amp;rx);     <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(pcx);     <span class="hljs-comment">// pcx是左值，故T被推导为const int*&amp;，param也一样</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// cpcx是左值，故T被推导为const int* const &amp;, param也一样</span><br>                <span class="hljs-comment">// 只不过按引用传递的情况，顶层const必须保留</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">int &amp;int &amp;<br>const int &amp;const int &amp;<br>const int &amp;const int &amp;<br>int *int *&amp;&amp;<br>const int *const int *&amp;&amp;<br>const int *const int *&amp;&amp;<br>const int *&amp;const int *&amp;<br>const int *const &amp;const int *const &amp;<br></code></pre></td></tr></table></figure><p>可以看到万能引用终归是个引用，不管是左值引用还是右值引用，不管有没有CV限定，最终都得是按引用传递，因此规则上和第三种：<code>ParamType</code>为左值引用时相同，只不过它多了一步根据实参来确定引用类型（同时也解决了传统C++中，只能用const左值引用来按引用传递右值以避免拷贝的局限性设计问题）。</p><p>事实上，我们大可以将分类改成两类，即前两种是一类，后两种是一类，分类的口径则是形参的传递方式（值传递还是引用传递）。</p><blockquote><p>不管是标准手册还是广为流传的参考书，它们对型别推导的归纳看上去都非常的复杂（哪怕是用很简单的例子），本质上是因为它们没有从值语义或是引用语义来出发，事实上，只要你拿捏住一件事：推导过程中形参究竟是值传递还是引用传递，那么不管多复杂的case，都有迹可循。</p></blockquote><h2 id="auto与decltype">auto与decltype</h2><p>以函数模板实参推导为例，我们看穿了型别推导背后的机制：值传递和引用传递的差别对待。C++11为了简化历来饱受诟病的又臭又长的语法(诸如<code>std::map&lt;std::string, std::vector&lt;std::string&gt;&gt;::const_iterator</code>)，引入了<code>auto</code>和<code>decltype</code>这两个关键字。这两位爷都是用于型别推导的，只是推导的规则不同，<code>auto</code>这个关键字的使用在现代C++中要分两个场景来看：其一是最常见的为变量做型别推导；其二是为函数返回类型做推导（C++14之后才发糖支持）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 第一种场景：变量型别推导</span><br><span class="hljs-keyword">auto</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; r = a;<br><span class="hljs-keyword">auto</span> *p = &amp;a;<br><br><span class="hljs-comment">// 第二种场景：函数返回类型推导</span><br><span class="hljs-comment">// 在C++11中，只能写作：</span><br><span class="hljs-comment">// auto f() -&gt; decltype(666) &#123; return 666; &#125;</span><br><span class="hljs-comment">// 虽然看起来只是加了个尾部型别推导，但这里的auto只是个占位符（PlaceHolder），与C++14中真正用于推导的auto有本质差别</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">666</span>; &#125;<br></code></pre></td></tr></table></figure><p>无论哪一种场景，<code>auto</code>所应用的推导规则实际上就是模板实参推导的规则。我们知道，前面在做函数模板实参推导时，需要考量的有3个维度：模板参数<code>T</code>，函数形参类型<code>ParamType</code>和传递的实参<code>argument</code>。如何类比呢？实际上我们可以把<code>auto</code>看做模板参数<code>T</code>，而<code>auto</code>结合CV限定和引用、指针修饰而成的最终变量类型则看做<code>ParamType</code>，<code>=</code>右边的表达式看做<code>argument</code>。</p><blockquote><p><code>auto</code>的型别推导与模板实参推导的规则实际上有一点不同：前者会将花括号语法视为<code>std::initializer_list</code>(C++17有所调整，仅限于'='右边)，而后者并不会。<code>std::initializer_list</code>这个东西在C++11引入，主要是为了给花括号初始化语法做补丁，然而C++语法的复杂导致这个东西在很多使用场景下显得格格不入，之后的标准演进中也一直在缝缝补补。</p></blockquote><p>我们直接看例子，按照上面描述的置换规则置换一下，再根据在模板实参推导中已掌握的知识，揣摩一下输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;            <span class="hljs-comment">// 值传递，对应case 1，T被推导为int，x的类型也是int</span><br>    <span class="hljs-keyword">auto</span>&amp; rx = x;           <span class="hljs-comment">// 引用传递，对应case3, T被推导为int, rx的类型是int&amp;</span><br>    <span class="hljs-keyword">auto</span>&amp;&amp; rrx = <span class="hljs-number">666</span>;       <span class="hljs-comment">// 引用传递，对应case4，auto&amp;&amp;是个万能引用</span><br>                            <span class="hljs-comment">// 666是prvalue，故T被推导为int，rrx的类型是int&amp;&amp;</span><br>    <span class="hljs-keyword">auto</span>&amp;&amp; lrx = x;         <span class="hljs-comment">// 引用传递，对应case4，auto&amp;&amp;是个万能引用</span><br>                            <span class="hljs-comment">// x是lvalue，故T被推导为int&amp;，lrx的类型也是int&amp;</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> cx = x;      <span class="hljs-comment">// 值传递，T被推导为int, cx的类型是const int</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; rcx = x;    <span class="hljs-comment">// 引用传递，T被推导为int, rcx的类型是const int&amp;</span><br><br>    <span class="hljs-keyword">auto</span>* px = &amp;x;          <span class="hljs-comment">// 值传递，T被推导为int, px的类型是int*</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>* pcx = &amp;cx;  <span class="hljs-comment">// 值传递，T被推导为int, pcx的类型是const int*    </span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>* <span class="hljs-type">const</span> cpcx = &amp;cx;   <span class="hljs-comment">// 值传递，T被推导为int, cpcx的类型是const int* const</span><br><br>    <span class="hljs-comment">// 这里用到了decltype这个specifier，我们暂且只需要知道decltype(variable)可以原封不动的给出variable的类型</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of x: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(x)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of rx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(rx)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of rrx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(rrx)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of cx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(cx)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of rcx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(rcx)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of px: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(px)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of pcx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(pcx)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of cpcx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(cpcx)&gt;() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of x: int<br>type of rx: int &amp;<br>type of rrx: int &amp;&amp;<br>type of lrx: int &amp;<br>type of cx: const int<br>type of rcx: const int &amp;<br>type of px: int *<br>type of pcx: const int *<br>type of cpcx: const int *const<br></code></pre></td></tr></table></figure><blockquote><p>思考一下：如果<code>auto* pcx2 = &amp;cx;</code>，<code>pcx2</code>是什么类型？<code>auto* const &amp; pcx3 = &amp;cx;</code>呢？如果你可以轻松地推导出来，那么恭喜你，你已经领悟了型别推导的奥义。</p></blockquote><p><code>decltype</code>也有两个与<code>auto</code>类似的使用场景，一种就是像上例那样使用的对变量做'='右边表达式的型别推导，另一种也是用在函数返回值推导中，写作<code>decltype(auto)</code>。</p><p><code>decltype</code>相比<code>auto</code>则没有那么麻烦的推导规则，它只是简单粗暴的告诉我们给定实参(<code>argument</code>)的真实类型（意味着不会忽略CV限定、引用修饰）。<code>argument</code>是一个表达式（也包括实体(entity)的情况），但通过前两节的学习，我们知道表达式的值类型有多种情况，所以还是要分情况讨论下：</p><ul><li>如果<code>argument</code>是没有套上小括号的变量(严格的说法是id-expression，不过为了便于理解我们忽略官方的黑话)或是类成员访问表达式(通俗的理解这也是个变量)，decltype给出其本身的类型。</li><li>否则，对于其他类型<code>T</code>的表达式<ul><li>如果表达式的值分类是xvalue，则推导为<code>T&amp;&amp;</code></li><li>如果表达式的值分类是lvalue，则推导为<code>T&amp;</code></li><li>如果表达式的值分类是prvalue，则推导为<code>T</code></li></ul></li></ul><p>这实际上就是cppreference给出的<code>decltype</code>说明符的解释，初学者可能会对第一条款中提到的小括号包裹感到奇怪，实际上它的本质原因在于entity和expresion的区别，假设有变量<code>int a = 3;</code>，<code>a</code>我们可以说它是一个entity，但是<code>(a)</code>就不再是一个实体，而是一个表达式了，套上小括号意味着表达式需要被计算(或处理)，即使我们对<code>a</code>什么都没做，它也需要处理。因此，对于<code>(a)</code>来说，它是个表达式，要根据第二条款来判定，由于<code>(a)</code>是个lvalue，所以此时型别为<code>int&amp;</code>。</p><blockquote><p>说到这里就不得不提一个现代C++中很有意思的坑：返回值类型支持<code>decltype(auto)</code>推导后，对于函数返回语句如果要返回一个变量，那么写成<code>return a;</code>和<code>return (a);</code>意义完全不同，前者会被推导为<code>a</code>的类型，而后者被推导为<code>a</code>的左值引用类型。而如果没有用到推导，而是老老实实的返回<code>a</code>的类型，那么这两种写法其实都可以，只不过后者做了一次计算，不会引入其他问题。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">double</span> x;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">get_ref</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *p)</span> </span>&#123; <span class="hljs-keyword">return</span> *p; &#125;<br><br><span class="hljs-comment">// 相当于C++11中的auto get_ref_forward1(const int* p) -&gt; decltype(get_ref(p))</span><br><span class="hljs-comment">// 由于get_ref(p)是个表达式返回的是个lvalue，故推导成const int&amp;</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">get_ref_forward1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_ref</span>(p);<br>&#125;<br><br><span class="hljs-comment">// 值传递，返回的一定是个值类型，此时的实参是get_ref(p)，忽略掉顶层CV限定，于是推导为int</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_ref_forward2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_ref</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-keyword">decltype</span>(a.x) y = <span class="hljs-number">1.0</span>;  <span class="hljs-comment">// 对于entity，y推导成其本身的类型double</span><br>    <span class="hljs-keyword">decltype</span>((a.x)) z = y;  <span class="hljs-comment">// 由于小括号的存在导致按表达式来推导，(a.x)是左值故推导成double&amp;</span><br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;             <br>    <span class="hljs-keyword">decltype</span>(i) j = i;      <span class="hljs-comment">// 对于entity，j推导成本身类型int</span><br>    <span class="hljs-keyword">decltype</span>((i)) k = j;    <span class="hljs-comment">// 由于小括号的存在导致按表达式来推导，(i)是左值故推导成int&amp;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i;       <br>    <span class="hljs-keyword">decltype</span>(ci) cj = ci;   <span class="hljs-comment">// 推导成const int，decltype不会像auto那样忽略顶层CV限定</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of y: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(y)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of z: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(z)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of j: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(j)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of k: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(k)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of cj: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(cj)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of return value of get_ref_forward1: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">get_ref_forward1</span>(&amp;ci))&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of return value of get_ref_forward2: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">get_ref_forward2</span>(&amp;ci))&gt;() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of y: double<br>type of z: double &amp;<br>type of j: int<br>type of k: int &amp;<br>type of cj: const int<br>type of return value of get_ref_forward1: const int &amp;<br>type of return value of get_ref_forward2: int<br></code></pre></td></tr></table></figure><blockquote><p>思考一下：如果get_ref_forward2的返回类型写作<code>auto&amp;</code>，又该是什么类型呢？</p></blockquote><h2 id="恼人的数组与函数">恼人的数组与函数</h2><p>凡是总有例外，在C++中，有两种类型天生需要被特殊处理，那就是从C语言继承过来的数组和函数名称。在C语言中，数组和指针常常混用，绝大部分场景都可以互为代替使用，这就导致很多人将数组和指针视为同一种东西的不同写法，虽然这个看法是错误的，但在日常开发中，用这样一种局限性的看法来读写代码确实会使事情简单化。函数名称则简单不少，在C中几乎被视为相应的函数指针类型。C++继承了C的legacy，但随着C++语法规则的不断演进，数组和函数名称逐渐显得格格不入，为此，C++做了很多语法上兼容性处理，在很多语境下，数组会退化(decay)成指向其首元素的指针型，而函数名称会退化(decay)成相应的函数指针型。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> name[] = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-comment">// name的类型是const char[6]</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* p1 = name;          <span class="hljs-comment">// 数组退化，p1指向name的首元素</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* p2 = <span class="hljs-string">&quot;world&quot;</span>;       <span class="hljs-comment">// &quot;world&quot;是一个字符串字面量左值，类型为const char[6]</span><br>                                <span class="hljs-comment">// 数组退化，p2指向&quot;world&quot;首元素</span><br></code></pre></td></tr></table></figure><p>从C++的视角来看，假如没有退化规则，那么对指针的初始化显然是不合法的，但为了兼容C的legacy，不得不做了容忍。另一方面，在C中我们经常写:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-comment">// 这在C中非常常见，但如果是在C++11之后是不合法的，尽管编译器只抛了warning：</span><br>                        <span class="hljs-comment">// ISO C++11 does not allow conversion from string literal to &#x27;char *&#x27; </span><br>                        <span class="hljs-comment">// 字符串字面量是左值（意味着可以被取地址），它有着const特性，底层const不能丢，所以得用const char*</span><br><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;world&quot;</span>;   <span class="hljs-comment">// 这是C语言对字符数组发放的语法糖，str的类型实际上是char[6]</span><br>                        <span class="hljs-comment">// 等价于char str[6] = &#123;&#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;\0&#x27;&#125;</span><br>                        <span class="hljs-comment">// C语言一方面支持定界值省略，另一方面对字符数组做了照顾：花括号初始化语法可以改写为字符串字面量</span><br>                        <span class="hljs-comment">// C++继承了C，所以这在C++中也合法，且语义相同，注意区分和前者的差别</span><br></code></pre></td></tr></table></figure><p>为了说明两种语法的差别，我们编写如下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;world&quot;</span>;<br><br>    cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of p: %p\n&quot;</span>, p);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of \&quot;hello\&quot;: %p\n&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of str: %p\n:&quot;</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of \&quot;world\&quot;: %p\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zsh">hello world<br>address of p: 0x10232bea4<br>address of &quot;hello&quot;: 0x10232bea4<br>address of str: 0x16dad76f8<br>:address of &quot;world&quot;: 0x10232bf03<br></code></pre></td></tr></table></figure><p>显然，<code>p</code>和<code>"hello"</code>的地址是相同的，说明它们是同一个对象。而<code>str</code>则和<code>"world"</code>有所不同，<code>str</code>只是以<code>char</code>为单位逐个拷贝了<code>"world"</code>的数据到自身的存储单元而已，其类型是<code>char[6]</code>。</p><p>再来看看当数组涉及型别推导时，效果如何：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">f</span>(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of T: int *<br>type of param: int *<br>type of T: char *<br>type of param: char *<br></code></pre></td></tr></table></figure><p>由于<code>param</code>值传递，所以推导时数组类型发生了退化，降级成对应的首元素指针型。而如果改为按引用传递，则不会发生decay：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);                          <br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-built_in">move</span>(str));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of T: int (&amp;)[5]<br>type of param: int (&amp;)[5]<br>type of T: char [6]<br>type of param: char (&amp;&amp;)[6]<br></code></pre></td></tr></table></figure><p>可以看到param就是传递进来的参数的原本类型。</p><p>如果说上面的例子根据我们的口诀来看还算中规中矩，那下面这个就有点反人类了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里的定界6不能少，否则param是个非法的数组引用</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T (&amp;param)[<span class="hljs-number">6</span>])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 虽然写作T[]，但因为值传递的关系，还是退化成了T*，定界写不写都无所谓，随便写什么都行</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T param[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);<br>    <span class="hljs-built_in">g</span>(v);<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">f</span>(str);<br>    <span class="hljs-built_in">g</span>(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of T: int<br>type of param: int (&amp;)[6]<br>type of T: int<br>type of param: int *<br>type of T: char<br>type of param: char (&amp;)[6]<br>type of T: char<br>type of param: char *<br></code></pre></td></tr></table></figure><blockquote><p>我特意把v改成了6个成员，思考一下如果这里不改的话会不会有啥问题？</p></blockquote><p>另外，由于数组引用并不是个直截了当的类型，如果我们写成<code>T (&amp;&amp;param)[6]</code>会编译报错，因为此时param不再是一个万能引用。</p><p>你以为这样就结束了？当数组和非类型模板参数相遇时，还有更离谱的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 函数模板也可以重载，但要注意可能会引发的ambiguous调用问题</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T (&amp;param)[<span class="hljs-number">5</span>])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;template f:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T (&amp;param)[N])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;nontype template f:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T param[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;template g:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T param[N])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;nontype template g:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);                   <span class="hljs-comment">// 优先匹配template f，template f比nontype template f更特殊</span><br>    <span class="hljs-built_in">g</span>(v);                   <span class="hljs-comment">// 只能匹配template g，因为值传递会退化成指针</span><br>                            <span class="hljs-comment">// 即使把template g注释掉也无法匹配nontype template g</span><br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;   <br>    <span class="hljs-built_in">f</span>(str);                 <span class="hljs-comment">// 只能匹配nontype template f，因为template f不满足匹配条件无法成为candidate</span><br>    <span class="hljs-built_in">g</span>(str);                 <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs zsh">template f:<br>type of T: int<br>type of param: int (&amp;)[5]<br>template g:<br>type of T: int<br>type of param: int *<br>nontype template f:<br>type of T: char<br>type of param: char (&amp;)[6]<br>template g:<br>type of T: char<br>type of param: char *<br></code></pre></td></tr></table></figure><p>因为decay的关系，nontype templateg实际上无法被用到，如果我们把它改写成传引用呢：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T (&amp;param)[N])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;nontype template g:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时就会遇到编译错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs zsh">test_array3.cpp:37:5: error: call to &#x27;g&#x27; is ambiguous<br>    g(v);<br>    ^<br>test_array3.cpp:21:6: note: candidate function [with T = int]<br>void g(T param[]) &#123;<br>     ^<br>test_array3.cpp:28:6: note: candidate function [with T = int, N = 5]<br>void g(T (&amp;param)[N]) &#123;<br>     ^<br>test_array3.cpp:40:5: error: call to &#x27;g&#x27; is ambiguous<br>    g(str);<br>    ^<br>test_array3.cpp:21:6: note: candidate function [with T = char]<br>void g(T param[]) &#123;<br>     ^<br>test_array3.cpp:28:6: note: candidate function [with T = char, N = 6]<br>void g(T (&amp;param)[N]) &#123;<br>     ^<br>2 errors generated.<br></code></pre></td></tr></table></figure><p>因为两个版本此时都可以完成匹配作为candidate，但二者之间论优先级或者说特殊性并不能分出高下，所以导致了函数模板重载所常见的ambiguous错误。</p><blockquote><p>实际上当涉及到类模板对数组的特化时，情形远远比这里给出的例子要复杂得多，另一方面未定界数组实际上也有特殊的手法来传递推导。考虑到不希望这一部分内容喧宾夺主故不做展开，有兴趣的同学可以看一下《C++Templates》5.4的内容。</p></blockquote><p>函数名称和函数指针的情景和数组很像：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &lt; b ? b : a;<br>&#125;<br><br><span class="hljs-keyword">using</span> func = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>(my_max);              <span class="hljs-comment">// decay，退化成函数指针</span><br>    <span class="hljs-built_in">g</span>(my_max);              <span class="hljs-comment">// 不会decay</span><br>    <span class="hljs-built_in">g</span>(std::<span class="hljs-built_in">move</span>(my_max));   <span class="hljs-comment">// 对函数名称进行move没意义</span><br><br>    func fp = my_max;       <span class="hljs-comment">// fp本身就是函数指针类型</span><br>    <span class="hljs-built_in">f</span>(fp);                  <span class="hljs-comment">// 不需要退化，单纯的值传递</span><br>    <span class="hljs-built_in">g</span>(fp);                  <span class="hljs-comment">// 注意是函数指针的左值引用</span><br>    <span class="hljs-built_in">g</span>(std::<span class="hljs-built_in">move</span>(fp));       <span class="hljs-comment">// 注意是函数指针的右值引用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs zsh">int (*)(int, int)<br>int (*)(int, int)<br>int (int, int)&amp;<br>int (int, int)&amp;<br>int (int, int)&amp;<br>int (int, int)&amp;<br>int (*)(int, int)<br>int (*)(int, int)<br>int (*)(int, int)&amp;<br>int (*)(int, int)&amp;<br>int (*)(int, int)<br>int (*)(int, int)&amp;&amp;<br></code></pre></td></tr></table></figure><p>相信读到这里的你，一定会觉着上面的结果一目了然。</p><h2 id="完美转发">完美转发</h2><p>最后谈谈完美转发。</p><p>除了我们之前详细解读过的<code>std::move</code>，C++11在标准库中还定义了一个非常常用的<code>std::forward</code>，相信对于大部分现代C++初学者来说，<code>std::forward</code>和<code>std::move</code>一度云里雾里。我们先撇开<code>std::forward</code>，来看看如下的一个使用场景：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(T&amp;&amp;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in func1, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>    <span class="hljs-comment">// 我们希望把param原封不动的“渗透”到下一层</span><br>    <span class="hljs-built_in">func2</span>(param);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;in func2, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">666</span>;<br>    <span class="hljs-built_in">func1</span>(a);       <span class="hljs-comment">// a是左值，所以func1中T被推导成int&amp;，param也是int&amp;，此时向下调用func2传递的依然是左值引用</span><br>                    <span class="hljs-comment">// 所以func2中的T和param也都是int&amp;，这是符合预期的 </span><br>    <span class="hljs-built_in">func1</span>(<span class="hljs-number">2333</span>);    <span class="hljs-comment">// 2333是纯右值，func1中T被推导成int，param被推导成int&amp;&amp;，此时向下调用func2传递的是右值引用类型的param</span><br>                    <span class="hljs-comment">// 尽管param的类型是右值引用，但param本身是个左值（具名的变量），这就导致渗透传递时func2中</span><br>                    <span class="hljs-comment">// T和param被推导成int&amp;，这就不符合预期了，我们的引用型在渗透过程中变质了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">in func1, T:int&amp;, param:int&amp;<br>in func2, T:int&amp;, param:int&amp;<br>in func1, T:int, param:int&amp;&amp;<br>in func2, T:int&amp;, param:int&amp;<br></code></pre></td></tr></table></figure><p>我们在<code>func1</code>中又调用了<code>func2</code>，且原封不动的将参数<code>param</code>传递了下去，希望能够把左值引用或是右值引用这一特性渗透到下一层，然而事与愿违，由于在C++语法中，即使类型为右值引用的具名变量其本身依然是个左值，这就导致了不可传递性。</p><p>可能有的小伙伴说了，我们不是学过<code>std::move</code>吗，只需要调用<code>func2</code>时对<code>param</code>再<code>move</code>一下不就行了吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in func1, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>    <span class="hljs-comment">// 强制传递右值引用</span><br>    <span class="hljs-built_in">func2</span>(<span class="hljs-built_in">move</span>(param));<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，如果按照这个写法，上述例子中后者的运行结果符合预期，可是前者却又出了问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">in func1, T:int&amp;, param:int&amp;<br>in func2, T:int, param:int&amp;&amp;<br>in func1, T:int, param:int&amp;&amp;<br>in func2, T:int, param:int&amp;&amp;<br></code></pre></td></tr></table></figure><p>为什么呢？因为你把一个原本是左值引用的param强制转成了右值引用向下传递！可以说是按下葫芦浮起瓢。可是这种需求在我们日常开发中很常见啊，就真的没办法兼容吗？不，成年人的世界从来都是：我全都要~</p><p>我们采用标准库中的<code>std::forward</code>试一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in func1, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>    <span class="hljs-built_in">func2</span>(forward&lt;T&gt;(param));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">in func1, T:int&amp;, param:int&amp;<br>in func2, T:int&amp;, param:int&amp;<br>in func1, T:int, param:int&amp;&amp;<br>in func2, T:int, param:int&amp;&amp;<br></code></pre></td></tr></table></figure><p>可以发现确实达成了我们想要的结果，而这就是C++中所谓的完美转发(PerfectForwarding)。那么问题来了，<code>std::forward</code>只不过是标准库中的函数，既不是什么语法糖，也不是什么黑科技，它是怎么做到完美转发的呢？</p><p>实际上<code>std::forward</code>并没有做什么神奇的操作，它背后所依赖的原理就在于：我们需要区分左值引用和右值引用，而这一信息其实通过param是可以知晓的，param要么是一个左值引用、要么是一个右值引用，而对于这两种情况，我们需要一种if-else的逻辑来分别处理，对于前者来说，我们直接传递下去即可；而对于后者来说，渗透传递时我们要做一次<code>std::move</code>来把它强制转成右值引用。</p><p>另一方面，<code>std::forward</code>是一个函数模板，我们传入了<code>param</code>作为参数，而<code>param</code>携带了引用类型的信息，所以只需要编写重载函数，分别处理左值引用和右值引用的不同<code>param</code>即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp; param)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp;&amp; param)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>remove_reference_t</code>是标准库中的一种typetrait，可以洗掉类型<code>T</code>的引用修饰，这里是为了先确保拿到一个纯净类型，然后再分别施加左值引用或者是右值引用的修饰，注意，对于后者而言<code>remove_reference_t&lt;T&gt;&amp;&amp;</code>不是万能引用，而是一个彻彻底底的右值引用。于是，当我们向<code>std::forward</code>传递一个左值时，会匹配到第一个函数模板，此时<code>T</code>是左值引用，因此返回的类型根据引用折叠规则已然是一个左值引用；而当传递右值时，则会匹配到第二个函数模板，此时<code>T</code>不是引用类型，但返回的类型由于<code>static_cast&lt;T&amp;&amp;&gt;</code>将<code>T</code>强制转成了其右值引用类型。</p><p>实际上上面的代码与各大编译器厂商实现的标准库<code>std::forward</code>如出一辙，只是标准库中的代码有更多的诸如constexpr、noexcept等杂七杂八的修饰。</p><h2 id="参考文献">参考文献</h2><ul><li><ahref="https://en.cppreference.com/w/cpp/language/template_argument_deduction">Templateargument deduction</a></li><li><ahref="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/">EffectiveModern C++</a></li><li><ahref="https://en.cppreference.com/w/cpp/language/reference">Referencedeclaration</a></li><li><ahref="https://en.cppreference.com/w/cpp/language/auto">Placeholder typespecifiers</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>cpp-templates</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++模板从入门到劝退(1)——右值引用与移动语义</title>
    <link href="/2022/06/04/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(1)%E2%80%94%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
    <url>/2022/06/04/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(1)%E2%80%94%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述严谨性，按照笔者的归纳方式穿针引线，为痴迷于黑魔法而又始终不得其解的同学打通任督二脉。</p><p>本篇是走进模板世界的第二道前菜，只有搞懂了这些C++中的基本概念，才能掌握模板世界的黑魔法。</p><span id="more"></span><h1 id="右值引用与移动语义">右值引用与移动语义</h1><h2 id="右值引用初探">右值引用初探</h2><p>上一讲我们对表达式的值分类进行了展开，围绕值语义和引用语义的探讨对现代C++的左值和右值有了深入的理解。但搞懂值分类的区分仅是第一步，我们尚未揭晓移动语义的帷幕。</p><p>在传统C++中，引用非常纯粹，比如代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> &amp;b = a; <span class="hljs-comment">// 这里的&amp;不是取址符，而是左值引用的声明符</span><br></code></pre></td></tr></table></figure><p>其中<code>b</code>就是<code>a</code>的引用，开发者简单地将<code>b</code>视为变量<code>a</code>的别名，通过<code>b</code>和<code>a</code>对变量值进行读写本质上并没有什么不同。引用语法相比从C继承的指针来说更加简洁，也更容易理解。而从现代C++的视角来看，这里的<code>b</code>是一个左值引用（显然，它绑定的<code>a</code>是个左值），这里对左值的强调是为了区分C++11所引入的另一种引用类型：右值引用。那么右值引用如何声明呢？既然是全新的语法，那肯定得量身定制：语法规定用<code>&amp;&amp;</code>作为右值引用的声明符。因此，形如<code>S&amp; D;</code>是将<code>D</code>声明为<code>S</code>所确定类型的左值引用；形如<code>S&amp;&amp; D;</code>则是将<code>D</code>声明为<code>S</code>所确定类型的右值引用。顾名思义，左值引用绑定到左值，右值引用绑定到右值（也就是xvalue和prvalue）。</p><blockquote><p>你可能还见到过别人这样写:<code>int&amp; b = a;</code>，声明符的空格位置和上述写法相反，而实际上这里怎么书写都是正确的（<code>&amp;</code>两边都有空格也无所谓），因为<code>&amp;</code>是声明符而非取地址符(addressof)，我个人习惯于这种写法，它有一种把<code>&amp;</code>和<code>int</code>联系起来的感觉。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span>&amp; b = a;         <span class="hljs-comment">// 正确：b是绑定到左值a的左值引用</span><br><span class="hljs-type">int</span>&amp; c = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 错误：字面量1是prvalue，左值引用不能绑定到右值</span><br><span class="hljs-type">int</span>&amp;&amp; d = a + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 正确：算术运算符表达式是prvalue</span><br><br>std::string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>std::strin&amp;&amp; r1 = s1;                                   <span class="hljs-comment">// 错误：右值引用不能绑定到左值</span><br>std::string&amp;&amp; r2 = s1 + s1;                             <span class="hljs-comment">// 正确：左右操作数为std::string的操作符重载(operator+)返回的是一个值类型，值分类上是prvalue</span><br>std::string&amp;&amp; r3 = <span class="hljs-built_in">static_cast</span>&lt;std::string&amp;&amp;&gt;(s1);      <span class="hljs-comment">// 正确：到右值引用类型转换的表达式值类型是xvalue</span><br></code></pre></td></tr></table></figure><p>上面是用基础内建类型<code>int</code>和标准库的<code>std::string</code>类类型作为示例演示的说明。</p><p>关于引用，还有些开发者必须知道的细节：</p><ul><li>引用必须被初始化为指代一个有效的对象或函数，这一点对左值引用一如既往，对右值引用也一视同仁。</li><li>尽管void类型存在指针，但不存在引用，实际上<code>void*</code>语义上也并非<code>void</code>类型的指针，而是某种未知/不确定类型的指针。</li><li>不存在引用类型的引用（禁止套娃），也不存在引用类型的指针或是引用的数组（但是存在数组的引用(<code>int(&amp;a)[3]</code>)），本质原因在于引用并非对象。</li><li>引用类型本身不能有CV(const/volatile)限定（顶层），但被引用的类型可以有CV限定(底层)，本质原因同样是在于引用并非对象。</li></ul><h2 id="引用与const限定">引用与const限定</h2><p>上述的最后一个条例提到了CV限定，它是指C++运行时对对象的一种<code>const</code>或<code>volatile</code>限定，后者对于大部分开发场景来说十分罕见(这货跟其他语言比如Java的<code>volatile</code>有着甚许微妙差别，而<code>volatile</code>在Java日常编程中十分常见)，而前者则常伴于身。对于引用来说，<code>const</code>限定无疑让语法的复杂度提升了一个维度，我们先用<code>int</code>基础内建类型来做示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b = a;           <span class="hljs-comment">// 正确：const左值引用可以绑定到非const变量</span><br>b = <span class="hljs-number">2</span>;                      <span class="hljs-comment">// 错误：左值引用b所绑定的变量有const限定，RT不可修改</span><br><span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(b) = <span class="hljs-number">2</span>;    <span class="hljs-comment">// 正确：const引用的RT限定可以通过const_cast来擦除，这里确实修改了变量a的值为2；</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">test2.cpp:9:7: error: cannot assign to variable &#x27;b&#x27; with const-qualified type &#x27;const int &amp;&#x27;</span><br><span class="hljs-comment">    b = 2;</span><br><span class="hljs-comment">    ~ ^</span><br><span class="hljs-comment">test2.cpp:8:16: note: variable &#x27;b&#x27; declared const here</span><br><span class="hljs-comment">    const int&amp; b = a;</span><br><span class="hljs-comment">    ~~~~~~~~~~~^~~~~</span><br><span class="hljs-comment">1 error generated.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;ra = a;     <span class="hljs-comment">// 错误：常量右值引用亦不能绑定到左值</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">test2.cpp:11:17: error: rvalue reference to type &#x27;const int&#x27; cannot bind to lvalue of type &#x27;int&#x27;</span><br><span class="hljs-comment">    const int&amp;&amp; ra = a;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;rb = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 正确：常量右值引用当然可以绑定到prvalue，只不过毫无卵用</span><br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span>&amp; d = c;         <span class="hljs-comment">// 错误：左值引用类型与所绑定的变量类型不一致</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">test2.cpp:11:11: error: binding reference of type &#x27;int&#x27; to value of type &#x27;const int&#x27; drops &#x27;const&#x27; qualifier</span><br><span class="hljs-comment">    int&amp;&amp; d = c;</span><br><span class="hljs-comment">          ^   ~</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; e = c;  <span class="hljs-comment">// 正确</span><br><span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(e) = <span class="hljs-number">2</span>;    <span class="hljs-comment">//正确：虽然语法上可以通过const_cast擦除来间接访问修改const对象，但产生的结果是undefined behaviour，不要依赖UB行为</span><br><span class="hljs-type">int</span>&amp;&amp; f = c;        <span class="hljs-comment">// 错误：右值引用类型与所绑定的变量类型不一致（第一关都没过去）</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">test2.cpp:17:11: error: binding reference of type &#x27;int&#x27; to value of type &#x27;const int&#x27; drops &#x27;const&#x27; qualifier</span><br><span class="hljs-comment">    int &amp;&amp;f = c;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-comment">// 一个出人意料的case</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; g = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 正确：虽然字面量1是prvalue，但是const左值引用可以绑定到右值（可以理解成字面量值先隐式转换成了一个匿名的const int，然后将const引用与其绑定）</span><br></code></pre></td></tr></table></figure><p>根据上述代码，我们简单归纳一下：</p><ul><li>引用绑定过程中const限定不能drop，但是可以add。换句话说，非const引用不能绑定const值，但const引用可以绑定到非const值。</li><li>对于绑定到非const值的const引用，可以通过<code>const_cast</code>来做临时的remove以开绿灯。</li><li>const左值引用之所以可以绑定到右值，是为了语言的向前兼容性，传统C++无所谓左值引用，可以理解成是const引用到非左值的绑定。</li></ul><blockquote><p>关于const左值引用可以绑定到右值的历史原因与标准化演进，可以参考《C++设计与演化》一书。</p></blockquote><table><thead><tr class="header"><th>引用类型</th><th>非const左值</th><th>const左值</th><th>非const右值</th><th>const右值</th></tr></thead><tbody><tr class="odd"><td>非const左值引用</td><td>是</td><td>否</td><td>否</td><td>否</td></tr><tr class="even"><td>const左值引用</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr class="odd"><td>非const右值引用</td><td>否</td><td>否</td><td>是</td><td>否</td></tr><tr class="even"><td>const右值引用</td><td>否</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h2 id="移动构造和移动赋值运算符">移动构造和移动赋值运算符</h2><p>连同上一讲，我们耗费了大量的篇幅来对左值、右值、引用与const做了阐释，可是不论是左值引用还是右值引用，引用终归只是个引用，我们知道引用本身不会产生拷贝，但是这和移动语义有什么关系呢？截止到目前，我们利用右值引用并不能做将资源A移动给资源B的操作。</p><p>到这里，就需要正式介绍C++11所引入的移动语义了，与传统的类成员函数：拷贝构造器(copyctor)和拷贝赋值运算符(copyassignment)对应，C++11为支持移动语义，引入了额外的两个类成员函数：移动构造器(movector)和移动赋值运算符(moveassignment)。正如拷贝构造器和拷贝赋值运算符的“孪生性”，移动构造器和移动赋值运算符也是如此，相比前一对的<code>const Object&amp;</code>参数，后一对的参数换成了右值引用<code>Object&amp;&amp;</code>。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Object</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;default ctor&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">const</span> Object&amp; rhs) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy ctor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Object</span>(Object &amp;&amp;rhs) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move ctor&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    Object&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Object&amp; rhs) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy assignment&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    Object&amp; <span class="hljs-keyword">operator</span>=(Object&amp;&amp; rhs) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move assignment&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Object</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Object a;       <span class="hljs-comment">// 调用默认构造器</span><br>    Object b = a;   <span class="hljs-comment">// 调用拷贝构造器</span><br><br>    Object c;       <span class="hljs-comment">// 调用默认构造器</span><br>    c = a;          <span class="hljs-comment">// 调用拷贝赋值运算符</span><br><br>    Object d = <span class="hljs-built_in">static_cast</span>&lt;Object&amp;&amp;&gt;(c);    <span class="hljs-comment">// 调用移动构造器</span><br>    Object e;                               <span class="hljs-comment">// 调用默认构造器</span><br>    e = <span class="hljs-built_in">static_cast</span>&lt;Object&amp;&amp;&gt;(c);           <span class="hljs-comment">// 调用移动赋值运算符</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs zsh">default ctor<br>copy ctor<br>default ctor<br>copy assignment<br>move ctor<br>default ctor<br>move assignment<br></code></pre></td></tr></table></figure><p>实际上看到这里你就会发现，所谓的移动构造器，不过就是一种参数为对象右值引用类型的构造器罢了，C++语法上的扩充仅仅是右值语义而已，移动构造和移动赋值运算符不过是一种优雅的称谓。</p><blockquote><p>你可能听说过默认构造器+BigFive（传统C++的BigThree(拷贝构造、拷贝赋值运算符、析构)再填上这两个移动兄弟，正好凑成五排(bushi)），当然这不是标准化的称谓（应该是侯捷老师带来的叫法），但编译器确实会按照标准所规定的那样，对默认构造和BigFive做一些特殊照顾。</p></blockquote><blockquote><p>思考：如果上述代码不定义移动构造器和移动赋值，那么<code>Object d = static_cast&lt;Object&amp;&amp;&gt;(c);</code>和<code>e = static_cast&lt;Object&amp;&amp;&gt;(c);</code>会不会编译报错呢？如果不会又该调用谁呢？</p></blockquote><p>然而很快你就会发现另一个问题，对<code>Object</code>来说，移动构造器和拷贝构造器除了打印信息不同以外，没有任何区别。回想一下传统C++中曾学过的拷贝构造器，如果是编译器默认生成的版本，拷贝构造器所做的事非常简单：</p><ul><li>对于基础内建类型、POD(Plain OfData)和指针类型，它以bit为单位将对象A中相应数据成员复制到对象B对应数据成员的存储地址。</li><li>对于复杂类型，则调用其拷贝构造函数，如有嵌套则逐层递归。</li></ul><p>基于第一条，如果数据成员里有指针类型，我们就<strong>必须</strong>自己重写BigFive，因为尽管C++基于值语义的默认拷贝动作是深拷贝，但是对于指针型变量来说，深拷贝拷贝的是地址值，而不是该地址所指向的对象（所以在C++中，这种情况被称作浅拷贝，此浅拷贝和其他引用语义编程语言中的浅拷贝有着微妙差别）。</p><blockquote><p>这里的“必须“并不是语法要求，而是基于编程常理，或者换句话说，如果不这样做，就很可能会引入诸如doublefree, uaf, memory leak等问题。这也是C++上手门槛高的一个原因。</p></blockquote><p>而另一方面，<code>Object</code>是个空类，我们原本打算通过<code>Object d = static_cast&lt;Object&amp;&amp;&gt;(c);</code>调用移动构造器把<code>c</code>“搬空”，资源归属转移到<code>d</code>而不是复制给<code>d</code>，可在实际实现移动构造器的时候才发现<code>Object</code>空空如也。没错，这个例子中<code>Object</code>是个空类（当然这种情况其实例化对象也是有size的），对于这种类本不用定义它的BigFive（编译器会默认生成），因为它并没有需要区分拷贝或者移动的资源。</p><p>我们改进一下，引入三个数据成员，分别用具有代表性的基础类型<code>int</code>，标准库的复杂类类型<code>std::string</code>和指针类型<code>char*</code>，请一定仔细阅读代码注释：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// custom ctor</span><br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">const</span> string&amp; name, <span class="hljs-type">int</span> size) : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">size_</span>(std::<span class="hljs-built_in">max</span>(size, <span class="hljs-number">16</span>)), <span class="hljs-built_in">data_ptr_</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size_]) &#123;&#125;<br><br>    <span class="hljs-comment">// copy ctor</span><br>    <span class="hljs-comment">// 对于拷贝构造器来说，我们需要对name_调用std::string的拷贝构造器来做一次copy</span><br>    <span class="hljs-comment">// 而基础内建类型没有拷贝构造器，它只能进行bit copy，这也是自动生成的拷贝构造器的动作</span><br>    <span class="hljs-comment">// 自动生成的copy ctor对data_ptr_做的也是bit copy，但显然我们希望对其做深拷贝，因此要自己写逻辑</span><br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">const</span> Object&amp; rhs) : <span class="hljs-built_in">name_</span>(rhs.name_), <span class="hljs-built_in">size_</span>(rhs.size_), <span class="hljs-built_in">data_ptr_</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[rhs.size_]) &#123;<br>        std::<span class="hljs-built_in">copy</span>(rhs.data_ptr_, rhs.data_ptr_ + rhs.size_, data_ptr_);<br>    &#125;<br><br>    <span class="hljs-comment">// move ctor</span><br>    <span class="hljs-comment">// 对于移动构造器来说，我们只需要对name_调用std::string的移动构造器来做move而非copy</span><br>    <span class="hljs-comment">// 基础内建类型没有移动构造器，它只能进行bit copy，这也是自动生成的移动构造器的动作</span><br>    <span class="hljs-comment">// 自动生成的move ctor对于data_ptr_做的也是bit copy，但显然我们不仅希望做浅拷贝，还希望传进来的右值引用所refer to的值可以被转移释放（偷走）</span><br>    <span class="hljs-built_in">Object</span>(Object &amp;&amp;rhs) : <span class="hljs-built_in">name_</span>(std::<span class="hljs-built_in">move</span>(rhs.name_)), <span class="hljs-built_in">size_</span>(rhs.size_), <span class="hljs-built_in">data_ptr_</span>(rhs.data_ptr_) &#123;<br>        rhs.data_ptr_ = <span class="hljs-literal">nullptr</span>;<br>        rhs.size_ = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// copy assignment</span><br>    <span class="hljs-comment">// 拷贝赋值运算符是copy ctor的孪生，用于适配非初始化赋值情景的赋值值语义</span><br>    <span class="hljs-comment">// 参数类型为const左值引用，意味着可以绑定到所有const/非const左值或右值，因此右操作数是啥都接得住</span><br>    Object&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Object&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            <span class="hljs-type">char</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[rhs.size_];<br>            std::<span class="hljs-built_in">copy</span>(rhs.data_ptr_, rhs.data_ptr_ + rhs.size_, ptr);<br>            <span class="hljs-keyword">if</span> (data_ptr_ != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">delete</span>[] data_ptr_;<br>            &#125;<br>            data_ptr_ = ptr;<br>            size_ = rhs.size_;<br>            name_ = rhs.name_;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// move assignment</span><br>    <span class="hljs-comment">// 移动赋值运算符是move ctor的孪生，用于适配非初始化赋值情景的赋值值语义</span><br>    <span class="hljs-comment">// 参数类型为右值引用，意味着仅可以绑定到非const右值引用，同时对于传递非const右值引用时</span><br>    <span class="hljs-comment">// 根据函数重载的优先级会优先匹配，换句话说，如果没有该定义，那就只能退一步去调用copy assignment</span><br>    Object&amp; <span class="hljs-keyword">operator</span>=(Object&amp;&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            <span class="hljs-keyword">if</span> (data_ptr_ != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">delete</span>[] data_ptr_;<br>            &#125;<br>            data_ptr_ = rhs.data_ptr_;<br>            size_ = rhs.size_;<br><br>            name_ = std::<span class="hljs-built_in">move</span>(rhs.name_);<br>            rhs.data_ptr_ = <span class="hljs-literal">nullptr</span>;<br>            rhs.size_ = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// dtor</span><br>    <span class="hljs-comment">// 对于拥有raw pointer数据成员的类来说，析构都是少不了的</span><br>    ~<span class="hljs-built_in">Object</span>() &#123; <span class="hljs-keyword">if</span>(data_ptr_ != <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">delete</span>[] data_ptr_; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DebugPrint</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; size_ &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(data_ptr_) &lt;&lt; std::endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    <span class="hljs-type">int</span> size_;<br>    <span class="hljs-type">char</span>* data_ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Object <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">32</span>)</span></span>;<br>    <span class="hljs-function">Object <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">64</span>)</span></span>;<br><br>    Object c = a;<br>    Object d = std::<span class="hljs-built_in">move</span>(b);    <span class="hljs-comment">// std::move见下文</span><br><br>    a.<span class="hljs-built_in">DebugPrint</span>();     <br>    b.<span class="hljs-built_in">DebugPrint</span>();    <br>    c.<span class="hljs-built_in">DebugPrint</span>();<br>    d.<span class="hljs-built_in">DebugPrint</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">a320x60000180d120<br>00x0<br>a320x60000180d140<br>b640x600000d0c1c0<br></code></pre></td></tr></table></figure><p>在解释运行结果之前，我们先来说明一个C++11标准库所引入的一个非常常见的函数模板：<code>std::move</code>，该函数的名称如果是从C++的语法角度来看非常的具有误导性，<code>std::move</code>本身并不能做”移动“或者说“资源归属转移”操作，它仅仅是返回一个调用参数的右值引用而已，在我们的代码中，它曾两次出现：</p><ul><li><code>Object d = std::move(b);</code></li><li><code>Object(Object &amp;&amp;rhs) : name_(std::move(rhs.name_)), size_(rhs.size_), data_ptr_(rhs.data_ptr_)&#123;...&#125;</code></li></ul><p>由于<code>std::move</code>函数模板本身比较复杂（个锤子），这里暂且按下不表，只需要了解这两行可以等价替换成：</p><ul><li><code>Object d = static_cast&lt;Object&amp;&amp;&gt;(b);</code></li><li><code>Object(Object &amp;&amp;rhs) : name_(static_cast&lt;std::string&amp;&amp;&gt;(rhs.name_)), size_(rhs.size_), data_ptr_(rhs.data_ptr_)&#123;...&#125;</code></li></ul><p>再来看看运行结果，<code>a</code>的打印结果直截了当，三个成员的值(<code>data_ptr_</code>的值就是地址，只不过通过<code>cout</code>打印需要做一点小小的trick)符合预期，尽管我们曾进行了<code>Object c = a;</code>的操作，但是由于值语义，这里调用的是<code>Object</code>的拷贝构造器，拷贝构造器并没有修改<code>a</code>的数据成员（事实上const左值引用也修改不了（不考虑const_cast绿灯大法））</p><p>而<code>b</code>的打印结果就不那么直观了，看上去<code>name_</code>变成了空字符串，<code>size_</code>也变成了<code>0</code>，<code>data_ptr_</code>更是变成了空指针。这是为什么呢，我们不是明明调用customctor构造了一个“有血有肉”的<code>b</code>对象实例吗，为何它的数据看起来就像是被搬空了一样呢？没错，它的数据正是被搬空了，答案就在于<code>Object d = std::move(b);</code>这一行代码，这里由于参数类型是<code>Object&amp;&amp;</code>，故优先匹配上了移动构造器而非拷贝构造器，而移动构造器中，我们的所作所为正是将参数的数据成员搬空！<strong>换言之，<code>std::move</code>就像是一个标记器，它将一个左值标记成了将亡值(还记得上一讲的表达式值分类吗？返回类型为右值引用的类型转换表达式是一个xvalue)，而后根据值语义和重载函数参数匹配规则，触发了移动构造器(或移动赋值运算符)的调用，而真正做资源归属转移的正是移动构造器(或移动赋值运算符)，这也就是上文一再强调，<code>std::move</code>本身没有做移动操作，真凶另有其人，<code>std::move</code>只能算作一个帮凶，没有移动构造器(或移动赋值运算符)，它什么也做不成。</strong></p><p>接下来，<code>c</code>是复制的<code>a</code>，由于我们的拷贝构造器中对<code>data_ptr_</code>做了深拷贝，故其打印结果与<code>a</code>并不相同。而<code>d</code>是移动的<code>b</code>，打印出的结果实际上就是<code>b</code>未被搬空前的成员值。</p><p>总结一下，这里用了三种典型的数据类型来对比拷贝和移动的差别：</p><ul><li>对于基础内建类型，无所谓拷贝还是移动，通通copy bit by bit</li><li>对于复杂的类类型嵌套，递归调用它本身的拷贝或移动构造器(or赋值运算符)</li><li>对于指针类型，默认行为是copy bit bybit，但我们往往需要自己重写BigFive来谨慎处理</li></ul><p>看到这里，一些同学一定会有这样的问题：说好的移动语义，怎么看上去还是东拼西凑呢？语法上为什么不对基础类型也来一个移动语义呢？比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> b = std::<span class="hljs-built_in">move</span>(a);<br><br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; b &lt;&lt; endl;<br>cout &lt;&lt; &amp;a &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;<br><span class="hljs-comment">// 输出结果:</span><br><span class="hljs-comment">// 3  3</span><br><span class="hljs-comment">// 0x16d11b7180x16d11b714</span><br><span class="hljs-comment">// a并没能被搬空，甚至继续使用也没有问题，a和b的地址也各不相同</span><br></code></pre></td></tr></table></figure><p>还记得移动语义的初衷吗？我们想要解决的是大对象冗余的拷贝，像是基础内建类型这种size非常小的数据，比如64bit机寄存器就可以一次性装载8B数据了，copy的成本过于低廉，真要支持个移动说不定反而效率更低(其他引用语义的语言如Java又何尝不是如此)。</p><blockquote><p>基础类型的raw数组也一样是copy bit by bit,但这个成本可能会很高昂，这也是modern C++不推荐用raw数组的原因之一。</p></blockquote><p>而另一方面，对于复杂的类类型比如<code>std::string</code>，它本身也是基础类型、指针和其他复杂类型堆砌而成，因此，它内部的移动构造或是移动赋值运算符的实现其实和我们这里对<code>size_</code>和<code>data_ptr_</code>的处理大同小异。</p><h2 id="移动语义的本质">移动语义的本质</h2><p>在了解了语言层面的移动语义实现机制后，我们需要再从复杂的语法规则中跳出来，高屋建瓴的思考移动语义的适用场景。一言以蔽之：<strong>移动语义适用于那些当某种资源已确定不再被需要的场景，此时仅需要通过移动语义做资源归属转移而非复制。</strong>C++为支撑移动语义所提供的语言机制，从值分类到右值引用再到移动构造/赋值运算符帮助我们完成了这一项工作，仅此而已。</p><p>上文中的例子是个"can be cast toxvalue"的场景，其中<code>b</code>不再被需要，通过<code>std::move</code>我们拿到其xvalue传递给了<code>d</code>的移动构造器，进而窃取资源。实际使用中，往往还有另一种场景，就是传入移动构造器的参数不是xvalue，而是一个prvalue，这常见于将那些返回类型为非引用类型的函数调用结果作为构造器参数的情景（虽然以前也有(N)RVO遮了羞）。</p><p>于是，对于移动构造器来说，我们在将参数的资源窃为己有后，一般会将其重置为默认态或者零值态（标准没有硬性规定要如何善后，但是规定了接下来对它的操作皆是UB行为（由编译器具体实现机制来买单）），正如我们在上例中对<code>size_</code>清零，对<code>data_ptr_</code>置空的操作，而<code>std::string</code>的移动构造器则是将字符串重置成空串作为善后处理手段。而移动赋值运算符则麻烦一点，因为被赋值的对象可能有历史的数据，尤其是对于指针型就要及时释放，避免memoryleak。</p><p>此外，移动构造器和移动赋值运算符只是两种比较特别的成员函数，并不是说移动只能在这两种函数内处理，比如，我们定义这样一个构造器：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>&#123;<br><span class="hljs-keyword">public</span>：<br>    <span class="hljs-built_in">Object</span>(std::string&amp;&amp; name) : <span class="hljs-built_in">name_</span>(std::<span class="hljs-built_in">move</span>(name)), <span class="hljs-built_in">size_</span>(<span class="hljs-number">16</span>), <span class="hljs-built_in">data_ptr_</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">16</span>]) &#123;&#125;<br>    。。。<br>&#125;;<br></code></pre></td></tr></table></figure>参数也可以是一个右值引用，此时我们可以通过<code>std::string</code>的移动构造器来将参数的资源偷走，而如果不进行窃取的话，比如改成：<code>name_(name)</code>（就会调用<code>std::string</code>的拷贝构造，因为<code>name</code>本身是左值）。</p><h2 id="stdmove">std::move</h2><p>上文也提到<code>std::move</code>是个函数模板，它的标准定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp;&amp;&gt;(<span class="hljs-type">__t</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>想要理解<code>std::move</code>，需要前置掌握这两个知识点：</p><ol type="1"><li><code>std::remove_reference_t&lt;T&gt;</code>是个typetrait，它会cut掉类型<code>T</code>的引用修饰符，返回裁剪后的类型，实际上是<code>typename std::remove_reference&lt;T&gt;::type</code>的别名模板，由C++14标准引入。</li><li>函数参数类型<code>T&amp;&amp;</code>在此并非右值引用，这里它搭配模板参数一起出现（本质上是<code>T</code>需要被推导时），是一个万能引用(UniversalReference)，它的真实类型遵循引用折叠规则。<ol type="1"><li>左值引用-左值引用<code>T&amp; &amp;</code>：左值引用<code>T&amp;</code></li><li>左值引用-右值引用<code>T&amp; &amp;&amp;</code>：左值引用<code>T&amp;</code></li><li>右值引用-左值引用<code>T&amp;&amp; &amp;</code>：左值引用<code>T&amp;</code></li><li>右值引用-右值引用<code>T&amp;&amp; &amp;&amp;</code>：右值引用<code>T&amp;&amp;</code></li></ol></li></ol><blockquote><p>Scott的《Effective Modern C++》的称其为万能引用（UniversalReference），这并不是标准的称呼，C++标准出台后称其为转发引用(ForwardingReference)，这个名称历来被诟病见名不知义，远不如Scott给出的称呼（当然它能当选也说明有忠实的拥趸，必有可取之处），故坊间皆以“万能引用”的说法传世，我们也弃用这个标准的说法，使用“万能引用”。</p></blockquote><blockquote><p>所有的引用折叠最终都代表一个引用，要么是左值引用，要么是右值引用。如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</p></blockquote><p>因此，对于<code>std::move</code>来说：</p><ul><li>如果传入的是左值，则参数类型被推导成左值引用，通过<code>static_cast</code>类型转换成右值引用返回。</li><li>如果传入的是右值，则参数类型被推导成右值引用，也通过<code>static_cast</code>类型转换成右值引用返回。</li></ul><p>至此，我们完成了右值引用和移动语义的学习，下一讲我们深入了解引用折叠、万能引用和完美转发机制。</p><h2 id="参考文献">参考文献</h2><ul><li><ahref="https://docs.microsoft.com/en-us/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170">Lvaluesand Rvalues</a></li><li><ahref="https://en.cppreference.com/w/cpp/language/value_category">Valuecategories</a></li><li><ahref="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/">EffectiveModern C++</a></li><li><ahref="https://stackoverflow.com/questions/39552272/is-there-a-difference-between-universal-references-and-forwarding-references">Isthere a difference between universal references and forwardingreferences?</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>cpp-templates</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++模板从入门到劝退(0)——左值与右值</title>
    <link href="/2022/05/27/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(0)%E2%80%94%E2%80%94%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/"/>
    <url>/2022/05/27/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(0)%E2%80%94%E2%80%94%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述严谨性，按照笔者的归纳方式穿针引线，为痴迷于黑魔法而又始终不得其解的同学打通任督二脉。</p><p>本篇是走进模板世界的第一道前菜，只有搞懂了这些C++中的基本概念，才能掌握模板世界的黑魔法。</p><span id="more"></span><h1 id="左值与右值">左值与右值</h1><p>随着C++11新标准的制定，C++正式进入现代(modern)时代，相对于传统(traditional/old)C++、新标准的推行可谓是革命性的船新版本。而这一变革带来了两种情况：</p><ol type="1"><li>C++神教的新教徒在阅读传统C++代码时会满脸黑人问号：这是个什么方言？</li><li>尚未解锁现代C++的传统C++程序员在接触新标准时会惊呼：还有这种操作？快住手，这根本不是C++！</li></ol><blockquote><p>在《C++ Primer5th》问世时，我曾自信满满淘得一本，自诩有着刷了4遍4th的经验，打开了新世界的大门，然后直接自闭。</p></blockquote><p>当大家聊起C++11时，最先想到的可能就是移动语义，没错，这个移动语义可谓是万恶之源，它一方面解决了C++长久以来的顽疾，另一方面也让原本就复杂的语法规则变本加厉。</p><h2 id="值语义">值语义</h2><p>传统C++的顽疾在于基于值语义(ValueSemantics)的冗余拷贝和赋值。所谓值语义，这是很多OO(ObjectOriented)语言中没有的概念，诸如Java,C#等大多数语言，几乎所有的变量都是引用语义(ReferenceSemantics)（它们天生有着GC(GarbageCollector)来管理所有对象的生命周期，开发者无需操心）。而C++并没有做如此现代化的封装，对外呈现的语言生态相当裸露，值语义是指目标对象由源对象拷贝生成，生成的目标对象与源对象毫无关系彼此独立（一些引用语义的编程语言可能只有基础类型是值语义，但同样的它们为了消除违和感对值语义只字不提，而是强调基础类型的特殊性）。对于不了解值语义的C++初学者来说，会想当然的把C++中的引用看成和其他引用语义编程语言中引用的对等概念，这在传统C++中最多是在使用体验上感觉到有些别扭，而到了C++11后，由于对左值引用、右值引用进行了区分，就使得原本理解上的缺失被进一步放大，自然而然得感觉右值引用莫名其妙。</p><blockquote><p>C++对变量生命周期的一种优雅管理方式是RAII，不过不代表RAII能解决所有场景的变量生命期管理需求，更不代表GC没用。</p></blockquote><p>我们以纯OO语言Java为例，如果写这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1;<br><br>        System.out.println(System.identityHashCode(s1));<br>        System.out.println(System.identityHashCode(s2));<br>        System.out.println(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs zsh">2060468723<br>2060468723<br>true<br></code></pre></td></tr></table></figure><p>可以看到，Java中<code>s1,s2</code>就是引用语义的典范，它们指向的对象是同一个，而在引用语义的编程语言中，这也被称作浅拷贝(ShallowCopy)：在进行赋值、方法传参和返回值时，对于引用类型（非基本类型）一概按引用传递（传址）。</p><blockquote><p>是不是觉着很简单很直观，如果再定义一个<code>String s3 = "hello";</code>，思考下<code>s3</code>和<code>s1</code>是不是同一个对象呢？如果换成<code>String s3 = new String("hello"); String s4 = new String("hello");</code>，<code>s3</code>和<code>s4</code>和<code>s1</code>又是什么关系呢？当然，这是Java体系下的另一个话题了。</p></blockquote><p>再看Python 3:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&quot;hello&quot;</span><br>s2 = s1<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(s1))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(s2))<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">4341128096<br>4341128096<br></code></pre></td></tr></table></figure><p>显然赋值操作是按引用进行传递，<code>s1,s2</code>所指是同一个对象。</p><blockquote><p>我常说python是一门乱七八糟的语言，所谓“动态类型一时爽，代码重构火葬场”。如果定义<code>s3 = "hello"</code>，<code>s3</code>和<code>s1</code>是什么关系呢？如果把"hello"换成"helloworld"呢？当然，这也是Python体系下的另一个话题了。</p></blockquote><blockquote><p>对于Java和Python这类工程/工具语言，没必要过于学究，实际上许多经验丰富的Java/Python程序员对这两个问题也是懵逼的，但这丝毫不影响写出健壮可用的代码，这些问题可能也就面试会被问到。。。但是对于C++来说，凡事都得学究一点，哪怕是经验丰富的C++程序员也常常犯语法错误。</p></blockquote><p>那么在C++中，对于标准库的<code>string</code>来说，我们进行类似的赋值是什么结果呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span>&#123;<br>    string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>    string s2 = s1;<br><br>    cout &lt;&lt; &amp;s1 &lt;&lt; endl;<br>    cout &lt;&lt; &amp;s2 &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">0x16d94f678<br>0x16d94f660<br></code></pre></td></tr></table></figure><p>可以看到<code>s1,s2</code>的地址并不相同，对于非基础类型，C++中使用相同类型的对象做初始化赋值的语义是去调用该类型的拷贝构造器(copyctor)（C++中初始化赋值和普通的赋值语义并不等同，后者在这种情况下调用的是拷贝赋值操作符(copyassignment))。此外，对于第一行<code>string s1 = "hello";</code>也并没有表面看上去那样简单，<code>std::string</code>并不是基础类型，赋值初始化在C++的语义是调用相应的拷贝构造器，但是由于<code>"hello"</code>这个字符串字面量的类型是<code>const char[6]</code>（有界常量字符数组，而且标准规定字符串字面量是左值），并不能匹配拷贝构造器的参数，因此按照常理来说编译应该报错才对。但另一方面，C++在某些特定场合支持适宜的隐式(implicit)转换，上述代码会先用<code>"hello"</code>隐式的生成一个临时的string对象（这需要<code>std::string</code>有一个接受<code>const char[6]</code>或其退化(decay)类型的构造器），然后再调用拷贝构造器将临时对象复制给<code>s1</code>。</p><p>我们尝试来探讨一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 如果加explicit关键字，那么String s1 = &quot;hello&quot;;就无法进行隐式转换而报错</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pstr) : <span class="hljs-built_in">s_</span>(pstr) &#123; cout &lt;&lt; <span class="hljs-string">&quot;call custom ctor&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; rhs) : <span class="hljs-built_in">s_</span>(rhs.s_) &#123; cout &lt;&lt; <span class="hljs-string">&quot;call copy ctor&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-keyword">private</span>:<br>    string s_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span>&#123;<br>    String s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>    String s2 = s1;<br><br>    cout &lt;&lt; &amp;s1 &lt;&lt; endl;<br>    cout &lt;&lt; &amp;s2 &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">call custom ctor<br>call copy ctor<br>0x7ff7b4ac1658<br>0x7ff7b4ac1640<br></code></pre></td></tr></table></figure><p>显然，运行结果并不符合预期，理论上除了<code>String s2=s1;</code>这一行会调用copyctor以外，<code>String s1 = "hello";</code>也应该调用一次才对，为什么只看到了一次customctor呢？这是因为C++11标准定义了复制省略(CopyElision)技术（诸如<code>String s1 = "hello";</code>的写法其实非常的符合直觉，但是因为值语义的关系，C++却不得不多做一次值拷贝），要求编译器在实现时对这一情景做一次合理的拷贝消除。实际上，在C++11标准化之前各大厂商的编译器就已经为这事买单了（委员会的“懒汉们”永远是亡羊补牢），传统C++的开发者应该也了解诸如RVO(ReturnValue Optimization), NRVO(Named Return ValueOptimization)等技术，而这本质上做的就是特定场合的复制省略（未标准化之前，可以视作语言天然缺陷的遮羞布）。</p><p>如果我们通过编译选项关闭复制省略(-fno-elide-constructors)，重新运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zsh">call custom ctor<br>call copy ctor<br>call copy ctor<br>0x7ff7bf7ba658<br>0x7ff7bf7ba618<br></code></pre></td></tr></table></figure><h2 id="表达式值分类">表达式值分类</h2><p>C++中基于值语义的拷贝构造和拷贝赋值，可能会导致大对象的冗余拷贝从而引发性能瓶颈。虽然开发者可以通过指针和引用来规避掉部分场景的copy（编译器也十分配合的蒙上遮羞布），但还是有诸多场景无可避免。我曾看过这么一个形象的比喻：要把大象从A冰箱转移到B冰箱需要几步呢？普通青年的做法是3步：打开冰箱A和B的门；把大象从A转移(move)到B；关闭冰箱A和B。2B青年的做法则是：打开冰箱A和B的门；启用量子复制系统在冰箱B克隆出大象；启用射频消融技术将A中大象解体气化。没错，C++曾经就是这个2B青年。</p><p>移动(move)这件事本身很好理解，因为这是一个符合直觉的做法，但是对背着重重历史包袱的C++来说，想要从语言层面理解移动，就需要前置理解这样一个概念：左值(lvalue)和右值(rvalue)。实际上，左值和右值并不是C++11所引入的术语，这两个概念的历史由来可以追溯到编程语言CPL，那么彼时何为左值和右值呢？顾名思义，在赋值操作符('=')左边的就是左值，右边的就是右值，而这也是左值和右值得以命名的历史原因。C语言继承了CPL的分类法，但是弱化了赋值的作用，C语言中左值一开始表示可以被赋值的对象，但由于<code>const</code>的引入，这类对象被修正称作“可更改的左值”，而右值则被视为“值”的同义词，分类上通通都叫作其他(others)（函数和非对象值）。由于const，我们不能再通过表达式值可否修改来判断是否是左值，而是通过是否可寻址（于是坊间流传的一个不严谨的说法就是：左值对应变量的存储位置，右值对应变量的值本身）。</p><blockquote><p>一种说法是ISO C中的lvalue其实是locatorvalue的缩写，算是个美丽的巧合。</p></blockquote><p>传统C++(C++98)对表达式的值分类继承了C的做法，但复辟了右值的称呼，此外，C++98规定函数为左值（因为可以被取地址，在后续的标准演进中函数甚至当家做主成了一等公民，实际上除了函数还有一些其他类似情况的表达式也被视为左值），而C++中的引用可以被绑定在左值之上，但不能绑定到右值（只有const引用可以绑定到右值）。截止C++03，我们把具有标识(identity)的表达式视为左值，没有标识的表达式视为右值。因此，名称、指针、引用都是左值，是命名对象，它们有可以寻址的确定内存地址；字面量、临时对象等视为右值，右值仅在创建它的表达式中可以被访问。函数名称是左值，数组名称是常量左值（只不过大多数表达式中函数名和数组名被自动隐式转换成右值）。右值的生命周期短暂，所以需要左值去捕获它，把右值拷贝(copy)给左值是常规操作。</p><p>然而在C++11之后，为了支撑移动语义引入了右值引用，因此左值和右值的定义发生了很大变化。右值引用可以绑定到右值上来给临时对象续命，而移动语义则把临时对象移动(move)而不是拷贝(copy)到左值对象上。对于左值和右值的分类，标准不得不做一些扩充和修正：</p><ul><li>左值(lvalue): 指定一个对象(object)或函数(function)。<ul><li>如果<code>E</code>是某种类型的指针类型，那么<code>*E</code>就是一个左值表达式，它引用的是<code>E</code>所指向的对象(object)或函数(function)。</li><li>调用一个返回类型为左值引用的函数，其结果是一个左值。</li></ul></li><li>将亡值(xvalue): expiringvalue的缩写，也指定一个对象，这个对象通常是生命周期即将结束的状态，因此它可以被移动。xvalue是某些涉及右值引用的表达式的结果。<ul><li>调用一个返回类型为右值引用的函数，其结果就是一个xvalue。</li></ul></li><li>泛左值(glvalue): lvalue或者是xvalue。</li><li>右值(rvalue):xvalue，临时的对象或子对象，或者是与对象无关的值。</li><li>纯右值(prvalue): 非xvalue的rvalue。<ul><li>调用一个返回类型为非引用类型的函数，其结果就是一个prvalue。</li></ul></li></ul><p><img src="2022-05-30-14-22-25.png" /></p><blockquote><p>大部分初学者都会因为不了解xvalue和prvalue的概念而想当然地把lvalue和rvalue想象成同一层级的概念，而这在学习过程中就会遇到重重困扰，进而对rvalue的概念云里雾里。实际上rvalue是个混合分类。</p></blockquote><p>自此，表达式的值分类不仅考虑了标识(identify)，还考虑了可移动性(movability)。我们按照标准做一下归纳：</p><ul><li>左值(lvalue): 具有标识，不可移动。</li><li>将亡值(xvalue): 具有标识，可以移动。</li><li>纯右值(prvalue): 没有标识，可以移动。</li><li>泛左值(glvalue): 具有标识</li><li>右值(rvalue): 可以移动</li></ul><p>这样一分类，是不是有种恍然大悟的感觉~</p><p>那么再看看三种基本值类型都对应哪些表达式呢？这里参考reference手册并裁剪掉一些cornercase：</p><ul><li>左值(lvalue):<ul><li>变量名、函数名、数据成员<ul><li>即使变量类型是右值引用，变量本身依然是左值(这不是特例，是正统的语法规则)</li><li><code>std::getline</code></li><li><code>std::cin</code>, <code>std::endl</code></li></ul></li><li>返回类型为左值引用的函数调用或操作符重载或类型转换<ul><li><code>std::getline(std::cin, str)</code></li><li><code>std::cout &lt;&lt; 1</code>, <code>str1 = str2</code>,<code>++it</code></li><li><code>static_cast&lt;int&amp;&gt;(val)</code></li></ul></li><li>返回类型为函数右值引用的函数调用或操作符重载或类型转换<ul><li><code>static_cast&lt;void (&amp;&amp;)(int)&gt;(x)</code></li></ul></li><li>内建(built-in)的赋值与复合赋值表达式<ul><li><code>a=b</code></li><li><code>a+=b</code>,<code>a*=b</code></li></ul></li><li>内建(built-in)的前缀自增、自减<ul><li><code>a++</code></li><li><code>a--</code></li></ul></li><li>内建(built-in)的解引用表达式<ul><li><code>*p</code></li></ul></li><li>内建(built-in)的下标操作符表达式<ul><li><code>a[n]</code>, <code>p[n]</code></li></ul></li><li>对象成员访问，内建(built-int)的指针成员访问<ul><li><code>a.m</code>(<code>m</code>不能是枚举成员，也不能是非静态成员函数）</li><li><code>t.m</code>(<code>t</code>为右值且<code>m</code>为非静态数据成员)</li><li><code>p-&gt;m</code>(<code>m</code>不能是成员枚举值，也不能是非静态成员函数)</li></ul></li><li>对象的成员指针访问，内建(built-in)的指针的成员指针访问（成员指针的指针本质上是偏移，和普通的指针不太一样，导致这两个东西非常的拗口和别扭）<ul><li><code>a.*mp</code>(<code>a</code>是左值，<code>mp</code>是数据成员指针)</li><li><code>p-&gt;*mp</code>(<code>mp</code>是数据成员指针)</li></ul></li><li>右端为左值的逗号表达式<ul><li><code>a, b</code>(<code>b</code>是左值)</li></ul></li><li>二、三操作数为特定值的三元运算符</li><li>字符串字面量(String Literal)<ul><li><code>"hello"</code></li></ul></li></ul></li><li>纯右值(prvalue):<ul><li>字面量<ul><li><code>42</code></li><li><code>'a'</code></li><li><code>true</code></li><li><code>nullptr</code></li></ul></li><li>返回类型为非引用的函数调用或操作符重载或类型转换<ul><li><code>str.substr(1, 2)</code></li><li><code>str1 + str2</code></li><li><code>it++</code></li><li><code>static_cast&lt;double&gt;(x)</code>,<code>std::string&#123;&#125;</code>, <code>(int)42</code></li></ul></li><li>内建(built-in)的后缀自增、自减表达式<ul><li><code>a++</code></li><li><code>b--</code></li></ul></li><li>内建(built-in)的算数、逻辑、比较、取地址表达式<ul><li><code>a + b</code>, <code>a % b</code>, <code>a &amp; b</code>,<code>a &lt;&lt; b</code></li><li><code>a &amp;&amp; b</code>, <code>a || b</code>,<code>!a</code></li><li><code>a &lt; b</code>, <code>a == b</code>,<code>a &gt;= b</code></li><li><code>&amp;a</code></li></ul></li><li>对象成员访问，内建(built-in)的指针成员访问<ul><li><code>a.m</code>(<code>m</code>是成员枚举值或非静态成员函数)</li><li><code>p-&gt;m</code>(<code>m</code>是成员枚举值或非静态成员函数)</li></ul></li><li>对象的成员指针访问，内建(built-in)的指针的成员指针访问<ul><li><code>a.*mp</code>(<code>mp</code>是成员函数指针)</li><li><code>p-&gt;*mp</code>(<code>mp</code>是成员函数指针)</li></ul></li><li>右端为右值的逗号表达式</li><li>二、三操作数为特定值的三元表达式</li><li><code>this</code>指针</li><li>枚举值</li><li>lambda表达式<ul><li><code>[](int x)&#123; return x * x; &#125;</code></li></ul></li></ul></li><li>将亡值(xvalue):<ul><li>返回类型为右值引用的函数调用或操作符重载或类型转换<ul><li><code>std::move(x)</code></li><li><code>static_cast&lt;char&amp;&amp;&gt;(x)</code></li></ul></li><li>对象成员访问<ul><li><code>t.m</code>(<code>t</code>是右值且<code>m</code>是非静态非引用数据成员)</li></ul></li><li>对象的成员指针访问<ul><li><code>t.*mp</code>(<code>t</code>是右值且<code>mp</code>是数据成员指针)</li></ul></li><li>二、三操作数为特定值的三元表达式</li></ul></li></ul><blockquote><p>三元表达式目前的分类比较复杂，详见https://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator</p></blockquote><p>这里的分类因C++历史的演进而变得非常复杂，初学者没必要全盘记住，实际上日后了解了更多的细节后，会发现这里的分类其实是非常直观的。至此，如果你能看到这里，那么恭喜你，基础的内容你已经掌握了，下一讲，我们谈谈右值引用和移动语义。</p><h2 id="参考文献">参考文献</h2><ul><li><ahref="https://docs.microsoft.com/en-us/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170">Lvaluesand Rvalues</a></li><li><ahref="https://en.cppreference.com/w/cpp/language/value_category">Valuecategories</a></li><li><ahref="https://en.wikipedia.org/wiki/Value_(computer_science)">Value(ComputerScience)</a></li><li><ahref="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/">EffectiveModern C++</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>cpp-templates</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十二)——图和网络</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%8C)%E2%80%94%E2%80%94%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%8C)%E2%80%94%E2%80%94%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>这一讲作为第一部分的最后一节内容，主要着重于描述线性代数的应用。</p><span id="more"></span><h1 id="图和网络">图和网络</h1><h2 id="有向图">有向图</h2><p>给定一个有向图：4节点，5条边</p><p><img src="2022-05-14-16-56-35.png" /></p><p>可以用如下方式来抽象描述： <span class="math display">\[\begin{array}{c | c c c c}&amp; node_1 &amp; node_2 &amp; node_3 &amp; node_4\\ \hlineedge_1 &amp; -1     &amp; 1      &amp; 0      &amp; 0\\ edge_2 &amp; 0      &amp; -1     &amp; 1      &amp; 0\\ edge_3 &amp; -1     &amp; 0      &amp; 1      &amp; 0\\ edge_4 &amp; -1     &amp; 0      &amp; 0      &amp; 1\\ edge_5 &amp; 0      &amp; 0      &amp; -1     &amp; 1\end{array}\]</span></p><p>写成<span class="math inline">\(5\times 4\)</span>矩阵来表示如下：<span class="math display">\[A=\begin{bmatrix}-1 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; -1 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; -1 &amp; 1\end{bmatrix}\]</span></p><p>这种矩阵叫做关联矩阵，其中每一列代表一个节点，每一行代表一条边（正负代表方向）。关联矩阵一般是稀疏阵，因为每一行只有两个非零元素。通过观察前三行，可以看出这三个行向量线性相关，而实际上，它的物理意义就是这三个向量（三条边）可以形成回路。</p><h3 id="a的零空间"><span class="math inline">\(A\)</span>的零空间</h3><p>矩阵<span class="math inline">\(A\)</span>的零空间可以通过解<spanclass="math inline">\(Ax=0\)</span>来得到，有： <spanclass="math display">\[Ax=\begin{bmatrix}-1 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; -1 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; -1 &amp; 1\end{bmatrix}\begin{bmatrix}x_1\\ x_2\\ x_3\\ x_4\end{bmatrix}=0\]</span></p><p>展开得： <span class="math display">\[\begin{bmatrix}x_2-x_1\\ x_3-x_2\\ x_3-x_1\\ x_4-x_1\\ x_4-x_3\end{bmatrix}=\begin{bmatrix}0\\ 0\\ 0\\ 0\\ 0\end{bmatrix}\]</span></p><p>引入矩阵的实际意义：将<spanclass="math inline">\(x=\begin{bmatrix}x_1 &amp; x_2 &amp; x_3 &amp;x_4\end{bmatrix}\)</span>视为各节点电势，则式子中的诸如<spanclass="math inline">\(x_2-x_1\)</span>的元素，可以看做该边上的电势差。容易看出其中一个解<spanclass="math inline">\(x=\begin{bmatrix}1\\ 1\\ 1\\1\end{bmatrix}\)</span>，即等电势情况，此时电势差为<spanclass="math inline">\(0\)</span>。化简<spanclass="math inline">\(A\)</span>易得<spanclass="math inline">\(rank(A)=3\)</span>，所以其零空间维数应为<spanclass="math inline">\(n-r=4-3=1\)</span>，即<spanclass="math inline">\(\begin{bmatrix}1\\1\\1\\1\end{bmatrix}\)</span>就是其零空间的一组基。</p><p>Q: 那么以电势为例，零空间的物理意义是什么呢？ A:电势差和电流的形成之间有着直接关系，<spanclass="math inline">\(b=0\)</span>说明我们求解的情况是各个边上都没有电流（或者说电势差）的情况，而我们最后所得到的解就意味着，当各点电势相等时，边上电流（电势差）为零，符合我们的常识。而这就是零空间的物理意义。</p><h3 id="a的左零空间"><spanclass="math inline">\(A\)</span>的左零空间</h3><p><span class="math inline">\(A\)</span>的左零空间是什么呢？或者说<spanclass="math inline">\(A^T\)</span>的零空间是什么呢？即求<spanclass="math inline">\(A^Ty=0\)</span>： <span class="math display">\[A^Ty=0=\begin{bmatrix}-1 &amp; 0 &amp; -1 &amp; -1 &amp; 0\\ 1 &amp; -1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; -1\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}\begin{bmatrix}y_1\\ y_2\\ y_3\\ y_4\\ y_5\end{bmatrix}=\begin{bmatrix}-y_1-y_3-y_4\\ y_1-y_2\\ y_2+y_3-y_5\\ y_4+y_5\end{bmatrix}=\begin{bmatrix}0\\ 0\\ 0\\ 0\end{bmatrix}\]</span></p><p>接着说上文提到的的电势差，引入<spanclass="math inline">\(y\)</span>的实际物理意义：即各边上的电流。电流和电势差的关系服从欧姆定律：边上的电流值是边上电势差的倍数，这个倍速就是边的电导，亦即电阻的倒数，通常我们把这个常数视为一个系数矩阵记为<spanclass="math inline">\(C\)</span>。于是，矩阵<spanclass="math inline">\(C\)</span>就将电势差与电流联系了起来： <spanclass="math display">\[y=\begin{bmatrix}y_1\\ y_2\\ y_3\\ y_4\\ y_5\end{bmatrix}=C\begin{bmatrix}x_2-x_1\\ x_3-x_2\\ x_3-x_1\\ x_4-x_1\\ x_4-x_3\end{bmatrix}\]</span></p><p>实际上<spanclass="math inline">\(A^Ty=0\)</span>阐释的就是“基尔霍夫电流定律”（KCL），基尔霍夫电流定律是一个平衡方程，守恒定律，它说明了流入等于流出，电荷在结点上不会积累。</p><p>对于<spanclass="math inline">\(A^T\)</span>，根据上文得出其零空间的维数是<spanclass="math inline">\(2\)</span>，则零空间的基应该有两个向量。假设<spanclass="math inline">\(y_1=1\)</span>，也就是令<spanclass="math inline">\(1\)</span>安培的电流在边<spanclass="math inline">\(1\)</span>上流动，由图看出<spanclass="math inline">\(y_2\)</span>也应该为<spanclass="math inline">\(1\)</span>，再令<spanclass="math inline">\(y_3=-1\)</span>，也就是让<spanclass="math inline">\(1\)</span>安培的电流流回节点<spanclass="math inline">\(1\)</span>，得出<spanclass="math inline">\(y_4=y_5=0\)</span>；</p><p>得到一个符合KCL的向量<span class="math inline">\(\begin{bmatrix}1\\1\\ -1\\ 0\\0\end{bmatrix}\)</span>，代回方程组发现此向量即为一个解，这个解发生在节点<spanclass="math inline">\(1,2,3\)</span>组成的回路中，该解即为零空间的一个基。</p><p>如法炮制可以得出另一个基向量：<spanclass="math inline">\(\begin{bmatrix}0\\ 0\\ 1\\ -1\\1\end{bmatrix}\)</span>，这实际上是节点<spanclass="math inline">\(1,3,4\)</span>构成的回路。</p><p>如此，我们得到<spanclass="math inline">\(N(A^T)\)</span>的一组基为<spanclass="math inline">\(\begin{bmatrix}1\\ 1\\ -1\\ 0\\0\end{bmatrix}\quad\begin{bmatrix}0\\ 0\\ 1\\ -1\\1\end{bmatrix}\)</span>。</p><blockquote><p>节点<spanclass="math inline">\(1,2,3,4\)</span>构成的大回路实际上是两个基向量回路的叠加。</p></blockquote><h3 id="a的行空间"><span class="math inline">\(A\)</span>的行空间</h3><p>亦即<spanclass="math inline">\(A^T\)</span>的列空间，方便起见我们直接计算<spanclass="math inline">\(A^T\)</span>的列空间： <spanclass="math display">\[A^T=\begin{bmatrix}-1 &amp; 0 &amp; -1 &amp; -1 &amp; 0\\ 1 &amp; -1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; -1\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}\]</span></p><p>显然，<span class="math inline">\(A^T\)</span>的主列为第<spanclass="math inline">\(1,2,4\)</span>列，对应在图中就是边<spanclass="math inline">\(1,2,4\)</span>，可以发现这三条边没有组成回路（<strong>换句话说，线性无关等价于没有回路</strong>）。由<spanclass="math inline">\(4\)</span>个节点与<spanclass="math inline">\(3\)</span>条边组成的图没有回路，就表明<spanclass="math inline">\(A^T\)</span>的对应列向量线性无关，也就是（<spanclass="math inline">\(nodes-1\)</span>）条边线性无关。</p><blockquote><p>没有回路的图叫作树。</p></blockquote><p>再看左零空间的维数公式：<span class="math inline">\(dimN(A^T)=m-r\)</span>，左零空间的维数就是相互无关的回路的数量，于是得到<spanclass="math inline">\(loops=edges-(nodes-1)\)</span>，整理得： <spanclass="math display">\[nodes-edges+loops=1\]</span></p><p>此等式对任何图均有效，任何图都有此拓扑性质，这就是著名的欧拉公式：<span class="math display">\[节点数-边数+最小回路数=1\]</span></p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570094064&amp;p=12&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B12%5D%20%E7%9F%A9%E9%98%B5%E5%BA%94%E7%94%A8%EF%BC%9A%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B012.pdf">矩阵应用：图与网络</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十一)——矩阵空间、秩1矩阵和小世界图</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4%E3%80%81%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4%E3%80%81%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>本讲是上一讲的扩展内容，共分为三部分：第一部分延续上一讲介绍了矩阵空间的特性并延展到微分方程的例子；第二部分介绍了一个特殊的秩1矩阵；第三部分介绍了图的概念以及图与矩阵的关系。</p><span id="more"></span><h1 id="矩阵空间秩1矩阵和小世界图">矩阵空间、秩1矩阵和小世界图</h1><h2 id="矩阵空间">矩阵空间</h2><p>话接上一讲，所有<span class="math inline">\(3\times3\)</span>的矩阵可以构成的封闭的空间（数乘和加法运算），记为<spanclass="math inline">\(M\)</span>，则其一组基为： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>对称矩阵构成的空间<spanclass="math inline">\(S\)</span>和上三角矩阵构成的空间<spanclass="math inline">\(U\)</span>是<spanclass="math inline">\(M\)</span>的子空间： 对称阵<spanclass="math inline">\(S\)</span>的基容易找到： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\end{bmatrix}\]</span></p><p>上三角阵<span class="math inline">\(U\)</span>的基： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>对角矩阵是对称阵和上三角矩阵的交，可以得到另一个子空间：<spanclass="math inline">\(D\)</span>，<spanclass="math inline">\(D\)</span>的基容易找到： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>因此，有：<span class="math inline">\(dim M=9\)</span>，<spanclass="math inline">\(dim S=6\)</span>，<span class="math inline">\(dimU=6\)</span>，<span class="math inline">\(dim D=3\)</span>。</p><ul><li>求和（sum）：<span class="math inline">\(S+U=M,dim(S+U)=9\)</span>；</li><li>求交（intersect）：<span class="math inline">\(S \cap U=D, dim(S\cap U)=3\)</span>；</li></ul><p>可以看出：<span class="math inline">\(dim S + dim U=12=dim(S+U) +dim(S \cap U)\)</span>。</p><blockquote><p><span class="math inline">\(S+U\)</span>其实就是<spanclass="math inline">\(M\)</span>，但是要注意<spanclass="math inline">\(S+U\)</span>并不是<span class="math inline">\(S\cup U\)</span>（这东西也不封闭，构不成空间），后者只包含了<spanclass="math inline">\(S\)</span>和<spanclass="math inline">\(U\)</span>，而前者包含的是<spanclass="math inline">\(S\)</span>中元素和<spanclass="math inline">\(U\)</span>中元素的线性组合，这样的线性组合显然包含了<spanclass="math inline">\(S\)</span>和<spanclass="math inline">\(U\)</span>，也即 <span class="math inline">\((S\cup U) \subseteq (S + U)\)</span>。</p></blockquote><h2 id="微分方程">微分方程</h2><p>空间内元素还可以进一步扩展，不仅限于矩阵或向量，比如还可以是微分方程的解。</p><p>例如，求解：<spanclass="math inline">\(\frac{d^2y}{dx^2}+y=0\)</span>，即<spanclass="math inline">\(y&#39;&#39;+y=0\)</span></p><p>方程的解有：<span class="math inline">\(y=\cos{x}, \quad y=\sin{x},\quad y=e^{ix}, \quad y=e^{-ix}\)</span>等等（<spanclass="math inline">\(e^{ix}=\cos{x}+i\sin{x}, \quade^{-ix}=\cos{x}-i\sin{x}\)</span>）</p><p>只考虑实数范围，该方程的通解为：<span class="math inline">\(y=c_1\cos{x} + c_2 \sin{x}\)</span>。</p><p>这很类似于零空间，可以把这些解看成零空间中的向量，其一组基为<spanclass="math inline">\(\cos{x},\sin{x}\)</span>，零空间的维数为2。同理，如果考虑复数范围，那么<spanclass="math inline">\(e^{ix}, e^{-ix}\)</span>也可以作为另一组基。</p><p>该微分方程的所有解的集合实际上就可以看做是一个“向量空间”，或者应该叫“解空间”，他们满足加法和数乘的封闭性。</p><h2 id="秩1矩阵">秩1矩阵</h2><p>秩<span class="math inline">\(1\)</span>矩阵，即秩为<spanclass="math inline">\(1\)</span>的矩阵。所有的秩<spanclass="math inline">\(1\)</span>矩阵都可以分解成一列乘以一行（<spanclass="math inline">\(A=UV^T\)</span>）的形式，如： <spanclass="math display">\[A=\begin{bmatrix}1&amp;4&amp;5\\ 2&amp;8&amp;10\end{bmatrix}=\begin{bmatrix}1\\ 2\end{bmatrix}\begin{bmatrix}1&amp;4&amp;5\end{bmatrix}\]</span></p><p>其中<span class="math inline">\(dimC(A)=1=dimC(A^T)\)</span>，<spanclass="math inline">\(U, V\)</span>均为列向量。</p><p>秩<spanclass="math inline">\(1\)</span>矩阵类似积木，任何矩阵都是由秩<spanclass="math inline">\(1\)</span>矩阵搭建而成的，如对于一个<spanclass="math inline">\(5 \times 17\)</span>秩为<spanclass="math inline">\(4\)</span>的矩阵，只需要<spanclass="math inline">\(4\)</span>个秩一矩阵就可以组合出来，具体过程类似于我们在第3讲中提到的矩阵乘法中的“列乘行”形式。</p><h2 id="同秩矩阵的集合">同秩矩阵的集合</h2><p>另外，矩阵的加法存在这样的性质：<span class="math inline">\(rank(A+B)\lerank(A)+rank(B)\)</span>。这意味着：对于同样规模的同秩矩阵所组成的集合，其加法是不封闭的。两个<spanclass="math inline">\(5\times 6\)</span>的秩为<spanclass="math inline">\(4\)</span>矩阵相加，结果的秩可能大于<spanclass="math inline">\(4\)</span>，因此，所有秩为<spanclass="math inline">\(4\)</span>的矩阵构成的集合并不是空间，同理，秩<spanclass="math inline">\(1\)</span>矩阵集合也不是空间。</p><h2 id="子空间转化">子空间转化</h2><p><span class="math inline">\(\mathbb{R}^4\)</span>空间中任一向量<spanclass="math inline">\(v=\begin{bmatrix}v_1\\ v_2\\ v_3\\v_4\end{bmatrix}\)</span>共有4个分量，取<spanclass="math inline">\(\mathbb{R}^4\)</span>中满足<spanclass="math inline">\(v_1+v_2+v_3+v_4=0\)</span>的所有向量组成一个向量空间<spanclass="math inline">\(S\)</span>，则<spanclass="math inline">\(S\)</span>显然是一个向量子空间。易看出，不论是使用系数乘以该向量，或是用两个满足条件的向量相加，其结果仍然落在分量和为零的向量空间中。</p><p><strong><span class="math inline">\(S\)</span>的维数</strong>从另一个角度看，<spanclass="math inline">\(v_1+v_2+v_3+v_4=0\)</span>等价于: <spanclass="math display">\[\begin{bmatrix}1&amp;1&amp;1&amp;1\end{bmatrix}\begin{bmatrix}v_1\\v_2\\v_3\\v_4\end{bmatrix}=0\]</span></p><p>则<span class="math inline">\(S\)</span>就是<spanclass="math inline">\(A=\begin{bmatrix}1&amp;1&amp;1&amp;1\end{bmatrix}\)</span>的零空间。<spanclass="math inline">\(rank(A)=1\)</span>，则对其零空间有<spanclass="math inline">\(rank(N(A))=n-r=3=dim N(A)\)</span>，则<spanclass="math inline">\(S\)</span>的维数是<spanclass="math inline">\(3\)</span>，其基为<spanclass="math inline">\(Av=0\)</span>的三个特解：<spanclass="math inline">\(\begin{bmatrix}-1\\1\\0\\0\end{bmatrix}\)</span>,<spanclass="math inline">\(\begin{bmatrix}-1\\0\\1\\0\end{bmatrix}\)</span>,<spanclass="math inline">\(\begin{bmatrix}-1\\0\\0\\1\end{bmatrix}\)</span></p><p>矩阵<span class="math inline">\(A\)</span>的四个基本子空间：</p><ul><li>列空间：<span class="math inline">\(dimC(A)=1\)</span>，其中一组基是<spanclass="math inline">\(\begin{bmatrix}1\end{bmatrix}\)</span>，可以看出列空间就是整个<spanclass="math inline">\(\mathbb{R}^1\)</span>空间。</li><li>零空间：<span class="math inline">\(dimN(A)=3\)</span>，其中的一组基是<spanclass="math inline">\(\begin{bmatrix}-1\\ 1\\ 0\\0\end{bmatrix}\begin{bmatrix}-1\\ 0\\ 1\\0\end{bmatrix}\begin{bmatrix}-1\\ 0\\ 0\\ 1\end{bmatrix}\)</span>。</li><li>行空间：<span class="math inline">\(dimC(A^T)=1\)</span>，其中的一组基是<spanclass="math inline">\(\begin{bmatrix}1\\ 1\\ 1\\1\end{bmatrix}\)</span>；</li><li>左零空间：<span class="math inline">\(dimN(A^T)=0\)</span>，因为<spanclass="math inline">\(A\)</span>转置后没有非零的<spanclass="math inline">\(v\)</span>可以使<spanclass="math inline">\(Av=0\)</span>成立，左零空间就只有<spanclass="math inline">\(\begin{bmatrix}0\end{bmatrix}\)</span>。</li></ul><p>综上： <span class="math display">\[dim C(A^T)+dim N(A)=4=n, dim C(A)+dim N(A^T)=1=m\]</span></p><h2 id="小世界图">小世界图</h2><p><strong>图是点和边的集合，边连通各个点。</strong></p><p><img src="2022-05-14-16-41-56.png" /></p><p>假设，每个人是图中的一个节点，如果两个人为朋友关系，则在这两个人的节点间添加一条边，通常来说，从一个节点到另一个节点只需要不超过<spanclass="math inline">\(6\)</span>步（即六条边）即可到达，这就是大名鼎鼎的“<strong>六度分割理论</strong>”。</p><p>图与矩阵有怎样的联系呢？下一讲会进行阐述。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569901788&amp;p=11&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B11%5D%20%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4%20%E7%A7%A91%20%E7%9F%A9%E9%98%B5/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B011.pdf">矩阵空间秩1 矩阵</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十)——四个基本子空间</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81)%E2%80%94%E2%80%94%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81)%E2%80%94%E2%80%94%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>这一讲系统地讲解了矩阵的四个基本子空间：行空间，列空间，零空间和左零空间。他们关系密切且极其重要，对于每个子空间，我们探索了基和维数并高度概括了其背后的关联性。</p><span id="more"></span><h1 id="四个基本子空间">四个基本子空间</h1><p>现有<span class="math inline">\(m \times n\)</span>矩阵<spanclass="math inline">\(A\)</span>，已知<spanclass="math inline">\(rank(A)=r, r\le min(n,m)\)</span>，则有：</p><ul><li>列空间<span class="math inline">\(C(A) \in \mathbb{R}^m, dimC(A)=r\)</span>。</li><li>零空间<span class="math inline">\(N(A) \in \mathbb{R}^n, dimN(A)=n-r\)</span>。</li><li>行空间<span class="math inline">\(C(A^T) \in \mathbb{R}^n, dimC(A^T)=r\)</span>。</li><li>左零空间<span class="math inline">\(N(A^T) \in \mathbb{R}^m, dimN(A^T)=m-r\)</span>。</li></ul><p>根据上一讲的内容，列空间和零空间的维数和基我们都已了然于胸，而实际上，行空间和左零空间也如出一辙，不过就是把<spanclass="math inline">\(A\)</span>做了转置以后，如法炮制得到的列空间和零空间。</p><blockquote><p>列空间的基：主元所在列的所有向量；零空间的基：所有线性无关的特解。</p></blockquote><p>事实上，除了先转置再如法炮制的法子以外，对于行空间和左零空间，我们还有更便捷的求解方法。</p><h2 id="行空间">行空间</h2>假如我们换个角度思考，直接来看<spanclass="math inline">\(A\)</span>的行向量组，消元得到： $ A=<span class="math display">\[\begin{bmatrix}1 &amp; 2 &amp; 3 &amp; 1\\ 1 &amp; 1 &amp; 2 &amp; 1\\ 1 &amp; 2 &amp; 3 &amp; 1\end{bmatrix}\underrightarrow{消元}\begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1\\ 0 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}\]</span><p>=R $</p><p>消元的本质是做行变换，此时A的列空间发生变化（<spanclass="math inline">\(C(R) \neqC(A)\)</span>），但却并不影响行空间。可以在<spanclass="math inline">\(R\)</span>中看出前两行就是行空间的一组基。所以，可以得出无论对于矩阵<spanclass="math inline">\(A\)</span>还是<spanclass="math inline">\(R\)</span>，其行空间的一组基，可以由<spanclass="math inline">\(R\)</span>矩阵的前<spanclass="math inline">\(r\)</span>行向量组成。</p><blockquote><p>这里的<spanclass="math inline">\(R\)</span>就是第七讲提到的简化行阶梯形式。</p></blockquote><h2 id="左零空间">左零空间</h2><p>对于左零空间，有<span class="math inline">\(A^Ty=0 \rightarrow(A^Ty)^T=0^T\rightarrow y^TA=0\)</span>，因此得名。</p><p>从转置视角来看，零空间的向量是A列向量的线性组合得到，同理左零空间的向量就是A行向量的线性组合。由此联想到前面的<spanclass="math inline">\(R\)</span>最简消元，<spanclass="math inline">\(R\)</span>的最后一个零行代表着行的线性组合产生了零向量，因此有：<spanclass="math inline">\(EA=R\)</span>，矩阵<spanclass="math inline">\(E\)</span>的最后一行向量就是将<spanclass="math inline">\(A\)</span>各行组合得到零向量的方式。</p><p>还记得怎么得到<spanclass="math inline">\(E\)</span>吗？采用Gauss-Jordan消元，将增广矩阵<spanclass="math inline">\(\left[\begin{array}{c|c}A_{m \times n} &amp; I_{m\times m}\end{array}\right]\)</span>中<spanclass="math inline">\(A\)</span>的部分划为简化行阶梯形式<spanclass="math inline">\(\left[\begin{array}{c|c}R_{m \times n} &amp; E_{m\times m}\end{array}\right]\)</span>，<spanclass="math inline">\(E\)</span>将<spanclass="math inline">\(A\)</span>变为<spanclass="math inline">\(R\)</span>的同时，也把<spanclass="math inline">\(I\)</span>变成了<spanclass="math inline">\(E\)</span>，化简完毕我们就得到了矩阵<spanclass="math inline">\(E\)</span>，而它则会把所有的行变换操作记录下来。</p><p>本例中： <span class="math display">\[\left[\begin{array}{c|c}A_{m \times n} &amp; I_{m \timesm}\end{array}\right]=\left[\begin{array}{c c c c|c c c}1 &amp; 2 &amp; 3 &amp; 1 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 1 &amp; 2 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\ 1 &amp; 2 &amp; 3 &amp; 1 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\underrightarrow{消元}\left[\begin{array}{c c c c|c c c}1 &amp; 0 &amp; 1 &amp; 1 &amp; -1 &amp; 2 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; -1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 1\end{array}\right]=\left[\begin{array}{c|c}R_{m \times n} &amp; E_{m \timesm}\end{array}\right]\]</span></p><p>则 <span class="math display">\[EA=\begin{bmatrix}-1 &amp; 2  &amp; 0\\ 1  &amp; -1 &amp; 0\\ -1 &amp; 0  &amp; 1\end{bmatrix}\cdot\begin{bmatrix}1 &amp; 2 &amp; 3 &amp; 1\\ 1 &amp; 1 &amp; 2 &amp; 1\\ 1 &amp; 2 &amp; 3 &amp; 1\end{bmatrix}=\begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1\\ 0 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}=R\]</span></p><p>很明显，式中<span class="math inline">\(E\)</span>的最后一行对<spanclass="math inline">\(A\)</span>的行做线性组合后（行视角：-1个行1+0个行2+1个行3），得到<spanclass="math inline">\(R\)</span>的最后一行，即<spanclass="math inline">\(0\)</span>向量，也就是<spanclass="math inline">\(y^TA=0\)</span>。另一方面，<spanclass="math inline">\(E\)</span>的第三行对应的行向量就是矩阵<spanclass="math inline">\(A\)</span>的左零空间的基，维数是1。</p><h2 id="矩阵空间">矩阵空间</h2><p>不只是向量可以构建出空间，万物皆可构造出空间，只要满足加法和数乘的封闭性即可。</p><p>举个例子，矩阵可以同向量一样，做求和、数乘。那么什么样的矩阵构成的空间满足封闭性呢？比如，设所有<span class="math inline">\(3 \times3\)</span>矩阵组成的矩阵空间为<spanclass="math inline">\(M\)</span>。则上三角矩阵、对称矩阵、对角矩阵（前两者的交集）都可以构成矩阵空间。</p><p>观察一下对角矩阵，如果取：<span class="math inline">\(\begin{bmatrix}1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0\end{bmatrix} \quad \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 3 &amp;0 \\ 0 &amp; 0 &amp; 0 \end{bmatrix} \quad \begin{bmatrix} 0 &amp; 0&amp; 0 \\ 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 7 \end{bmatrix}\)</span>，可以发现，任何三阶对角矩阵均可用这三个矩阵的线性组合生成，因此，他们生成了三阶对角矩阵空间，即这三个矩阵是三阶对角矩阵空间的一组基。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569896824&amp;p=10&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B10%5D%20%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B010.pdf">四个基本子空间</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(九)——线性相关性、基和维数</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B9%9D)%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E3%80%81%E5%9F%BA%E5%92%8C%E7%BB%B4%E6%95%B0/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B9%9D)%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E3%80%81%E5%9F%BA%E5%92%8C%E7%BB%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>这一讲对向量组的线性相关性、线性无关性做了进一步的阐释，之后引出向量空间中基和维数的概念。</p><span id="more"></span><h1 id="线性相关性基和维数">线性相关性、基和维数</h1><h2 id="线性相关线性无关">线性相关、线性无关</h2><p>所谓的线性相关和线性无关是用于描述向量组中所有向量的关系，根据此前所掌握的知识，我们知道：以<spanclass="math inline">\(A\)</span>中列向量组为例，如果不存在零解以外的零向量的线性组合，那么列向量组就是线性无关的，否则就是线性相关的。</p><p>进一步，如果向量组包含一个零向量，那么该向量组一定是线性相关的（零向量取任意分量，其他向量取零分量）。</p><p>总结： 给定<span class="math inline">\(v_1,\ v_2,\ \cdots,\v_n\)</span>是<span class="math inline">\(m\times n\)</span>矩阵<spanclass="math inline">\(A\)</span>的列向量： - 如果<spanclass="math inline">\(A\)</span>零空间中有且仅有<spanclass="math inline">\(0\)</span>向量，则各向量线性无关，此时有：<spanclass="math inline">\(rank(A)=n\)</span>。 - 如果存在非零向量<spanclass="math inline">\(c\)</span>使得<spanclass="math inline">\(Ac=0\)</span>，则存在线性相关向量，此时有：<spanclass="math inline">\(rank(A)\lt n\)</span>。</p><p>用此前课程所掌握的知识来描述，前者就是列满秩，此时没有自由列，也就没有自由变量，因此零空间只有零向量，因而向量组线性无关；后者则存在自由列，零空间除了零向量以外还有其他向量，因而向量组线性相关。</p><p>至此，向量组的线性相关性与矩阵的零空间就联系起来了。</p><h2 id="基和维数">基和维数</h2><p>对于线性无关的情况，我们实际上关心的正是这一组“最小的”向量组：它们线性无关，且能生成相应大小的向量空间。而这恰恰就是“基”的概念。</p><p>向量空间的基本质上就是一个向量组，我们之所以额外地称这些向量组为基是因为其既有两个性质：- 向量组中的向量线性无关 -向量组中的向量能够生成相应大小的整个向量空间</p><p>因此，如果需要确定一个向量空间，那么只需要把向量空间对应的基找出来即可，向量空间对应的基包含了这个向量空间的全部有用信息。</p><p>进一步，对于向量空间<spanclass="math inline">\(\mathbb{R}^n\)</span>中的<spanclass="math inline">\(n\)</span>个向量，如果想要构成基，那么以这<spanclass="math inline">\(n\)</span>个向量为列向量的矩阵<spanclass="math inline">\(A\)</span>必然是可逆的。</p><p>显然向量空间<spanclass="math inline">\(\mathbb{R}^n\)</span>的基有无穷多个，而我们平常在选取的时候，则一般会选择标准基，所谓的<strong>标准基</strong>，就是向量空间中最明显的基，把每个基向量以一定顺序作为列向量，可以组成一个单位矩阵。另一方面，这无穷多个基有着一个共同点：基所包含的向量（基向量）的个数是一定的。而这个确定的基向量的个数实际上就表示了向量空间的大小，我们一般称其为向量空间的“<strong>维数</strong>”。</p><h2 id="案例">案例</h2><p><span class="math inline">\(A=\begin{bmatrix} 1 &amp; 2 &amp; 3 &amp;1 \\ 1 &amp; 1 &amp; 2 &amp; 1 \\ 1 &amp; 2 &amp; 3 &amp; 1\end{bmatrix}\)</span></p><h3 id="a的各列是不是a列空间的基">A的各列是不是A列空间的基？</h3><p>显然不是，列3是列1和列2的加和，列4和列1完全相同，A的列向量线性相关，所以不是基。这也意味着其零空间中有非零向量，不难看出<spanclass="math inline">\(rank(A)=2\)</span>。可以很容易的求得<spanclass="math inline">\(Ax=0\)</span>的两个解，如<spanclass="math inline">\(x_1=\begin{bmatrix} -1 \\ -1 \\ 1 \\ 0\end{bmatrix}, x_2= \begin{bmatrix} -1 \\ 0 \\ 0 \\ 1\end{bmatrix}\)</span>，而特解的个数就是自由变量的个数，所以<spanclass="math inline">\(n-rank(A)=2\)</span>，即自由变量存在的列数，亦是零空间的维数。</p><h3 id="给出a列空间的基和维数">给出A列空间的基和维数。</h3><p>可以取前两列线性无关列作为基。A列空间的维数是2。</p><h3 id="a零空间的维数是多少">A零空间的维数是多少？</h3><p>先找出零空间的基的个数，<spanclass="math inline">\(Ax=0\)</span>的特解有两个（自由变量有两个），所以零空间的维数也是2。</p><p>由此观之：</p><ul><li>列空间维数<span class="math inline">\(dim C(A)=rank(A), C(A)\in\mathbb{R}^m\)</span></li><li>零空间维数<span class="math inline">\(dim N(A)=n-rank(A), N(A)\in\mathbb{R}^n\)</span></li></ul><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569906223&amp;p=9&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B09%5D%20%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%EF%BC%8C%E5%9F%BA%EF%BC%8C%E7%BB%B4%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B09.pdf">线性相关性，基，维数</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(八)——求解Ax=b：可解性和解的结构</title>
    <link href="/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AB)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-b%EF%BC%9A%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <url>/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AB)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-b%EF%BC%9A%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>这一讲系统的讲解了线性方程组<spanclass="math inline">\(Ax=b\)</span>的求解，对可解性和解的结构进行了展开说明，得到了具体的通用解法：<spanclass="math inline">\(X_p+X_n\)</span>，并按照秩与<spanclass="math inline">\(m,n\)</span>的关系对解做了归类。</p><h1 id="求解axb可解性和解的结构">求解<spanclass="math inline">\(Ax=b\)</span>：可解性和解的结构</h1><p>我们知道<span class="math inline">\(Ax=b\)</span>未必有解，当<spanclass="math inline">\(A\)</span>的列空间无法线性组合出<spanclass="math inline">\(b\)</span>时，方程组是无解的。而在有解时可能存在唯一解，也可能存在无穷多个解，那么这其中又有什么规律呢？我们尝试按照上一讲对<spanclass="math inline">\(Ax=0\)</span>的研究方法来进行消元操作。</p><h2 id="可解性">可解性</h2><p>依然采用上一讲的矩阵：<span class="math inline">\(A=\begin{bmatrix} 1&amp; 2 &amp; 2 &amp; 2 \\ 2 &amp; 4 &amp; 6 &amp; 8 \\ 3 &amp; 6 &amp;8 &amp; 10 \end{bmatrix}\)</span>，求<spanclass="math inline">\(Ax=b\)</span>的特解。</p><p>这一次<span class="math inline">\(b\)</span>不再是<spanclass="math inline">\(0\)</span>向量，我们消元时写出增广矩阵： <spanclass="math display">\[\left[\begin{array}{c c c c|c}1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\ 2 &amp; 4 &amp; 6 &amp; 8 &amp; b_2\\ 3 &amp; 6 &amp; 8 &amp; 10 &amp; b_3\end{array}\right]\underrightarrow{消元}\left[\begin{array}{c c c c|c}1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\ 0 &amp; 0 &amp; 2 &amp; 4 &amp; b_2-2b_1\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; b_3-b_2-b_1\end{array}\right]\]</span></p><p>从最后一行可见，要使<spanclass="math inline">\(Ax=b\)</span>有解，则必须满足<spanclass="math inline">\(b_3-b_2-b_1=0\)</span>，而这就是可解性。</p><p>我们此前按照列空间视角，对此可以给出这样的解释：<spanclass="math inline">\(b\)</span>必须要属于<spanclass="math inline">\(A\)</span>的列空间才有解，也就是<spanclass="math inline">\(A\)</span>中各列的线性组合。</p><p>现在让我们换个角度来理解可解性：<strong>如果<spanclass="math inline">\(A\)</span>中各行线性组合产生了零行，那么向量<spanclass="math inline">\(b\)</span>的分量在同样的线性组合后也必须为零。</strong></p><h2 id="解的结构">解的结构</h2><p>设<span class="math inline">\(b=\begin{bmatrix} 1\\ 5\\ 6\end{bmatrix}\)</span>满足可解性，那么<spanclass="math inline">\(Ax=b\)</span>的解是什么呢？直观上来看，消元以后我们得到了两个方程，但是未知数有4个，因此，理论上我们可以找到无穷多个解（因为存在自由变量）。<span class="math display">\[\begin{cases}x_1+2x_2+2x_3+2x_4 = 1\\ 2x_3+4x_4 = 3\end{cases}\]</span></p><p>想要求得通解，首先我们要找出特解：先让所有的自由变量取<spanclass="math inline">\(0\)</span>，以解出此时主变量的值。这里自由变量是<spanclass="math inline">\(x_2\)</span>和<spanclass="math inline">\(x_4\)</span>，回代求得<spanclass="math inline">\(x_1=-2,x_3=\frac{3}{2}\)</span>，故特解<spanclass="math inline">\(x_p=\begin{bmatrix}-2\\ 0\\ \frac{3}{2}\\0\end{bmatrix}\)</span>。</p><blockquote><p>自由变量取<spanclass="math inline">\(0\)</span>只是为了方便计算，实际上你想取啥都行，因为它们会被主变量抵消、毫无贡献。</p></blockquote><p>显然，将特解<spanclass="math inline">\(x_p\)</span>加上上一讲所学的零空间中的任意向量(写为<spanclass="math inline">\(x_n\)</span>)就可以得到通解：<spanclass="math inline">\(x=x_p+x_n\)</span>。这是因为零空间的向量带入方程后结果永远是<spanclass="math inline">\(0\)</span>，它不会影响等式（<spanclass="math inline">\(A(x_p+x_n)=Ax_p+Ax_n=b+0=b\)</span>）。</p><p>而上一讲中我们得到了零空间解集为：<spanclass="math inline">\(x_n=c\begin{bmatrix} -2\\ 1\\ 0\\ 0\end{bmatrix}+d\begin{bmatrix} 2\\ 0\\ -2\\ 1 \end{bmatrix}\)</span></p><p>因此，<span class="math inline">\(Ax=b\)</span>的通解为<spanclass="math inline">\(\begin{bmatrix}-2\\ 0\\ \frac{3}{2}\\0\end{bmatrix}+c\begin{bmatrix} -2\\ 1\\ 0\\0\end{bmatrix}+d\begin{bmatrix}2\\ 0\\ -2\\ 1\end{bmatrix}\)</span></p><h2 id="解与秩的关系">解与秩的关系</h2><p>考虑秩为<span class="math inline">\(r\)</span>的<spanclass="math inline">\(m*n\)</span>矩阵<spanclass="math inline">\(A\)</span>，显然<span class="math inline">\(r\leqm, r\leq n\)</span>。</p><ul><li>当列满秩时(<span class="math inline">\(r=n\)</span>)，消元后<spanclass="math inline">\(R\)</span>为<spanclass="math inline">\(\begin{bmatrix}I \\0\end{bmatrix}\)</span>，意味着每一列都有主元，那么也就没有自由变量，此时零空间里只有零向量，因此若<spanclass="math inline">\(b\)</span>满足可解性，则解必唯一。</li><li>当行满秩时(<span class="math inline">\(r=m\)</span>)，消元后<spanclass="math inline">\(R\)</span>为<spanclass="math inline">\(\begin{bmatrix}I &amp;F\end{bmatrix}\)</span>，意味着没有零行，此时对<spanclass="math inline">\(b\)</span>就没有任何约束，那么<spanclass="math inline">\(Ax=b\)</span>是必然有解，自由变量有<spanclass="math inline">\(n-m\)</span>个，此时解有无穷多个。</li><li>当<spanclass="math inline">\(m=n=r\)</span>时，行列皆满秩，消元后<spanclass="math inline">\(R\)</span>为单位阵，不存在自由列，也没有零行对<spanclass="math inline">\(b\)</span>进行约束，因此必有解且解唯一。</li><li>当不满秩，即<span class="math inline">\(r&lt;n\)</span>且<spanclass="math inline">\(r&lt;m\)</span>时，消元后<spanclass="math inline">\(R\)</span>为<spanclass="math inline">\(\begin{bmatrix}I &amp; F \\ 0 &amp;0\end{bmatrix}\)</span>的形式，此时有两种情况：<ul><li>无解。零行约束了<span class="math inline">\(b\)</span>，但<spanclass="math inline">\(b\)</span>不满足约束条件。</li><li>无穷多个解。<spanclass="math inline">\(b\)</span>满足零行约束，解集为：特解+零空间任意向量</li></ul></li></ul><p>总结如下： <span class="math display">\[\begin{array}{c|c|c|c}r=m=n&amp;r=n\lt m&amp;r=m\lt n&amp;r\lt m,r\lt n\\ R=I&amp;R=\begin{bmatrix}I\\0\end{bmatrix}&amp;R=\begin{bmatrix}I&amp;F\end{bmatrix}&amp;R=\begin{bmatrix}I&amp;F\\0&amp;0\end{bmatrix}\\1\ solution&amp;0\ or\ 1\ solution&amp;\infty\ solution&amp;0\ or\\infty\ solution\end{array}\]</span></p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569898565&amp;p=8&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B08%5D%20Ax%3Db%20%E7%9A%84%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B08.pdf">Ax=b的可解性和解的结构</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(七)——求解Ax=0：主变量，特解</title>
    <link href="/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%83)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-0%EF%BC%9A%E4%B8%BB%E5%8F%98%E9%87%8F%EF%BC%8C%E7%89%B9%E8%A7%A3/"/>
    <url>/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%83)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-0%EF%BC%9A%E4%B8%BB%E5%8F%98%E9%87%8F%EF%BC%8C%E7%89%B9%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>这一讲深入探讨了求解<spanclass="math inline">\(Ax=0\)</span>过程中，消元法所得到的主列、自由列、自由变量与特解以及它们与矩阵的秩的关系。</p><span id="more"></span><h1 id="求解ax0-主变量特解">求解<spanclass="math inline">\(Ax=0\)</span>: 主变量，特解</h1><p>给定一个<span class="math inline">\(3\times 4\)</span>的矩阵： <spanclass="math inline">\(A=\begin{bmatrix}  1&amp;2&amp;2&amp;2  \\2&amp;4&amp;6&amp;8  \\ 3&amp;6&amp;8&amp;10 \end{bmatrix}\)</span></p><h2 id="求解零空间">求解零空间</h2><p>零空间由求<spanclass="math inline">\(Ax=0\)</span>的解集合组成，除了零向量以外，欲求其他解，首先要通过高斯消元法找到主变量：<span class="math display">\[A=\begin{bmatrix}1 &amp; 2 &amp; 2 &amp; 2\\ 2 &amp; 4 &amp; 6 &amp; 8\\ 3 &amp; 6 &amp; 8 &amp; 10\end{bmatrix}\underrightarrow{eliminate}\begin{bmatrix}\underline{1} &amp; 2 &amp; 2 &amp; 2\\ 0 &amp; 0 &amp; \underline{2} &amp; 4\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}=U\]</span></p><p>可以看出经过消元后，主变量还剩2个（下划线元素），因此矩阵<spanclass="math inline">\(A\)</span>的秩就是2，即<spanclass="math inline">\(r=2\)</span>。主变量所在的列我们称为主列，其余列则称为自由列。自由列对应的变量我们称为自由变量，那么自由变量的个数就是：<spanclass="math inline">\(n-r=4-2=2\)</span>。</p><p>高斯消元处理后，线性相关的行就会被暴露出来，比如<spanclass="math inline">\(A\)</span>矩阵的行三实际上就是行一和行二的加和，所以在消元后整行都变成了<spanclass="math inline">\(0\)</span>(<spanclass="math inline">\(0\)</span>行，即没有主元)。另一方面，线性相关的列也会被暴露，我们在消元过程中发现第二列原本要做主元的元素变成了0，这恰恰是因为第二列和前面的列（这里只有第一列）线性相关（刚好是两倍的列1），因此第二列没有主元，是自由列。而同样的，第四列也没有主元，这就说明第四列实际上是前三列的线性组合（两倍的第三列减第二列）。</p><p>消元的本质是行变换，行变换改变的是列向量（从而可能改变列空间），但是无法改变列向量之间的线性相关性。另一方面，消元不会改变零空间，因为<spanclass="math inline">\(b\)</span>为<spanclass="math inline">\(0\)</span>时，随你怎么折腾，他都是<spanclass="math inline">\(0\)</span>，解不会改变。</p><p>因此，<span class="math inline">\(Ax=0\)</span>求解问题变成了对<spanclass="math inline">\(Ux=0\)</span>的求解，首先我们找出主变量和自由变量，<spanclass="math inline">\(x_1\)</span>和<spanclass="math inline">\(x_3\)</span>是主变量，<spanclass="math inline">\(x_2\)</span>和<spanclass="math inline">\(x_4\)</span>是自由变量。自由变量可以对其分配任意的值（不管你赋什么值，都会被计算出来的主变量抵消掉）。</p><p><strong>我们对自由变量随意赋值，一般采用的一种简单策略是：对其中一个自由变量赋值为<spanclass="math inline">\(1\)</span>，其余赋值为<spanclass="math inline">\(0\)</span>，循环往复。</strong></p><p>通过这样的策略，我们对自由变量进行赋值，并回代求出主变量：</p><ul><li>令<span class="math inline">\(x_2=1, x_4=0\)</span>，得解<spanclass="math inline">\(x=\begin{bmatrix}-2\\ 1\\ 0\\0\end{bmatrix}\)</span></li><li>令<span class="math inline">\(x_2=0, x_4=1\)</span>，得解<spanclass="math inline">\(x=\begin{bmatrix}2\\ 0\\ -2\\1\end{bmatrix}\)</span></li></ul><p>这两个解我们称之为特解，<strong>特解的线性组合构成的向量空间就是零空间，零空间的每个向量都是方程组的解</strong>：<span class="math display">\[x=c\begin{bmatrix}-2\\ 1\\ 0\\ 0\end{bmatrix}+d\begin{bmatrix}2\\ 0\\-2\\ 1\end{bmatrix}\]</span></p><p><strong>特解之间线性无关。</strong></p><blockquote><p>求特解的策略非常优雅直观，采用控制变量的思想，我们每次只关注其中一个自由变量，避免自由变量的相互影响，从而得到所有的线性无关的特解。</p></blockquote><p><strong>归纳：对于<spanclass="math inline">\(m*n\)</span>矩阵，若其秩为<spanclass="math inline">\(r\)</span>，则主变量有<spanclass="math inline">\(r\)</span>个，自由变量有<spanclass="math inline">\(n-r\)</span>个。</strong></p><h2 id="rrefreduced-row-echelon-form">RREF(Reduced row echelonform)</h2><p>上例中消元得到的<spanclass="math inline">\(U\)</span>矩阵是个上三角阵，实际上还可以进一步简化成<spanclass="math inline">\(R\)</span>矩阵，即RREF(Reduced row echelonform)——简化行阶梯形式。</p><p><spanclass="math inline">\(R\)</span>矩阵中主元上下的元素都是0，主元提取公倍数化简为1：<span class="math display">\[U=\begin{bmatrix}\underline{1} &amp; 2 &amp; 2 &amp; 2\\ 0 &amp; 0 &amp; \underline{2} &amp; 4\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}\underrightarrow{自底向上}\begin{bmatrix}\underline{1} &amp; 2 &amp; 0 &amp; -2\\ 0 &amp; 0 &amp; \underline{1} &amp; 2\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}=R\]</span></p><p>将<spanclass="math inline">\(R\)</span>矩阵中的主列放在一起，自由列放在一起（列交换），得到：<span class="math display">\[R=\begin{bmatrix}\underline{1} &amp; 2 &amp; 0 &amp; -2\\ 0 &amp; 0 &amp; \underline{1} &amp; 2\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}\underrightarrow{列交换}\left[\begin{array}{c c | c c}1&amp;0&amp;2&amp;-2\\0&amp;1&amp;0&amp;2\\ \hline 0&amp;0&amp;0&amp;0\end{array}\right]=\begin{bmatrix}I &amp; F\\ 0 &amp; 0\end{bmatrix}\textrm{，其中}I\textrm{为主列组成的$r*r$大小的单位矩阵，}F\textrm{为自由列经过化简后组成的矩阵}\]</span></p><p>计算零空间矩阵<span class="math inline">\(N\)</span>（nullspacematrix），其列为特解，有<span class="math inline">\(RN=0\)</span>。<span class="math display">\[\begin{align}x_{pivot}=-Fx_{free}\\ \begin{bmatrix}I&amp;F\end{bmatrix}\begin{bmatrix}x_{pivot}\\ x_{free}\end{bmatrix}=0\\ N=\begin{bmatrix}-F\\ I\end{bmatrix}\end{align}\]</span></p><p>在本例中<span class="math inline">\(N=\begin{bmatrix}  -2&amp;2  \\0&amp;-2  \\ 1&amp;0  \\ 0&amp;1\end{bmatrix}\)</span>，与上面求得的两个<spanclass="math inline">\(x\)</span>特解一致，因此，可以利用<spanclass="math inline">\(R\)</span>直接求解零空间。</p><blockquote><p>主元的概念是消元带来的，而消元过程中挖掘的实际上就是行、列的线性相关性。</p></blockquote><p><strong>总结：<span class="math inline">\(A\)</span> 的主元个数 =<span class="math inline">\(A\)</span> 矩阵线性无关的列的个数 = <spanclass="math inline">\(A^T\)</span> 矩阵线性无关的行的个数 = <spanclass="math inline">\(A^T\)</span> 的主元个数。</strong></p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569901010&amp;p=7&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B07%5D%20%E6%B1%82%E8%A7%A3%20Ax%20%3D%200%EF%BC%8C%E4%B8%BB%E5%8F%98%E9%87%8F%EF%BC%8C%E7%89%B9%E8%A7%A3/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%5B%E4%B8%83%5D.pdf">求解Ax = 0，主变量，特解</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(六)——列空间和零空间</title>
    <link href="/2022/05/03/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AD)%E2%80%94%E2%80%94%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/05/03/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AD)%E2%80%94%E2%80%94%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>这一讲主要介绍了<strong>列空间</strong>和<strong>零空间</strong>。二者都是四个基本子空间的重要成员。</p><span id="more"></span><h1 id="列空间和零空间">列空间和零空间</h1><h2 id="子空间的并和交">子空间的并和交</h2><p>某向量空间的两个子空间<span class="math inline">\(S\)</span>和<spanclass="math inline">\(T\)</span>，它们的并（<spanclass="math inline">\(S\cup T\)</span>）不一定是子空间，但它们的交(<spanclass="math inline">\(S\capT\)</span>)一定是子空间，这一点是显而易见的：以<spanclass="math inline">\(R^3\)</span>举例，过原点的某个平面<spanclass="math inline">\(P\)</span>是一个子空间，过原点的某条直线<spanclass="math inline">\(L\)</span>也是一个子空间，如果<spanclass="math inline">\(L\)</span>不在平面<spanclass="math inline">\(P\)</span>上，那么我们从原点出发，取<spanclass="math inline">\(L\)</span>上的任意向量<spanclass="math inline">\(v\)</span>和平面<spanclass="math inline">\(P\)</span>上的任意向量<spanclass="math inline">\(w\)</span>，对二者进行加法操作，得到的向量<spanclass="math inline">\(v+w\)</span>既不在平面<spanclass="math inline">\(P\)</span>上，也不在直线<spanclass="math inline">\(L\)</span>上，所以子空间的交不一定是子空间（直线<spanclass="math inline">\(L\)</span>在平面<spanclass="math inline">\(P\)</span>上时才是）；而对于<spanclass="math inline">\(P\)</span>和<spanclass="math inline">\(L\)</span>的交来说，要么只有一个原点，要么是<spanclass="math inline">\(L\)</span>（此时<spanclass="math inline">\(L\)</span>在平面<spanclass="math inline">\(P\)</span>之内），它们的交依然是一个子空间。</p><p>沿此思路扩展到高维空间亦是如此，子空间的并放宽了限制条件导致规则被破坏，而子空间的交则实际上是进行了更严格的限制，(<spanclass="math inline">\(S\cap T\)</span>)既满足<spanclass="math inline">\(S\)</span>的法则，也满足<spanclass="math inline">\(T\)</span>的法则，因此它当然是子空间。</p><blockquote><p>严格的证明需要对数乘封闭和加法封闭分别进行论证。</p></blockquote><h2 id="列空间大小">列空间大小</h2><p><span class="math display">\[\begin{bmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1(n-1)} &amp; a_{1n}\\ a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2(n-1)} &amp; a_{2n}\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots\\ a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{m(n-1)} &amp; a_{mn}\end{bmatrix}\cdot\begin{bmatrix}x_{1}\\ x_{2}\\ \vdots\\ x_{n-1}\\ x_{n}\end{bmatrix}=\begin{bmatrix}b_{1}\\ b_{2}\\ \vdots\\ b_{m}\end{bmatrix}\]</span></p><p>矩阵<spanclass="math inline">\(A\)</span>的列空间是由它的各列线性组合构成。在探究列空间的大小时，又将回到这个问题：<spanclass="math inline">\(Ax=b\)</span>是否对任意的<spanclass="math inline">\(b\)</span>都有解？或者退一步，什么样的<spanclass="math inline">\(b\)</span>方程组才有解？</p><p>从列空间的视角出发，这一问题有更加具象的回答方式：<strong><spanclass="math inline">\(Ax=b\)</span>有解，当且仅当<spanclass="math inline">\(b\)</span>属于<spanclass="math inline">\(A\)</span>的列空间。只有当<spanclass="math inline">\(b\)</span>是<spanclass="math inline">\(A\)</span>各列的线性组合时，<spanclass="math inline">\(Ax=b\)</span>才有解。</strong></p><p>举个例子： <span class="math display">\[Ax=\begin{bmatrix}1 &amp; 1 &amp; 2\\ 2 &amp; 1 &amp; 3\\ 3 &amp; 1 &amp; 4\\ 4 &amp; 1 &amp; 5\end{bmatrix}\cdot\begin{bmatrix}x_1\\ x_2\\ x_3\end{bmatrix}=\begin{bmatrix}b_1\\ b_2\\ b_3\\ b_4\end{bmatrix}=b\]</span></p><p><span class="math inline">\(A\)</span>的三个列向量构成的是<spanclass="math inline">\(R^4\)</span>的一个子空间，由于列向量仅有3个，显然无论如何线性组合也无法铺满整个四维空间（正如两个三维向量无法铺满整个三维空间一样，它最多只能构成一个平面），因此，我们无法保证任意的向量<spanclass="math inline">\(b\)</span>，方程组都有解。当且仅当<spanclass="math inline">\(b\)</span>在三个列向量构成的<spanclass="math inline">\(R^4\)</span>子空间之内时，方程组才有解。</p><p>此外，我们还注意到，第三个列向量<spanclass="math inline">\(\begin{bmatrix}2\\3\\4\\5\end{bmatrix}\)</span>是前两个列向量的线性组合（两者相加），也就是说，第三个列向量对于线性组合来说毫无贡献，三个列向量最终形成的是一个<spanclass="math inline">\(R^4\)</span>空间内的平面。</p><p>因此，矩阵列空间的大小实际上与各列的线性无关性有关系，越多的列线性无关，那么它们能构成的列空间就越大，越多的列线性相关，那么其中相关的那一部分对列空间的构建就毫无贡献。</p><h2 id="零空间">零空间</h2><p>所谓零空间，就是由<spanclass="math inline">\(Ax=0\)</span>的所有解向量<spanclass="math inline">\(x\)</span>构成的空间。</p><p>还是考虑上例： <span class="math display">\[\begin{bmatrix}1 &amp; 1 &amp; 2\\ 2 &amp; 1 &amp; 3\\ 3 &amp; 1 &amp; 4\\ 4 &amp; 1 &amp; 5\end{bmatrix}\cdot\begin{bmatrix}x_1\\ x_2\\ x_3\end{bmatrix}=0\]</span></p><p><span class="math inline">\(x\)</span>有三个分量，所以<spanclass="math inline">\(x\)</span>构成的是一个<spanclass="math inline">\(R^3\)</span>的子空间。因此，对于<spanclass="math inline">\(m*n\)</span>的矩阵来说，其列空间是<spanclass="math inline">\(R^m\)</span>的子空间（列向量的维数），零空间是<spanclass="math inline">\(R^n\)</span>的子空间（列向量的个数）。</p><p>显然，零空间一定包含零向量：所有<spanclass="math inline">\(x_i\)</span>都为0显然是一个解，另一方面，不难证明零空间本身也是一个向量空间，满足矩阵加法与数乘的封闭性。</p><blockquote><p>零空间内任取两个向量<span class="math inline">\(v\)</span>和<spanclass="math inline">\(w\)</span>，由于<spanclass="math inline">\(Av=Aw=0\)</span>，故<spanclass="math inline">\(A(v+w)=0\)</span>，<spanclass="math inline">\(c(Av)=A(cv)=0\)</span>，证毕。</p></blockquote><blockquote><p>特别注意：零空间不是零向量空间，零向量空间只包含一个零向量，本质上是<spanclass="math inline">\(R^0\)</span>，零空间是一种子空间，可以包含无数个向量。</p></blockquote><p>针对上例，由于第三列是前两列的加和，我们可以轻松拿到一个特解：<spanclass="math inline">\(\begin{bmatrix}1\\1\\-1\end{bmatrix}\)</span>，其零空间就是：<spanclass="math inline">\(C\begin{bmatrix}1\\1\\-1\end{bmatrix}\)</span>（<spanclass="math inline">\(C\)</span>表示任意常数），即<spanclass="math inline">\(R^3\)</span>中的一条过原点的直线。</p><h3 id="思考">思考</h3><p>如果<span class="math inline">\(b\not=0\)</span>，那么对于<spanclass="math inline">\(x\)</span>的求解是否也能够找到一个向量空间呢？</p><p>答案是不能：若 <spanclass="math inline">\(b\not=0\)</span>，那么<spanclass="math inline">\(x\)</span>就不可能等于<spanclass="math inline">\(0\)</span>，这就意味着如果要形成向量空间，那么它无法包含零向量，这一点就已经违背了空间的法则。因此，解集无法构成一个向量空间。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569895746&amp;p=6&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B06%5D%20%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4/%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4.pdf">列空间和零空间</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(五)——转置、置换和向量空间R</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%94)%E2%80%94%E2%80%94%E8%BD%AC%E7%BD%AE%E3%80%81%E7%BD%AE%E6%8D%A2%E5%92%8C%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%94)%E2%80%94%E2%80%94%E8%BD%AC%E7%BD%AE%E3%80%81%E7%BD%AE%E6%8D%A2%E5%92%8C%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R/</url>
    
    <content type="html"><![CDATA[<p>这一讲内容包括转置、置换和向量空间<spanclass="math inline">\(R\)</span>，实际上是基于<spanclass="math inline">\(A=LU\)</span>的剖解提纲挈领，形而上学，引出线性代数的核心内容——向量空间。</p><span id="more"></span><h1 id="转置置换和向量空间r">转置、置换和向量空间R</h1><p>对于可逆矩阵<spanclass="math inline">\(A\)</span>，在消元过程中可能会遇到主元为0的情况，此时就需要进行行变换，而行变换的本质实际上就是左乘一个置换矩阵<spanclass="math inline">\(P\)</span>而已。上一讲中已经讲过了置换矩阵<spanclass="math inline">\(P\)</span>，当它左乘矩阵<spanclass="math inline">\(A\)</span>时，从行视角来看实际上就是对<spanclass="math inline">\(A\)</span>的行进行交换。当行变换找到新的不为0的主元时，消元得以继续进行。所以完全体应该写作<spanclass="math inline">\(PA=LU\)</span>。</p><h2 id="对称矩阵">对称矩阵</h2><p>转置以后矩阵没有发生变化的矩阵，称为对称矩阵，即<spanclass="math inline">\(A^T=A\)</span>（置换矩阵群中有4个就是对称矩阵）。例如：<span class="math display">\[\begin{bmatrix}3 &amp; 1 &amp; 7\\ 1 &amp; 2 &amp; 9\\ 7 &amp; 9 &amp; 4\end{bmatrix}\]</span></p><p>如何得到对称阵呢？一种简单的生成方法是：矩阵的转置和矩阵自身相乘<spanclass="math inline">\((R^TR)\)</span>。</p><p>证明如下： <span class="math display">\[(R^TR)^T = R^T(R^T)^T = R^TR\]</span></p><p>可以看到，<span class="math inline">\(R^TR\)</span>转置后还是<spanclass="math inline">\(R^TR\)</span>，故为对称阵。</p><h2 id="向量空间">向量空间</h2><p>所谓向量空间，它表示的是由一组向量集合共同构成的某个空间。然而，并非任意的向量集合都可以组成空间，空间必须得满足这一法则：对线性运算（加法与数乘）封闭。如果集合内任意向量的线性运算结果仍然在空间之内，那么构成的就是向量空间。显然，向量空间至少包含原点（<spanclass="math inline">\(v-v=0\)</span>），也就是零向量。</p><p>高维向量空间又包含各种低维的向量子空间。</p><h3 id="二维向量空间">二维向量空间</h3><p>对于<spanclass="math inline">\(R^2\)</span>来说，向量空间内的子空间可以轻易的枚举：</p><ul><li><span class="math inline">\(R^2\)</span>本身（构成一个平面）</li><li>任何过原点的直线</li><li>零向量空间(只包含零向量)</li></ul><h3 id="三维向量空间">三维向量空间</h3><p>进一步，扩展到<spanclass="math inline">\(R^3\)</span>，子空间就多了一个维度：</p><ul><li><span class="math inline">\(R^3\)</span>本身</li><li>任何过原点的平面</li><li>任何过原点的直线</li><li>零向量空间(只包含零向量)</li></ul><p>显然，<spanclass="math inline">\(R^2\)</span>的向量子空间是更高维度<spanclass="math inline">\(R^3\)</span>子空间的子集，以此类推。</p><h3 id="列空间简述">列空间简述</h3><p>那么矩阵是如何构建向量子空间的呢？显而易见的方法是通过枚举列向量来构造：即选取各列进行线性组合，所有线性组合的结果构成的就是一个特定的子空间，这个子空间一般称作矩阵的列空间，记为<spanclass="math inline">\(C(A)\)</span>，它也是矩阵4大子空间中的一个。</p><blockquote><p>这一讲主要是为了让大家先接受向量空间这一概念，因为线性代数的核心都是围绕着向量空间来描摹，如果不能在脑海中将矩阵投射成向量空间来理解，那么后续的课程也都无法真正掌握。</p></blockquote><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569897195&amp;p=5&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B05%5D%20%E8%BD%AC%E7%BD%AE-%E8%BD%AC%E6%8D%A2-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%20R/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%5B%E4%BA%94%5D.pdf">转置-转换-向量空间R</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(四)——A的LU分解</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%9B%9B)%E2%80%94%E2%80%94A%E7%9A%84LU%E5%88%86%E8%A7%A3/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%9B%9B)%E2%80%94%E2%80%94A%E7%9A%84LU%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>本讲主要是围绕<span class="math inline">\(A\)</span>的<spanclass="math inline">\(LU\)</span>分解，深入展开矩阵乘法、逆与转置的关系。最后自然而然的引出了置换矩阵。</p><span id="more"></span><h1 id="a的lu分解"><span class="math inline">\(A\)</span>的<spanclass="math inline">\(LU\)</span>分解</h1><h2 id="ab的逆"><span class="math inline">\(AB\)</span>的逆</h2><p><span class="math inline">\(AB\)</span>如果有逆，那么其逆显然是<spanclass="math inline">\(B^{-1}A^{-1}\)</span>，因为有： <spanclass="math display">\[\begin{align}(AB)(B^{-1} A^{-1})=I\\ (B^{-1} A^{-1})(AB)=I\end{align}\]</span></p><p>根据结合律法则，我们把括号挪一下，俩俩结合成<spanclass="math inline">\(I\)</span>，上式一目了然。</p><h2 id="ab的转置"><span class="math inline">\(AB\)</span>的转置</h2><p>显然是<span class="math inline">\(B^TA^T\)</span>（对结果<spanclass="math inline">\(C\)</span>中的每个元素求和分别计算即可证等），由此可见转置如果想要拆除括号，则内层矩阵的转置顺序要倒置。</p><h2 id="at的逆"><span class="math inline">\(A^T\)</span>的逆</h2><p>显然： <span class="math display">\[\begin{align}(AA^{-1})^T = I^T = I\\ (A^{-1})^TA^T = I\end{align}\]</span></p><p>因此<span class="math inline">\(A^T\)</span>的逆矩阵就是<spanclass="math inline">\((A^{-1})^T\)</span>，即<spanclass="math inline">\((A^T)^{-1}=(A^{-1})^T\)</span>，因此得出：对单个矩阵，转置和取逆操作顺序可以互换。</p><h2 id="alu和eau的关系"><span class="math inline">\(A=LU\)</span>和<spanclass="math inline">\(EA=U\)</span>的关系</h2><p>通过不断的左乘<spanclass="math inline">\(E_{xy}\)</span>做高斯消元，可以让矩阵<spanclass="math inline">\(A\)</span>变换为<spanclass="math inline">\(U\)</span>，而只需要在等号两边同时左乘<spanclass="math inline">\(E^{-1}\)</span>，就得到<spanclass="math inline">\(A=E^{-1}U\)</span>，显然，<spanclass="math inline">\(L\)</span>和<spanclass="math inline">\(E\)</span>互为逆矩阵。高斯消元本质上做的是行变换，最终得到的<spanclass="math inline">\(U\)</span>是一个上三角阵，而<spanclass="math inline">\(L\)</span>则是一个下三角阵。</p><p><span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(A\)</span>变换为<spanclass="math inline">\(LU\)</span>需要的计算量有多少呢？对100阶方阵，从第2行开始到第100行针对列1元素都需要进行行变换，每行有100个元素，计算次数为<spanclass="math inline">\(99\times100\)</span>，然后对于列2，则需要从第3行开始到第100行，计算次数为<spanclass="math inline">\(98\times99\)</span>，递归下去，总的时间复杂度可用平方和来预估：<spanclass="math inline">\(O(n^2+(n-1)^2+\dots+2^2+1^2)\)</span>，即<spanclass="math inline">\(O(\frac{n^3}{3})\)</span>。</p><h2 id="置换矩阵">置换矩阵</h2><p>3阶置换矩阵有6个： <span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\end{bmatrix}\]</span></p><p>这6个置换矩阵组成了一个很有意思的矩阵群（任取两个矩阵相乘，结果仍在该矩阵群中），它们有非常有意思的性质：置换矩阵的逆等于其转置，这一点非常好理解，相当于被交换的行又再次被交换回来。</p><p>根据每行中1的位置，可以知道<spanclass="math inline">\(n\)</span>阶方阵的置换矩阵个数就是全排列数：共<spanclass="math inline">\(\binom{n}{1}=n!\)</span>个。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569890100&amp;p=4&amp;autoplay=0" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B04%5DA%20%E7%9A%84%20LU%20%E5%88%86%E8%A7%A3/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%5B%E5%9B%9B%5D.pdf">A的LU分解</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(三)——乘法和逆矩阵</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%89)%E2%80%94%E2%80%94%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%89)%E2%80%94%E2%80%94%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p>这一讲是对矩阵乘法和逆矩阵的深入说明。矩阵乘法主要介绍了按不同视角来理解的多种计算方式。逆矩阵则给出了求解非奇异矩阵的逆矩阵的方法。</p><span id="more"></span><h1 id="乘法和逆矩阵">乘法和逆矩阵</h1><h2 id="矩阵乘法的视觉意义">矩阵乘法的视觉意义</h2><p>矩阵乘法<span class="math inline">\(AB=C\)</span>，其中<spanclass="math inline">\(A\)</span>是<span class="math inline">\(m\timesn\)</span>阵，<span class="math inline">\(B\)</span>是<spanclass="math inline">\(n\times p\)</span>阵，我们知道得到的<spanclass="math inline">\(C\)</span>是一个<spanclass="math inline">\(m\times p\)</span>阵。对于<spanclass="math inline">\(C\)</span>中第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(j\)</span>列元素<spanclass="math inline">\(C_{ij}\)</span>。</p><p>从不同视角看矩阵乘法，我们可以给出不同的计算式：</p><h3 id="从每个元素的角度">从每个元素的角度</h3><p>有： <span class="math display">\[c_{ij}=row_i\cdot column_j = \sum_{k=i}^na_{ik}b_{kj}\]</span></p><p>其中<span class="math inline">\(a_{ik}\)</span>是矩阵<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(k\)</span>列元素，<spanclass="math inline">\(b_{kj}\)</span>是<spanclass="math inline">\(B\)</span>矩阵第<spanclass="math inline">\(k\)</span>行第<spanclass="math inline">\(j\)</span>列元素。 <spanclass="math inline">\(c_{ij}\)</span>可以看成是<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行乘以<spanclass="math inline">\(B\)</span>的第<spanclass="math inline">\(j\)</span>列。</p><h3 id="列的线性组合">列的线性组合</h3><p>从列的角度看，<span class="math inline">\(C\)</span>的各列是<spanclass="math inline">\(A\)</span>中各列的线性组合，组合方式由<spanclass="math inline">\(B\)</span>来确定。比如<spanclass="math inline">\(C\)</span>的第一列是 <spanclass="math inline">\(A\)</span>中各列相对于<spanclass="math inline">\(B\)</span>的第一列的一个线性组合。</p><p><span class="math display">\[\begin{bmatrix}&amp;&amp;\\ A_{col1}&amp;A_{col2}&amp;\cdots&amp;A_{coln}\\ &amp;&amp;\end{bmatrix}\begin{bmatrix}\cdots&amp;b_{1j}&amp;\cdots\\ \cdots&amp;b_{2j}&amp;\cdots\\ \cdots&amp;\vdots&amp;\cdots\\ \cdots&amp;b_{nj}&amp;\cdots\\ \end{bmatrix}=\begin{bmatrix}&amp;&amp;\\\cdots&amp;\left(b_{1j}A_{col1}+b_{2j}A_{col2}+\cdots+b_{nj}A_{coln}\right)&amp;\cdots\\ &amp;&amp;\end{bmatrix}\]</span></p><p>上面的运算为<span class="math inline">\(B\)</span>的第<spanclass="math inline">\(j\)</span>个列向量右乘矩阵<spanclass="math inline">\(A\)</span>，求得的结果就是<spanclass="math inline">\(C\)</span>矩阵的第<spanclass="math inline">\(j\)</span>列，即<spanclass="math inline">\(C\)</span>的第<spanclass="math inline">\(j\)</span>列是<spanclass="math inline">\(A\)</span>的列向量以<spanclass="math inline">\(B\)</span>的第<spanclass="math inline">\(j\)</span>列作为系数所求得的线性组合，<spanclass="math inline">\(C_j=b_{1j}A_{col1}+b_{2j}A_{col2}+\cdots+b_{nj}A_{coln}\)</span>。</p><h3 id="行的线性组合">行的线性组合</h3><p><span class="math inline">\(C\)</span>的各行是<spanclass="math inline">\(B\)</span>中各行的一个线性组合，组合方式由<spanclass="math inline">\(A\)</span>决定。比如<spanclass="math inline">\(C\)</span>的第一行是<spanclass="math inline">\(B\)</span>中各行相对于<spanclass="math inline">\(A\)</span>的第一行的一个线性组合。</p><p><span class="math display">\[\begin{bmatrix}\vdots&amp;\vdots&amp;\vdots&amp;\vdots\\ a_{i1}&amp;a_{i2}&amp;\cdots&amp;a_{in}\\ \vdots&amp;\vdots&amp;\vdots&amp;\vdots\end{bmatrix}\begin{bmatrix}&amp;B_{row1}&amp;\\ &amp;B_{row2}&amp;\\ &amp;\vdots&amp;\\ &amp;B_{rown}&amp;\end{bmatrix}=\begin{bmatrix}\vdots\\ \left(a_{i1}B_{row1}+a_{i2}B_{row2}+\cdots+a_{in}B_{rown}\right)\\ \vdots\end{bmatrix}\]</span></p><p>上面的运算为<span class="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>个行向量左乘矩阵<spanclass="math inline">\(B\)</span>，求得的结果就是<spanclass="math inline">\(C\)</span>矩阵的第<spanclass="math inline">\(i\)</span>行，即<spanclass="math inline">\(C\)</span>的第<spanclass="math inline">\(i\)</span>行是<spanclass="math inline">\(B\)</span>的行向量以<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行作为系数所求的的线性组合，<spanclass="math inline">\(C_i=a_{i1}B_{row1}+a_{i2}B_{row2}+\cdots+a_{in}B_{rown}\)</span>。</p><h3 id="从矩阵的角度看">从矩阵的角度看</h3><p><span class="math inline">\(A\)</span>的列乘以<spanclass="math inline">\(B\)</span>的行： <span class="math display">\[\begin{bmatrix}&amp;&amp;\\ A_{col1}&amp;A_{col2}&amp;\cdots&amp;A_{coln}\\ &amp;&amp;\end{bmatrix}\begin{bmatrix}&amp;B_{row1}&amp;\\ &amp;B_{row2}&amp;\\ &amp;\vdots&amp;\\ &amp;B_{rown}&amp;\end{bmatrix}=A_{col1}B_{row1}+A_{col2}B_{row2}+\cdots+A_{coln}B_{rown}\]</span></p><p><span class="math inline">\(A_{coli}B_{rowi}\)</span>是一个<spanclass="math inline">\(m\times 1\)</span>向量乘以一个<spanclass="math inline">\(1\times p\)</span>向量，其结果是一个<spanclass="math inline">\(m\times p\)</span>矩阵，而所有的<spanclass="math inline">\(m\times p\)</span>矩阵之和就是计算结果。</p><h3 id="分块来看">分块来看</h3><p><span class="math display">\[\left[\begin{array}{c|c}A_1&amp;A_2\\ \hlineA_3&amp;A_4\end{array}\right]\left[\begin{array}{c|c}B_1&amp;B_2\\\hlineB_3&amp;B_4\end{array}\right]=\left[\begin{array}{c|c}A_1B_1+A_2B_3&amp;A_1B_2+A_2B_4\\\hline A_3B_1+A_4B_3&amp;A_3B_2+A_4B_4\end{array}\right]\]</span></p><p>简写成： <span class="math display">\[\left[\begin{array}{c|c}A_1&amp;A_2\\ \hlineA_3&amp;A_4\end{array}\right]\left[\begin{array}{c|c}B_1&amp;B_2\\\hlineB_3&amp;B_4\end{array}\right]=\left[\begin{array}{c|c}C_1&amp;C_2\\\hline C_3&amp;C_4\end{array}\right]\]</span></p><p>可以看到 矩阵完全可以拆成多个块，各块的关联关系也一目了然。</p><h2 id="逆矩阵">逆矩阵</h2><p>逆矩阵分为左逆和右逆，不是所有方阵都可逆，对于方阵来说，左逆和右逆是相等的。</p><p>对这些有逆的矩阵，我们称其为可逆的或非奇异的。</p><p>如何判断一个矩阵是可逆的？从列图像来看，如果<spanclass="math inline">\(A^{-1}\)</span>存在，那么有<spanclass="math inline">\(AA^{-1}=I\)</span>，如果<spanclass="math inline">\(A\)</span>中各列无法线性组合成单位阵，则矩阵不可逆。相反，如果可以找到非零向量<spanclass="math inline">\(x\)</span>使得<spanclass="math inline">\(Ax=0\)</span>有解，那么<spanclass="math inline">\(A\)</span>也是不可逆的（某些列是相关的，反证法非常容易求证）。</p><p>那么如何求解一个逆矩阵呢？可以采用高斯-若尔当思想：构造这样一个增广矩阵： <spanclass="math inline">\(\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\\2&amp;7&amp;0&amp;1\end{array}\right]\)</span>，</p><p>右侧补充一个单位阵<spanclass="math inline">\(I\)</span>，接下来用消元法将左侧变为单位矩阵：</p><p><span class="math display">\[\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\\2&amp;7&amp;0&amp;1\end{array}\right]\xrightarrow{row_2-2row_1}\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\\0&amp;1&amp;-2&amp;1\end{array}\right]\xrightarrow{row_1-3row_2}\left[\begin{array}{cc|cc}1&amp;0&amp;7&amp;-3\\0&amp;1&amp;-2&amp;1\end{array}\right]\]</span></p><p>于是，我们就将矩阵从<spanclass="math inline">\(\left[\begin{array}{c|c}A&amp;I\end{array}\right]\)</span>变为<spanclass="math inline">\(\left[\begin{array}{c|c}I&amp;A^{-1}\end{array}\right]\)</span></p><p>而高斯-若尔当思想的本质是使用消元矩阵<spanclass="math inline">\(E\)</span>，对<spanclass="math inline">\(A\)</span>进行操作，<spanclass="math inline">\(E\left[\begin{array}{c|c}A&amp;I\end{array}\right]\)</span>，利用一步步消元有<spanclass="math inline">\(EA=I\)</span>，进而得到<spanclass="math inline">\(\left[\begin{array}{c|c}I&amp;E\end{array}\right]\)</span>，其实这个消元矩阵<spanclass="math inline">\(E\)</span>就是<spanclass="math inline">\(A^{-1}\)</span>，而高斯-若尔当法中的<spanclass="math inline">\(I\)</span>只是负责记录消元的每一步操作，待消元完成，逆矩阵就自然出现了。</p><p><strong>结论：如果矩阵可以通过行变换变成<spanclass="math inline">\(I\)</span>，那么矩阵就是可逆的。</strong></p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569894536&amp;p=3&amp;autoplay=0" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B03%5D%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%5B%E4%B8%89%5D.pdf">乘法和逆矩阵</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(二)——矩阵消元</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83/</url>
    
    <content type="html"><![CDATA[<p>高斯消元法是如今小学生都耳熟能详的解决齐次线性方程组的方法，课程第二讲主要讲授了高斯消元法应用在矩阵上的视觉效果与解读。</p><span id="more"></span><h1 id="矩阵消元">矩阵消元</h1><h2 id="非矩阵视角的消元">非矩阵视角的消元</h2><p>有三元方程组： <spanclass="math inline">\(\begin{cases}  x&amp;+2y&amp;+z&amp;=2  \\3x&amp;+8y&amp;+z&amp;=12  \\&amp;4y&amp;+z&amp;=2  \end{cases}\)</span></p><p>如果我们想通过消元法来解决，那么一般是考虑选中其中的一行，乘以某个系数对另外两行进行加法（系数为负就是减法）操作，以消除掉<spanclass="math inline">\(x\)</span>未知数，如此，后两个方程组就变成了二元一次方程组求解问题，而方法也是以此类推，用其中的一个消掉另一个的<spanclass="math inline">\(y\)</span>，最终剩下的那一行就只有<spanclass="math inline">\(z\)</span>了。在解出<spanclass="math inline">\(z\)</span>以后，再将<spanclass="math inline">\(z\)</span>回代到方程组，进而再解另外两个未知数<spanclass="math inline">\(x,y\)</span>。这种方法我们在小学的时候就已经掌握了。</p><h2 id="矩阵视角的消元">矩阵视角的消元</h2><p>方程组对应的矩阵形式<span class="math inline">\(Ax=b\)</span>为：<span class="math inline">\(\begin{bmatrix}  1&amp;2&amp;1  \\3&amp;8&amp;1  \\ 0&amp;4&amp;1  \end{bmatrix}\begin{bmatrix}  x  \\y  \\ z  \end{bmatrix}=\begin{bmatrix}  2  \\ 12  \\2\end{bmatrix}\)</span>。</p><p>实际上如果将消元的手法应用到矩阵上，本质上也并没有什么不同，从矩阵的视角来看，消元的第一步是选定第一行的第一个元素作为主元（对应<spanclass="math inline">\(x\)</span>系数），分别乘以不同的系数对第二、三行进行加法操作，进而消除掉第二、三行的首个元素。由于第三行原本首个元素就是0，故这里只需要对第二行操作：<spanclass="math inline">\(\begin{bmatrix}  \underline{1}&amp;2&amp;1  \\3&amp;8&amp;1  \\0&amp;4&amp;1\end{bmatrix}\xrightarrow{row_2-3row_1}\begin{bmatrix}  \underline{1}&amp;2&amp;1  \\0&amp;2&amp;-2  \\ 0&amp;4&amp;1\end{bmatrix}\)</span></p><p>这里暂时先不管对<spanclass="math inline">\(b\)</span>的影响（实际上也要跟着变化），矩阵<spanclass="math inline">\(A\)</span>经过消元变成了这个样子。</p><p>接下来，我们如法炮制，选择第二行的第二个元素(对应<spanclass="math inline">\(y\)</span>系数)作为主元，对第三行进行消元动作：<spanclass="math inline">\(\begin{bmatrix}  \underline{1}&amp;2&amp;1  \\0&amp;\underline{2}&amp;-2  \\0&amp;4&amp;1\end{bmatrix}\xrightarrow{row_3-2row_2}\begin{bmatrix}\underline{1}&amp;2&amp;1  \\0&amp;\underline{2}&amp;-2  \\0&amp;0&amp;\underline{5}\end{bmatrix}\)</span></p><p>到此，消元动作结束，最后一行仅剩<spanclass="math inline">\(z\)</span>的系数，即第三个元素5。</p><p>上例的矩阵是精心设计的，实际上消元过程中可能会遇到一些失效的情形：首先主元不能为0，为0的主元无论乘上什么样的系数都无法消除其他行的对应列。其次，如果消元过程中遇到主元位置为0，则需要交换行，使主元不为0。</p><p>消元结束后，我们就可以进行回代，由于方程组在矩阵消元时发生了变化，我们需要对<spanclass="math inline">\(b\)</span>也进行相同的操作以同步这些变化，如此我们写成下面的增广矩阵形式：<span class="math display">\[\left[\begin{array}{c|c}A&amp;b\end{array}\right]=\left[\begin{array}{ccc|c}  1&amp;2&amp;1&amp;2  \\ 3&amp;8&amp;1&amp;12  \\ 0&amp;4&amp;1&amp;2  \end{array}\right]\to\left[\begin{array}{ccc|c}1&amp;2&amp;1&amp;2\\ 0&amp;2&amp;-2&amp;6\\ 0&amp;4&amp;1&amp;2\end{array}\right]\to\left[\begin{array}{ccc|c}1&amp;2&amp;1&amp;2\\ 0&amp;2&amp;-2&amp;6\\ 0&amp;0&amp;5&amp;-10\end{array}\right]\]</span></p><p>此时方程组变为：<spanclass="math inline">\(\begin{cases}x&amp;+2y&amp;+z&amp;=2\\&amp;2y&amp;-2z&amp;=6\\&amp;&amp;5z&amp;=-10\end{cases}\)</span>，最后一行可以得出<spanclass="math inline">\(z=-2\)</span>，回代到<spanclass="math inline">\(2y-2z=6\)</span>得到<spanclass="math inline">\(y=1\)</span>，再进一步得到<spanclass="math inline">\(x=2\)</span>。</p><blockquote><p>可以用这里的方程组和我们小学时学到的消元法得到的方程组作对比，本质上完全一样。</p></blockquote><h2 id="矩阵消元的本质">矩阵消元的本质</h2><p>通过第一节课我们知道，对于矩阵乘法<spanclass="math inline">\(AB\)</span>可以看成是对矩阵<spanclass="math inline">\(B\)</span>中行按<spanclass="math inline">\(A\)</span>中系数的线性组合，如果<spanclass="math inline">\(B\)</span>想要维持不变，那么<spanclass="math inline">\(A\)</span>就得是个单位矩阵<spanclass="math inline">\(I\)</span>: <spanclass="math inline">\(\begin{bmatrix}  1&amp;0&amp;0  \\0&amp;1&amp;0  \\ 0&amp;0&amp;1\end{bmatrix}\)</span>这个单位矩阵就相当于我们实数运算中的1，只不过在矩阵的世界，它长这个样子。</p><blockquote><p>单位阵的三行彼此换一换，就能得到一个置换矩阵群，这个东西很有意思，以后会讲到。</p></blockquote><p>于是我们还原一下消元的第一步操作：<spanclass="math inline">\(row_2-3row_1\)</span> <spanclass="math inline">\(\begin{bmatrix}  1&amp;0&amp;0  \\-3&amp;1&amp;0  \\0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}  1&amp;2&amp;1  \\3&amp;8&amp;1  \\0&amp;4&amp;1\end{bmatrix}=\begin{bmatrix}  1&amp;2&amp;1  \\0&amp;2&amp;-2  \\ 0&amp;4&amp;1\end{bmatrix}\)</span></p><p>这个消元矩阵我们记作<spanclass="math inline">\(E_{21}\)</span>，即将第二行第一个元素变为0。</p><p>同理，我们找到<spanclass="math inline">\(E_{32}\)</span>，将第三行第二个元素变为0： <spanclass="math inline">\(\begin{bmatrix}  1&amp;0&amp;0  \\0&amp;1&amp;0  \\0&amp;-2&amp;1  \end{bmatrix}\begin{bmatrix}  1&amp;2&amp;1  \\0&amp;2&amp;-2  \\0&amp;4&amp;1\end{bmatrix}=\begin{bmatrix}  1&amp;2&amp;1  \\0&amp;2&amp;-2  \\ 0&amp;0&amp;5\end{bmatrix}\)</span></p><p><span class="math inline">\(E_{21}\)</span>和<spanclass="math inline">\(E_{32}\)</span>就是消元过程中用到的两个初等矩阵。</p><p>最后，我们将两步综合起来，即<spanclass="math inline">\(E_{32}(E_{21}A)=U\)</span>。矩阵的乘法是满足结合律的，所以这里的括号可以移动一下，即<spanclass="math inline">\((E_{32}E_{21})A=U\)</span>，这里的<spanclass="math inline">\(U\)</span>表示upper，即上三角矩阵（对角线下面的元素全都是0）。</p><h2 id="逆">逆</h2><p>如此，我们可以通过对<spanclass="math inline">\(A\)</span>做行变换得到<spanclass="math inline">\(U\)</span>，那么显然，如果要从<spanclass="math inline">\(U\)</span>变回<spanclass="math inline">\(A\)</span>我们只需要再反向操作一波即可，比如<spanclass="math inline">\(E_{21}\)</span>是从第二行减去三倍的第一行，那么它的反向操作就应该是第二行加上3倍的第一行，所以其逆矩阵就应该是<spanclass="math inline">\(\begin{bmatrix}1&amp;0&amp;0\\ 3&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix}\)</span>。</p><p>我们把矩阵<span class="math inline">\(E\)</span>的逆记作<spanclass="math inline">\(E^{-1}\)</span>，显然有<spanclass="math inline">\(E^{-1}E=I\)</span>，从行变换意义上来看，单位阵<spanclass="math inline">\(I\)</span>乘以<spanclass="math inline">\(A\)</span>相当于什么都没有改变，也就是二者抵消后的结果。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569889975&amp;p=2&amp;autoplay=0" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B02%5D%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%5B%E4%BA%8C%5D.pdf">矩阵消元</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(一)——方程组的几何解释</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E2%80%94%E2%80%94%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E2%80%94%E2%80%94%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<p>开篇第一讲主要通过线性方程组引出矩阵，并传授了如何通过<strong>行图像</strong>和<strong>列图像</strong>来分别理解矩阵的意义。最后基于列的线性组合视角来初步解答了这样的一个问题：对任意向量<spanclass="math inline">\(b\)</span>，能否求解<spanclass="math inline">\(Ax=b\)</span>。</p><span id="more"></span><h1 id="方程组的几何解释">方程组的几何解释</h1><h2 id="二元一次方程组">二元一次方程组</h2><p>方程组： <span class="math inline">\(\begin{cases}  2x&amp;-y&amp;=0\\  -x&amp;+2y&amp;=3 \end{cases}\)</span></p><p>写作矩阵形式有： <spanclass="math inline">\(\begin{bmatrix}  2&amp;-1 \\  -1&amp;2\end{bmatrix} \begin{bmatrix}  x \\  y \end{bmatrix}= \begin{bmatrix} 0\\ 3 \end{bmatrix}\)</span></p><p>第一个矩阵一般称为系数矩阵<spanclass="math inline">\(A\)</span>，第二个矩阵成为向量<spanclass="math inline">\(x\)</span>，第三个矩阵称为向量<spanclass="math inline">\(b\)</span>，线性方程组写为<spanclass="math inline">\(Ax=b\)</span>。</p><h2 id="行图像row-picture">行图像(Row picture)</h2><p>如上例，按行解读如下：</p><ul><li>第一行为2个x和-1个y组合成0</li><li>第二行为-1个x和2个y组合成3</li></ul><p>这种解读与我们此前对二元一次方程组的解读方法是一致的，我们都知道，二元一次方程组实际上就是求解二维平面两条直线的交点：<img src="2022-05-02-12-15-37.png" /></p><p>交点坐标为<span class="math inline">\((1,2)\)</span>，即<spanclass="math inline">\(x=1, y=2\)</span>为方程组的解。</p><h2 id="列图像column-picture">列图像(Column picture)</h2><p>那么，如果我们换一个视角呢？我们把矩阵<spanclass="math inline">\(A\)</span>拆成列向量，进行如下线性组合： <spanclass="math inline">\(x \begin{bmatrix}  2 \\  -1 \end{bmatrix}+y\begin{bmatrix} -1 \\ 2 \end{bmatrix}= \begin{bmatrix} 0 \\ 3\end{bmatrix}\)</span></p><p>那么就可以解读为<span class="math inline">\(x\)</span>个<spanclass="math inline">\(col_1\)</span>和<spanclass="math inline">\(y\)</span>个<spanclass="math inline">\(col_2\)</span>的组合，其中<spanclass="math inline">\(\begin{bmatrix}2\\-1\end{bmatrix}\)</span>称为<spanclass="math inline">\(col_1\)</span>，<spanclass="math inline">\(\begin{bmatrix}-1\\2\end{bmatrix}\)</span>称为<spanclass="math inline">\(col_2\)</span>。</p><p>肉眼观察就可以看出，需要1个<spanclass="math inline">\(col_1\)</span>和2个<spanclass="math inline">\(col_2\)</span>，组合起来就可以变成<spanclass="math inline">\(\begin{bmatrix}0\\3\end{bmatrix}\)</span>。因此同样得出<spanclass="math inline">\(x=1, y=2\)</span>。</p><p>列向量相加的几何意义： <img src="2022-05-02-13-01-08.png" /></p><p>绿向量<span class="math inline">\(col_1\)</span>与蓝向量<spanclass="math inline">\(col_2\)</span>相加，按照平行四边形法则，合成的就是红向量<spanclass="math inline">\(b\)</span>。</p><p>进一步思考<span class="math inline">\(col_1\)</span>和<spanclass="math inline">\(col_2\)</span>的所有线性组合能够得到什么呢？显然它们可以铺满整个二维平面。那么<spanclass="math inline">\(Ax=b\)</span>如果按照列的线性组合来看，<strong>求解<spanclass="math inline">\(Ax=b\)</span>实际上就是在问询对于给定的<spanclass="math inline">\(b\)</span>，是否能够找到一种组合方式来让<spanclass="math inline">\(A\)</span>中各列向量<spanclass="math inline">\(col_i\)</span>可以组合成列向量<spanclass="math inline">\(b\)</span>。</strong></p><h2 id="三元一次方程组">三元一次方程组</h2><p><span class="math inline">\(\begin{cases}  2x&amp;-y&amp;&amp;=0\\  -x&amp;+2y&amp;-z&amp;=-1 \\  &amp;-3y&amp;+4z&amp;=4\end{cases}\)</span></p><p>写作矩阵形式： <span class="math inline">\(A=\begin{bmatrix}2&amp;-1&amp;0 \\ -1&amp;2&amp;-1 \\ 0&amp;-3&amp;4\end{bmatrix}\)</span>,<span class="math inline">\(b=\begin{bmatrix} 0\\ -1 \\ 4 \end{bmatrix}\)</span></p><p>如果按行图像来思考：三维直角坐标系中，每个方程都将确定一个平面，三个平面会相交于一点，该点即为方程组的解。</p><p>如果按列图像来思考，拆写成： <spanclass="math inline">\(x\begin{bmatrix} 2 \\ -1 \\ 0\end{bmatrix}+y\begin{bmatrix} -1 \\  2 \\-3\end{bmatrix}+z\begin{bmatrix} 0 \\ -1 \\4\end{bmatrix}=\begin{bmatrix} 0 \\ -1 \\ 4\end{bmatrix}\)</span></p><p>也就是<span class="math inline">\(x\)</span>个<spanclass="math inline">\(col_1\)</span>，<spanclass="math inline">\(y\)</span>个<spanclass="math inline">\(col_2\)</span>和<spanclass="math inline">\(z\)</span>个<spanclass="math inline">\(col_3\)</span>线性组合成列向量<spanclass="math inline">\(b\)</span>。通过列视角来看这个方程组的解非常显然，只需要<spanclass="math inline">\(x=0,y=0,z=1\)</span>即可满足（<spanclass="math inline">\(z\)</span>刚好等于<spanclass="math inline">\(b\)</span>），而从行视角来看就没有那么一目了然。</p><blockquote><p>当然了，这是精心构造的一组例子，并不是说列视角就比行视角优越，只是培养列视角分析问题的sense对线性代数这门课（我觉着更像一门语言）来说非常重要。</p></blockquote><p>那么问题又回来了，对于任意<spanclass="math inline">\(b\)</span>，是否都能求解<spanclass="math inline">\(Ax=b\)</span>呢？用列向量视角来说，就是<spanclass="math inline">\(col_1,col_2,col_3\)</span>三个列向量的线性组合是否可以填满整个三维坐标系？对上例来说，答案是肯定的。因为实际上这个<spanclass="math inline">\(A\)</span>矩阵是个<strong>非奇异矩阵、可逆矩阵</strong>（后续课程会讲到），对于任意的列向量<spanclass="math inline">\(b\)</span>，它总是有解的。</p><p>那么在什么情况下，三个列向量的组合得不到所有的<spanclass="math inline">\(b\)</span>呢？试想这样一种情况：三个列向量在同一平面，那么无论它们如何组合，产生的列向量也一定在该平面上，因此，对于不在该平面的列向量<spanclass="math inline">\(b\)</span>，方程组就是无解的。后续课程会学习到这种情况叫做<strong>奇异矩阵、不可逆矩阵</strong>。</p><p>人类的大脑是三维的，所以四维以上的空间是无法具象化的，但是我们从二维到三维，和从三维到更高维的过程实际上并没有什么差别，因此，通过列视角的线性组合，哪怕是100维的向量，思考与处理也如法炮制。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569893465&amp;p=1&amp;autoplay=0" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B01%5D%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%5B%E4%B8%80%5D.pdf">方程组的几何解释</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>楔子</title>
    <link href="/2022/05/01/%E6%A5%94%E5%AD%90/"/>
    <url>/2022/05/01/%E6%A5%94%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>上次折腾博客还是醉心于binarysecurity的时节，如今却是弃之如敝履。彼时彼刻，正如此时此刻，何移之速也！</p><p>互联网变化之快让人越来越浮躁，工作越久、越难以静下心来去专研某个领域的知识，不学无术就愈发膨胀，一点点丧失核心竞争力，最后与前沿脱轨，熬成药渣，泄入深渊。我不知道一个人应该如何消化掉鸡飞蛋打、毫无成就的日常工作的挫败感和996福报带来的身心俱疲，只是入行这么多年，的的确确是弄丢了意气风发、快意恩仇，满脑子想的尽是冠冕堂皇的不粘锅、踢皮球，冰与火，周旋久。</p><span id="more"></span><p>用如今的流行梗来说：小僧没有那种世俗的欲望。“举世誉之而不加劝，举世非之而不加沮。不以物喜，不以己悲。”秉承着这样的人生信条，靠物我两忘屏蔽了职场所有的画饼和PUA，也接受了“是岁年大旱，衢州人食人”的魔幻与惨案，甚至乐在其中。坦白来说，我不红眼那些蹭上时代红利的既得利益者，也不在乎能不能坐上位高权重的玉座，毕生所求不过自由，而自由其实并不意味着“想做什么就可以做什么”，而是“不想做什么，就可以不做”。壁立千仞，无欲则刚。</p><p>这么多年过去，扪心自问这一身本领从何而来，只道是“年少轻狂不服气，万千道法书中藏。穷经皓首等闲事，千锤百炼证沧桑。”算来前前后后，一共经历了三重心境上的变化：</p><ol type="1"><li>待到秋来九月八，我花开后百花杀：以前觉着自己得天独厚，是故事的主角，只要是自己想做的，一定可以做到最好。因此接受不了自己的平庸，拼尽全力证明自己。</li><li>横看成岭侧成峰，远近高低各不同：几经挫折后发现人确实有不同的天赋，我要找到自己擅长的领域，做到最好；不擅长的东西不要强求。</li><li>沉舟侧畔千帆过，病树前头万木春：终于认识到人与人的差距比人与狗的差距还大，强中自有强中手，一山更比一山高，逐渐接受了自己的平庸，与自己妥协，但心意却更加坚定。</li></ol><p>当认识到自己是一个废物的时候，就再也没有包袱了：没有必要和别人比较，我只想看看自己的天花板有多高。遂重整旗鼓，勤将劝勉，闭关清修……这回必定给大伙整个好活~</p><p>千头万绪，百感交集，不知从何说起，唯愿顺其自然，一切随缘。飘蓬入海沉浮定，马齿徒增未可知。</p><p align="right">by 玉涵，写于2022年5月1日深夜，雨</p>]]></content>
    
    
    <categories>
      
      <category>杂感</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>chromium-base库源码解读之引用计数拆解篇</title>
    <link href="/2020/10/22/chromium-base%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%8B%86%E8%A7%A3%E7%AF%87/"/>
    <url>/2020/10/22/chromium-base%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%8B%86%E8%A7%A3%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>chromium-base库作为业界标杆实现，值得每一位开发者细细品读。本系列将围绕“基本概念、设计哲学、代码技巧”三个关键点来对chromium-base库进行深度剖析，本篇拆解“引用计数”。</p><span id="more"></span><h1id="chromium-base库源码解读之引用计数拆解篇">chromium-base库源码解读之引用计数拆解篇</h1><p>引用计数，应是开发者耳熟能详的概念，不做赘述。</p><p>封装一个引用计数类，无非就是内部维护一个计数器，然后提供一对Add/Release接口，在计数器归零时，将对象释放。引用计数类一般由开发者定义的子类继承，然后配合智能指针类一起使用，达到开发者无需关心对象的生命周期、通过智能指针将对象传来传去的目的（<del>妈妈再也不用担心内存泄漏了（然而并不一定）</del>）。</p><p>chromium-base的引用计数类封装在<code>base/memory/ref_counted.h</code>，分别命名为<code>RefCounted</code>和<code>RefCountedThreadSafe</code>，顾名思义，后者是线程安全的。</p><p>读本文前，最好先阅读《chromium-base库源码解读之智能指针拆解篇》。</p><h2 id="refcounted"><code>RefCounted</code></h2><p>这是个类模板，形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">typename</span> Traits = DefaultRefCountedTraits&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> RefCounted : <span class="hljs-keyword">public</span> subtle::RefCountedBase &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>其他类如果想要使用<code>RefCounted</code>类，一般会通过公有继承<code>RefCounted&lt;T&gt;</code>来实现，<code>T</code>就是类本身的名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFoo</span> : <span class="hljs-keyword">public</span> RefCounted&lt;MyFoo&gt; &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 引用计数对象的消亡无需（且不能由）外部接管，故析构器为private/protected权限</span><br>    <span class="hljs-comment">// 对象的析构由RefCounted&lt;&gt;在合适的时点(引用计数归0)执行，所以要声明为友元类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCounted</span>&lt;MyFoo&gt;;  <span class="hljs-comment">// Allow destruction by RefCounted&lt;&gt;.</span><br>    ~<span class="hljs-built_in">MyFoo</span>();                        <span class="hljs-comment">// Destructor must be private/protected.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>另外它公有继承了<code>subtle::RefCountedBase</code>这么个基类，subtle是base内部的命名空间，对外曝光的类去公有继承一个<code>XXXBase</code>的基类，这是老套路了。</p><h3 id="subtlerefcountedbase"><code>subtle::RefCountedBase</code></h3><p>我们先看看基类（移除了调试用的各种脚手架）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCountedBase</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 两个对外曝光的接口，用于判断引用计数个数</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasOneRef</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ref_count_ == <span class="hljs-number">1</span>; &#125;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasAtLeastOneRef</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ref_count_ &gt;= <span class="hljs-number">1</span>; &#125;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// StartRefCountFromZeroTag和StartRefCountFromOneTag是两种枚举类型</span><br>  <span class="hljs-comment">// 使用枚举类型做构造器参数，主要是为了表意（算是见名知意）</span><br>  <span class="hljs-comment">// explicit禁用了危险的隐式转换</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCountedBase</span><span class="hljs-params">(StartRefCountFromZeroTag)</span> </span>&#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCountedBase</span><span class="hljs-params">(StartRefCountFromOneTag)</span> : ref_count_(<span class="hljs-number">1</span>) &#123;</span>&#125;<br><br>  ~<span class="hljs-built_in">RefCountedBase</span>() &#123;&#125;<br><br>  <span class="hljs-comment">// AddRef和Release就是核心的add/release语义接口，实际上是个wrapper</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRef</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-built_in">AddRefImpl</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// Returns true if the object should self-delete.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Release</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-built_in">ReleaseImpl</span>();<br>    <span class="hljs-keyword">return</span> ref_count_ == <span class="hljs-number">0</span>;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// 该友元函数用于RefCountedBase(StartRefCountFromOneTag)构造的场景</span><br>  <span class="hljs-comment">// 返回对象的智能指针对象scoped_refptr&lt;U&gt;</span><br>  <span class="hljs-comment">// scoped_refptr的解析请参考《chromium-base库源码解读之智能指针拆解篇》</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> scoped_refptr&lt;U&gt; <span class="hljs-title">base::AdoptRef</span><span class="hljs-params">(U*)</span></span>;<br><br><span class="hljs-comment">// 这里才是add/release语义的真正实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ARCH_CPU_64_BITS)</span><br>  <span class="hljs-comment">// 对64位来说，位数充足的溢出会导致安全漏洞，所以不能简单的++/--</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRefImpl</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReleaseImpl</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRefImpl</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; ++ref_count_; &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReleaseImpl</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; --ref_count_; &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">// 经典mutable+const函数限定，以支持const对象</span><br>  <span class="hljs-keyword">mutable</span> <span class="hljs-type">uint32_t</span> ref_count_ = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 直接用了标准库的型别萃取，确保编译环境下uint32_t是种无符号类型</span><br>  <span class="hljs-built_in">static_assert</span>(std::is_unsigned&lt;<span class="hljs-keyword">decltype</span>(ref_count_)&gt;::value,<br>                <span class="hljs-string">&quot;ref_count_ must be an unsigned type.&quot;</span>);<br><br>  <span class="hljs-comment">// 禁用拷贝构造器和赋值操作符</span><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(RefCountedBase);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>知识点：C++11之后，禁用默认生成的拷贝构造器和赋值操作符有了更表意的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ALL DISALLOW_xxx MACROS ARE DEPRECATED; DO NOT USE IN NEW CODE.</span><br><span class="hljs-comment">// Use explicit deletions instead.  See the section on copyability/movability in</span><br><span class="hljs-comment">// //styleguide/c++/c++-dos-and-donts.md for more information.</span><br><br><span class="hljs-comment">// Put this in the declarations for a class to be uncopyable.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISALLOW_COPY(TypeName) \</span><br><span class="hljs-meta">  TypeName(const TypeName&amp;) = delete</span><br><br><span class="hljs-comment">// Put this in the declarations for a class to be unassignable.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISALLOW_ASSIGN(TypeName) TypeName&amp; operator=(const TypeName&amp;) = delete</span><br><br><span class="hljs-comment">// Put this in the declarations for a class to be uncopyable and unassignable.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISALLOW_COPY_AND_ASSIGN(TypeName) \</span><br><span class="hljs-meta">  DISALLOW_COPY(TypeName);                 \</span><br><span class="hljs-meta">  DISALLOW_ASSIGN(TypeName)</span><br></code></pre></td></tr></table></figure><p>利用<code>=delete</code>语法糖，相比C++11之前的仅声明不定义的迂回写法，更加易懂。</p></blockquote><p>64位机器需要对上溢和下溢做检查：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// For security and correctness, we check the arithmetic on ref counts.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// In an attempt to avoid binary bloat (from inlining the `CHECK`), we define</span><br><span class="hljs-comment">// these functions out-of-line. However, compilers are wily. Further testing may</span><br><span class="hljs-comment">// show that `NOINLINE` helps or hurts.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ARCH_CPU_64_BITS)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RefCountedBase::AddRefImpl</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-comment">// An attacker could induce use-after-free bugs, and potentially exploit them,</span><br>  <span class="hljs-comment">// by creating so many references to a ref-counted object that the reference</span><br>  <span class="hljs-comment">// count overflows. On 32-bit architectures, there is not enough address space</span><br>  <span class="hljs-comment">// to succeed. But on 64-bit architectures, it might indeed be possible.</span><br>  <span class="hljs-comment">// Therefore, we can elide the check for arithmetic overflow on 32-bit, but we</span><br>  <span class="hljs-comment">// must check on 64-bit.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Make sure the addition didn&#x27;t wrap back around to 0. This form of check</span><br>  <span class="hljs-comment">// works because we assert that `ref_count_` is an unsigned integer type.</span><br>  <span class="hljs-built_in">CHECK</span>(++ref_count_ != <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RefCountedBase::ReleaseImpl</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-comment">// Make sure the subtraction didn&#x27;t wrap back around from 0 to the max value.</span><br>  <span class="hljs-comment">// That could cause memory leaks, and may induce application-semantic</span><br>  <span class="hljs-comment">// correctness or safety bugs. (E.g. what if we really needed that object to</span><br>  <span class="hljs-comment">// be destroyed at the right time?)</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Note that unlike with overflow, underflow could also happen on 32-bit</span><br>  <span class="hljs-comment">// architectures. Arguably, we should do this check on32-bit machines too.</span><br>  <span class="hljs-built_in">CHECK</span>(--ref_count_ != std::numeric_limits&lt;<span class="hljs-keyword">decltype</span>(ref_count_)&gt;::<span class="hljs-built_in">max</span>());<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>对于上溢来说，32位无须检查的理由是：32位架构中这种通过疯狂创建引用的攻击手法会因为没有足够的地址空间而不奏效；但对下溢来说，实际上32位架构也可以奏效，目前chromium-base库并没对32位的<code>ReleaseImpl</code>做检查，这就为漏洞利用留了操作空间。</p><blockquote><p>知识点：CHECK宏实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Discard log strings to reduce code bloat.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This is not calling BreakDebugger since this is called frequently, and</span><br><span class="hljs-comment">// calling an out-of-line function instead of a noreturn inline macro prevents</span><br><span class="hljs-comment">// compiler optimizations.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHECK(condition) \</span><br><span class="hljs-meta">  UNLIKELY(!(condition)) ? IMMEDIATE_CRASH() : EAT_CHECK_STREAM_PARAMS()</span><br><br><span class="hljs-comment">// Macro for hinting that an expression is likely to be false.</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(UNLIKELY)</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(COMPILER_GCC) || defined(__clang__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNLIKELY(x) __builtin_expect(!!(x), 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNLIKELY(x) (x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// defined(COMPILER_GCC)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// !defined(UNLIKELY)</span></span><br></code></pre></td></tr></table></figure><p>UNLIKELY宏的包装是为了提升gcc和clang对分支处理的效率，可以参考：</p><p>https://www.jianshu.com/p/2684613a300f</p><p>后两个宏不展开了，要根据编译器和指令集来细分，前者会导致程序崩溃，后者返回0。</p></blockquote><hr /><p>回头来看<code>RefCounted</code>类模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">typename</span> Traits&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCounted</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DefaultRefCountedTraits</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Destruct</span><span class="hljs-params">(<span class="hljs-type">const</span> T* x)</span> </span>&#123;<br>    <span class="hljs-comment">// 友元类可以调用RefCounted&lt;T,Traits&gt;的private静态函数</span><br>    RefCounted&lt;T, DefaultRefCountedTraits&gt;::<span class="hljs-built_in">DeleteInternal</span>(x);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">typename</span> Traits = DefaultRefCountedTraits&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> RefCounted : <span class="hljs-keyword">public</span> subtle::RefCountedBase &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 定义一个静态枚举常量，这个枚举值用于从0引用计数起始创建对象</span><br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> subtle::StartRefCountFromZeroTag kRefCountPreference =<br>      subtle::kStartRefCountFromZeroTag;<br><br>  <span class="hljs-comment">// 这里之所以写成T::kRefCountPreference是因为T会继承RefCounted&lt;T&gt;</span><br>  <span class="hljs-comment">// 所以类T本身可以覆盖定义kRefCountPreference，如未定义，则继承上面的static变量</span><br>  <span class="hljs-built_in">RefCounted</span>() : subtle::<span class="hljs-built_in">RefCountedBase</span>(T::kRefCountPreference) &#123;&#125;<br><br>  <span class="hljs-comment">// AddRef和Release只是个代理</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRef</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    subtle::RefCountedBase::<span class="hljs-built_in">AddRef</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Release</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (subtle::RefCountedBase::<span class="hljs-built_in">Release</span>()) &#123;<br>  <span class="hljs-comment">// 返回true表示引用计数归0，调用T的析构器</span><br>      <span class="hljs-comment">// 指向本对象的指针实际上是继承了RefCounted&lt;T&gt;的T对象，所以cast即可</span><br>      <span class="hljs-comment">// const修饰是为了同时兼容const和非const T对象</span><br>      <span class="hljs-comment">// Traits默认实参是DefaultRefCountedTraits&lt;T&gt;，Destruct是其静态函数</span><br>      Traits::<span class="hljs-built_in">Destruct</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> T*&gt;(<span class="hljs-keyword">this</span>));<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">protected</span>:<br>  ~<span class="hljs-built_in">RefCounted</span>() = <span class="hljs-keyword">default</span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// 声明为友元类，因为它需要调用DeleteInternal</span><br>  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DefaultRefCountedTraits</span>&lt;T&gt;;<br>  <span class="hljs-comment">// 兜兜转转，实际上就是个delete</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DeleteInternal</span><span class="hljs-params">(<span class="hljs-type">const</span> U* x)</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span> x;<br>  &#125;<br><br>  <span class="hljs-comment">// 经典禁用拷贝构造器和赋值操作符</span><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(RefCounted);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的<code>kRefCountPreference</code>静态成员变量值得一提，内置默认的是<code>subtle::kStartRefCountFromZeroTag</code>，象征着<code>RefCountedBase</code>的<code>ref_count_</code>成员的0值，因此构造器的初始化列表中<code>subtle::RefCountedBase(T::kRefCountPreference)</code>默认会匹配到<code>RefCountedBase::RefCountedBase(StartRefCountFromZeroTag)</code>，从而最终构造出来的对象一开始引用计数是0；当外部需要从1值初始化时，就需要在类<code>T</code>内自己覆盖定义<code>kRefCountPreference</code>。</p><p>显然，从使用者视角来看，定义一个又臭又长且意义不明的<code>kRefCountPreference</code>非常奇怪，而针对这种情况最简单的处理就是提供一个封装好的宏定义，宏定义除了语句简洁以外，还有名称表意的效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE()             \</span><br><span class="hljs-meta">  static constexpr ::base::subtle::StartRefCountFromOneTag \</span><br><span class="hljs-meta">      kRefCountPreference = ::base::subtle::kStartRefCountFromOneTag</span><br></code></pre></td></tr></table></figure><blockquote><p>实际上<code>kRefCountPreference</code>还会在智能指针<code>scoped_refptr</code>的相关操作中引用到，毕竟引用计数对象要搭配智能指针类来使用，引用计数负责对象的生命周期，智能指针负责把对象传来传去。</p><p>比如我们展开看上面的友元函数实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> subtle &#123;<br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">AdoptRefTag</span> &#123; kAdoptRefTag &#125;;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">scoped_refptr&lt;T&gt; <span class="hljs-title">AdoptRef</span><span class="hljs-params">(T* obj)</span> </span>&#123;<br>  <span class="hljs-keyword">using</span> Tag = std::<span class="hljs-type">decay_t</span>&lt;<span class="hljs-keyword">decltype</span>(T::kRefCountPreference)&gt;;<br>  <span class="hljs-built_in">static_assert</span>(std::is_same&lt;subtle::StartRefCountFromOneTag, Tag&gt;::value,<br>                <span class="hljs-string">&quot;Use AdoptRef only if the reference count starts from one.&quot;</span>);<br><br>  <span class="hljs-comment">// subtle::kAdoptRefTag用于占位，去匹配其private构造器（所以它也是scoped_refptr&lt;T&gt;的友元）</span><br>  <span class="hljs-comment">// scoped_refptr&lt;T&gt;::scoped_refptr(T* p, base::subtle::AdoptRefTag);</span><br>  <span class="hljs-comment">// 如此就区分开了public构造器scoped_refptr&lt;T&gt;::scoped_refptr(T* p);</span><br>  <span class="hljs-comment">// 后者会调用p-&gt;AddRef()来为T对象增加引用计数，而前者不会</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">scoped_refptr</span>&lt;T&gt;(obj, subtle::kAdoptRefTag);<br>&#125;<br></code></pre></td></tr></table></figure><p>静态断言确保<code>T::kRefCountPreference</code>是<code>subtle::StartRefCountFromOneTag</code>，即引用从1值起始。然后直接用<code>obj</code>对象和<code>subtle::kAdoptRefTag</code>构造一个<code>scoped_refptr&lt;T&gt;</code>智能指针对象并返回，该指针也就指向了对象<code>obj</code>。</p></blockquote><h2 id="refcountedthreadsafe"><code>RefCountedThreadSafe</code></h2><p>这个是<code>RefCounted</code>的线程安全版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">typename</span> Traits = DefaultRefCountedThreadSafeTraits&lt;T&gt; &gt;<br><span class="hljs-keyword">class</span> RefCountedThreadSafe : <span class="hljs-keyword">public</span> subtle::RefCountedThreadSafeBase &#123;<br><span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>老套路，先看基类。</p><h3id="subtlerefcountedthreadsafebase"><code>subtle::RefCountedThreadSafeBase</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCountedThreadSafeBase</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasOneRef</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasAtLeastOneRef</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-title">RefCountedThreadSafeBase</span><span class="hljs-params">(StartRefCountFromZeroTag)</span> </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-title">RefCountedThreadSafeBase</span><span class="hljs-params">(StartRefCountFromOneTag)</span></span><br><span class="hljs-function">      : ref_count_(<span class="hljs-number">1</span>) &#123;</span>&#125;<br><br>  ~<span class="hljs-built_in">RefCountedThreadSafeBase</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-comment">// Release and AddRef are suitable for inlining on X86 because they generate</span><br><span class="hljs-comment">// very small code sequences. On other platforms (ARM), it causes a size</span><br><span class="hljs-comment">// regression and is probably not worth it.</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ARCH_CPU_X86_FAMILY)</span><br>  <span class="hljs-comment">// Returns true if the object should self-delete.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Release</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReleaseImpl</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRef</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-built_in">AddRefImpl</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRefWithCheck</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-built_in">AddRefWithCheckImpl</span>(); &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-comment">// Returns true if the object should self-delete.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Release</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRef</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRefWithCheck</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> scoped_refptr&lt;U&gt; <span class="hljs-title">base::AdoptRef</span><span class="hljs-params">(U*)</span></span>;<br><br>  <span class="hljs-function">ALWAYS_INLINE <span class="hljs-type">void</span> <span class="hljs-title">AddRefImpl</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    ref_count_.<span class="hljs-built_in">Increment</span>();<br>  &#125;<br><br>  <span class="hljs-function">ALWAYS_INLINE <span class="hljs-type">void</span> <span class="hljs-title">AddRefWithCheckImpl</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-built_in">CHECK</span>(ref_count_.<span class="hljs-built_in">Increment</span>() &gt; <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-function">ALWAYS_INLINE <span class="hljs-type">bool</span> <span class="hljs-title">ReleaseImpl</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!ref_count_.<span class="hljs-built_in">Decrement</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">mutable</span> AtomicRefCount ref_count_&#123;<span class="hljs-number">0</span>&#125;;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(RefCountedThreadSafeBase);<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>知识点：我们知道对现代编译器来说，inline并不一定真的能inline，<code>ALWAYS_INLINE</code>宏用于确保inline生效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(COMPILER_GCC) &amp;&amp; defined(NDEBUG)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALWAYS_INLINE inline __attribute__((__always_inline__))</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(COMPILER_MSVC) &amp;&amp; defined(NDEBUG)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALWAYS_INLINE __forceinline</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALWAYS_INLINE inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></blockquote><p>可以看到与非线程安全的版本大致相同，只是在几个关键点上有所区别：</p><ol type="1"><li><p>引用计数器不再是个<code>uint32_t</code>，换成了使用原子操作的<code>AtomicRefCount</code>。</p><p>线程安全嘛，理所应当。<code>AtomicRefCount</code>是chromium-base对标准库<code>std::atomic_int</code>的封装，后面展开。</p></li><li><p>多了一个<code>AddRefWithCheck</code>接口。</p><p>这个接口替代了<code>AddRef</code>，除了首次增加引用计数的场景，我们可以在<code>RefCountThreadSafe</code>类中看到。该接口增强了保护，对previousvalue做了<code>CHECK</code>。</p></li><li><p>非X86架构因为"size regression"的成本而放弃了inline。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 对于X86架构的，由于Release、AddRef和AddRefWithCheck都在类内定义，所以都是inline</span><br><span class="hljs-comment">// 对非X86的就迂回一下，把这几个定义放到了类外</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(ARCH_CPU_X86_FAMILY)</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">RefCountedThreadSafeBase::Release</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReleaseImpl</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RefCountedThreadSafeBase::AddRef</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">AddRefImpl</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RefCountedThreadSafeBase::AddRefWithCheck</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">AddRefWithCheckImpl</span>();<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><blockquote><p>疑点：这里的知识点我并不清楚，以后懂了再做补充。</p></blockquote></li></ol><hr /><p>回头看<code>RefCountThreadSafe</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">typename</span> Traits&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCountedThreadSafe</span>;<br><br><span class="hljs-comment">// Default traits for RefCountedThreadSafe&lt;T&gt;.  Deletes the object when its ref</span><br><span class="hljs-comment">// count reaches 0.  Overload to delete it on a different thread etc.</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DefaultRefCountedThreadSafeTraits</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Destruct</span><span class="hljs-params">(<span class="hljs-type">const</span> T* x)</span> </span>&#123;<br>    <span class="hljs-comment">// Delete through RefCountedThreadSafe to make child classes only need to be</span><br>    <span class="hljs-comment">// friend with RefCountedThreadSafe instead of this struct, which is an</span><br>    <span class="hljs-comment">// implementation detail.</span><br>    RefCountedThreadSafe&lt;T,<br>                         DefaultRefCountedThreadSafeTraits&gt;::<span class="hljs-built_in">DeleteInternal</span>(x);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// Traits的默认实参实际上只是换了个壳，用以区分线程安全版本</span><br><span class="hljs-comment">// 内部还是通过调用RefCountedThreadSafe的static private方法来销毁对象</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">typename</span> Traits = DefaultRefCountedThreadSafeTraits&lt;T&gt; &gt;<br><span class="hljs-keyword">class</span> RefCountedThreadSafe : <span class="hljs-keyword">public</span> subtle::RefCountedThreadSafeBase &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> subtle::StartRefCountFromZeroTag kRefCountPreference =<br>      subtle::kStartRefCountFromZeroTag;<br><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCountedThreadSafe</span><span class="hljs-params">()</span></span><br><span class="hljs-function">      : subtle::RefCountedThreadSafeBase(T::kRefCountPreference) &#123;</span>&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRef</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-built_in">AddRefImpl</span>(T::kRefCountPreference); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Release</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (subtle::RefCountedThreadSafeBase::<span class="hljs-built_in">Release</span>()) &#123;<br>      Traits::<span class="hljs-built_in">Destruct</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> T*&gt;(<span class="hljs-keyword">this</span>));<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">protected</span>:<br>  ~<span class="hljs-built_in">RefCountedThreadSafe</span>() = <span class="hljs-keyword">default</span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DefaultRefCountedThreadSafeTraits</span>&lt;T&gt;;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DeleteInternal</span><span class="hljs-params">(<span class="hljs-type">const</span> U* x)</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span> x;<br>  &#125;<br><br>  <span class="hljs-comment">// 根据两种不同的枚举类型参数做了重载</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRefImpl</span><span class="hljs-params">(subtle::StartRefCountFromZeroTag)</span> <span class="hljs-type">const</span> </span>&#123;<br>    subtle::RefCountedThreadSafeBase::<span class="hljs-built_in">AddRef</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRefImpl</span><span class="hljs-params">(subtle::StartRefCountFromOneTag)</span> <span class="hljs-type">const</span> </span>&#123;<br>    subtle::RefCountedThreadSafeBase::<span class="hljs-built_in">AddRefWithCheck</span>();<br>  &#125;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(RefCountedThreadSafe);<br>&#125;;<br></code></pre></td></tr></table></figure><p>与非线程安全版本基本一致，只是对<code>AddRef</code>加强了保护。</p><h2 id="atomicrefcount"><code>AtomicRefCount</code></h2><p>这个类非常简单，包装了<code>std::atomic_int</code>。</p><blockquote><p>这里用<code>int</code>应该是基于以下两种考虑的：</p><ol type="1"><li>引用计数一般不会太离谱，不会超过int的正数范围</li><li>刚好配合<code>subtle::RefCountedThreadSafeBase::AddRefWithCheck</code>，用于在add之后检查是否溢出(<code>CHECK(ref_count_.Increment() &gt; 0);</code>)。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicRefCount</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">AtomicRefCount</span><span class="hljs-params">()</span> : ref_count_(<span class="hljs-number">0</span>) &#123;</span>&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-title">AtomicRefCount</span><span class="hljs-params">(<span class="hljs-type">int</span> initial_value)</span></span><br><span class="hljs-function">      : ref_count_(initial_value) &#123;</span>&#125;<br><br>  <span class="hljs-comment">// Increment a reference count.</span><br>  <span class="hljs-comment">// Returns the previous value of the count.</span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Increment</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Increment</span>(<span class="hljs-number">1</span>); &#125;<br><br>  <span class="hljs-comment">// Increment a reference count by &quot;increment&quot;, which must exceed 0.</span><br>  <span class="hljs-comment">// Returns the previous value of the count.</span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Increment</span><span class="hljs-params">(<span class="hljs-type">int</span> increment)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ref_count_.<span class="hljs-built_in">fetch_add</span>(increment, std::memory_order_relaxed);<br>  &#125;<br><br>  <span class="hljs-comment">// Decrement a reference count, and return whether the result is non-zero.</span><br>  <span class="hljs-comment">// Insert barriers to ensure that state written before the reference count</span><br>  <span class="hljs-comment">// became zero will be visible to a thread that has just made the count zero.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Decrement</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// TODO(jbroman): Technically this doesn&#x27;t need to be an acquire operation</span><br>    <span class="hljs-comment">// unless the result is 1 (i.e., the ref count did indeed reach zero).</span><br>    <span class="hljs-comment">// However, there are toolchain issues that make that not work as well at</span><br>    <span class="hljs-comment">// present (notably TSAN doesn&#x27;t like it).</span><br>    <span class="hljs-keyword">return</span> ref_count_.<span class="hljs-built_in">fetch_sub</span>(<span class="hljs-number">1</span>, std::memory_order_acq_rel) != <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Return whether the reference count is one.  If the reference count is used</span><br>  <span class="hljs-comment">// in the conventional way, a refrerence count of 1 implies that the current</span><br>  <span class="hljs-comment">// thread owns the reference and no other thread shares it.  This call</span><br>  <span class="hljs-comment">// performs the test for a reference count of one, and performs the memory</span><br>  <span class="hljs-comment">// barrier needed for the owning thread to act on the object, knowing that it</span><br>  <span class="hljs-comment">// has exclusive access to the object.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsOne</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ref_count_.<span class="hljs-built_in">load</span>(std::memory_order_acquire) == <span class="hljs-number">1</span>; &#125;<br><br>  <span class="hljs-comment">// Return whether the reference count is zero.  With conventional object</span><br>  <span class="hljs-comment">// referencing counting, the object will be destroyed, so the reference count</span><br>  <span class="hljs-comment">// should never be zero.  Hence this is generally used for a debug check.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsZero</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ref_count_.<span class="hljs-built_in">load</span>(std::memory_order_acquire) == <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns the current reference count (with no barriers). This is subtle, and</span><br>  <span class="hljs-comment">// should be used only for debugging.</span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SubtleRefCountForDebug</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ref_count_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  std::atomic_int ref_count_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里考虑CPU架构通用性以及性能，没有使用C++默认的<code>memory_order_seq_cst</code>，而是精心设计了恰当的Acquire/Release语义。这些东西是为了防止多线程环境因指令重排序、CPU缓存而导致的依赖关系错乱，详细可以参考该文章：https://zhuanlan.zhihu.com/p/31386431，强烈推荐！</p>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-base</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核学习——内存管理之进程地址空间</title>
    <link href="/2018/08/13/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
    <url>/2018/08/13/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>Linux内存管理非常复杂，从物理内存的分门别类，到内核用户态进程的索取，可以说是包罗万象。这一篇透过源码理解一下进程地址空间的管理。</p><span id="more"></span><h1 id="linux内存管理进程地址空间">Linux内存管理—进程地址空间</h1><p>内核获取动态内存的方式有3种：</p><ol type="1"><li>直接调用buddysystem接口<code>__get_free_pages()</code>或<code>alloc_pages()</code>从zone的页框分配器中获取页框。</li><li><code>kmem_cache_alloc</code>或<code>kmalloc</code>使用slab分配器为专用或通用对象分配块。</li><li><code>vmalloc()</code>或<code>vmalloc_32()</code>获取非连续内存区。</li></ol><p>上面的机制都是内核自身使用的，内核为用户态进程分配内存时，情况就完全不同了。用户态内存请求被认为是不紧迫的，内核总是尽量推迟给用户态进程分配动态内存，同时由于用户进程不可信任，所以内核还需要实时捕获用户态进程引起的寻址错误。</p><p>那么我们平时用户态进程请求内存时难道还需要等吗？等到内核推迟后再分配的时点？显然不是的。内核使用一种叫“线性区”的资源分配给用户进程，用户进程请求内存分配时，并没有立即获得页框，而仅仅得到了一个线性区，也就是一片线性地址空间的使用权（线性地址空间是进程地址空间0~3GB的一部分）。而真正的页框分配被推迟到了缺页异常处理程序中。</p><h2 id="内存描述符">内存描述符</h2><p>每个进程的进程地址空间相互之间没什么联系，在内核中由不同的线性区表示，每个进程都有对应的一些线性区资源。</p><p>每个进程的地址空间都对应一个内存描述符结构—<code>mm_struct</code>。<code>task_struct.mm</code>字段指向这个结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存描述符。task_struct的mm字段指向它。</span><br><span class="hljs-comment"> * 它包含了进程地址空间有关的全部信息。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> &#123;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向线性区对象的链表头。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> * <span class="hljs-title">mmap</span>;</span><span class="hljs-comment">/* list of VMAs */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向线性区对象的红-黑树的根</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">mm_rb</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向最后一个引用的线性区对象。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> * <span class="hljs-title">mmap_cache</span>;</span><span class="hljs-comment">/* last find_vma result */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在进程地址空间中搜索有效线性地址区的方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放线性地址区间时调用的方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> (*unmap_area) (<span class="hljs-keyword">struct</span> vm_area_struct *area);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 标识第一个分配的匿名线性区或文件内存映射的线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_base;<span class="hljs-comment">/* base of mmap area */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内核从这个地址开始搜索进程地址空间中线性地址的空间区间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> free_area_cache;<span class="hljs-comment">/* first hole */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向页全局目录。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">pgd_t</span> * pgd;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 次使用计数器。存放共享mm_struct数据结构的轻量级进程的个数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">atomic_t</span> mm_users;<span class="hljs-comment">/* How many users with user space? */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 主使用计数器。每当mm_count递减时，内核都要检查它是否变为0,如果是，就要解除这个内存描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">atomic_t</span> mm_count;<span class="hljs-comment">/* How many references to &quot;struct mm_struct&quot; (users count as 1) */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性区的个数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> map_count;<span class="hljs-comment">/* number of VMAs */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存描述符的读写信号量。</span><br><span class="hljs-comment"> * 由于描述符可能在几个轻量级进程间共享，通过这个信号量可以避免竞争条件。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span> <span class="hljs-title">mmap_sem</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性区和页表的自旋锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">spinlock_t</span> page_table_lock;<span class="hljs-comment">/* Protects page tables, mm-&gt;rss, mm-&gt;anon_rss */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向内存描述符链表中的相邻元素。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">mmlist</span>;</span><span class="hljs-comment">/* List of maybe swapped mm&#x27;s.  These are globally strung</span><br><span class="hljs-comment"> * together off init_mm.mmlist, and are protected</span><br><span class="hljs-comment"> * by mmlist_lock</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * start_code-可执行代码的起始地址。</span><br><span class="hljs-comment"> * end_code-可执行代码的最后地址。</span><br><span class="hljs-comment"> * start_data-已初始化数据的起始地址。</span><br><span class="hljs-comment"> * end_data--已初始化数据的结束地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_code, end_code, start_data, end_data;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * start_brk-堆的超始地址。</span><br><span class="hljs-comment"> * brk-堆的当前最后地址。</span><br><span class="hljs-comment"> * start_stack-用户态堆栈的起始地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_brk, brk, start_stack;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * arg_start-命令行参数的起始地址。</span><br><span class="hljs-comment"> * arg_end-命令行参数的结束地址。</span><br><span class="hljs-comment"> * env_start-环境变量的起始地址。</span><br><span class="hljs-comment"> * env_end-环境变量的结束地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg_start, arg_end, env_start, env_end;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * rss-分配给进程的页框总数</span><br><span class="hljs-comment"> * anon_rss-分配给匿名内存映射的页框数。s</span><br><span class="hljs-comment"> * total_vm-进程地址空间的大小(页框数)</span><br><span class="hljs-comment"> * locked_vm-锁住而不能换出的页的个数。</span><br><span class="hljs-comment"> * shared_vm-共享文件内存映射中的页数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rss, anon_rss, total_vm, locked_vm, shared_vm;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * exec_vm-可执行内存映射的页数。</span><br><span class="hljs-comment"> * stack_vm-用户态堆栈中的页数。</span><br><span class="hljs-comment"> * reserved_vm-在保留区中的页数或在特殊线性区中的页数。</span><br><span class="hljs-comment"> * def_flags-线性区默认的访问标志。</span><br><span class="hljs-comment"> * nr_ptes-this进程的页表数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> exec_vm, stack_vm, reserved_vm, def_flags, nr_ptes;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 开始执行elf程序时使用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> saved_auxv[<span class="hljs-number">42</span>]; <span class="hljs-comment">/* for /proc/PID/auxv */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 表示是否可以产生内存信息转储的标志。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> dumpable:<span class="hljs-number">1</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒惰TLB交换的位掩码。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">cpumask_t</span> cpu_vm_mask;<br><br><span class="hljs-comment">/* Architecture-specific MM context */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 特殊体系结构信息的表。</span><br><span class="hljs-comment"> * 如80X86平台上的LDT地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">mm_context_t</span> context;<br><br><span class="hljs-comment">/* Token based thrashing protection. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程有资格获得交换标记的时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> swap_token_time;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果最近发生了主缺页。则设置该标志。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> recent_pagein;<br><br><span class="hljs-comment">/* coredumping support */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 正在把进程地址空间的内容卸载到转储文件中的轻量级进程的数量。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> core_waiters;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * core_startup_done-指向创建内存转储文件时的补充原语。</span><br><span class="hljs-comment"> * core_done-创建内存转储文件时使用的补充原语。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> *<span class="hljs-title">core_startup_done</span>, <span class="hljs-title">core_done</span>;</span><br><br><span class="hljs-comment">/* aio bits */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于保护异步IO上下文链表的锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">rwlock_t</span>ioctx_list_lock;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 异步IO上下文链表。</span><br><span class="hljs-comment"> * 一个应用可以创建多个AIO环境，一个给定进程的所有的kioctx描述符存放在一个单向链表中，该链表位于ioctx_list字段</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kioctx</span>*<span class="hljs-title">ioctx_list</span>;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认的异步IO上下文。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kioctx</span><span class="hljs-title">default_kioctx</span>;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程所拥有的最大页框数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hiwater_rss;<span class="hljs-comment">/* High-water RSS usage */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程线性区中的最大页数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hiwater_vm;<span class="hljs-comment">/* High-water virtual memory usage */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>根据<code>mmlist</code>成员可以看出设计上所有内存描述符都链成一个表。链表第一个元素是<code>init_mm</code>的<code>mmlist</code>，<code>init_mm</code>是初始化阶段进程0所用。</p><h3 id="内核线程">内核线程</h3><p>内核线程比较特别，它没有自己的进程空间，运行在内核态使用的是TASK_SIZE以上的地址，所以不用线性区。</p><p>内核线程使用一组最近运行的普通进程的页表（大于TASK_SIZE线性地址空间页表项都是相同的，内核线程使用什么页表集根本没有关系）。所以，每个进程描述符中包含了两种内存描述符指针：<code>mm</code>和<code>active_mm</code>。</p><p><code>mm</code>指向的是进程拥有的内存描述符，而<code>active_mm</code>指向进程运行时使用的内存描述符。对普通进程来说，两个字段值相同。然而内核线程没有内存描述符，所以<code>mm</code>一直是NULL。内核线程得以运行时，<code>active_mm</code>字段会被初始化为上一个运行进程的<code>active_mm</code>值（参考schedule()调度函数）。</p><h2 id="线性区">线性区</h2><p>每个线性区都对应一个<code>vm_area_struct</code>对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This struct defines a memory VMM memory area. There is one of these</span><br><span class="hljs-comment"> * per VM-area/task.  A VM area is any part of the process virtual memory</span><br><span class="hljs-comment"> * space that has a special rule for the page-fault handlers (ie a shared</span><br><span class="hljs-comment"> * library, the executable area etc).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性区描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> &#123;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向线性区所在的内存描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> * <span class="hljs-title">vm_mm</span>;</span><span class="hljs-comment">/* The address space we belong to. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性区内的第一个线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_start;<span class="hljs-comment">/* Our start address within vm_mm. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性区之后的第一个线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_end;<span class="hljs-comment">/* The first byte after our end address</span><br><span class="hljs-comment">   within vm_mm. */</span><br><br><span class="hljs-comment">/* linked list of VM areas per task, sorted by address */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程链表中的下一个线性区。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vm_next</span>;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性区中页框的访问许可权。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">pgprot_t</span> vm_page_prot;<span class="hljs-comment">/* Access permissions of this VMA. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性区的标志。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_flags;<span class="hljs-comment">/* Flags, listed below. */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于红黑树的数据。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> <span class="hljs-title">vm_rb</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For areas with an address space and backing store,</span><br><span class="hljs-comment"> * linkage into the address_space-&gt;i_mmap prio tree, or</span><br><span class="hljs-comment"> * linkage to the list of like vmas hanging off its node, or</span><br><span class="hljs-comment"> * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 链接到反映射所使用的数据结构。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果在优先搜索树中，存在两个节点的基索引、堆索引、大小索引完全相同，那么这些相同的节点会被链接到一个链表，而vm_set就是这个链表的元素。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br><span class="hljs-type">void</span> *parent;<span class="hljs-comment">/* aligns with prio_tree_node parent */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">head</span>;</span><br>&#125; vm_set;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果是文件映射，那么prio_tree_node用于将线性区插入到优先搜索树中。作为搜索树的一个节点。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">raw_prio_tree_node</span> <span class="hljs-title">prio_tree_node</span>;</span><br>&#125; shared;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span><br><span class="hljs-comment"> * list, after a COW of one of the file pages.  A MAP_SHARED vma</span><br><span class="hljs-comment"> * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span><br><span class="hljs-comment"> * or brk vma (with NULL file) can only be in an anon_vma list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向匿名线性区链表的指针(参见&quot;映射页的反映射&quot;)。</span><br><span class="hljs-comment"> * 页框结构有一个anon_vma指针，指向该页的第一个线性区，随后的线性区通过此字段链接起来。</span><br><span class="hljs-comment"> * 通过此字段，可以将线性区链接到此链表中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">anon_vma_node</span>;</span><span class="hljs-comment">/* Serialized by anon_vma-&gt;lock */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向anon_vma数据结构的指针(参见&quot;映射页的反映射&quot;)。此指针也存放在页结构的mapping字段中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anon_vma</span> *<span class="hljs-title">anon_vma</span>;</span><span class="hljs-comment">/* Serialized by page_table_lock */</span><br><br><span class="hljs-comment">/* Function pointers to deal with this struct. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向线性区的方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_operations_struct</span> * <span class="hljs-title">vm_ops</span>;</span><br><br><span class="hljs-comment">/* Information about our backing store: */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在映射文件中的偏移量(以页为单位)。对匿名页，它等于0或vm_start/PAGE_SIZE</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_pgoff;<span class="hljs-comment">/* Offset (within vm_file) in PAGE_SIZE</span><br><span class="hljs-comment">   units, *not* PAGE_CACHE_SIZE */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向映射文件的文件对象(如果有的话)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">vm_file</span>;</span><span class="hljs-comment">/* File we map to (can be NULL). */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向内存区的私有数据。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> * vm_private_data;<span class="hljs-comment">/* was vm_pte (shared mem) */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放非线性文件内存映射中的一个线性地址区间时使用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_truncate_count;<span class="hljs-comment">/* truncate_count or restart_addr */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><br><span class="hljs-type">atomic_t</span> vm_usage;<span class="hljs-comment">/* refcount (VMAs shared if !MMU) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mempolicy</span> *<span class="hljs-title">vm_policy</span>;</span><span class="hljs-comment">/* NUMA policy for the VMA */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>线性区从不重叠，内核尽力把新分配的线性区与紧邻的现有线性区合并。</p><p><img src="20180807_1.jpg" /></p><p><code>vm_ops</code>结构存放了线性区的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * These are the virtual MM functions - opening of an area, closing and</span><br><span class="hljs-comment"> * unmapping it (needed to keep files on disk up-to-date etc), pointer</span><br><span class="hljs-comment"> * to the functions called when a no-page or a wp-page exception occurs. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性区的方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_operations_struct</span> &#123;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当把线性区增加到进程所拥有的线性区集合时调用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> (*open)(<span class="hljs-keyword">struct</span> vm_area_struct * area);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当从进程所拥有的线性区集合删除线性区时调用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> (*close)(<span class="hljs-keyword">struct</span> vm_area_struct * area);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当进程试图访问RAM中不存在的一个页，但该页的线性地址属于线性区时，由缺页异常处理程序调用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> * (*<span class="hljs-title">nopage</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> * <span class="hljs-title">area</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">long</span> <span class="hljs-title">address</span>, <span class="hljs-title">int</span> *<span class="hljs-title">type</span>);</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置线性区的线性地址(预缺页)所对应的页表项时调用。主要用于非线性文件内存映射。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*populate)(<span class="hljs-keyword">struct</span> vm_area_struct * area, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">pgprot_t</span> prot, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff, <span class="hljs-type">int</span> nonblock);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br><span class="hljs-type">int</span> (*set_policy)(<span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-keyword">struct</span> mempolicy *new);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mempolicy</span> *(*<span class="hljs-title">get_policy</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span>,</span><br><span class="hljs-class"><span class="hljs-title">unsigned</span> <span class="hljs-title">long</span> <span class="hljs-title">addr</span>);</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>线性区的结构图：</p><p><img src="20180807_2.jpg" /></p><p>链表遍历搜索线性区毕竟低效，Linux内核也使用了红黑树来存放进程线性区（红黑树太经典了，不科普了），内存描述符的<code>mm_rb</code>字段指向红黑树的根。</p><p>线性区管理的几个底层函数：</p><h3 id="find_vma"><code>find_vma()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查找给定地址的最邻近区。</span><br><span class="hljs-comment"> * 它查找线性区的vm_end字段大于addr的第一个线性区的位置。并返回这个线性区描述符的地址。</span><br><span class="hljs-comment"> * 如果没有这样的线性区存在，就返回NULL。</span><br><span class="hljs-comment"> * 由find_vma函数所选择的线性区并不一定要包含addr，因为addr可能位于任何线性区之外。</span><br><span class="hljs-comment"> *     mm-进程内存描述符地址</span><br><span class="hljs-comment"> *     addr-线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> vm_area_struct * <span class="hljs-title function_">find_vma</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct * mm, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (mm) &#123;<br><span class="hljs-comment">/* Check the cache first. */</span><br><span class="hljs-comment">/* (Cache hit rate is typically around 35%.) */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * mmap_cache指向最后一个引用的线性区对象。</span><br><span class="hljs-comment"> * 引入这个附加的字段是为了减少查找一个给定线性地址所在线性区而花费的时间。</span><br><span class="hljs-comment"> * 程序中引用地址的局部性使这种情况出现的可能性非常大:</span><br><span class="hljs-comment"> *    如果检查的最后一个线性地址属于某一给定的线性区。那么下一个要检查的线性地址也属于这一个线性区。</span><br><span class="hljs-comment"> */</span><br>vma = mm-&gt;mmap_cache;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先检查mmap_cache指定的线性区是否包含addr，如果是就返回这个线性区描述符的指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进入这里，说明mmap_cache中没有包含addr。就扫描进程的线性区。并在红黑树中查找线性区。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> * <span class="hljs-title">rb_node</span>;</span><br><br>rb_node = mm-&gt;mm_rb.rb_node;<br>vma = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">while</span> (rb_node) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> * <span class="hljs-title">vma_tmp</span>;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * rb_entry从指向红黑树中一个节点的指针导出相应线性区描述符的指针。</span><br><span class="hljs-comment"> */</span><br>vma_tmp = rb_entry(rb_node,<br><span class="hljs-keyword">struct</span> vm_area_struct, vm_rb);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 视情况在左右子树中查找。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;<br>vma = vma_tmp;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当前线性区包含addr,退出循环并返回vma.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 否则在左子树中继续</span><br><span class="hljs-comment"> */</span><br>rb_node = rb_node-&gt;rb_left;<br>&#125; <span class="hljs-keyword">else</span><span class="hljs-comment">/* 在右子树中继续 */</span><br>rb_node = rb_node-&gt;rb_right;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果有必要，记录下mmap_cache。这样，下次就从mmap_cache继续查找。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (vma)<br>mm-&gt;mmap_cache = vma;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> vma;<br>&#125;<br></code></pre></td></tr></table></figure><p>一目了然的红黑树搜索操作。</p><h3 id="find_vma_intersection"><code>find_vma_intersection()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Look up the first VMA which intersects the interval start_addr..end_addr-1,</span><br><span class="hljs-comment">   NULL if none.  Assume start_addr &lt; end_addr. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * find_vma_intersection函数查找与给定的线性地址区间相重叠的第一个线性区。完全交叉才叫intersection</span><br><span class="hljs-comment"> * mm-进程的内存描述符。</span><br><span class="hljs-comment"> * start_addr-要查找的区间的起始地址。</span><br><span class="hljs-comment"> * end_addr-要查找的区间的结束地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> vm_area_struct * <span class="hljs-title function_">find_vma_intersection</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct * mm, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end_addr)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> * <span class="hljs-title">vma</span> =</span> find_vma(mm,start_addr);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果没有这样的线性区存在就返回NULL。</span><br><span class="hljs-comment"> * 如果所找到的线性区是从地址区间的末尾开始的，也返回0.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (vma &amp;&amp; end_addr &lt;= vma-&gt;vm_start)<br>vma = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> vma;<br>&#125;<br></code></pre></td></tr></table></figure><p>内部复用了<code>find_vma</code>，如果没有找到就返回NULL。</p><h3 id="get_unmapped_area"><code>get_unmapped_area()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 搜索进程的地址空间以找到一个可以使用的线性地址区间。</span><br><span class="hljs-comment"> * len-区间的长度。</span><br><span class="hljs-comment"> * addr-指定必须从哪个地址开始进行查找。如果查找成功，函数返回这个新区间的起始地址。否则返回错误码-ENOMEM.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span><br><span class="hljs-title function_">get_unmapped_area</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span><br>&#123;<br><span class="hljs-keyword">if</span> (flags &amp; MAP_FIXED) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ret;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果addr不等于0,就检查指定的地址是否在用户态空间。</span><br><span class="hljs-comment"> * 这是为了避免用户态程序绕过安全检查而影响内核地址空间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (addr &gt; TASK_SIZE - len)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查是否与页边界对齐。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (addr &amp; ~PAGE_MASK)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-keyword">if</span> (file &amp;&amp; is_file_hugepages(file))  &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Check if the given range is hugepage aligned, and</span><br><span class="hljs-comment"> * can be made suitable for hugepages.</span><br><span class="hljs-comment"> */</span><br>ret = prepare_hugepage_range(addr, len);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Ensure that a normal request is not falling in a</span><br><span class="hljs-comment"> * reserved hugepage range.  For some archs like IA-64,</span><br><span class="hljs-comment"> * there is a separate region for hugepages.</span><br><span class="hljs-comment"> */</span><br>ret = is_hugepage_only_range(addr, len);<br>&#125;<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> -EINVAL;<br><span class="hljs-keyword">return</span> addr;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查线性地址区间是否应该用于文件内存映射或匿名内存映射。</span><br><span class="hljs-comment"> * 分别调用文件和内存的get_unmapped_area操作。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (file &amp;&amp; file-&gt;f_op &amp;&amp; file-&gt;f_op-&gt;get_unmapped_area)<br><span class="hljs-keyword">return</span> file-&gt;f_op-&gt;get_unmapped_area(file, addr, len,<br>pgoff, flags);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 磁盘文件系统不会定义这个方法，那么就调用内存描述符的get_unmapped_area()方法</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">return</span> current-&gt;mm-&gt;get_unmapped_area(file, addr, len, pgoff, flags);<br>&#125;<br></code></pre></td></tr></table></figure><p>心智健全检查后，进一步判断线性地址区间是否应该用于文件内存映射(<code>file-&gt;f_op-&gt;get_unmapped_area</code>)或匿名内存映射(<code>current-&gt;mm-&gt;get_unmapped_area</code>)。</p><p>第一种文件映射很复杂，以后再研究。而第二种则执行内存描述符本身的<code>get_unmapped_area</code>方法。根据进程的线性区类型，由函数<code>arch_get_unmapped_area()</code>或<code>arch_get_unmapped_area_topdown()</code>实现<code>get_unmapped_area</code>方法。</p><blockquote><p>通过系统调用mmap，每个进程都可能获得两种不同形式的线性区：从线性地址0x40000000开始向高端地址增长；从用户态堆栈开始向低端地址增长。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分配从低端地址向高端地址移动的线性区(xie.baoyou注：如堆而不是栈)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span><br><span class="hljs-title function_">arch_get_unmapped_area</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_addr;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当然了，只要是普通进程地址，就不能超过TASK_SIZE(一般就是3G)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (len &gt; TASK_SIZE)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br><span class="hljs-keyword">if</span> (addr) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果地址不是0，就从addr处开始分配</span><br><span class="hljs-comment"> * 当然，需要将addr按4K取整</span><br><span class="hljs-comment"> */</span><br>addr = PAGE_ALIGN(addr);<br>vma = find_vma(mm, addr);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * TASK_SIZE - len &gt;= addr而不是addr + len &lt;= TASK_SIZE</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (TASK_SIZE - len &gt;= addr &amp;&amp;<br>    (!vma || addr + len &lt;= vma-&gt;vm_start))<br><span class="hljs-keyword">return</span> addr;<span class="hljs-comment">/* 没有被映射，这块区间可以使用。 */</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果addr==0或者前面的搜索失败</span><br><span class="hljs-comment"> * 从free_area_cache开始搜索，这个值初始为用户态空间的1/3处（即1G处），它也是为正文段、数据段、BSS段保留的</span><br><span class="hljs-comment"> */</span><br>start_addr = addr = mm-&gt;free_area_cache;<br><br>full_search:<br><span class="hljs-keyword">for</span> (vma = find_vma(mm, addr); ; vma = vma-&gt;vm_next) &#123;<br><span class="hljs-comment">/* At this point:  (!vma || addr &lt; vma-&gt;vm_end). */</span><br><span class="hljs-keyword">if</span> (TASK_SIZE - len &lt; addr) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Start a new search - just in case we missed</span><br><span class="hljs-comment"> * some holes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有找到，从TASK_UNMAPPED_BASE(1G)处开始找</span><br><span class="hljs-comment"> * 第二次再从1G开始搜索的时候，start_addr = TASK_UNMAPPED_BASE，就会直接返回错误 -ENOMEM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (start_addr != TASK_UNMAPPED_BASE) &#123;<br>start_addr = addr = TASK_UNMAPPED_BASE;<br><span class="hljs-keyword">goto</span> full_search;<br>&#125;<br><span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br><span class="hljs-keyword">if</span> (!vma || addr + len &lt;= vma-&gt;vm_start) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Remember the place where we stopped the search:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 找到了，记下本次找到的地方，下次从addr+len处开始找</span><br><span class="hljs-comment"> */</span><br>mm-&gt;free_area_cache = addr + len;<br><span class="hljs-keyword">return</span> addr;<br>&#125;<br>addr = vma-&gt;vm_end;<br>&#125;<br>&#125;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span><br><span class="hljs-title function_">arch_get_unmapped_area_topdown</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr0,</span><br><span class="hljs-params">  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff,</span><br><span class="hljs-params">  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span>, *<span class="hljs-title">prev_vma</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> base = mm-&gt;mmap_base, addr = addr0;<br><span class="hljs-type">int</span> first_time = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/* requested length too big for entire address space */</span><br><span class="hljs-keyword">if</span> (len &gt; TASK_SIZE)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br><span class="hljs-comment">/* dont allow allocations above current base */</span><br><span class="hljs-keyword">if</span> (mm-&gt;free_area_cache &gt; base)<br>mm-&gt;free_area_cache = base;<br><br><span class="hljs-comment">/* requesting a specific address */</span><br><span class="hljs-keyword">if</span> (addr) &#123;<br>addr = PAGE_ALIGN(addr);<br>vma = find_vma(mm, addr);<br><span class="hljs-keyword">if</span> (TASK_SIZE - len &gt;= addr &amp;&amp;<br>(!vma || addr + len &lt;= vma-&gt;vm_start))<br><span class="hljs-keyword">return</span> addr;<br>&#125;<br><br>try_again:<br><span class="hljs-comment">/* make sure it can fit in the remaining address space */</span><br><span class="hljs-keyword">if</span> (mm-&gt;free_area_cache &lt; len)<br><span class="hljs-keyword">goto</span> fail;<br><br><span class="hljs-comment">/* either no address requested or cant fit in requested address hole */</span><br>addr = (mm-&gt;free_area_cache - len) &amp; PAGE_MASK;<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Lookup failure means no vma is above this address,</span><br><span class="hljs-comment"> * i.e. return with success:</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-keyword">if</span> (!(vma = find_vma_prev(mm, addr, &amp;prev_vma)))<br><span class="hljs-keyword">return</span> addr;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * new region fits between prev_vma-&gt;vm_end and</span><br><span class="hljs-comment"> * vma-&gt;vm_start, use it:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (addr+len &lt;= vma-&gt;vm_start &amp;&amp;<br>(!prev_vma || (addr &gt;= prev_vma-&gt;vm_end)))<br><span class="hljs-comment">/* remember the address as a hint for next time */</span><br><span class="hljs-keyword">return</span> (mm-&gt;free_area_cache = addr);<br><span class="hljs-keyword">else</span><br><span class="hljs-comment">/* pull free_area_cache down to the first hole */</span><br><span class="hljs-keyword">if</span> (mm-&gt;free_area_cache == vma-&gt;vm_end)<br>mm-&gt;free_area_cache = vma-&gt;vm_start;<br><br><span class="hljs-comment">/* try just below the current vma-&gt;vm_start */</span><br>addr = vma-&gt;vm_start-len;<br>&#125; <span class="hljs-keyword">while</span> (len &lt;= vma-&gt;vm_start);<br><br>fail:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * if hint left us with no space for the requested</span><br><span class="hljs-comment"> * mapping then try again:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (first_time) &#123;<br>mm-&gt;free_area_cache = base;<br>first_time = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">goto</span> try_again;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * A failed mmap() very likely causes application failure,</span><br><span class="hljs-comment"> * so fall back to the bottom-up function here. This scenario</span><br><span class="hljs-comment"> * can happen with large stack limits and large mmap()</span><br><span class="hljs-comment"> * allocations.</span><br><span class="hljs-comment"> */</span><br>mm-&gt;free_area_cache = TASK_UNMAPPED_BASE;<br>addr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Restore the topdown base:</span><br><span class="hljs-comment"> */</span><br>mm-&gt;free_area_cache = base;<br><br><span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="insert_vm_struct"><code>insert_vm_struct()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Insert vm structure into process list sorted by address</span><br><span class="hljs-comment"> * and into the inode&#x27;s i_mmap tree.  If vm_file is non-NULL</span><br><span class="hljs-comment"> * then i_mmap_lock is taken here.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在线性区对象链表和内存描述符的红黑树中插入一个vm_area_struct结构。</span><br><span class="hljs-comment"> * mm-指定进程内存描述符的地址。</span><br><span class="hljs-comment"> * vmp-指定要插入的vm_area_struct对象的地址。要求线性区对象的vm_start和vm_end字段必须被初始化。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">insert_vm_struct</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct * mm, <span class="hljs-keyword">struct</span> vm_area_struct * vma)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> * __<span class="hljs-title">vma</span>, * <span class="hljs-title">prev</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> ** <span class="hljs-title">rb_link</span>, * <span class="hljs-title">rb_parent</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The vm_pgoff of a purely anonymous vma should be irrelevant</span><br><span class="hljs-comment"> * until its first write fault, when page&#x27;s anon_vma and index</span><br><span class="hljs-comment"> * are set.  But now set the vm_pgoff it will almost certainly</span><br><span class="hljs-comment"> * end up with (unless mremap moves it elsewhere before that</span><br><span class="hljs-comment"> * first wfault), so /proc/pid/maps tells a consistent story.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * By setting it to reflect the virtual start address of the</span><br><span class="hljs-comment"> * vma, merges and splits can happen in a seamless way, just</span><br><span class="hljs-comment"> * using the existing file pgoff checks and manipulations.</span><br><span class="hljs-comment"> * Similarly in do_mmap_pgoff and in do_brk.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!vma-&gt;vm_file) &#123;<br>BUG_ON(vma-&gt;anon_vma);<br>vma-&gt;vm_pgoff = vma-&gt;vm_start &gt;&gt; PAGE_SHIFT;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用find_vma_prepare确定在红黑树中vma应该位于何处。</span><br><span class="hljs-comment"> */</span><br>__vma = find_vma_prepare(mm,vma-&gt;vm_start,&amp;prev,&amp;rb_link,&amp;rb_parent);<br><span class="hljs-keyword">if</span> (__vma &amp;&amp; __vma-&gt;vm_start &lt; vma-&gt;vm_end)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用vma_link执行以下操作:</span><br><span class="hljs-comment"> *     在mm-&gt;mmap所指向的链表中插入线性区。</span><br><span class="hljs-comment"> *     在红黑树中插入线性区。</span><br><span class="hljs-comment"> *     如果线性区是匿名的，就把它插入相应的anon_vma数据结构作为头节点的链表中。</span><br><span class="hljs-comment"> *     递增mm-&gt;map_count计数器。</span><br><span class="hljs-comment"> *     如果线性区包含一个内存映射文件，则vma_link执行其他与内存映射文件相关的任务。</span><br><span class="hljs-comment"> */</span><br>vma_link(mm, vma, prev, rb_link, rb_parent);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用vma_link执行以下操作:</span><br><span class="hljs-comment"> *     在mm-&gt;mmap所指向的链表中插入线性区。</span><br><span class="hljs-comment"> *     在红黑树中插入线性区。</span><br><span class="hljs-comment"> *     如果线性区是匿名的，就把它插入相应的anon_vma数据结构作为头节点的链表中。</span><br><span class="hljs-comment"> *     递增mm-&gt;map_count计数器。</span><br><span class="hljs-comment"> *     如果线性区包含一个内存映射文件，则vma_link执行其他与内存映射文件相关的任务。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vma_link</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> vm_area_struct *prev, <span class="hljs-keyword">struct</span> rb_node **rb_link,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> rb_node *rb_parent)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *<span class="hljs-title">mapping</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (vma-&gt;vm_file)<br>mapping = vma-&gt;vm_file-&gt;f_mapping;<br><br><span class="hljs-keyword">if</span> (mapping) &#123;<br>spin_lock(&amp;mapping-&gt;i_mmap_lock);<br>vma-&gt;vm_truncate_count = mapping-&gt;truncate_count;<br>&#125;<br>anon_vma_lock(vma);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * VMA上树，上链</span><br><span class="hljs-comment">     */</span><br>__vma_link(mm, vma, prev, rb_link, rb_parent);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 如果线性区包含一个内存映射文件，则vma_link执行其他与内存映射文件相关的任务。</span><br><span class="hljs-comment">     */</span><br>__vma_link_file(vma);<br><br>anon_vma_unlock(vma);<br><span class="hljs-keyword">if</span> (mapping)<br>spin_unlock(&amp;mapping-&gt;i_mmap_lock);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 递增mm-&gt;map_count计数器。</span><br><span class="hljs-comment">     */</span><br>mm-&gt;map_count++;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 校验mm的合法性并调试打印</span><br><span class="hljs-comment">     */</span><br>validate_mm(mm);<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>不展开了，脑补都知道干了些什么。</p><h2 id="分配线性地址空间">分配线性地址空间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为当前进程创建并初始化一个新的线性区。</span><br><span class="hljs-comment"> * 分配成功后，可以把这个新的线性区与进程已有的其他线性区进行合并。</span><br><span class="hljs-comment"> * file,offset-如果新的线性区将把一个文件映射到内存，则使用文件描述符指针file和文件偏移量offset.当不需要内存映射时，file和offset都会为空</span><br><span class="hljs-comment"> * addr-这个线性地址指定从何处开始查找一个空闲的区间。</span><br><span class="hljs-comment"> * len-线性地址区间的长度。</span><br><span class="hljs-comment"> * prot-这个参数指定这个线性区所包含页的访问权限。可能的标志有PROT_READ,PROT_WRITE,PROT_EXEC和PROT_NONE.前三个标志与VM_READ,VM_WRITE,WM_EXEC一样。PROT_NONE表示没有以上权限中的任意一个</span><br><span class="hljs-comment"> * flag-这个参数指定线性区的其他标志。MAP_GROWSDOWN,MAP_LOCKED,MAP_DENYWRITE,MAP_EXECURABLE</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_mmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> prot,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flag, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> offset)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ret = -EINVAL;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先检查是否溢出。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((offset + PAGE_ALIGN(len)) &lt; offset)<br><span class="hljs-keyword">goto</span> out;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查是否对齐页。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(offset &amp; ~PAGE_MASK))<br>ret = do_mmap_pgoff(file, addr, len, prot, flag, offset &gt;&gt; PAGE_SHIFT);<br>out:<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The caller must hold down_write(current-&gt;mm-&gt;mmap_sem).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * do_mmap的辅助函数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_mmap_pgoff</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file * file, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> prot,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> * <span class="hljs-title">mm</span> =</span> current-&gt;mm;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> * <span class="hljs-title">vma</span>, * <span class="hljs-title">prev</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vm_flags;<br><span class="hljs-type">int</span> correct_wcount = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> error;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> ** <span class="hljs-title">rb_link</span>, * <span class="hljs-title">rb_parent</span>;</span><br><span class="hljs-type">int</span> accountable = <span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> charged = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (file) &#123;<br><span class="hljs-keyword">if</span> (is_file_hugepages(file))<br>accountable = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查是否为要映射的文件定义了mmap文件操作。如果没有，就返回一个错误码。</span><br><span class="hljs-comment"> * 如果文件操作表的mmap为NULL说明相应的文件不能被映射(例如，这是一个目录).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!file-&gt;f_op || !file-&gt;f_op-&gt;mmap)<br><span class="hljs-keyword">return</span> -ENODEV;<br><br><span class="hljs-keyword">if</span> ((prot &amp; PROT_EXEC) &amp;&amp;<br>    (file-&gt;f_vfsmnt-&gt;mnt_flags &amp; MNT_NOEXEC))<br><span class="hljs-keyword">return</span> -EPERM;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Does the application expect PROT_READ to imply PROT_EXEC?</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (the exception is when the underlying filesystem is noexec</span><br><span class="hljs-comment"> *  mounted, in which case we dont add PROT_EXEC.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((prot &amp; PROT_READ) &amp;&amp; (current-&gt;personality &amp; READ_IMPLIES_EXEC))<br><span class="hljs-keyword">if</span> (!(file &amp;&amp; (file-&gt;f_vfsmnt-&gt;mnt_flags &amp; MNT_NOEXEC)))<br>prot |= PROT_EXEC;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查长度为0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!len)<br><span class="hljs-keyword">return</span> addr;<br><br><span class="hljs-comment">/* Careful about overflows.. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查包含的地址大于TASK_SIZE</span><br><span class="hljs-comment"> */</span><br>len = PAGE_ALIGN(len);<br><span class="hljs-keyword">if</span> (!len || len &gt; TASK_SIZE)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-comment">/* offset overflow? */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 是否越界了</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((pgoff + (len &gt;&gt; PAGE_SHIFT)) &lt; pgoff)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-comment">/* Too many mappings? */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程映射了过多的线性区。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (mm-&gt;map_count &gt; sysctl_max_map_count)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br><span class="hljs-comment">/* Obtain the address to map to. we verify (or select) it and ensure</span><br><span class="hljs-comment"> * that it represents a valid section of the address space.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * get_unmapped_area获得新线性区的线性地址区间。</span><br><span class="hljs-comment"> * 这个函数可能会调用文件对象的get_unapped_area方法。</span><br><span class="hljs-comment"> */</span><br>addr = get_unmapped_area(file, addr, len, pgoff, flags); <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">if</span> (addr &amp; ~PAGE_MASK)<br><span class="hljs-keyword">return</span> addr;<br><br><span class="hljs-comment">/* Do simple checking here so the lower-level routines won&#x27;t have</span><br><span class="hljs-comment"> * to. we assume access permissions have been handled by the open</span><br><span class="hljs-comment"> * of the memory object, so we don&#x27;t do any here.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过prot和flag计算新线性区描述符的标志。</span><br><span class="hljs-comment"> * mm-&gt;def_flags是线性区的默认标志。它只能由mlockall系统调用修改。这个调用可以设置VM_LOCKED标志。由此锁住以后申请的RAM中的有页。</span><br><span class="hljs-comment"> */</span><br>vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) |<br>mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC; <span class="hljs-comment">/*★*/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * flag参数指定新线性区地址区间的页必须被锁在RAM中，但不允许进程创建上锁的线性区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (flags &amp; MAP_LOCKED) &#123;<br><span class="hljs-keyword">if</span> (!can_do_mlock())<br><span class="hljs-keyword">return</span> -EPERM;<br>vm_flags |= VM_LOCKED;<br>&#125;<br><span class="hljs-comment">/* mlock MCL_FUTURE? */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 或者进程加锁页的总数超过了保存在进程描述符的rlim[RLIMIT_MEMLOCK].rlim_cur字段中的值。</span><br><span class="hljs-comment"> * 也直接返回错误。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (vm_flags &amp; VM_LOCKED) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> locked, lock_limit;<br>locked = mm-&gt;locked_vm &lt;&lt; PAGE_SHIFT;<br>lock_limit = current-&gt;signal-&gt;rlim[RLIMIT_MEMLOCK].rlim_cur;<br>locked += len;<br><span class="hljs-keyword">if</span> (locked &gt; lock_limit &amp;&amp; !capable(CAP_IPC_LOCK))<br><span class="hljs-keyword">return</span> -EAGAIN;<br>&#125;<br><br>inode = file ? file-&gt;f_dentry-&gt;d_inode : <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (file) &#123; <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">switch</span> (flags &amp; MAP_TYPE) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 如果请求一个共享的内存映射</span><br><span class="hljs-comment">         */</span><br><span class="hljs-keyword">case</span> MAP_SHARED:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果请求一个共享可写的内存映射，就检查文件是否为写入而打开的。而不是以追加模式打开的(O_APPEND标志)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((prot&amp;PROT_WRITE) &amp;&amp; !(file-&gt;f_mode&amp;FMODE_WRITE))<br><span class="hljs-keyword">return</span> -EACCES;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Make sure we don&#x27;t allow writing to an append-only</span><br><span class="hljs-comment"> * file..</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果节点仅仅允许追加写，但是文件以写方式打开，则返回错误。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (IS_APPEND(inode) &amp;&amp; (file-&gt;f_mode &amp; FMODE_WRITE))<br><span class="hljs-keyword">return</span> -EACCES;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Make sure there are no mandatory locks on the file.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果请求一个共享内存映射，就检查文件上没有强制锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (locks_verify_locked(inode))<br><span class="hljs-keyword">return</span> -EAGAIN;<br><br>vm_flags |= VM_SHARED | VM_MAYSHARE;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果文件没有写权限，那么相应的线性区也不会有写权限。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))<br>vm_flags &amp;= ~(VM_MAYWRITE | VM_SHARED);<br><br><span class="hljs-comment">/* fall through */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此处没有调用break，也就是说，即便是共享映射，也要进行下面的映射。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 对于任何形式的内存映射，都要检查文件是为读操作而打开的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">case</span> MAP_PRIVATE:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不论是共享映射还是私有映射，都要检查文件的读权限。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_READ))<br><span class="hljs-keyword">return</span> -EACCES;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">switch</span> (flags &amp; MAP_TYPE) &#123;<br><span class="hljs-keyword">case</span> MAP_SHARED:<br>vm_flags |= VM_SHARED | VM_MAYSHARE;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> MAP_PRIVATE:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Set pgoff according to addr for anon_vma.</span><br><span class="hljs-comment"> */</span><br>pgoff = addr &gt;&gt; PAGE_SHIFT;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br>&#125;<br><br>error = security_file_mmap(file, prot, flags);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br><br><span class="hljs-comment">/* Clear old maps */</span><br>error = -ENOMEM;<br>munmap_back:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * find_vma_prepare确定处于新区间前的线性区对象的位置，以及在红黑树中新线性区的位置。</span><br><span class="hljs-comment"> */</span><br>vma = find_vma_prepare(mm, addr, &amp;prev, &amp;rb_link, &amp;rb_parent);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查是否还存在与新区间重叠的线性区。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (vma &amp;&amp; vma-&gt;vm_start &lt; addr + len) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重叠了，就调用do_munmap删除新的线性区，然后重复整个步骤。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (do_munmap(mm, addr, len))<br><span class="hljs-keyword">return</span> -ENOMEM;<br><span class="hljs-keyword">goto</span> munmap_back;<br>&#125;<br><br><span class="hljs-comment">/* Check against address space limit. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查进程地址空间的大小mm-&gt;total_vm &lt;&lt; PAGE_SHIFT) + len是否超过允许的值。</span><br><span class="hljs-comment"> * 此检查不能被提前，因为上一步分配的线性区可能和已有线性区重叠，不能被加入线性区链表。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((mm-&gt;total_vm &lt;&lt; PAGE_SHIFT) + len<br>    &gt; current-&gt;signal-&gt;rlim[RLIMIT_AS].rlim_cur)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有MAP_NORESERVE表示需要检查空闲页框的数目。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (accountable &amp;&amp; (!(flags &amp; MAP_NORESERVE) ||<br>    sysctl_overcommit_memory == OVERCOMMIT_NEVER)) &#123;<br><span class="hljs-keyword">if</span> (vm_flags &amp; VM_SHARED) &#123;<br><span class="hljs-comment">/* Check memory availability in shmem_file_setup? */</span><br>vm_flags |= VM_ACCOUNT;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vm_flags &amp; VM_WRITE) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Private writable mapping: check memory availability</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 需要检查空闲页框数目，并且新的线性区是私有可写页</span><br><span class="hljs-comment"> */</span><br>charged = len &gt;&gt; PAGE_SHIFT;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果没有足够的空闲页框，就返回ENOMEM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (security_vm_enough_memory(charged))<br><span class="hljs-keyword">return</span> -ENOMEM;<br>vm_flags |= VM_ACCOUNT;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Can we just expand an old private anonymous mapping?</span><br><span class="hljs-comment"> * The VM_SHARED test is necessary because shmem_zero_setup</span><br><span class="hljs-comment"> * will create the file object for a shared anonymous map below.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不是文件映射，并且新区间是私有的，那么就调用vma_merge</span><br><span class="hljs-comment"> * 它会检查前一个线性区是否可扩展，以包含新区间。</span><br><span class="hljs-comment"> * 当新区间正好是两个区间之间的空洞时，它会将三个区间合并起来。</span><br><span class="hljs-comment"> * vma_merge成功，返回值为新merged的新的vma，如果不成功，返回NULL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!file &amp;&amp; !(vm_flags &amp; VM_SHARED) &amp;&amp;<br>    vma_merge(mm, prev, addr, addr + len, vm_flags,<br><span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, pgoff, <span class="hljs-literal">NULL</span>))<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Determine the object being mapped and call the appropriate</span><br><span class="hljs-comment"> * specific mapper. the address has already been validated, but</span><br><span class="hljs-comment"> * not unmapped, but the maps are removed from the list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 运行到此，说明没有发生线性区合并。</span><br><span class="hljs-comment"> * 首先调用kmem_cache_alloc为新的线性区分配一个vm_area_struct</span><br><span class="hljs-comment"> */</span><br>vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);<br><span class="hljs-keyword">if</span> (!vma) &#123;<br>error = -ENOMEM;<br><span class="hljs-keyword">goto</span> unacct_error;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化新vma对象。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">memset</span>(vma, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(*vma));<br><br>vma-&gt;vm_mm = mm;<br>vma-&gt;vm_start = addr;<br>vma-&gt;vm_end = addr + len;<br>vma-&gt;vm_flags = vm_flags;<br>vma-&gt;vm_page_prot = protection_map[vm_flags &amp; <span class="hljs-number">0x0f</span>];<br>vma-&gt;vm_pgoff = pgoff;<br><br><span class="hljs-keyword">if</span> (file) &#123;<br>error = -EINVAL;<br><span class="hljs-keyword">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))<br><span class="hljs-keyword">goto</span> free_vma;<br><span class="hljs-keyword">if</span> (vm_flags &amp; VM_DENYWRITE) &#123;<br>error = deny_write_access(file);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> free_vma;<br>correct_wcount = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用文件对象的地址初始化线性区描述符的vm_file字段，并增加文件的引用计数。</span><br><span class="hljs-comment"> */</span><br>vma-&gt;vm_file = file;<br>get_file(file);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对映射的文件调用mmap方法，对于大多数文件系统，该方法由generic_file_mmap实现。它执行以下步骤:</span><br><span class="hljs-comment"> *     将当前时间赋给文件索引节点对象的i_atime字段，并将该索引节点标记为脏。</span><br><span class="hljs-comment"> *     用generic_file_vm_ops表的地址初始化线性区描述符的vm_ops字段，在这个表中的方法，除了nopage和populate方法外，其他所有都为空。</span><br><span class="hljs-comment"> *          其中nopage方法由filemap_nopage实现，而populate方法由filemap_populate实现。</span><br><span class="hljs-comment"> * 对于大多数文件系统，这里调用generic_file_mmap</span><br><span class="hljs-comment"> */</span><br>error = file-&gt;f_op-&gt;mmap(file, vma); <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> unmap_and_free_vma;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vm_flags &amp; VM_SHARED) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 新线性区有VM_SHARED标志，又不是映射磁盘上的文件。则该线性区是一个共享匿名区。</span><br><span class="hljs-comment"> * shmem_zero_setup对它进行初始化。共享匿名区主要用于进程间通信。</span><br><span class="hljs-comment"> */</span><br>error = shmem_zero_setup(vma);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> free_vma;<br>&#125;<br><br><span class="hljs-comment">/* We set VM_ACCOUNT in a shared mapping&#x27;s vm_flags, to inform</span><br><span class="hljs-comment"> * shmem_zero_setup (perhaps called through /dev/zero&#x27;s -&gt;mmap)</span><br><span class="hljs-comment"> * that memory reservation must be checked; but that reservation</span><br><span class="hljs-comment"> * belongs to shared memory object, not to vma: so now clear it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((vm_flags &amp; (VM_SHARED|VM_ACCOUNT)) == (VM_SHARED|VM_ACCOUNT))<br>vma-&gt;vm_flags &amp;= ~VM_ACCOUNT;<br><br><span class="hljs-comment">/* Can addr have changed??</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Answer: Yes, several device drivers can do it in their</span><br><span class="hljs-comment"> *         f_op-&gt;mmap method. -DaveM</span><br><span class="hljs-comment"> */</span><br>addr = vma-&gt;vm_start;<br>pgoff = vma-&gt;vm_pgoff;<br>vm_flags = vma-&gt;vm_flags;<br><br><span class="hljs-keyword">if</span> (!file || !vma_merge(mm, prev, addr, vma-&gt;vm_end,<br>vma-&gt;vm_flags, <span class="hljs-literal">NULL</span>, file, pgoff, vma_policy(vma))) &#123;<br>file = vma-&gt;vm_file;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * vma_link将新线性区插入到线性区链表和红黑树中。</span><br><span class="hljs-comment"> */</span><br>vma_link(mm, vma, prev, rb_link, rb_parent);<br><span class="hljs-keyword">if</span> (correct_wcount)<br><span class="hljs-type">atomic_inc</span>(&amp;inode-&gt;i_writecount);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (file) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 增加文件索引节点对象的i_writecount</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (correct_wcount)<br><span class="hljs-type">atomic_inc</span>(&amp;inode-&gt;i_writecount); <span class="hljs-comment">/*★*/</span><br>fput(file);<br>&#125;<br>mpol_free(vma_policy(vma));<br>kmem_cache_free(vm_area_cachep, vma);<br>&#125;<br>out:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 增加进程地址空间的大小。</span><br><span class="hljs-comment"> */</span><br>mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;<br>__vm_stat_account(mm, vm_flags, file, len &gt;&gt; PAGE_SHIFT);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VM_LOCKED标志被设置，就调用make_pages_present连续分配线性区的所有页，并将所有页锁在RAM中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (vm_flags &amp; VM_LOCKED) &#123;<br>mm-&gt;locked_vm += len &gt;&gt; PAGE_SHIFT;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * make_pages_present在所有页上循环，对其中每个页，调用follow_page检查当前页表中是否有到物理页的映射。</span><br><span class="hljs-comment"> * 如果没有这样的页存在，就调用handle_mm_fault。这个函数分配一个页框并根据内存描述符的vm_flags字段设置它的页表项。</span><br><span class="hljs-comment"> */</span><br>make_pages_present(addr, addr + len);<br>&#125;<br><span class="hljs-keyword">if</span> (flags &amp; MAP_POPULATE) &#123;<br>up_write(&amp;mm-&gt;mmap_sem);<br>sys_remap_file_pages(addr, len, <span class="hljs-number">0</span>,<br>pgoff, flags &amp; MAP_NONBLOCK);<br>down_write(&amp;mm-&gt;mmap_sem);<br>&#125;<br>acct_update_integrals();<br>update_mem_hiwater();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 最后，函数通过返回新线性区的线性地址而终止</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">return</span> addr;<br><br>unmap_and_free_vma:<br><span class="hljs-keyword">if</span> (correct_wcount)<br><span class="hljs-type">atomic_inc</span>(&amp;inode-&gt;i_writecount);<br>vma-&gt;vm_file = <span class="hljs-literal">NULL</span>;<br>fput(file);<br><br><span class="hljs-comment">/* Undo any partial mapping done by a device driver. */</span><br>zap_page_range(vma, vma-&gt;vm_start, vma-&gt;vm_end - vma-&gt;vm_start, <span class="hljs-literal">NULL</span>);<br>free_vma:<br>kmem_cache_free(vm_area_cachep, vma);<br>unacct_error:<br><span class="hljs-keyword">if</span> (charged)<br>vm_unacct_memory(charged);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><p>##释放线性地址空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Munmap is split into 2 main parts -- this part which finds</span><br><span class="hljs-comment"> * what needs doing, and the areas themselves, which do the</span><br><span class="hljs-comment"> * work.  This now handles partial unmappings.</span><br><span class="hljs-comment"> * Jeremy Fitzhardinge &lt;jeremy@goop.org&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从当前进程的地址空间中删除一个线性地址区间。</span><br><span class="hljs-comment"> * 要删除的区间并不总是对应一个线性区。它或者是一个线性区的一部分，或者是多个线性区。</span><br><span class="hljs-comment"> * mm-进程内存描述符。</span><br><span class="hljs-comment"> * start-要删除的地址区间的起始地址。</span><br><span class="hljs-comment"> * len-要删除的长度。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">do_munmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">mpnt</span>, *<span class="hljs-title">prev</span>, *<span class="hljs-title">last</span>;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初步检查：线性区地址不能大于TASK_SIZE，start必须是4096的整数倍。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((start &amp; ~PAGE_MASK) || start &gt; TASK_SIZE || len &gt; TASK_SIZE-start)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * len也不能为0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((len = PAGE_ALIGN(len)) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-comment">/* Find the first overlapping VMA */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * mpnt是要删除的线性地址区间之后第一个线性区的位置。mpnt-&gt;end&gt;start</span><br><span class="hljs-comment"> */</span><br>mpnt = find_vma_prev(mm, start, &amp;prev);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有这样的线性区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!mpnt)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">/* we have  start &lt; mpnt-&gt;vm_end  */</span><br><br><span class="hljs-comment">/* if it doesn&#x27;t overlap, we have nothing.. */</span><br>end = start + len;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 也没有与线性地址区间重叠的线性区，就不必做什么了。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (mpnt-&gt;vm_start &gt;= end)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we need to split any vma, do it now to save pain later.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note: mremap&#x27;s move_vma VM_ACCOUNT handling assumes a partially</span><br><span class="hljs-comment"> * unmapped vm_area_struct will remain in use: so lower split_vma</span><br><span class="hljs-comment"> * places tmp vma above, and higher split_vma places tmp vma below.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 第一步: 分裂前半部分</span><br><span class="hljs-comment">     */</span> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性区的起始地址在mpnt内，就调用split_vma把线性区mpnt划分成两个较小的区：一个区在线性地址区间外部，而另一个区间内部</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (start &gt; mpnt-&gt;vm_start) &#123;<br><span class="hljs-type">int</span> error = split_vma(mm, mpnt, start, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * prev以前存储的是指向线性区mpnt前面一个线性区的指针。</span><br><span class="hljs-comment"> * 现在它指向mpnt，即指向线性地址区间外部的那个新线性区。</span><br><span class="hljs-comment"> * 这样，prev仍然指向要删除的那个线性区前面的那个线性区。</span><br><span class="hljs-comment"> */</span><br>prev = mpnt;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 第二步: 分裂后半部分</span><br><span class="hljs-comment">     */</span> <br><span class="hljs-comment">/* Does it split the last one? */</span><br>last = find_vma(mm, end);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果线性地址空间的结束地址在一个线性区内部，就再次调用split_vma把最后重叠的那个线性区划分成两个较小的区。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (last &amp;&amp; end &gt; last-&gt;vm_start) &#123;<br><span class="hljs-type">int</span> error = split_vma(mm, last, end, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 更新mpnt，使它指向线性地址区间的第一个线性区。</span><br><span class="hljs-comment"> * 如果prev为空，即没有，就从mm-&gt;mmap获得第一个线性区的地址。</span><br><span class="hljs-comment"> */</span><br>mpnt = prev? prev-&gt;vm_next: mm-&gt;mmap;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Remove the vma&#x27;s, and unmap the actual pages</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * detach_vmas_to_be_unmapped从进程的线性地址空间中删除位于线性地址区间中的线性区。</span><br><span class="hljs-comment"> * 这可能是一个链表。</span><br><span class="hljs-comment"> */</span><br>detach_vmas_to_be_unmapped(mm, mpnt, prev, end);<br>spin_lock(&amp;mm-&gt;page_table_lock);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * unmap_region清除与线性地址区间对应的页表项并释放相应的页框。</span><br><span class="hljs-comment"> */</span><br>unmap_region(mm, mpnt, prev, start, end);<br>spin_unlock(&amp;mm-&gt;page_table_lock);<br><br><span class="hljs-comment">/* Fix up all other VM information */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放detach_vmas_to_be_unmapped收集的位于线性区间内的线性区描述符</span><br><span class="hljs-comment"> */</span><br>unmap_vma_list(mm, mpnt);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 返回0，成功</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="appendix">Appendix</h2><h3 id="split_vma"><code>split_vma()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Split a vma into two pieces at address &#x27;addr&#x27;, a new vma is allocated</span><br><span class="hljs-comment"> * either for the first part or the the tail.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把与线性地址区间交叉的线性区划分成两个较小的区。一个在线性地址区间外部，另一个在区间的内部。</span><br><span class="hljs-comment"> * mm-内存描述符指针。</span><br><span class="hljs-comment"> * vma-要被划分的线性区。</span><br><span class="hljs-comment"> * addr-区间与线性区之间交叉点的地址。</span><br><span class="hljs-comment"> * new_below-表示区间与线性区之间交叉点在区间超始处还是结束处的标志。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">split_vma</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct * mm, <span class="hljs-keyword">struct</span> vm_area_struct * vma,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">int</span> new_below)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mempolicy</span> *<span class="hljs-title">pol</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">new</span>;</span><br><br><span class="hljs-keyword">if</span> (is_vm_hugetlb_page(vma) &amp;&amp; (addr &amp; ~HPAGE_MASK))<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-keyword">if</span> (mm-&gt;map_count &gt;= sysctl_max_map_count)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得线性区描述符。如果没有可用的空闲空间，就返回-ENOMEM</span><br><span class="hljs-comment"> */</span><br>new = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);<br><span class="hljs-keyword">if</span> (!new)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br><span class="hljs-comment">/* most fields are the same, copy all, and then fixup */</span><br>*new = *vma;<br><br><span class="hljs-keyword">if</span> (new_below)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果new_below为1,表示线性地址区间的结束地址在vma线性区的内部。</span><br><span class="hljs-comment"> * 因此把新线性区放在vma线性区的前面。因此把new-&gt;vm_end和vma-&gt;vm_start设置成addr.</span><br><span class="hljs-comment"> */</span><br>new-&gt;vm_end = addr;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性地址区间的起始地址在vma线性区的内部。因此必须把新线性区放在vma线性区之后。</span><br><span class="hljs-comment"> * 因此把new-&gt;vm_start和vma-&gt;vm_end设置成addr.</span><br><span class="hljs-comment"> */</span><br>new-&gt;vm_start = addr;<br>new-&gt;vm_pgoff += ((addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT);<br>&#125;<br><br>pol = mpol_copy(vma_policy(vma));<br><span class="hljs-keyword">if</span> (IS_ERR(pol)) &#123;<br>kmem_cache_free(vm_area_cachep, new);<br><span class="hljs-keyword">return</span> PTR_ERR(pol);<br>&#125;<br>vma_set_policy(new, pol);<br><br><span class="hljs-keyword">if</span> (new-&gt;vm_file)<br>get_file(new-&gt;vm_file);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果定义了新线性区的open方法，就执行它。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (new-&gt;vm_ops &amp;&amp; new-&gt;vm_ops-&gt;open)<br>new-&gt;vm_ops-&gt;open(new);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把新线性区链接到线性区链表和红黑树中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (new_below)<br>vma_adjust(vma, addr, vma-&gt;vm_end, vma-&gt;vm_pgoff +<br>((addr - new-&gt;vm_start) &gt;&gt; PAGE_SHIFT), new);<br><span class="hljs-keyword">else</span><br>vma_adjust(vma, vma-&gt;vm_start, addr, vma-&gt;vm_pgoff, new);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="unmap_region"><code>unmap_region</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Get rid of page table information in the indicated region.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Called with the page table lock held.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 遍历线性区链表并释放它们的页框。</span><br><span class="hljs-comment"> * mm-内存描述符指针</span><br><span class="hljs-comment"> * vma-指向第一个被删除线性区描述符的指针。</span><br><span class="hljs-comment"> * prev-指向vma前面的线性区的指针。</span><br><span class="hljs-comment"> * start,end-界定被删除线性地址区间的范围。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">unmap_region</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> vm_area_struct *prev,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mmu_gather</span> *<span class="hljs-title">tlb</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_accounted = <span class="hljs-number">0</span>;<br><br>lru_add_drain();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * tlb_gather_mmu初始化每CPU变量mmu_gathers。mmu_gather的值依赖于体系结构。</span><br><span class="hljs-comment"> * 通常该变量应该存放成功更新进程页表项所需要的所有信息。</span><br><span class="hljs-comment"> * 在x86中，该函数只是简单地把内存描述符指针mm的值赋给本地CPU的mmu_gather变量</span><br><span class="hljs-comment"> */</span><br>tlb = tlb_gather_mmu(mm, <span class="hljs-number">0</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用unmap_vmas扫描线性地址空间的所有页表项。</span><br><span class="hljs-comment"> * 如果只有一个CPU，就调用free_swap_and_cache反复释放相应的页。</span><br><span class="hljs-comment"> */</span><br>unmap_vmas(&amp;tlb, mm, vma, start, end, &amp;nr_accounted, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">/*★*/</span><br>vm_unacct_memory(nr_accounted);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * free_pgtables回收已经清空的进程页表。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (is_hugepage_only_range(start, end - start))<br>hugetlb_free_pgtables(tlb, prev, start, end);<br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//因为删除了一些映射，会造成一个页表空闲的情况，回收页表项所占的空间</span><br>free_pgtables(tlb, prev, start, end);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 刷新TLB</span><br><span class="hljs-comment"> */</span><br>tlb_finish_mmu(tlb, start, end);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="缺页异常处理程序">缺页异常处理程序</h2><p>缺页异常有两种情况：编程错误引发异常；引用进程地址空间但尚未分配物理页框。</p><p><img src="20180813_1.jpg" /></p><p>80x86的缺页异常处理程序非常复杂：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This routine handles page faults.  It determines the address,</span><br><span class="hljs-comment"> * and the problem, and then passes it off to one of the appropriate</span><br><span class="hljs-comment"> * routines.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * error_code:</span><br><span class="hljs-comment"> *bit 0 == 0 means no page found, 1 means protection fault</span><br><span class="hljs-comment"> *bit 1 == 0 means read, 1 means write</span><br><span class="hljs-comment"> *bit 2 == 0 means kernel, 1 means user-mode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 缺页中断服务程序。</span><br><span class="hljs-comment"> * regs-发生异常时寄存器的值</span><br><span class="hljs-comment"> * error_code-当异常发生时，控制单元压入栈中的错误代码。</span><br><span class="hljs-comment"> *  当第0位被清0时，则异常是由一个不存在的页所引起的。否则是由无效的访问权限引起的。</span><br><span class="hljs-comment"> *  如果第1位被清0，则异常由读访问或者执行访问所引起，如果被设置，则异常由写访问引起。</span><br><span class="hljs-comment"> *  如果第2位被清0，则异常发生在内核态，否则异常发生在用户态。</span><br><span class="hljs-comment"> */</span><br>fastcall <span class="hljs-type">void</span> <span class="hljs-title function_">do_page_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">tsk</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> * <span class="hljs-title">vma</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page;<br><span class="hljs-type">int</span> write;<br><span class="hljs-type">siginfo_t</span> info;<br><br><span class="hljs-comment">/* get the address */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 读取引起异常的线性地址。CPU控制单元把这个值存放在cr2控制寄存器中。</span><br><span class="hljs-comment"> */</span><br>__asm__(<span class="hljs-string">&quot;movl %%cr2,%0&quot;</span>:<span class="hljs-string">&quot;=r&quot;</span> (address));<br><br><span class="hljs-keyword">if</span> (notify_die(DIE_PAGE_FAULT, <span class="hljs-string">&quot;page fault&quot;</span>, regs, error_code, <span class="hljs-number">14</span>,<br>SIGSEGV) == NOTIFY_STOP)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-comment">/* It&#x27;s safe to allow irq&#x27;s after cr2 has been saved */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 只在保存了cr2就可以打开中断了。</span><br><span class="hljs-comment"> * 如果中断发生前是允许中断的，或者运行在虚拟8086模式，就打开中断。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (regs-&gt;eflags &amp; (X86_EFLAGS_IF|VM_MASK))<br>local_irq_enable();<br><br>tsk = current;<br><br>info.si_code = SEGV_MAPERR;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We fault-in kernel-space virtual memory on-demand. The</span><br><span class="hljs-comment"> * &#x27;reference&#x27; page table is init_mm.pgd.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * NOTE! We MUST NOT take any locks for this case. We may</span><br><span class="hljs-comment"> * be in an interrupt or a critical region, and should</span><br><span class="hljs-comment"> * only copy the information from the master page table,</span><br><span class="hljs-comment"> * nothing more.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This verifies that the fault happens in kernel space</span><br><span class="hljs-comment"> * (error_code &amp; 4) == 0, and that the fault was not a</span><br><span class="hljs-comment"> * protection error (error_code &amp; 1) == 0.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据异常地址，判断是访问内核态地址还是用户态地址发生了异常。</span><br><span class="hljs-comment"> * xie.baoyou注：这并不代表异常发生在用户态还是内核态。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(address &gt;= TASK_SIZE)) &#123; <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * !(第0位 = 1，由无效的访问权限引起的； 第2位==1，异常发生在用户态。) ==&gt; 内核态访问了一个不存在的页框</span><br><span class="hljs-comment">         */</span><br><span class="hljs-keyword">if</span> (!(error_code &amp; <span class="hljs-number">5</span>))<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内核态访问了一个不存在的页框，这可能是由于内核态访问非连续内存区而引起的。</span><br><span class="hljs-comment"> * 注:vmalloc可能打乱了内核页表，而进程切换后，并没有随着修改这些页表项。这可能会引起异常，而这种异常其实不是程序逻辑错误。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">goto</span> vmalloc_fault;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Don&#x27;t take the mm semaphore here. If we fixup a prefetch</span><br><span class="hljs-comment"> * fault we could otherwise deadlock.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  第0位 = 1，由无效的访问权限引起的； 或者 第2位==1，异常发生在用户态。</span><br><span class="hljs-comment">         */</span> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 否则，第0位或者第2位设置了，可能是没有访问权限或者用户态程序访问了内核态地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">goto</span> bad_area_nosemaphore;<br>&#125; <br><br>mm = tsk-&gt;mm;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we&#x27;re in an interrupt, have no user context or are running in an</span><br><span class="hljs-comment"> * atomic region then we must not take the fault..</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内核是否在执行一些关键例程，或者是内核线程出错了。</span><br><span class="hljs-comment"> * in_atomic表示内核现在禁止抢占，一般是中断处理程序、可延迟函数、临界区或内核线程中。</span><br><span class="hljs-comment"> * 一般来说，这些程序不会去访问用户空间地址。因为访问这些地址总是可能造成导致阻塞。</span><br><span class="hljs-comment"> * 而这些地方是不允许阻塞的。</span><br><span class="hljs-comment"> * 总之，问题有点严重。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (in_atomic() || !mm)<br><span class="hljs-keyword">goto</span> bad_area_nosemaphore;<br><br><span class="hljs-comment">/* When running in the kernel we expect faults to occur only to</span><br><span class="hljs-comment"> * addresses in user space.  All other faults represent errors in the</span><br><span class="hljs-comment"> * kernel and should generate an OOPS.  Unfortunatly, in the case of an</span><br><span class="hljs-comment"> * erroneous fault occuring in a code path which already holds mmap_sem</span><br><span class="hljs-comment"> * we will deadlock attempting to validate the fault against the</span><br><span class="hljs-comment"> * address space.  Luckily the kernel only validly references user</span><br><span class="hljs-comment"> * space from well defined areas of code, which are listed in the</span><br><span class="hljs-comment"> * exceptions table.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * As the vast majority of faults will be valid we will only perform</span><br><span class="hljs-comment"> * the source reference check when there is a possibilty of a deadlock.</span><br><span class="hljs-comment"> * Attempt to lock the address space, if we cannot we then validate the</span><br><span class="hljs-comment"> * source.  If this is invalid we can skip the address space check,</span><br><span class="hljs-comment"> * thus avoiding the deadlock.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 缺页没有发生在中断处理程序、可延迟函数、临界区、内核线程中</span><br><span class="hljs-comment"> * 那么，就需要检查进程所拥有的线性区，以决定引起缺页的线性地址是否包含在进程的地址空间中</span><br><span class="hljs-comment"> * 为此，必须获得进程的mmap_sem读写信号量。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 既然不是内核BUG，也不是硬件故障，那么缺页发生时，当前进程就还没有为写而获得信号量mmap_sem.</span><br><span class="hljs-comment"> * 但是为了稳妥起见，还是调用down_read_trylock确保mmap_sem没有被其他地方占用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!down_read_trylock(&amp;mm-&gt;mmap_sem)) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一般不会运行到这里来。</span><br><span class="hljs-comment"> * 运行到这里表示:信号被关闭了。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((error_code &amp; <span class="hljs-number">4</span>) == <span class="hljs-number">0</span> &amp;&amp;<br>    !search_exception_tables(regs-&gt;eip)) <span class="hljs-comment">/* 第2位被清0，则异常发生在内核态; 且在异常处理表中又没有对应的处理函数。*/</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 内核态异常，在异常处理表中又没有对应的处理函数。</span><br><span class="hljs-comment">     * 转到bad_area_nosemaphore，它会再检查一下：是否是使用作为系统调用参数被传递给内核的线性地址。</span><br><span class="hljs-comment">     * 请回想一下,access_ok只是作了简单的检查，并不确保线性地址空间真的存在（只要是用户态地址就行了）</span><br><span class="hljs-comment">     * 也就是说：用户态程序在调用系统调用的时候，可能传递了一个非法的用户态地址给内核。</span><br><span class="hljs-comment">     * 而内核试图读写这个地址的时候，就出错了</span><br><span class="hljs-comment">     * 的确，这里就会处理这个情况。</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">goto</span> bad_area_nosemaphore;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 否则，不是内核异常或者严重的硬件故障。并且信号量被其他线程占用了，等待其他线程释放信号量后继续。</span><br><span class="hljs-comment"> */</span><br>down_read(&amp;mm-&gt;mmap_sem);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 运行到此，就已经获得了mmap_sem信号量。</span><br><span class="hljs-comment"> * 可以放心的操作mm了。</span><br><span class="hljs-comment"> * 现在开始搜索出错地址所在的线性区。</span><br><span class="hljs-comment"> */</span><br>vma = find_vma(mm, address); <span class="hljs-comment">/*★*/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果vma为空，说明在出错地址后面没有线性区了，说明错误的地址肯定是无效的。</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-keyword">if</span> (!vma)<br><span class="hljs-keyword">goto</span> bad_area;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * vma在address后面，并且它的起始地址在address前面，说明线性区包含了这个地址。</span><br><span class="hljs-comment"> * 谢天谢地，这很可能不是真的错误，可能是COW机制起作用了，也可能是需要调页了。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (vma-&gt;vm_start &lt;= address) <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">goto</span> good_area;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 运行到此，说明地址并不在线性区中。</span><br><span class="hljs-comment"> * 但是我们还要再判断一下，有可能是push指令引起的异常。和vma==NULL还不太一样。</span><br><span class="hljs-comment"> * 直接转到bad_area是不正确的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN)) <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">goto</span> bad_area;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 运行到此，说明address地址后面的vma有VM_GROWSDOWN标志，表示它是一个堆栈区</span><br><span class="hljs-comment"> * 请注意，如果是内核态访问用户态的堆栈空间，就应该直接扩展堆栈，而不判断if (address + 32 &lt; regs-&gt;esp)</span><br><span class="hljs-comment"> * 注意，如果是内核态在访问用户态堆栈空间，没有32的距离限制，都应该expand_stack</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (error_code &amp; <span class="hljs-number">4</span>) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * accessing the stack below %esp is always a bug.</span><br><span class="hljs-comment"> * The &quot;+ 32&quot; is there due to some instructions (like</span><br><span class="hljs-comment"> * pusha) doing post-decrement on the stack and that</span><br><span class="hljs-comment"> * doesn&#x27;t show up until later..</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 虽然下一个线性区是堆栈，可是离非法地址太远了，不可能是操作堆栈引起的错误</span><br><span class="hljs-comment"> * xie.baoyou注：32而不是4是考虑到pusha的存在。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (address + <span class="hljs-number">32</span> &lt; regs-&gt;esp) <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">goto</span> bad_area;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程堆栈空间不足，就扩展一下，一般会成功的，不会运行到bad_area.</span><br><span class="hljs-comment"> * 注意:如果异常发生在内核态，说明内核正在访问用户态的栈，就直接扩展用户栈。</span><br><span class="hljs-comment"> * 注意这里只是扩展了vma，但是并没有分配新的也</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (expand_stack(vma, address)) <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">goto</span> bad_area;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Ok, we have a good vm_area for this memory access, so</span><br><span class="hljs-comment"> * we can handle it..</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理地址空间内的错误地址。其实可能并不是错误地址。</span><br><span class="hljs-comment"> */</span><br>good_area:<br>info.si_code = SEGV_ACCERR;<br>write = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">switch</span> (error_code &amp; <span class="hljs-number">3</span>) &#123;<span class="hljs-comment">/* 错误是由写访问引起的 */</span> <span class="hljs-comment">/*★*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 无权写？？</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">default</span>:<span class="hljs-comment">/* 3: write, present */</span> <span class="hljs-comment">/*异常是由写访问,无效的访问权限引起的。*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> TEST_VERIFY_AREA</span><br><span class="hljs-keyword">if</span> (regs-&gt;cs == KERNEL_CS)<br>printk(<span class="hljs-string">&quot;WP fault at %08lx\n&quot;</span>, regs-&gt;eip);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* fall through */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 写访问出错。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-comment">/* write, not present */</span> <span class="hljs-comment">/*异常由由一个不存在的页, 写访问引起。*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 但是线性区不允许写，难道是想写只读数据区或者代码段？？？</span><br><span class="hljs-comment"> * 注意，当errcode==3也会到这里</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE))<br><span class="hljs-keyword">goto</span> bad_area;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性区可写，但是此时发生了写访问错误。</span><br><span class="hljs-comment"> * 说明可以启动写时复制或请求调页了。将write++其实就是将它置1</span><br><span class="hljs-comment"> */</span><br>write++; <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有读权限？？</span><br><span class="hljs-comment"> * 可能是由于进程试图访问一个有特权的页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-comment">/* read, present */</span> <span class="hljs-comment">/*异常由无效的访问权限, 读访问或者执行访问所引起*/</span><br><span class="hljs-keyword">goto</span> bad_area;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 要读的页不存在，检查是否真的可读或者可执行</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-comment">/* read, not present */</span> <span class="hljs-comment">/*异常由一个不存在的页, 读访问或者执行访问所引起*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 要读的页不存在，也不允许读和执行，那也是一种错误</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC)))<br><span class="hljs-keyword">goto</span> bad_area;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 运行到这里，说明要读的页不存在，但是线性区允许读，说明是需要调页了。</span><br><span class="hljs-comment"> */</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 幸免于难，可能不是真正的错误。</span><br><span class="hljs-comment"> * 呵呵，找块毛巾擦擦汗。</span><br><span class="hljs-comment"> */</span><br> survive:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If for any reason at all we couldn&#x27;t handle the fault,</span><br><span class="hljs-comment"> * make sure we exit gracefully rather than endlessly redo</span><br><span class="hljs-comment"> * the fault.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性区的访问权限与引起异常的类型相匹配，调用handle_mm_fault分配一个新页框。</span><br><span class="hljs-comment"> * handle_mm_fault中会处理请求调页和写时复制两种机制。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">switch</span> (handle_mm_fault(mm, vma, address, write)) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VM_FAULT_MINOR表示没有阻塞当前进程，即次缺页。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">case</span> VM_FAULT_MINOR: <span class="hljs-comment">/*正常*/</span><br>tsk-&gt;min_flt++;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VM_FAULT_MAJOR表示阻塞了当前进程，即主缺页。</span><br><span class="hljs-comment"> * 很可能是由于当用磁盘上的数据填充所分配的页框时花费了时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">case</span> VM_FAULT_MAJOR: <span class="hljs-comment">/*正常*/</span><br>tsk-&gt;maj_flt++;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VM_FAULT_SIGBUS表示其他错误。</span><br><span class="hljs-comment"> * do_sigbus会向进程发送SIGBUS信号。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">case</span> VM_FAULT_SIGBUS: <span class="hljs-comment">/*不正常*/</span><br><span class="hljs-keyword">goto</span> do_sigbus;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VM_FAULT_OOM表示没有足够的内存</span><br><span class="hljs-comment"> * 如果不是init进程，就杀死它，否则就调度其他进程运行，等待内存被释放出来。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">case</span> VM_FAULT_OOM: <span class="hljs-comment">/*不正常*/</span><br><span class="hljs-keyword">goto</span> out_of_memory;<br><span class="hljs-keyword">default</span>:<br>BUG();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Did it hit the DOS screen memory VA from vm86 mode?</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (regs-&gt;eflags &amp; VM_MASK) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bit = (address - <span class="hljs-number">0xA0000</span>) &gt;&gt; PAGE_SHIFT;<br><span class="hljs-keyword">if</span> (bit &lt; <span class="hljs-number">32</span>)<br>tsk-&gt;thread.screen_bitmap |= <span class="hljs-number">1</span> &lt;&lt; bit;<br>&#125;<br>up_read(&amp;mm-&gt;mmap_sem);<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Something tried to access memory that isn&#x27;t in our memory map..</span><br><span class="hljs-comment"> * Fix it, but check if it&#x27;s kernel or user first..</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理地址空间以外的错误地址。</span><br><span class="hljs-comment"> * 当要访问的地址不在进程的地址空间内时，执行到此。</span><br><span class="hljs-comment"> */</span><br>bad_area:<br>up_read(&amp;mm-&gt;mmap_sem);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户态程序访问了内核态地址，或者访问了没有权限的页框。</span><br><span class="hljs-comment"> * 或者是内核态线程出错了，也或者是当前有很紧要的操作</span><br><span class="hljs-comment"> * 总之，运行到这里可不是什么好事。</span><br><span class="hljs-comment"> */</span><br>bad_area_nosemaphore:<br><span class="hljs-comment">/* User mode accesses just cause a SIGSEGV */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第2位 == 1, 异常发生在用户态。</span><br><span class="hljs-comment"> * 发生在用户态的错误地址。</span><br><span class="hljs-comment"> * 就发生一个SIGSEGV信号给current进程，并结束函数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (error_code &amp; <span class="hljs-number">4</span>) &#123;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Valid to do another page fault here because this one came </span><br><span class="hljs-comment"> * from user space.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (is_prefetch(regs, address, error_code))<br><span class="hljs-keyword">return</span>;<br><br>tsk-&gt;thread.cr2 = address;<br><span class="hljs-comment">/* Kernel addresses are always protection faults */</span><br>tsk-&gt;thread.error_code = error_code | (address &gt;= TASK_SIZE);<br>tsk-&gt;thread.trap_no = <span class="hljs-number">14</span>;<br>info.si_signo = SIGSEGV; <span class="hljs-comment">/*SIGSEGV信号*/</span><br>info.si_errno = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/* info.si_code has been set above */</span><br>info.si_addr = (<span class="hljs-type">void</span> __user *)address;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * force_sig_info确信进程不忽略或阻塞SIGSEGV信号</span><br><span class="hljs-comment"> * SEGV_MAPERR或SEGV_ACCERR已经被设置在info.si_code中。</span><br><span class="hljs-comment"> */</span><br>force_sig_info(SIGSEGV, &amp;info, tsk); <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>    <span class="hljs-comment">/*从这里往下，异常发生在内核态*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_F00F_BUG</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Pentium F0 0F C7 C8 bug workaround.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (boot_cpu_data.f00f_bug) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr;<br><br>nr = (address - idt_descr.address) &gt;&gt; <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">if</span> (nr == <span class="hljs-number">6</span>) &#123;<br>do_invalid_op(regs, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 异常发生在内核态。</span><br><span class="hljs-comment"> */</span><br>no_context:<br><span class="hljs-comment">/* Are we prepared to handle this kernel fault?  */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 异常的引起是因为把某个线性地址作为系统调用的参数传递给内核。</span><br><span class="hljs-comment"> * 调用fixup_exception判断这种情况，如果是这样的话，那谢天谢地，还有修复的可能。</span><br><span class="hljs-comment"> * 典型的：fixup_exception可能会向进程发送SIGSEGV信号或者用一个适当的出错码终止系统调用处理程序。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (fixup_exception(regs)) <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Valid to do another page fault here, because if this fault</span><br><span class="hljs-comment"> * had been triggered by is_prefetch fixup_exception would have </span><br><span class="hljs-comment"> * handled it.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">if</span> (is_prefetch(regs, address, error_code))<br> <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Oops. The kernel tried to access some bad page. We&#x27;ll have to</span><br><span class="hljs-comment"> * terminate things with extreme prejudice.</span><br><span class="hljs-comment"> */</span><br><br>bust_spinlocks(<span class="hljs-number">1</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_PAE</span><br><span class="hljs-keyword">if</span> (error_code &amp; <span class="hljs-number">16</span>) &#123;<br><span class="hljs-type">pte_t</span> *pte = lookup_address(address);<br><br><span class="hljs-keyword">if</span> (pte &amp;&amp; pte_present(*pte) &amp;&amp; !pte_exec_kernel(*pte))<br>printk(KERN_CRIT <span class="hljs-string">&quot;kernel tried to execute NX-protected page - exploit attempt? (uid: %d)\n&quot;</span>, current-&gt;uid);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 但愿程序不要运行到这里来，著名的oops出现了^-^</span><br><span class="hljs-comment"> * 不过oops算什么呢，真正的内核高手在等着解决这些错误呢</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (address &lt; PAGE_SIZE)<br>printk(KERN_ALERT <span class="hljs-string">&quot;Unable to handle kernel NULL pointer dereference&quot;</span>);<br><span class="hljs-keyword">else</span><br>printk(KERN_ALERT <span class="hljs-string">&quot;Unable to handle kernel paging request&quot;</span>);<br>printk(<span class="hljs-string">&quot; at virtual address %08lx\n&quot;</span>,address);<br>printk(KERN_ALERT <span class="hljs-string">&quot; printing eip:\n&quot;</span>);<br>printk(<span class="hljs-string">&quot;%08lx\n&quot;</span>, regs-&gt;eip);<br><span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;movl %%cr3,%0&quot;</span>:<span class="hljs-string">&quot;=r&quot;</span> (page));<br>page = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) __va(page))[address &gt;&gt; <span class="hljs-number">22</span>];<br>printk(KERN_ALERT <span class="hljs-string">&quot;*pde = %08lx\n&quot;</span>, page);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We must not directly access the pte in the highpte</span><br><span class="hljs-comment"> * case, the page table might be allocated in highmem.</span><br><span class="hljs-comment"> * And lets rather not kmap-atomic the pte, just in case</span><br><span class="hljs-comment"> * it&#x27;s allocated already.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_HIGHPTE</span><br><span class="hljs-keyword">if</span> (page &amp; <span class="hljs-number">1</span>) &#123;<br>page &amp;= PAGE_MASK;<br>address &amp;= <span class="hljs-number">0x003ff000</span>;<br>page = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) __va(page))[address &gt;&gt; PAGE_SHIFT];<br>printk(KERN_ALERT <span class="hljs-string">&quot;*pte = %08lx\n&quot;</span>, page);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>die(<span class="hljs-string">&quot;Oops&quot;</span>, regs, error_code); <span class="hljs-comment">/*★*/</span><br>bust_spinlocks(<span class="hljs-number">0</span>);<br>do_exit(SIGKILL);   <span class="hljs-comment">/*★*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We ran out of memory, or some other thing happened to us that made</span><br><span class="hljs-comment"> * us unable to handle the page fault gracefully.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 缺页了，但是没有内存了，就杀死进程（init除外）</span><br><span class="hljs-comment"> */</span><br>out_of_memory:<br>up_read(&amp;mm-&gt;mmap_sem);<br><span class="hljs-keyword">if</span> (tsk-&gt;pid == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/*如果是init, 则调度其他进行*/</span><br>yield(); <span class="hljs-comment">/*★*/</span><br>down_read(&amp;mm-&gt;mmap_sem);<br><span class="hljs-keyword">goto</span> survive;<br>&#125;<br>printk(<span class="hljs-string">&quot;VM: killing process %s\n&quot;</span>, tsk-&gt;comm);<br><span class="hljs-keyword">if</span> (error_code &amp; <span class="hljs-number">4</span>) <span class="hljs-comment">/*★*/</span> <span class="hljs-comment">/*如果不是init,就杀死进程*/</span><br>do_exit(SIGKILL);<br><span class="hljs-keyword">goto</span> no_context;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 缺页了，但是分配页时出现了错误，就向进程发送SIGBUS信号。</span><br><span class="hljs-comment"> */</span><br>do_sigbus:<br>up_read(&amp;mm-&gt;mmap_sem);<br><br><span class="hljs-comment">/* Kernel mode? Handle exceptions or die */</span><br><span class="hljs-keyword">if</span> (!(error_code &amp; <span class="hljs-number">4</span>))<br><span class="hljs-keyword">goto</span> no_context;<br><br><span class="hljs-comment">/* User space =&gt; ok to do another page fault */</span><br><span class="hljs-keyword">if</span> (is_prefetch(regs, address, error_code))<br><span class="hljs-keyword">return</span>;<br><br>tsk-&gt;thread.cr2 = address;<br>tsk-&gt;thread.error_code = error_code;<br>tsk-&gt;thread.trap_no = <span class="hljs-number">14</span>;<br>info.si_signo = SIGBUS;<br>info.si_errno = <span class="hljs-number">0</span>;<br>info.si_code = BUS_ADRERR;<br>info.si_addr = (<span class="hljs-type">void</span> __user *)address;<br>force_sig_info(SIGBUS, &amp;info, tsk); <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内核访问了不存在的页框。</span><br><span class="hljs-comment"> * 内核在更新非连续内存区对应的页表项时是非常懒惰的。实际上，vmalloc和vfree函数只把自己限制在更新主内核页表（即全局目录和它的子页表）。</span><br><span class="hljs-comment"> * 但是，如果内核真的访问到了vmalloc的空间，就需要把页表项补充完整了。</span><br><span class="hljs-comment"> */</span><br>vmalloc_fault:<br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Synchronize this task&#x27;s top level page-table</span><br><span class="hljs-comment"> * with the &#x27;reference&#x27; page table.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Do _not_ use &quot;tsk&quot; here. We might be inside</span><br><span class="hljs-comment"> * an interrupt in the middle of a task switch..</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> index = pgd_index(address);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgd_paddr;<br><span class="hljs-type">pgd_t</span> *pgd, *pgd_k;<br><span class="hljs-type">pud_t</span> *pud, *pud_k;<br><span class="hljs-type">pmd_t</span> *pmd, *pmd_k;<br><span class="hljs-type">pte_t</span> *pte_k;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把cr3中当前进程页全局目录的物理地址赋给局部变量pgd_paddr。</span><br><span class="hljs-comment"> * 注：内核不使用current-&gt;mm-&gt;pgd导出当前进程的页全局目录地址。因为这种缺页可能在任何时刻发生，甚至在进程切换期间发生。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;movl %%cr3,%0&quot;</span>:<span class="hljs-string">&quot;=r&quot;</span> (pgd_paddr));<br>pgd = index + (<span class="hljs-type">pgd_t</span> *)__va(pgd_paddr);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把主内核页全局目录的线性地址赋给pgd_k</span><br><span class="hljs-comment"> */</span><br>pgd_k = init_mm.pgd + index;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * pgd_k对应的主内核页全局目录项为空。说明不是非连续内存区产生的错误。</span><br><span class="hljs-comment"> * 因为非连续内存区产生的缺页仅仅是没有页表项，而不会缺少目录项。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!pgd_present(*pgd_k))<br><span class="hljs-keyword">goto</span> no_context;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * set_pgd(pgd, *pgd_k); here would be useless on PAE</span><br><span class="hljs-comment"> * and redundant with the set_pmd() on non-PAE. As would</span><br><span class="hljs-comment"> * set_pud.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查了全局目录项，还必须检查主内核页上级目录项和中间目录项。</span><br><span class="hljs-comment"> * 如果它们中有一个为空，也转到no_context</span><br><span class="hljs-comment"> */</span><br>pud = pud_offset(pgd, address); <span class="hljs-comment">/*直接用，没有分配，因为共享了内核主页表的PUD*/</span><br>pud_k = pud_offset(pgd_k, address);<br><span class="hljs-keyword">if</span> (!pud_present(*pud_k))<br><span class="hljs-keyword">goto</span> no_context;<br><br>pmd = pmd_offset(pud, address); <span class="hljs-comment">/*直接用，没有分配，因为共享了内核主页表的PMD*/</span><br>pmd_k = pmd_offset(pud_k, address);<br><span class="hljs-keyword">if</span> (!pmd_present(*pmd_k))<br><span class="hljs-keyword">goto</span> no_context;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目录项不为空，说明真的是在访问非连续内存区。就把主目录项复制到进程页中间目录的相应项中。</span><br><span class="hljs-comment"> */</span><br>set_pmd(pmd, *pmd_k); <span class="hljs-comment">/*这里共享了内核主页表的PT，因为PMD,PUD都是共享的，所以vmalloc只可能是因为pgd中的present没有置位引发的*/</span><br><br>pte_k = pte_offset_kernel(pmd_k, address);<br><span class="hljs-keyword">if</span> (!pte_present(*pte_k))<br><span class="hljs-keyword">goto</span> no_context;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * By the time we get here, we already hold the mm semaphore</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当程序缺页时，调用此过程分配新的页框。</span><br><span class="hljs-comment"> * mm-异常发生时，正在CPU上运行的进程的内存描述符</span><br><span class="hljs-comment"> * vma-指向引起异常的线性地址所在线性区的描述符。</span><br><span class="hljs-comment"> * address-引起异常的地址。</span><br><span class="hljs-comment"> * write_access-如果tsk试图向address写，则为1，否则为0。为1时候，表示COW</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">handle_mm_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-keyword">struct</span> vm_area_struct * vma,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">int</span> write_access)</span><br>&#123;<br><span class="hljs-type">pgd_t</span> *pgd;<br><span class="hljs-type">pud_t</span> *pud;<br><span class="hljs-type">pmd_t</span> *pmd;<br><span class="hljs-type">pte_t</span> *pte;<br><br>__set_current_state(TASK_RUNNING);<br><br>inc_page_state(pgfault);<br><br><span class="hljs-keyword">if</span> (is_vm_hugetlb_page(vma))<br><span class="hljs-keyword">return</span> VM_FAULT_SIGBUS;<span class="hljs-comment">/* mapping truncation does this. */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We need the page table lock to synchronize with kswapd</span><br><span class="hljs-comment"> * and the SMP-safe atomic PTE updates.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * pgd_offset和pud_alloc检查映射address的页中间目录和页表是否存在。</span><br><span class="hljs-comment"> */</span><br>pgd = pgd_offset(mm, address);<br>spin_lock(&amp;mm-&gt;page_table_lock);<br><br>pud = pud_alloc(mm, pgd, address);<br><span class="hljs-keyword">if</span> (!pud)<br><span class="hljs-keyword">goto</span> oom;<br><br>pmd = pmd_alloc(mm, pud, address);<br><span class="hljs-keyword">if</span> (!pmd)<br><span class="hljs-keyword">goto</span> oom;<br><br>pte = pte_alloc_map(mm, pmd, address); <br><span class="hljs-keyword">if</span> (!pte)<br><span class="hljs-keyword">goto</span> oom;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 至此，从pgd到pte的页表已经建立好了，就差新分配一个页面并填写到pte中了</span><br><span class="hljs-comment">     */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * handle_pte_fault函数检查address地址所对应的页表项。并决定如何为进程分配一个新页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> handle_pte_fault(mm, vma, address, write_access, pte, pmd);<br><br> oom:<br>spin_unlock(&amp;mm-&gt;page_table_lock);<br><span class="hljs-keyword">return</span> VM_FAULT_OOM;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果被访问的页不存在，内核分配一个新的页框并适当初始化，这种技术叫请求调页。而如果被访问的页存在但是只读，那么内核分配一个新的页框并把旧页框数据拷贝到新页框来初始化它的内容，这叫写时复制COW。</p><h3 id="请求调页">请求调页</h3><p>本质上是一种推迟，直到第一次访问页时才借助缺页异常在RAM中分配。这种推迟很有意义，因为进程开始运行时并不会访问全部地址。这种策略节省了RAM开销但也增加了CPU开销（局部性原理使得缺页异常注定稀有）。</p><p>被访问的页不在ram中，有几种可能：要么进程从未访问过该页，要么该页对应页框被内核回收了。此时就需要分配新页框，如何初始化取决于是哪一种页，以前是否被进程访问过。</p><p>几种特殊情况：</p><ol type="1"><li>这个页从未被进程访问且没有映射磁盘文件，或者页映射了磁盘文件。内核可以识别这种情况，因为页表相应的表项被填充为0，<code>pte_none</code>会返回1。</li><li>页属于非线性磁盘文件的映射。内核通过Present标志为0且Dirty标志为1来识别。<code>pte_file</code>返回1。</li><li>进程已经访问过这个页，但是内容被临时保存在磁盘上。内核能够识别这种情况，这是因为相应表项没被填充为0，但是Present和Dirty标志被清0。</li></ol><p>这三种情况的鉴别在上面的<code>handle_pte_fault</code>中皆已看到。</p><p>对第二种和第三种来说，会牵扯到文件映射和页高速磁盘缓存的内容，这些又自成话题了，暂时不做探索。我们关心<code>do_no_page()-&gt;do_anonymous_page()</code>这一脉：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * do_no_page() tries to create a new page mapping. It aggressively</span><br><span class="hljs-comment"> * tries to share with existing pages, but makes a separate copy if</span><br><span class="hljs-comment"> * the &quot;write_access&quot; parameter is true in order to avoid the next</span><br><span class="hljs-comment"> * page fault.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * As this is called only for pages that do not currently exist, we</span><br><span class="hljs-comment"> * do not need to flush old virtual caches or the TLB.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This is called with the MM semaphore held and the page table</span><br><span class="hljs-comment"> * spinlock held. Exit with the spinlock released.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当被访问的页不在主存中时，如果页从没有访问过，或者映射了磁盘文件</span><br><span class="hljs-comment"> * 那么pte_none宏会返回1，handle_pte_fault函数会调用本函数装入所缺的页。</span><br><span class="hljs-comment"> * 也就是还从来没有使用过这个页面</span><br><span class="hljs-comment"> * 执行对请求调页的所有类型都通用的操作。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">do_no_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">int</span> write_access, <span class="hljs-type">pte_t</span> *page_table, <span class="hljs-type">pmd_t</span> *pmd)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> * <span class="hljs-title">new_page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *<span class="hljs-title">mapping</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">pte_t</span> entry;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sequence = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ret = VM_FAULT_MINOR;<br><span class="hljs-type">int</span> anon = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * vma-&gt;vm_ops || !vma-&gt;vm_ops-&gt;nopage,这是判断线性区是否映射了一个磁盘文件。</span><br><span class="hljs-comment"> * 这两个值只要某一个为空，说明没有映射磁盘文件。也就是说：它是一个匿名映射。</span><br><span class="hljs-comment"> * nopage指向装入页的函数。</span><br><span class="hljs-comment"> * 当没有映射时，就调用do_anonymous_page获得一个新的页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!vma-&gt;vm_ops || !vma-&gt;vm_ops-&gt;nopage)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * do_anonymous_page获得一个新的页框。分别处理写请求和读讨还。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> do_anonymous_page(mm, vma, page_table,<br>pmd, write_access, address); <span class="hljs-comment">/*★*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 否则，就是一个文件映射。进行请求调页处理。</span><br><span class="hljs-comment"> */</span><br>pte_unmap(page_table);<br>spin_unlock(&amp;mm-&gt;page_table_lock);<br><br><span class="hljs-keyword">if</span> (vma-&gt;vm_file) &#123;<br>mapping = vma-&gt;vm_file-&gt;f_mapping;<br>sequence = mapping-&gt;truncate_count;<br>smp_rmb(); <span class="hljs-comment">/* serializes i_size against truncate_count */</span><br>&#125;<br>retry:<br>cond_resched();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线性区定义了nopage方法，则回调此方法以返回所请求页的页框的地址。</span><br><span class="hljs-comment"> * 调用filemap_nopage</span><br><span class="hljs-comment"> */</span><br>new_page = vma-&gt;vm_ops-&gt;nopage(vma, address &amp; PAGE_MASK, &amp;ret); <span class="hljs-comment">/*★*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * No smp_rmb is needed here as long as there&#x27;s a full</span><br><span class="hljs-comment"> * spin_lock/unlock sequence inside the -&gt;nopage callback</span><br><span class="hljs-comment"> * (for the pagecache lookup) that acts as an implicit</span><br><span class="hljs-comment"> * smp_mb() and prevents the i_size read to happen</span><br><span class="hljs-comment"> * after the next truncate_count read.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* no page was available -- either SIGBUS or OOM */</span><br><span class="hljs-keyword">if</span> (new_page == NOPAGE_SIGBUS)<br><span class="hljs-keyword">return</span> VM_FAULT_SIGBUS;<br><span class="hljs-keyword">if</span> (new_page == NOPAGE_OOM)<br><span class="hljs-keyword">return</span> VM_FAULT_OOM;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Should we do an early C-O-W break?</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程试图对页进行写入，而该内存映射是私有的，需要取消内存映射。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 这是什么情况?</span><br><span class="hljs-keyword">if</span> (write_access &amp;&amp; !(vma-&gt;vm_flags &amp; VM_SHARED)) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-keyword">if</span> (unlikely(anon_vma_prepare(vma)))<br><span class="hljs-keyword">goto</span> oom;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分配一个新页。并将读取的页拷贝一份到新页中。。</span><br><span class="hljs-comment"> */</span><br>page = alloc_page_vma(GFP_HIGHUSER, vma, address); <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">goto</span> oom;<br>copy_user_highpage(page, new_page, address); <span class="hljs-comment">/*★*/</span><br>page_cache_release(new_page); <span class="hljs-comment">/*★*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在后面的步骤中，使用新页而不是nopage方法返回的页，这样，后者就不会被用户态进程修改。</span><br><span class="hljs-comment"> */</span><br>new_page = page; <span class="hljs-comment">/*★*/</span><br>anon = <span class="hljs-number">1</span>;<br>&#125;<br><br>spin_lock(&amp;mm-&gt;page_table_lock);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For a file-backed vma, someone could have truncated or otherwise</span><br><span class="hljs-comment"> * invalidated this page.  If unmap_mapping_range got called,</span><br><span class="hljs-comment"> * retry getting the page.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果某个其他进程删改或者作废了该页(truncate_count用于此种检查),则跳转回去，尝试再次获得该页。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (mapping &amp;&amp; unlikely(sequence != mapping-&gt;truncate_count)) &#123;<br>sequence = mapping-&gt;truncate_count;<br>spin_unlock(&amp;mm-&gt;page_table_lock);<br>page_cache_release(new_page);<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br>    <span class="hljs-comment">/*返回address对应的页表项pte*/</span><br>page_table = pte_offset_map(pmd, address);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This silly early PAGE_DIRTY setting removes a race</span><br><span class="hljs-comment"> * due to the bad i386 page protection. But it&#x27;s valid</span><br><span class="hljs-comment"> * for other architectures too.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note that if write_access is true, we either now have</span><br><span class="hljs-comment"> * an exclusive copy of the page, or this is a shared mapping,</span><br><span class="hljs-comment"> * so we can make it writable and dirty to avoid having to</span><br><span class="hljs-comment"> * handle that later.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Only go through if we didn&#x27;t race with anybody else... */</span><br><span class="hljs-keyword">if</span> (pte_none(*page_table)) &#123;<br><span class="hljs-keyword">if</span> (!PageReserved(new_page))<br>++mm-&gt;rss;<span class="hljs-comment">/* 增加进程的rss字段，以表示一个新页框已经分配给进程。 */</span><br>acct_update_integrals();<br>update_mem_hiwater();<br><br>flush_icache_page(vma, new_page);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用新页框 的地址以及线性区的vm_page_prot字段中所包含的页访问权来设置缺页所在的地址对应的页表项。</span><br><span class="hljs-comment"> */</span><br>entry = mk_pte(new_page, vma-&gt;vm_page_prot);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果进程试图对这个页进行写入，则把页表项的read/write和dirty设置为1.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (write_access)<br>entry = maybe_mkwrite(pte_mkdirty(entry), vma);<br>        <span class="hljs-comment">/*设定pte*/</span><br>set_pte(page_table, entry); <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">if</span> (anon) &#123;<br>lru_cache_add_active(new_page);<br>page_add_anon_rmap(new_page, vma, address);<br>&#125; <span class="hljs-keyword">else</span><br>page_add_file_rmap(new_page);<br>pte_unmap(page_table);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* One of our sibling threads was faster, back out. */</span><br>pte_unmap(page_table);<br>page_cache_release(new_page);<br>spin_unlock(&amp;mm-&gt;page_table_lock);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-comment">/* no need to invalidate: a not-present page shouldn&#x27;t be cached */</span><br>update_mmu_cache(vma, address, entry);<br>spin_unlock(&amp;mm-&gt;page_table_lock);<br>out:<br><span class="hljs-keyword">return</span> ret;<br>oom:<br>page_cache_release(new_page);<br>ret = VM_FAULT_OOM;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We are called with the MM semaphore and page_table_lock</span><br><span class="hljs-comment"> * spinlock held to protect against concurrent faults in</span><br><span class="hljs-comment"> * multithreaded programs. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得一个新的页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">do_anonymous_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params"><span class="hljs-type">pte_t</span> *page_table, <span class="hljs-type">pmd_t</span> *pmd, <span class="hljs-type">int</span> write_access,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br><span class="hljs-type">pte_t</span> entry;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> * <span class="hljs-title">page</span> =</span> ZERO_PAGE(addr); <span class="hljs-comment">/*★*/</span><br><br><span class="hljs-comment">/* Read-only mapping of ZERO_PAGE. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对读访问时，页的内容是无关紧要的。</span><br><span class="hljs-comment"> * 但是，第一次分给进程的页，最好还是填上0。以免旧页的信息被黑客利用。</span><br><span class="hljs-comment"> * 没有必要立即分配这样的页框。只需要把empty_zero_page页映射给进程就行了。</span><br><span class="hljs-comment"> * 并且将页标记为只读，当进程试图写这个页时，再启动写时复制机制。</span><br><span class="hljs-comment"> */</span><br>entry = pte_wrprotect(mk_pte(ZERO_PAGE(addr), vma-&gt;vm_page_prot)); <span class="hljs-comment">/*★*/</span><br><br><span class="hljs-comment">/* ..except if it&#x27;s a write access */</span><br><span class="hljs-keyword">if</span> (write_access) &#123;<br><span class="hljs-comment">/* Allocate our own private page. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放临时内核映射。</span><br><span class="hljs-comment"> * 在调用handle_pte_fault函数之前，由pte_offset_map所建立页表项的高端内存物理地址。</span><br><span class="hljs-comment"> * pte_offset_map宏是和pte_unmap配对使用的。</span><br><span class="hljs-comment"> * pte_unmap必须在alloc_page前释放。因为alloc_page可能阻塞当前进程？？</span><br><span class="hljs-comment"> * 答: 在alloc_zeroed_user_highpage时(可能睡眠)，其他线程可能更新的执行分配页面和设定页表，所指这里需要先unmap，防止阻塞其他线程</span><br><span class="hljs-comment"> */</span><br>pte_unmap(page_table);<br>spin_unlock(&amp;mm-&gt;page_table_lock);<br><br><span class="hljs-keyword">if</span> (unlikely(anon_vma_prepare(vma)))<br><span class="hljs-keyword">goto</span> no_mem;<br>page = alloc_zeroed_user_highpage(vma, addr); <span class="hljs-comment">/*★*/</span><br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">goto</span> no_mem;<br><br>spin_lock(&amp;mm-&gt;page_table_lock);<br>page_table = pte_offset_map(pmd, addr);<br><br><span class="hljs-keyword">if</span> (!pte_none(*page_table)) &#123;<br>pte_unmap(page_table);<br>page_cache_release(page);<br>spin_unlock(&amp;mm-&gt;page_table_lock);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递增rss字段，它记录了分配给进程的页框总数。</span><br><span class="hljs-comment"> */</span><br>mm-&gt;rss++;<br>acct_update_integrals();<br>update_mem_hiwater();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 标记页框为既脏又可写。</span><br><span class="hljs-comment"> * 如果调试程序试图往被跟踪进程只读线性区中的页中写数据。内核不会设置相关标志。</span><br><span class="hljs-comment"> * maybe_mkwrite会处理这种特殊情况。</span><br><span class="hljs-comment"> */</span><br>entry = maybe_mkwrite(pte_mkdirty(mk_pte(page,<br> vma-&gt;vm_page_prot)),<br>      vma);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * lru_cache_add_active把新页框插入与交换相关的数据结构中。</span><br><span class="hljs-comment"> */</span><br>lru_cache_add_active(page);<br>SetPageReferenced(page);<br>page_add_anon_rmap(page, vma, addr);<br>&#125;<br><br>    <span class="hljs-comment">/*设定页表项*/</span><br>set_pte(page_table, entry); <span class="hljs-comment">/*★*/</span><br>pte_unmap(page_table);<br><br><span class="hljs-comment">/* No need to invalidate - it was non-present before */</span><br>update_mmu_cache(vma, addr, entry);<br>spin_unlock(&amp;mm-&gt;page_table_lock);<br>out:<br><span class="hljs-keyword">return</span> VM_FAULT_MINOR;<br>no_mem:<br><span class="hljs-keyword">return</span> VM_FAULT_OOM;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cow">COW</h3><p>傻老帽的fork方式：</p><ul><li>为子进程的页表和页分配页框</li><li>初始化子进程页表</li><li>把父进程的页复制到子进程相应的页中</li></ul><p>笨重至极！</p><p>现代Linux采用COW，父进程和子进程一开始共享页框不进行复制。一旦开始共享，那么二者都不能去修改，一旦父进程或子进程其中一个想要写共享页框，就产生异常。内核此时才会进行复制，独立出一个可写的页框给他。这也是<code>handle_pte_fault()</code>完成的（这函数非单一职责，当然复杂得很）。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux-kernel</tag>
      
      <tag>ulk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-ThreadProcess-analysis</title>
    <link href="/2018/06/03/chromium-sandbox-ThreadProcess-analysis/"/>
    <url>/2018/06/03/chromium-sandbox-ThreadProcess-analysis/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第十五篇，主要分析了子系统ThreadProcess的三大组件。</p><p>Target进程执行9个进程线程相关API时，应用于此的三大组件进行了一些处理。该子系统和Filesystem类似，但9个API却分成了3个类别，具体内容请参考本文的详细解读。</p><p>阅读本篇前，请先阅读前面所有章节。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-threadprocess-analysis">chromium-sandbox-ThreadProcess-analysis</h1><p>上一篇分析了Filesystem子系统，通过对filesystem子系统三大组件的分析，我们已经理清了完整的脉络。本篇我们采用相同的方式，长驱直入，分析ThreadProcess子系统。</p><h2 id="初始化设置">初始化设置</h2><p>在分析三大组件前，先看看初始化时都置办了哪些物件。</p><h3id="topleveldispatchertopleveldispatcher"><code>TopLevelDispatcher::TopLevelDispatcher</code></h3><p><code>TopLevelDispatcher</code>的构造器是在<code>PolicyBase</code>的构造器中调用的，构造器内部我们已经非常熟悉了，它会将<code>ipc_targets_</code>指针数组的每一个成员指向正确的dispatcher对象。而对于ThreadProcess子系统来说，这个dispatcher对象是一个<code>ThreadProcessDispatcher</code>对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dispatcher = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ThreadProcessDispatcher</span>(policy_);<br>ipc_targets_[IPC_NTOPENTHREAD_TAG] = dispatcher;<br>ipc_targets_[IPC_NTOPENPROCESS_TAG] = dispatcher;<br>ipc_targets_[IPC_CREATEPROCESSW_TAG] = dispatcher;<br>ipc_targets_[IPC_NTOPENPROCESSTOKEN_TAG] = dispatcher;<br>ipc_targets_[IPC_NTOPENPROCESSTOKENEX_TAG] = dispatcher;<br>ipc_targets_[IPC_CREATETHREAD_TAG] = dispatcher;<br>thread_process_dispatcher_.<span class="hljs-built_in">reset</span>(dispatcher);<br></code></pre></td></tr></table></figure><p>可以看到该子系统相关的IPC请求tag有6种，分别是NtOpenThread,NtOpenProcess, CreateProcess, NtOpenProcessToken, NtOpenProcessTokenEx,CreateThread。</p><h3 id="policybaseaddtarget"><code>PolicyBase::AddTarget</code></h3><p><code>PolicyBase</code>的Rules是预先由操纵者设计好的，当在<code>BrokerServices::SpawnTarget</code>中调用<code>PolicyBase::AddTarget</code>时，会进行一大堆关键操作，此前我们已经分析过数个了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::AddTarget</span><span class="hljs-params">(TargetProcess* target)</span> </span>&#123;<br>  <span class="hljs-comment">// 把AddRules添加的PolicyRule解析出来全部置入PolicyGlobal</span><br>  <span class="hljs-keyword">if</span> (policy_)<br>    policy_maker_-&gt;<span class="hljs-built_in">Done</span>();<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ApplyProcessMitigationsToSuspendedProcess</span>(target-&gt;<span class="hljs-built_in">Process</span>(),<br>                                                 mitigations_)) &#123;<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_APPLY_ASLR_MITIGATIONS;<br>  &#125;<br><br>  <span class="hljs-comment">// 我们本次对它感兴趣</span><br>  ResultCode ret = <span class="hljs-built_in">SetupAllInterceptions</span>(target);<br><br>  <span class="hljs-keyword">if</span> (ret != SBOX_ALL_OK)<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetupHandleCloser</span>(target))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_SETUP_HANDLE_CLOSER;<br><br>  DWORD win_error = ERROR_SUCCESS;<br>  <span class="hljs-comment">// Initialize the sandbox infrastructure for the target.</span><br>  <span class="hljs-comment">// TODO(wfh) do something with win_error code here.</span><br>  ret = target-&gt;<span class="hljs-built_in">Init</span>(dispatcher_.<span class="hljs-built_in">get</span>(), policy_, kIPCMemSize, kPolMemSize,<br>                     &amp;win_error);<br><br>  <span class="hljs-keyword">if</span> (ret != SBOX_ALL_OK)<br>    <span class="hljs-keyword">return</span> ret;<br><br>  g_shared_delayed_integrity_level = delayed_integrity_level_;<br>  ret = target-&gt;<span class="hljs-built_in">TransferVariable</span>(<span class="hljs-string">&quot;g_shared_delayed_integrity_level&quot;</span>,<br>                                 &amp;g_shared_delayed_integrity_level,<br>                                 <span class="hljs-built_in">sizeof</span>(g_shared_delayed_integrity_level));<br>  g_shared_delayed_integrity_level = INTEGRITY_LEVEL_LAST;<br>  <span class="hljs-keyword">if</span> (SBOX_ALL_OK != ret)<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// Add in delayed mitigations and pseudo-mitigations enforced at startup.</span><br>  g_shared_delayed_mitigations =<br>      delayed_mitigations_ | <span class="hljs-built_in">FilterPostStartupProcessMitigations</span>(mitigations_);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CanSetProcessMitigationsPostStartup</span>(g_shared_delayed_mitigations))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br>  ret = target-&gt;<span class="hljs-built_in">TransferVariable</span>(<span class="hljs-string">&quot;g_shared_delayed_mitigations&quot;</span>,<br>                                 &amp;g_shared_delayed_mitigations,<br>                                 <span class="hljs-built_in">sizeof</span>(g_shared_delayed_mitigations));<br>  g_shared_delayed_mitigations = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (SBOX_ALL_OK != ret)<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-function">AutoLock <span class="hljs-title">lock</span><span class="hljs-params">(&amp;lock_)</span></span>;<br>  targets_.<span class="hljs-built_in">push_back</span>(target);<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>LowLevelPolicy::Done</code>操作没什么好说的，我们感兴趣的是<code>SetupAllInterceptions</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetupAllInterceptions</span><span class="hljs-params">(TargetProcess* target)</span> </span>&#123;<br>  <span class="hljs-function">InterceptionManager <span class="hljs-title">manager</span><span class="hljs-params">(target, relaxed_interceptions_)</span></span>;<br><br>  <span class="hljs-keyword">if</span> (policy_) &#123;<br>    <span class="hljs-comment">// 对每个IPC tag，都要进行dispatcher_-&gt;SetupService</span><br>    <span class="hljs-comment">// 此处的dispatcher_是个TopLevelDispatcher，内部会根据tag分发</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; IPC_LAST_TAG; i++) &#123;<br>      <span class="hljs-keyword">if</span> (policy_-&gt;entry[i] &amp;&amp; !dispatcher_-&gt;<span class="hljs-built_in">SetupService</span>(&amp;manager, i))<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_SETUP_INTERCEPTION_SERVICE;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 这些是target不允许加载的dll，加入manager管制</span><br>  <span class="hljs-keyword">if</span> (!blacklisted_dlls_.<span class="hljs-built_in">empty</span>()) &#123;<br>    std::vector&lt;base::string16&gt;::iterator it = blacklisted_dlls_.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">for</span> (; it != blacklisted_dlls_.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>      manager.<span class="hljs-built_in">AddToUnloadModules</span>(it-&gt;<span class="hljs-built_in">c_str</span>());<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 非常关键的调用</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetupBasicInterceptions</span>(&amp;manager, is_csrss_connected_))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_SETUP_BASIC_INTERCEPTIONS;<br><br>  ResultCode rc = manager.<span class="hljs-built_in">InitializeInterceptions</span>();<br>  <span class="hljs-keyword">if</span> (rc != SBOX_ALL_OK)<br>    <span class="hljs-keyword">return</span> rc;<br><br>  <span class="hljs-comment">// Finally, setup imports on the target so the interceptions can work.</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetupNtdllImports</span>(target))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_SETUP_NTDLL_IMPORTS;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br><br><span class="hljs-comment">// Delegate to the appropriate dispatcher.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TopLevelDispatcher::SetupService</span><span class="hljs-params">(InterceptionManager* manager,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">int</span> service)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (IPC_PING1_TAG == service || IPC_PING2_TAG == service)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// GetDispatcher不过是取出ipc_targets_[service]，它在构造器中设置过了</span><br>  Dispatcher* dispatcher = <span class="hljs-built_in">GetDispatcher</span>(service);<br>  <span class="hljs-keyword">if</span> (!dispatcher) &#123;<br>    <span class="hljs-built_in">NOTREACHED</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> dispatcher-&gt;<span class="hljs-built_in">SetupService</span>(manager, service);<br>&#125;<br></code></pre></td></tr></table></figure><p>上一篇分析的<code>FilesystemDispatcher</code>在此处对5个系统调用进行了Interceptions的安装。类比一下，其他的子系统应该也差不多。我们先看看<code>ThreadProcessDispatcher::SetupService</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ThreadProcessDispatcher::SetupService</span><span class="hljs-params">(InterceptionManager* manager,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">int</span> service)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (service) &#123;<br>    <span class="hljs-keyword">case</span> IPC_NTOPENTHREAD_TAG:<br>    <span class="hljs-keyword">case</span> IPC_NTOPENPROCESS_TAG:<br>    <span class="hljs-keyword">case</span> IPC_NTOPENPROCESSTOKEN_TAG:<br>    <span class="hljs-keyword">case</span> IPC_NTOPENPROCESSTOKENEX_TAG:<br>    <span class="hljs-keyword">case</span> IPC_CREATETHREAD_TAG:<br>      <span class="hljs-comment">// There is no explicit policy for these services.</span><br>      <span class="hljs-comment">// 这里非常奇怪，SetupService对这5个IPC tag没有做任何的拦截，它们不需要拦截？</span><br>      <span class="hljs-comment">// 还是说因为某种原因而不在此处处理？</span><br>      <span class="hljs-built_in">NOTREACHED</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">case</span> IPC_CREATEPROCESSW_TAG:<br>      <span class="hljs-comment">// 只有CreateProcess这个kernel32.dll的函数在这里处理</span><br>      <span class="hljs-comment">// 这里和filesystem不同，它是个eat类型的interception</span><br>      <span class="hljs-comment">// eat是通过修改dll导入表地址的方式来hook的，且它的安装是broker交由target自己处理的</span><br>      <span class="hljs-comment">// hook函数叫TargetCreateProcess</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">INTERCEPT_EAT</span>(manager, kKerneldllName, CreateProcessW,<br>                           CREATE_PROCESSW_ID, <span class="hljs-number">44</span>) &amp;&amp;<br>             <span class="hljs-built_in">INTERCEPT_EAT</span>(manager, <span class="hljs-string">L&quot;kernel32.dll&quot;</span>, CreateProcessA,<br>                           CREATE_PROCESSA_ID, <span class="hljs-number">44</span>);<br><br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERCEPT_EAT(manager, dll, function, id, num_params) \</span><br><span class="hljs-meta">  manager-&gt;AddToPatchedFunctions(                             \</span><br><span class="hljs-meta">      dll, #function, sandbox::INTERCEPTION_EAT,              \</span><br><span class="hljs-meta">      reinterpret_cast<span class="hljs-string">&lt;void*&gt;</span>(MAKE_SERVICE_NAME(function)), id)</span><br></code></pre></td></tr></table></figure><p>再看看此后的关键call——<code>SetupBasicInterceptions</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetupBasicInterceptions</span><span class="hljs-params">(InterceptionManager* manager,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">bool</span> is_csrss_connected)</span> </span>&#123;<br>  <span class="hljs-comment">// Interceptions provided by process_thread_policy, without actual policy.</span><br>  <span class="hljs-comment">// 这3个连同下面的NtOpenProcessTokenEx都是有对应IPC tag的，看来它们4个的拦截器实际上是装了的，只不过移到了此处</span><br>  <span class="hljs-comment">// 根据注释，之所以移到此处是因为它们无需policy</span><br>  <span class="hljs-comment">// 但是dispatcher也和policy没有直接关系啊，我不太理解这种设计，历史原因？</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">INTERCEPT_NT</span>(manager, NtOpenThread, OPEN_THREAD_ID, <span class="hljs-number">20</span>) ||<br>      !<span class="hljs-built_in">INTERCEPT_NT</span>(manager, NtOpenProcess, OPEN_PROCESS_ID, <span class="hljs-number">20</span>) ||<br>      !<span class="hljs-built_in">INTERCEPT_NT</span>(manager, NtOpenProcessToken, OPEN_PROCESS_TOKEN_ID, <span class="hljs-number">16</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// Interceptions with neither policy nor IPC.</span><br>  <span class="hljs-comment">// 这两个函数没有对应的IPC tag，是因为它们无需IPC请求</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">INTERCEPT_NT</span>(manager, NtSetInformationThread, SET_INFORMATION_THREAD_ID,<br>                    <span class="hljs-number">20</span>) ||<br>      !<span class="hljs-built_in">INTERCEPT_NT</span>(manager, NtOpenThreadToken, OPEN_THREAD_TOKEN_ID, <span class="hljs-number">20</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// This one is also provided by process_thread_policy.</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">INTERCEPT_NT</span>(manager, NtOpenProcessTokenEx, OPEN_PROCESS_TOKEN_EX_ID,<br>                    <span class="hljs-number">20</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// NtOpenThreadTokenEx也没有对应的IPC tag，它也无需IPC请求</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">INTERCEPT_NT</span>(manager, NtOpenThreadTokenEx, OPEN_THREAD_TOKEN_EX_ID, <span class="hljs-number">24</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 如果csrss未连接，那么还要拦截kernel32.dll的CreateThread</span><br>  <span class="hljs-comment">// 它是有IPC tag的，注意它是导入表hook</span><br>  <span class="hljs-keyword">if</span> (!is_csrss_connected) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">INTERCEPT_EAT</span>(manager, kKerneldllName, CreateThread, CREATE_THREAD_ID,<br>                       <span class="hljs-number">28</span>))<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>9个函数中有3个是不需要IPC请求的，其余6个仅有CreateProcess在dispatcher的<code>SetupService</code>中进行了设置，其他都是由<code>SetupBasicInterceptions</code>部署的。除了没有IPC请求的3个以及需要判定<code>is_csrss_connected</code>的CreateThread，其他的几个为什么不放入Dispatcher中的<code>SetupService</code>处理，我也不是很懂，字面的意思是因为它们无需实际的policy，但另一方面，dispatcher和policy并没有直接关联。</p><p>或许继续分析会找到答案也说不定。</p><h2 id="policy">policy</h2><p>和filesystem子系统大同小异，policy也提供了一个最为重要的接口<code>GenerateRules</code>以及6个在dispatcher中调用的action。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This class centralizes most of the knowledge related to process execution.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessPolicy</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Creates the required low-level policy rules to evaluate a high-level.</span><br>  <span class="hljs-comment">// policy rule for process creation</span><br>  <span class="hljs-comment">// &#x27;name&#x27; is the executable to be spawn.</span><br>  <span class="hljs-comment">// &#x27;semantics&#x27; is the desired semantics.</span><br>  <span class="hljs-comment">// &#x27;policy&#x27; is the policy generator to which the rules are going to be added.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">GenerateRules</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                            TargetPolicy::Semantics semantics,</span></span><br><span class="hljs-params"><span class="hljs-function">                            LowLevelPolicy* policy)</span></span>;<br><br>  <span class="hljs-comment">// Opens a thread from the child process and returns the handle.</span><br>  <span class="hljs-comment">// client_info contains the information about the child process,</span><br>  <span class="hljs-comment">// desired_access is the access requested by the child and thread_id</span><br>  <span class="hljs-comment">// is the thread_id to be opened.</span><br>  <span class="hljs-comment">// The function returns the return value of NtOpenThread.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> NTSTATUS <span class="hljs-title">OpenThreadAction</span><span class="hljs-params">(<span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">uint32_t</span> thread_id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   HANDLE* handle)</span></span>;<br><br>  <span class="hljs-comment">// Opens the process id passed in and returns the duplicated handle to</span><br>  <span class="hljs-comment">// the child. We only allow the child processes to open themselves. Any other</span><br>  <span class="hljs-comment">// pid open is denied.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> NTSTATUS <span class="hljs-title">OpenProcessAction</span><span class="hljs-params">(<span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">uint32_t</span> process_id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    HANDLE* handle)</span></span>;<br><br>  <span class="hljs-comment">// Opens the token associated with the process and returns the duplicated</span><br>  <span class="hljs-comment">// handle to the child. We only allow the child processes to open its own</span><br>  <span class="hljs-comment">// token (using ::GetCurrentProcess()).</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> NTSTATUS <span class="hljs-title">OpenProcessTokenAction</span><span class="hljs-params">(<span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         HANDLE process,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         HANDLE* handle)</span></span>;<br><br>  <span class="hljs-comment">// Opens the token associated with the process and returns the duplicated</span><br>  <span class="hljs-comment">// handle to the child. We only allow the child processes to open its own</span><br>  <span class="hljs-comment">// token (using ::GetCurrentProcess()).</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> NTSTATUS <span class="hljs-title">OpenProcessTokenExAction</span><span class="hljs-params">(<span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           HANDLE process,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">uint32_t</span> attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           HANDLE* handle)</span></span>;<br><br>  <span class="hljs-comment">// Processes a &#x27;CreateProcessW()&#x27; request from the target.</span><br>  <span class="hljs-comment">// &#x27;client_info&#x27; : the target process that is making the request.</span><br>  <span class="hljs-comment">// &#x27;eval_result&#x27; : The desired policy action to accomplish.</span><br>  <span class="hljs-comment">// &#x27;app_name&#x27; : The full path of the process to be created.</span><br>  <span class="hljs-comment">// &#x27;command_line&#x27; : The command line passed to the created process.</span><br>  <span class="hljs-comment">// &#x27;current_dir&#x27; : The CWD with which to spawn the child process.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> DWORD <span class="hljs-title">CreateProcessWAction</span><span class="hljs-params">(EvalResult eval_result,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> base::string16&amp; app_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> base::string16&amp; command_line,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> base::string16&amp; current_dir,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    PROCESS_INFORMATION* process_info)</span></span>;<br><br>  <span class="hljs-comment">// Processes a &#x27;CreateThread()&#x27; request from the target.</span><br>  <span class="hljs-comment">// &#x27;client_info&#x27; : the target process that is making the request.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> DWORD <span class="hljs-title">CreateThreadAction</span><span class="hljs-params">(<span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  SIZE_T stack_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  LPTHREAD_START_ROUTINE start_address,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  PVOID parameter,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  DWORD creation_flags,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  LPDWORD thread_id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  HANDLE* handle)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>GenerateRules</code>也是一个德行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ProcessPolicy::GenerateRules</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  TargetPolicy::Semantics semantics,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  LowLevelPolicy* policy)</span> </span>&#123;<br>  std::unique_ptr&lt;PolicyRule&gt; process;<br>  <span class="hljs-keyword">switch</span> (semantics) &#123;<br>    <span class="hljs-keyword">case</span> TargetPolicy::PROCESS_MIN_EXEC: &#123;<br>      <span class="hljs-comment">// 如果是PROCESS_MIN_EXEC，那么rule的action opcode设定为资源只读</span><br>      process.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PolicyRule</span>(GIVE_READONLY));<br>      <span class="hljs-keyword">break</span>;<br>    &#125;;<br>    <span class="hljs-keyword">case</span> TargetPolicy::PROCESS_ALL_EXEC: &#123;<br>      <span class="hljs-comment">// 如果是PROCESS_ALL_EXEC，那么rule的action opcode设定位full access</span><br>      process.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PolicyRule</span>(GIVE_ALLACCESS));<br>      <span class="hljs-keyword">break</span>;<br>    &#125;;<br>    <span class="hljs-keyword">default</span>: &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// NameBased::Name这一参数需要是name</span><br>  <span class="hljs-keyword">if</span> (!process-&gt;<span class="hljs-built_in">AddStringMatch</span>(IF, NameBased::NAME, name, CASE_INSENSITIVE)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// 绑定IPC_CREATEPROCESSW_TAG这一service id与process</span><br>  <span class="hljs-comment">// 实际的意义就是如果此后service id为IPC_CREATEPROCESSW_TAG请求到来以后</span><br>  <span class="hljs-comment">// 如果NameBased::NAME这一参数位与此处设置的name相同，那么审判的结果就是</span><br>  <span class="hljs-comment">// GIVE_READONLY或GIVE_ALLACCESS（取决于AddRule时的semantics）</span><br>  <span class="hljs-keyword">if</span> (!policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_CREATEPROCESSW_TAG, process.<span class="hljs-built_in">get</span>())) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 相关的两个semantics语义</span><br>PROCESS_MIN_EXEC,      <span class="hljs-comment">// Allows to create a process with minimal rights</span><br>                           <span class="hljs-comment">// over the resulting process and thread handles.</span><br>                           <span class="hljs-comment">// No other parameters besides the command line are</span><br>                           <span class="hljs-comment">// passed to the child process.</span><br>    PROCESS_ALL_EXEC,      <span class="hljs-comment">// Allows the creation of a process and return full</span><br>                           <span class="hljs-comment">// access on the returned handles.</span><br>                           <span class="hljs-comment">// This flag can be used only when the main token of</span><br>                           <span class="hljs-comment">// the sandboxed application is at least INTERACTIVE.</span><br></code></pre></td></tr></table></figure><p>实际上在<code>GenerateRules</code>中就可以发现，对于ThreadProcess子系统来说，所有的规则都只能限制CreateProcess。回想<code>SetupService</code>，它内部也仅对CreateProcess进行了拦截器的部署，其他的5个IPC请求的tag，由于没有实际的policy参数条件约束，所以设计上并未在此处进行拦截器部署。另外5个拦截器的部署是在一个全局的<code>SetupBasicInterceptions</code>中处理的。</p><p>所以，从设计者的角度来讲，dispatcher的<code>SetupService</code>和policy的<code>GenerateRules</code>有一定程度的耦合。</p><p>6个action函数先不关心，继续看dispatcher。</p><h2 id="dispatcher">dispatcher</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This class handles process and thread-related IPC calls.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadProcessDispatcher</span> : <span class="hljs-keyword">public</span> Dispatcher &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ThreadProcessDispatcher</span><span class="hljs-params">(PolicyBase* policy_base)</span></span>;<br>  ~<span class="hljs-built_in">ThreadProcessDispatcher</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br>  <span class="hljs-comment">// Dispatcher interface.</span><br>  <span class="hljs-comment">// Setup已经见过了</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetupService</span><span class="hljs-params">(InterceptionManager* manager, <span class="hljs-type">int</span> service)</span> <span class="hljs-keyword">override</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Processes IPC requests coming from calls to NtOpenThread() in the target.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NtOpenThread</span><span class="hljs-params">(IPCInfo* ipc, <span class="hljs-type">uint32_t</span> desired_access, <span class="hljs-type">uint32_t</span> thread_id)</span></span>;<br><br>  <span class="hljs-comment">// Processes IPC requests coming from calls to NtOpenProcess() in the target.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NtOpenProcess</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">uint32_t</span> process_id)</span></span>;<br><br>  <span class="hljs-comment">// Processes IPC requests from calls to NtOpenProcessToken() in the target.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NtOpenProcessToken</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                          HANDLE process,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">uint32_t</span> desired_access)</span></span>;<br><br>  <span class="hljs-comment">// Processes IPC requests from calls to NtOpenProcessTokenEx() in the target.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NtOpenProcessTokenEx</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                            HANDLE process,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">uint32_t</span> attributes)</span></span>;<br><br>  <span class="hljs-comment">// Processes IPC requests coming from calls to CreateProcessW() in the target.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateProcessW</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                      base::string16* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                      base::string16* cmd_line,</span></span><br><span class="hljs-params"><span class="hljs-function">                      base::string16* cur_dir,</span></span><br><span class="hljs-params"><span class="hljs-function">                      base::string16* target_cur_dir,</span></span><br><span class="hljs-params"><span class="hljs-function">                      CountedBuffer* info)</span></span>;<br><br>  <span class="hljs-comment">// Processes IPC requests coming from calls to CreateThread() in the target.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateThread</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                    SIZE_T stack_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    LPTHREAD_START_ROUTINE start_address,</span></span><br><span class="hljs-params"><span class="hljs-function">                    LPVOID parameter,</span></span><br><span class="hljs-params"><span class="hljs-function">                    DWORD creation_flags)</span></span>;<br><br>  PolicyBase* policy_base_;<br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(ThreadProcessDispatcher);<br>&#125;;<br></code></pre></td></tr></table></figure><p>构造器实际上也颇为重要，实际上他是在<code>PolicyBase::AddTarget</code>首次<code>GetTarget</code>时调用到的(还记得各子系统static局部dispatcher对象吗)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ThreadProcessDispatcher::<span class="hljs-built_in">ThreadProcessDispatcher</span>(PolicyBase* policy_base)<br>    : <span class="hljs-built_in">policy_base_</span>(policy_base) &#123;<br>  <span class="hljs-comment">// 做出6个IPCCall，把它们塞入dispatcher的ipc_calls_用于此后处理IPC请求时</span><br>  <span class="hljs-comment">// 匹配请求，它们绑定的6个callback函数也在该类中定义，它们内部会进行broker端的处理</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> IPCCall open_thread = &#123;<br>      &#123;IPC_NTOPENTHREAD_TAG, &#123;UINT32_TYPE, UINT32_TYPE&#125;&#125;,<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;CallbackGeneric&gt;(<br>          &amp;ThreadProcessDispatcher::NtOpenThread)&#125;;<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> IPCCall open_process = &#123;<br>      &#123;IPC_NTOPENPROCESS_TAG, &#123;UINT32_TYPE, UINT32_TYPE&#125;&#125;,<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;CallbackGeneric&gt;(<br>          &amp;ThreadProcessDispatcher::NtOpenProcess)&#125;;<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> IPCCall process_token = &#123;<br>      &#123;IPC_NTOPENPROCESSTOKEN_TAG, &#123;VOIDPTR_TYPE, UINT32_TYPE&#125;&#125;,<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;CallbackGeneric&gt;(<br>          &amp;ThreadProcessDispatcher::NtOpenProcessToken)&#125;;<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> IPCCall process_tokenex = &#123;<br>      &#123;IPC_NTOPENPROCESSTOKENEX_TAG, &#123;VOIDPTR_TYPE, UINT32_TYPE, UINT32_TYPE&#125;&#125;,<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;CallbackGeneric&gt;(<br>          &amp;ThreadProcessDispatcher::NtOpenProcessTokenEx)&#125;;<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> IPCCall create_params = &#123;<br>      &#123;IPC_CREATEPROCESSW_TAG,<br>       &#123;WCHAR_TYPE, WCHAR_TYPE, WCHAR_TYPE, WCHAR_TYPE, INOUTPTR_TYPE&#125;&#125;,<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;CallbackGeneric&gt;(<br>          &amp;ThreadProcessDispatcher::CreateProcessW)&#125;;<br><br>  <span class="hljs-comment">// NOTE(liamjm): 2nd param is size_t: Using VOIDPTR_TYPE as they are</span><br>  <span class="hljs-comment">// the same size on windows.</span><br>  <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>) == <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*),<br>                <span class="hljs-string">&quot;VOIDPTR_TYPE not same size as size_t&quot;</span>);<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> IPCCall create_thread_params = &#123;<br>      &#123;IPC_CREATETHREAD_TAG,<br>       &#123;VOIDPTR_TYPE, VOIDPTR_TYPE, VOIDPTR_TYPE, UINT32_TYPE&#125;&#125;,<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;CallbackGeneric&gt;(<br>          &amp;ThreadProcessDispatcher::CreateThread)&#125;;<br><br>  ipc_calls_.<span class="hljs-built_in">push_back</span>(open_thread);<br>  ipc_calls_.<span class="hljs-built_in">push_back</span>(open_process);<br>  ipc_calls_.<span class="hljs-built_in">push_back</span>(process_token);<br>  ipc_calls_.<span class="hljs-built_in">push_back</span>(process_tokenex);<br>  ipc_calls_.<span class="hljs-built_in">push_back</span>(create_params);<br>  ipc_calls_.<span class="hljs-built_in">push_back</span>(create_thread_params);<br>&#125;<br></code></pre></td></tr></table></figure><p>Server端IPC的处理机制本篇就不再说了，我们直接来看看这些请求处理的callback函数是如何处理的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 以下4个是ntdll的4个系统调用</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ThreadProcessDispatcher::NtOpenThread</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">uint32_t</span> thread_id)</span> </span>&#123;<br>  HANDLE handle;<br>  <span class="hljs-comment">// 直接就调用了ProcessPolicy::OpenThreadAction，没有任何处理</span><br>  <span class="hljs-comment">// 下面的3个函数也类似</span><br>  NTSTATUS ret = ProcessPolicy::<span class="hljs-built_in">OpenThreadAction</span>(<br>      *ipc-&gt;client_info, desired_access, thread_id, &amp;handle);<br>  ipc-&gt;return_info.nt_status = ret;<br>  ipc-&gt;return_info.handle = handle;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ThreadProcessDispatcher::NtOpenProcess</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">uint32_t</span> process_id)</span> </span>&#123;<br>  HANDLE handle;<br>  NTSTATUS ret = ProcessPolicy::<span class="hljs-built_in">OpenProcessAction</span>(<br>      *ipc-&gt;client_info, desired_access, process_id, &amp;handle);<br>  ipc-&gt;return_info.nt_status = ret;<br>  ipc-&gt;return_info.handle = handle;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ThreadProcessDispatcher::NtOpenProcessToken</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 HANDLE process,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">uint32_t</span> desired_access)</span> </span>&#123;<br>  HANDLE handle;<br>  NTSTATUS ret = ProcessPolicy::<span class="hljs-built_in">OpenProcessTokenAction</span>(<br>      *ipc-&gt;client_info, process, desired_access, &amp;handle);<br>  ipc-&gt;return_info.nt_status = ret;<br>  ipc-&gt;return_info.handle = handle;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ThreadProcessDispatcher::NtOpenProcessTokenEx</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                   HANDLE process,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                   <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                   <span class="hljs-type">uint32_t</span> attributes)</span> </span>&#123;<br>  HANDLE handle;<br>  NTSTATUS ret = ProcessPolicy::<span class="hljs-built_in">OpenProcessTokenExAction</span>(<br>      *ipc-&gt;client_info, process, desired_access, attributes, &amp;handle);<br>  ipc-&gt;return_info.nt_status = ret;<br>  ipc-&gt;return_info.handle = handle;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外两个kernel32.dll的函数则不太一致：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ThreadProcessDispatcher::CreateProcessW</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             base::string16* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             base::string16* cmd_line,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             base::string16* cur_dir,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             base::string16* target_cur_dir,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             CountedBuffer* info)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(PROCESS_INFORMATION) != info-&gt;<span class="hljs-built_in">Size</span>())<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// Check if there is an application name.</span><br>  base::string16 exe_name;<br>  <span class="hljs-keyword">if</span> (!name-&gt;<span class="hljs-built_in">empty</span>())<br>    exe_name = *name;<br>  <span class="hljs-keyword">else</span><br>    exe_name = <span class="hljs-built_in">GetPathFromCmdLine</span>(*cmd_line);<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsPathRelative</span>(exe_name)) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ConvertToAbsolutePath</span>(*cur_dir, name-&gt;<span class="hljs-built_in">empty</span>(), &amp;exe_name)) &#123;<br>      <span class="hljs-comment">// Cannot find the path. Maybe the file does not exist.</span><br>      ipc-&gt;return_info.win32_result = ERROR_FILE_NOT_FOUND;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 这里构造CountedParameterSet&lt;NameBased&gt;进行了审判</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* const_exe_name = exe_name.<span class="hljs-built_in">c_str</span>();<br>  CountedParameterSet&lt;NameBased&gt; params;<br>  params[NameBased::NAME] = <span class="hljs-built_in">ParamPickerMake</span>(const_exe_name);<br><br>  EvalResult eval =<br>      policy_base_-&gt;<span class="hljs-built_in">EvalPolicy</span>(IPC_CREATEPROCESSW_TAG, params.<span class="hljs-built_in">GetBase</span>());<br><br>  PROCESS_INFORMATION* proc_info =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;PROCESS_INFORMATION*&gt;(info-&gt;<span class="hljs-built_in">Buffer</span>());<br>  <span class="hljs-comment">// Here we force the app_name to be the one we used for the policy lookup.</span><br>  <span class="hljs-comment">// If our logic was wrong, at least we wont allow create a random process.</span><br>  <span class="hljs-comment">// 连同审判结果一起传入了ProcessPolicy::CreateProcessWAction</span><br>  DWORD ret = ProcessPolicy::<span class="hljs-built_in">CreateProcessWAction</span>(<br>      eval, *ipc-&gt;client_info, exe_name, *cmd_line, *target_cur_dir, proc_info);<br><br>  ipc-&gt;return_info.win32_result = ret;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ThreadProcessDispatcher::CreateThread</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           SIZE_T stack_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           LPTHREAD_START_ROUTINE start_address,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           LPVOID parameter,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           DWORD creation_flags)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!start_address) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  HANDLE handle;<br>  <span class="hljs-comment">// CreateThread就很干脆，没有审判</span><br>  DWORD ret = ProcessPolicy::<span class="hljs-built_in">CreateThreadAction</span>(<br>      *ipc-&gt;client_info, stack_size, start_address, parameter, creation_flags,<br>      <span class="hljs-literal">nullptr</span>, &amp;handle);<br><br>  ipc-&gt;return_info.nt_status = ret;<br>  ipc-&gt;return_info.handle = handle;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次回到policy组件，最为关心的当属进行了Rule审判的<code>CreateProcessWAction</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">ProcessPolicy::CreateProcessWAction</span><span class="hljs-params">(EvalResult eval_result,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">const</span> base::string16&amp; app_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">const</span> base::string16&amp; command_line,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">const</span> base::string16&amp; current_dir,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          PROCESS_INFORMATION* process_info)</span> </span>&#123;<br>  <span class="hljs-comment">// The only action supported is ASK_BROKER which means create the process.</span><br>  <span class="hljs-comment">// 这里的注释有点问题，实际上匹配rule时EvalResult只能是GIVE_ALLACCESS或GIVE_READONLY</span><br>  <span class="hljs-keyword">if</span> (GIVE_ALLACCESS != eval_result &amp;&amp; GIVE_READONLY != eval_result) &#123;<br>    <span class="hljs-keyword">return</span> ERROR_ACCESS_DENIED;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果通过了审判，那么会调用一个helper函数来进一步调用CreateProcess API</span><br>  STARTUPINFO startup_info = &#123;<span class="hljs-number">0</span>&#125;;<br>  startup_info.cb = <span class="hljs-built_in">sizeof</span>(startup_info);<br>  <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">wchar_t</span>, base::FreeDeleter&gt; <span class="hljs-title">cmd_line</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      _wcsdup(command_line.c_str()))</span></span>;<br><br>  <span class="hljs-type">bool</span> should_give_full_access = (GIVE_ALLACCESS == eval_result);<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* cwd = current_dir.<span class="hljs-built_in">c_str</span>();<br>  <span class="hljs-keyword">if</span> (current_dir.<span class="hljs-built_in">empty</span>())<br>    cwd = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateProcessExWHelper</span>(client_info.process, should_give_full_access,<br>                              app_name.<span class="hljs-built_in">c_str</span>(), cmd_line.<span class="hljs-built_in">get</span>(), <span class="hljs-literal">nullptr</span>,<br>                              <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, cwd, &amp;startup_info,<br>                              process_info)) &#123;<br>    <span class="hljs-keyword">return</span> ERROR_ACCESS_DENIED;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个helper函数实际上就是一层封装：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Creates a child process and duplicates the handles to &#x27;target_process&#x27;. The</span><br><span class="hljs-comment">// remaining parameters are the same as CreateProcess().</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateProcessExWHelper</span><span class="hljs-params">(HANDLE target_process,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">bool</span> give_full_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                            LPCWSTR lpApplicationName,</span></span><br><span class="hljs-params"><span class="hljs-function">                            LPWSTR lpCommandLine,</span></span><br><span class="hljs-params"><span class="hljs-function">                            LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                            LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">bool</span> bInheritHandles,</span></span><br><span class="hljs-params"><span class="hljs-function">                            DWORD dwCreationFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">                            LPVOID lpEnvironment,</span></span><br><span class="hljs-params"><span class="hljs-function">                            LPCWSTR lpCurrentDirectory,</span></span><br><span class="hljs-params"><span class="hljs-function">                            LPSTARTUPINFOW lpStartupInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">                            LPPROCESS_INFORMATION lpProcessInformation)</span> </span>&#123;<br>  <span class="hljs-comment">// 这里进行了CreateProcessW API的调用</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">CreateProcessW</span>(lpApplicationName, lpCommandLine, lpProcessAttributes,<br>                        lpThreadAttributes, bInheritHandles, dwCreationFlags,<br>                        lpEnvironment, lpCurrentDirectory, lpStartupInfo,<br>                        lpProcessInformation)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  DWORD process_access = kProcessRights;<br>  DWORD thread_access = kThreadRights;<br>  <span class="hljs-comment">// 访问权限会受传入的give_full_access影响，而give_full_access对应宿主的两个EvalResult</span><br>  <span class="hljs-keyword">if</span> (give_full_access) &#123;<br>    process_access = PROCESS_ALL_ACCESS;<br>    thread_access = THREAD_ALL_ACCESS;<br>  &#125;<br>  <span class="hljs-comment">// 复制句柄给target进程，它会在IPC处理后填充到CrossCallResult中返还给target client</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), lpProcessInformation-&gt;hProcess,<br>                         target_process, &amp;lpProcessInformation-&gt;hProcess,<br>                         process_access, <span class="hljs-literal">false</span>, DUPLICATE_CLOSE_SOURCE)) &#123;<br>    ::<span class="hljs-built_in">CloseHandle</span>(lpProcessInformation-&gt;hThread);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), lpProcessInformation-&gt;hThread,<br>                         target_process, &amp;lpProcessInformation-&gt;hThread,<br>                         thread_access, <span class="hljs-literal">false</span>, DUPLICATE_CLOSE_SOURCE)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他的5个action，就仅仅是封装罢了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">ProcessPolicy::OpenThreadAction</span><span class="hljs-params">(<span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         <span class="hljs-type">uint32_t</span> thread_id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         HANDLE* handle)</span> </span>&#123;<br>  *handle = <span class="hljs-literal">nullptr</span>;<br><br>  NtOpenThreadFunction NtOpenThread = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-built_in">ResolveNTFunctionPtr</span>(<span class="hljs-string">&quot;NtOpenThread&quot;</span>, &amp;NtOpenThread);<br><br>  OBJECT_ATTRIBUTES attributes = &#123;<span class="hljs-number">0</span>&#125;;<br>  attributes.Length = <span class="hljs-built_in">sizeof</span>(attributes);<br>  CLIENT_ID client_id = &#123;<span class="hljs-number">0</span>&#125;;<br>  client_id.UniqueProcess =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;PVOID&gt;(<span class="hljs-built_in">static_cast</span>&lt;ULONG_PTR&gt;(client_info.process_id));<br>  client_id.UniqueThread =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;PVOID&gt;(<span class="hljs-built_in">static_cast</span>&lt;ULONG_PTR&gt;(thread_id));<br><br>  HANDLE local_handle = <span class="hljs-literal">nullptr</span>;<br>  NTSTATUS status =<br>      <span class="hljs-built_in">NtOpenThread</span>(&amp;local_handle, desired_access, &amp;attributes, &amp;client_id);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NT_SUCCESS</span>(status)) &#123;<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), local_handle,<br>                           client_info.process, handle, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>,<br>                           DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS)) &#123;<br>      <span class="hljs-keyword">return</span> STATUS_ACCESS_DENIED;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-function">NTSTATUS <span class="hljs-title">ProcessPolicy::OpenProcessAction</span><span class="hljs-params">(<span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">uint32_t</span> process_id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          HANDLE* handle)</span> </span>&#123;<br>  *handle = <span class="hljs-literal">nullptr</span>;<br><br>  NtOpenProcessFunction NtOpenProcess = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-built_in">ResolveNTFunctionPtr</span>(<span class="hljs-string">&quot;NtOpenProcess&quot;</span>, &amp;NtOpenProcess);<br><br>  <span class="hljs-keyword">if</span> (client_info.process_id != process_id)<br>    <span class="hljs-keyword">return</span> STATUS_ACCESS_DENIED;<br><br>  OBJECT_ATTRIBUTES attributes = &#123;<span class="hljs-number">0</span>&#125;;<br>  attributes.Length = <span class="hljs-built_in">sizeof</span>(attributes);<br>  CLIENT_ID client_id = &#123;<span class="hljs-number">0</span>&#125;;<br>  client_id.UniqueProcess =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;PVOID&gt;(<span class="hljs-built_in">static_cast</span>&lt;ULONG_PTR&gt;(client_info.process_id));<br>  HANDLE local_handle = <span class="hljs-literal">nullptr</span>;<br>  NTSTATUS status =<br>      <span class="hljs-built_in">NtOpenProcess</span>(&amp;local_handle, desired_access, &amp;attributes, &amp;client_id);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NT_SUCCESS</span>(status)) &#123;<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), local_handle,<br>                           client_info.process, handle, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>,<br>                           DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS)) &#123;<br>      <span class="hljs-keyword">return</span> STATUS_ACCESS_DENIED;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-function">NTSTATUS <span class="hljs-title">ProcessPolicy::OpenProcessTokenAction</span><span class="hljs-params">(<span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                               HANDLE process,</span></span><br><span class="hljs-params"><span class="hljs-function">                                               <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                               HANDLE* handle)</span> </span>&#123;<br>  *handle = <span class="hljs-literal">nullptr</span>;<br>  NtOpenProcessTokenFunction NtOpenProcessToken = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-built_in">ResolveNTFunctionPtr</span>(<span class="hljs-string">&quot;NtOpenProcessToken&quot;</span>, &amp;NtOpenProcessToken);<br><br>  <span class="hljs-keyword">if</span> (CURRENT_PROCESS != process)<br>    <span class="hljs-keyword">return</span> STATUS_ACCESS_DENIED;<br><br>  HANDLE local_handle = <span class="hljs-literal">nullptr</span>;<br>  NTSTATUS status =<br>      <span class="hljs-built_in">NtOpenProcessToken</span>(client_info.process, desired_access, &amp;local_handle);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NT_SUCCESS</span>(status)) &#123;<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), local_handle,<br>                           client_info.process, handle, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>,<br>                           DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS)) &#123;<br>      <span class="hljs-keyword">return</span> STATUS_ACCESS_DENIED;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-function">NTSTATUS <span class="hljs-title">ProcessPolicy::OpenProcessTokenExAction</span><span class="hljs-params">(<span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 HANDLE process,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">uint32_t</span> attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 HANDLE* handle)</span> </span>&#123;<br>  *handle = <span class="hljs-literal">nullptr</span>;<br>  NtOpenProcessTokenExFunction NtOpenProcessTokenEx = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-built_in">ResolveNTFunctionPtr</span>(<span class="hljs-string">&quot;NtOpenProcessTokenEx&quot;</span>, &amp;NtOpenProcessTokenEx);<br><br>  <span class="hljs-keyword">if</span> (CURRENT_PROCESS != process)<br>    <span class="hljs-keyword">return</span> STATUS_ACCESS_DENIED;<br><br>  HANDLE local_handle = <span class="hljs-literal">nullptr</span>;<br>  NTSTATUS status = <span class="hljs-built_in">NtOpenProcessTokenEx</span>(client_info.process, desired_access,<br>                                         attributes, &amp;local_handle);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NT_SUCCESS</span>(status)) &#123;<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), local_handle,<br>                           client_info.process, handle, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>,<br>                           DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS)) &#123;<br>      <span class="hljs-keyword">return</span> STATUS_ACCESS_DENIED;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-function">DWORD <span class="hljs-title">ProcessPolicy::CreateThreadAction</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> SIZE_T stack_size,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> LPTHREAD_START_ROUTINE start_address,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> LPVOID parameter,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> DWORD creation_flags,</span></span><br><span class="hljs-params"><span class="hljs-function">    LPDWORD thread_id,</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE* handle)</span> </span>&#123;<br>  *handle = <span class="hljs-literal">nullptr</span>;<br>  HANDLE local_handle =<br>      ::<span class="hljs-built_in">CreateRemoteThread</span>(client_info.process, <span class="hljs-literal">nullptr</span>, stack_size,<br>                           start_address, parameter, creation_flags, thread_id);<br>  <span class="hljs-keyword">if</span> (!local_handle) &#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), local_handle,<br>                         client_info.process, handle, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>,<br>                         DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS)) &#123;<br>    <span class="hljs-keyword">return</span> ERROR_ACCESS_DENIED;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>IPC请求处理的后半段相关部分已经分析过了，剩下的就是回去看看targetclient端是如何发起请求的了。</p><h2 id="interceptions">interceptions</h2><p>target在调用以上9个WINAPI或系统调用时，实际上调用到的是broker或target自己为target部署的拦截器函数。其中系统调用的拦截器由broker为target部署，而除了ntdll的其他dll（这里仅有kernel32.dll）中函数的导入表(Eat)拦截器是target自己部署的（broker会在<code>AddToPatchFunction</code>和<code>AddUnloadModule</code>后把它们传给target，sidestep和smart_sidestep虽有组件但目前尚未用到）。</p><p>对于ThreadProcess子系统的拦截器来说，一共有3种：</p><ol type="1"><li>broker部署的4个系统调用拦截器</li><li>target自身部署的2个kernel32.dll的导入表拦截器</li><li>无需IPC请求的3个系统调用拦截器</li></ol><p>其中前两种都在process_thread_interceptions.cc中定义，后一种则独立开来，在policy_target.cc中定义。policy_target.cc中不仅包含这3个interceptions，还包含一个我们上一篇分析过的函数<code>QueryBroker</code>。</p><p>我们先看第一种，以<code>TargetNtOpenThread</code>为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Hooks NtOpenThread and proxy the call to the broker if it&#x27;s trying to</span><br><span class="hljs-comment">// open a thread in the same process.</span><br><span class="hljs-function">NTSTATUS WINAPI <span class="hljs-title">TargetNtOpenThread</span><span class="hljs-params">(NtOpenThreadFunction orig_OpenThread,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   PHANDLE thread,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   ACCESS_MASK desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   POBJECT_ATTRIBUTES object_attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   PCLIENT_ID client_id)</span> </span>&#123;<br>  <span class="hljs-comment">// x86下第一个参数是原始函数</span><br>  NTSTATUS status =<br>      <span class="hljs-built_in">orig_OpenThread</span>(thread, desired_access, object_attributes, client_id);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NT_SUCCESS</span>(status))<br>    <span class="hljs-keyword">return</span> status;<br><br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (!SandboxFactory::<span class="hljs-built_in">GetTargetServices</span>()-&gt;<span class="hljs-built_in">GetState</span>()-&gt;<span class="hljs-built_in">InitCalled</span>())<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (!client_id)<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-type">uint32_t</span> thread_id = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> should_break = <span class="hljs-literal">false</span>;<br>    __try &#123;<br>      <span class="hljs-comment">// We support only the calls for the current process</span><br>      <span class="hljs-keyword">if</span> (client_id-&gt;UniqueProcess)<br>        should_break = <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-comment">// Object attributes should be nullptr or empty.</span><br>      <span class="hljs-keyword">if</span> (!should_break &amp;&amp; object_attributes) &#123;<br>        <span class="hljs-keyword">if</span> (object_attributes-&gt;Attributes || object_attributes-&gt;ObjectName ||<br>            object_attributes-&gt;RootDirectory ||<br>            object_attributes-&gt;SecurityDescriptor ||<br>            object_attributes-&gt;SecurityQualityOfService) &#123;<br>          should_break = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;<br><br>      thread_id = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<br>          <span class="hljs-built_in">reinterpret_cast</span>&lt;ULONG_PTR&gt;(client_id-&gt;UniqueThread));<br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (should_break)<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ValidParameter</span>(thread, <span class="hljs-built_in">sizeof</span>(HANDLE), WRITE))<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-type">void</span>* memory = <span class="hljs-built_in">GetGlobalIPCMemory</span>();<br>    <span class="hljs-keyword">if</span> (!memory)<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 填充参数以后，发起具体的tag（service id）的IPC请求</span><br>    <span class="hljs-function">SharedMemIPCClient <span class="hljs-title">ipc</span><span class="hljs-params">(memory)</span></span>;<br>    CrossCallReturn answer = &#123;<span class="hljs-number">0</span>&#125;;<br>    ResultCode code = <span class="hljs-built_in">CrossCall</span>(ipc, IPC_NTOPENTHREAD_TAG, desired_access,<br>                                thread_id, &amp;answer);<br>    <span class="hljs-keyword">if</span> (SBOX_ALL_OK != code)<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(answer.nt_status))<br>      <span class="hljs-comment">// The nt_status here is most likely STATUS_INVALID_CID because</span><br>      <span class="hljs-comment">// in the broker we set the process id in the CID (client ID) param</span><br>      <span class="hljs-comment">// to be the current process. If you try to open a thread from another</span><br>      <span class="hljs-comment">// process you will get this INVALID_CID error. On the other hand, if you</span><br>      <span class="hljs-comment">// try to open a thread in your own process, it should return success.</span><br>      <span class="hljs-comment">// We don&#x27;t want to return STATUS_INVALID_CID here, so we return the</span><br>      <span class="hljs-comment">// return of the original open thread status, which is most likely</span><br>      <span class="hljs-comment">// STATUS_ACCESS_DENIED.</span><br>      <span class="hljs-keyword">break</span>;<br><br>    __try &#123;<br>      <span class="hljs-comment">// Write the output parameters.</span><br>      *thread = answer.handle;<br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> answer.nt_status;<br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二类有两个，<code>TargetCreateProcess</code>和<code>TargetCreateThread</code>，前者有ASCII和Unicode两个版本，且它是有Rule可match的，后者一无所有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL WINAPI <span class="hljs-title">TargetCreateProcessW</span><span class="hljs-params">(CreateProcessWFunction orig_CreateProcessW,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 LPCWSTR application_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 LPWSTR command_line,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 LPSECURITY_ATTRIBUTES process_attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 LPSECURITY_ATTRIBUTES thread_attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 BOOL inherit_handles,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 DWORD flags,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 LPVOID environment,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 LPCWSTR current_directory,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 LPSTARTUPINFOW startup_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 LPPROCESS_INFORMATION process_information)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (SandboxFactory::<span class="hljs-built_in">GetTargetServices</span>()-&gt;<span class="hljs-built_in">GetState</span>()-&gt;<span class="hljs-built_in">IsCsrssConnected</span>() &amp;&amp;<br>      <span class="hljs-built_in">orig_CreateProcessW</span>(application_name, command_line, process_attributes,<br>                          thread_attributes, inherit_handles, flags,<br>                          environment, current_directory, startup_info,<br>                          process_information)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// We don&#x27;t trust that the IPC can work this early.</span><br>  <span class="hljs-keyword">if</span> (!SandboxFactory::<span class="hljs-built_in">GetTargetServices</span>()-&gt;<span class="hljs-built_in">GetState</span>()-&gt;<span class="hljs-built_in">InitCalled</span>())<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// Don&#x27;t call GetLastError before InitCalled() succeeds because kernel32 may</span><br>  <span class="hljs-comment">// not be mapped yet.</span><br>  DWORD original_error = ::<span class="hljs-built_in">GetLastError</span>();<br><br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ValidParameter</span>(process_information, <span class="hljs-built_in">sizeof</span>(PROCESS_INFORMATION),<br>                        WRITE))<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-type">void</span>* memory = <span class="hljs-built_in">GetGlobalIPCMemory</span>();<br>    <span class="hljs-keyword">if</span> (!memory)<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* cur_dir = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-type">wchar_t</span> this_current_directory[MAX_PATH];<br>    DWORD result = ::<span class="hljs-built_in">GetCurrentDirectory</span>(MAX_PATH, this_current_directory);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != result &amp;&amp; result &lt; MAX_PATH)<br>      cur_dir = this_current_directory;<br><br>    <span class="hljs-comment">// target端也仅仅是发起了IPC请求，没有像filesystem那样在target端自己还来了一次QueryBroker</span><br>    <span class="hljs-function">SharedMemIPCClient <span class="hljs-title">ipc</span><span class="hljs-params">(memory)</span></span>;<br>    CrossCallReturn answer = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-function">InOutCountedBuffer <span class="hljs-title">proc_info</span><span class="hljs-params">(process_information,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-keyword">sizeof</span>(PROCESS_INFORMATION))</span></span>;<br><br>    ResultCode code =<br>        <span class="hljs-built_in">CrossCall</span>(ipc, IPC_CREATEPROCESSW_TAG, application_name, command_line,<br>                  cur_dir, current_directory, proc_info, &amp;answer);<br>    <span class="hljs-keyword">if</span> (SBOX_ALL_OK != code)<br>      <span class="hljs-keyword">break</span>;<br><br>    ::<span class="hljs-built_in">SetLastError</span>(answer.win32_result);<br>    <span class="hljs-keyword">if</span> (ERROR_SUCCESS != answer.win32_result)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">false</span>);<br><br>  ::<span class="hljs-built_in">SetLastError</span>(original_error);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>中规中矩的<code>TargetCreateThread</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HANDLE WINAPI <span class="hljs-title">TargetCreateThread</span><span class="hljs-params">(CreateThreadFunction orig_CreateThread,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 LPSECURITY_ATTRIBUTES thread_attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 SIZE_T stack_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 LPTHREAD_START_ROUTINE start_address,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 LPVOID parameter,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 DWORD creation_flags,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 LPDWORD thread_id)</span> </span>&#123;<br>  HANDLE hThread = <span class="hljs-literal">nullptr</span>;<br><br>  TargetServices* target_services = SandboxFactory::<span class="hljs-built_in">GetTargetServices</span>();<br>  <span class="hljs-keyword">if</span> (!target_services || target_services-&gt;<span class="hljs-built_in">GetState</span>()-&gt;<span class="hljs-built_in">IsCsrssConnected</span>()) &#123;<br>    hThread = <span class="hljs-built_in">orig_CreateThread</span>(thread_attributes, stack_size, start_address,<br>                                parameter, creation_flags, thread_id);<br>    <span class="hljs-keyword">if</span> (hThread)<br>      <span class="hljs-keyword">return</span> hThread;<br>  &#125;<br><br>  DWORD original_error = ::<span class="hljs-built_in">GetLastError</span>();<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (!target_services)<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// We don&#x27;t trust that the IPC can work this early.</span><br>    <span class="hljs-keyword">if</span> (!target_services-&gt;<span class="hljs-built_in">GetState</span>()-&gt;<span class="hljs-built_in">InitCalled</span>())<br>      <span class="hljs-keyword">break</span>;<br><br>    __try &#123;<br>      <span class="hljs-keyword">if</span> (thread_id &amp;&amp; !<span class="hljs-built_in">ValidParameter</span>(thread_id, <span class="hljs-built_in">sizeof</span>(*thread_id), WRITE))<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">if</span> (!start_address)<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-comment">// We don&#x27;t support thread_attributes not being null.</span><br>      <span class="hljs-keyword">if</span> (thread_attributes)<br>        <span class="hljs-keyword">break</span>;<br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-type">void</span>* memory = <span class="hljs-built_in">GetGlobalIPCMemory</span>();<br>    <span class="hljs-keyword">if</span> (!memory)<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-function">SharedMemIPCClient <span class="hljs-title">ipc</span><span class="hljs-params">(memory)</span></span>;<br>    CrossCallReturn answer = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> we don&#x27;t pass the thread_attributes through. This matches the</span><br>    <span class="hljs-comment">// approach in CreateProcess and in CreateThreadInternal().</span><br>    ResultCode code = <span class="hljs-built_in">CrossCall</span>(ipc, IPC_CREATETHREAD_TAG,<br>                                <span class="hljs-built_in">reinterpret_cast</span>&lt;LPVOID&gt;(stack_size),<br>                                <span class="hljs-built_in">reinterpret_cast</span>&lt;LPVOID&gt;(start_address),<br>                                parameter, creation_flags, &amp;answer);<br>    <span class="hljs-keyword">if</span> (SBOX_ALL_OK != code)<br>      <span class="hljs-keyword">break</span>;<br><br>    ::<span class="hljs-built_in">SetLastError</span>(answer.win32_result);<br>    <span class="hljs-keyword">if</span> (ERROR_SUCCESS != answer.win32_result)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    __try &#123;<br>      <span class="hljs-keyword">if</span> (thread_id)<br>        *thread_id = ::<span class="hljs-built_in">GetThreadId</span>(answer.handle);<br>      <span class="hljs-keyword">return</span> answer.handle;<br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">false</span>);<br><br>  ::<span class="hljs-built_in">SetLastError</span>(original_error);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三种就有点意思了，我们都展开看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Hooks NtSetInformationThread to block RevertToSelf from being</span><br><span class="hljs-comment">// called before the actual call to LowerToken.</span><br><span class="hljs-comment">// 看起来之所以要hook这个函数，是为了防止调用LowerToken前，进行RevertToSelf</span><br><span class="hljs-function">NTSTATUS WINAPI <span class="hljs-title">TargetNtSetInformationThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    NtSetInformationThreadFunction orig_SetInformationThread,</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE thread,</span></span><br><span class="hljs-params"><span class="hljs-function">    NT_THREAD_INFORMATION_CLASS thread_info_class,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID thread_information,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG thread_information_bytes)</span> </span>&#123;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// 判断LowerToken是否被掉用过，如果已经被掉用过就跳出去</span><br>    <span class="hljs-keyword">if</span> (SandboxFactory::<span class="hljs-built_in">GetTargetServices</span>()-&gt;<span class="hljs-built_in">GetState</span>()-&gt;<span class="hljs-built_in">RevertedToSelf</span>())<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">// 传入的thread_info_class是否是Impersonate token，如果是就跳出去</span><br>    <span class="hljs-keyword">if</span> (ThreadImpersonationToken != thread_info_class)<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">// This is a revert to self.</span><br>    <span class="hljs-comment">// 如果上述两种情况不满足，说明是个RevertToSelf，抱歉，不放行。</span><br>    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-comment">// 放行</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">orig_SetInformationThread</span>(<br>      thread, thread_info_class, thread_information, thread_information_bytes);<br>&#125;<br></code></pre></td></tr></table></figure><p>另外两个是和thread token相关：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Hooks NtOpenThreadToken to force the open_as_self parameter to be set to</span><br><span class="hljs-comment">// false if we are still running with the impersonation token. open_as_self set</span><br><span class="hljs-comment">// to true means that the token will be open using the process token instead of</span><br><span class="hljs-comment">// the impersonation token. This is bad because the process token does not have</span><br><span class="hljs-comment">// access to open the thread token.</span><br><span class="hljs-function">NTSTATUS WINAPI</span><br><span class="hljs-function"><span class="hljs-title">TargetNtOpenThreadToken</span><span class="hljs-params">(NtOpenThreadTokenFunction orig_OpenThreadToken,</span></span><br><span class="hljs-params"><span class="hljs-function">                        HANDLE thread,</span></span><br><span class="hljs-params"><span class="hljs-function">                        ACCESS_MASK desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                        BOOLEAN open_as_self,</span></span><br><span class="hljs-params"><span class="hljs-function">                        PHANDLE token)</span> </span>&#123;<br>  <span class="hljs-comment">// 这个拦截函数纯粹是为了在LowerToken调用前，防止以open_as_self=true的形式获取</span><br>  <span class="hljs-comment">// 线程token，此时target仍以impersonate这个高权限token在运行，所以不能让操作得逞</span><br>  <span class="hljs-comment">// 此时获取thread token必须得是lockdown token而不能是当前的impersonate token</span><br>  <span class="hljs-keyword">if</span> (!SandboxFactory::<span class="hljs-built_in">GetTargetServices</span>()-&gt;<span class="hljs-built_in">GetState</span>()-&gt;<span class="hljs-built_in">RevertedToSelf</span>())<br>    open_as_self = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">orig_OpenThreadToken</span>(thread, desired_access, open_as_self, token);<br>&#125;<br><br><span class="hljs-comment">// See comment for TargetNtOpenThreadToken</span><br><span class="hljs-comment">// 这个同理，双胞胎同等对待</span><br><span class="hljs-function">NTSTATUS WINAPI</span><br><span class="hljs-function"><span class="hljs-title">TargetNtOpenThreadTokenEx</span><span class="hljs-params">(NtOpenThreadTokenExFunction orig_OpenThreadTokenEx,</span></span><br><span class="hljs-params"><span class="hljs-function">                          HANDLE thread,</span></span><br><span class="hljs-params"><span class="hljs-function">                          ACCESS_MASK desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                          BOOLEAN open_as_self,</span></span><br><span class="hljs-params"><span class="hljs-function">                          ULONG handle_attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                          PHANDLE token)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!SandboxFactory::<span class="hljs-built_in">GetTargetServices</span>()-&gt;<span class="hljs-built_in">GetState</span>()-&gt;<span class="hljs-built_in">RevertedToSelf</span>())<br>    open_as_self = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">orig_OpenThreadTokenEx</span>(thread, desired_access, open_as_self,<br>                                handle_attributes, token);<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，我们就缕清了ThreadProcess子系统的相关内容，尽管和filesystem子系统有一定的不同，但整体的架构是一致的，只是具体的应用因场景而有所差异。</p>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-Filesystem-analysis</title>
    <link href="/2018/06/03/chromium-sandbox-Filesystem-analysis/"/>
    <url>/2018/06/03/chromium-sandbox-Filesystem-analysis/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第十四篇，主要分析了子系统Filesystem的三大组件。</p><p>Target在执行5个文件系统相关的API时，会因为Interceptions的部署（该子系统由broker远程部署(servicecall)）而调用hook函数，hook函数通过SharedMemIPC与broker通信，将调用参数传给broker，broker此后通过dispatcher分发找到对应子系统的dispatcher，子系统dispatcher会匹配调用参数并调用一早便注册好的callback，callback会进行Low-levelpolicy的Evaluate鉴权，并进一步调用low-levelpolicy的业务处理函数，根据鉴权结果来执行API，并在CrossCallResult回执结果。</p><p>阅读本篇前，请先阅读前面所有章节。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-filesystem-analysis">chromium-sandbox-Filesystem-analysis</h1><p>Low-levelpolicy、Dispatcher、Interceptions作为三个基本组件，目前都已经分析完了。sandbox中对每个子系统使用了这三大组件。</p><h2 id="low-level-policy">low-level policy</h2><p>类头定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This class centralizes most of the knowledge related to file system policy</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemPolicy</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Creates the required low-level policy rules to evaluate a high-level</span><br>  <span class="hljs-comment">// policy rule for File IO, in particular open or create actions.</span><br>  <span class="hljs-comment">// &#x27;name&#x27; is the file or directory name.</span><br>  <span class="hljs-comment">// &#x27;semantics&#x27; is the desired semantics for the open or create.</span><br>  <span class="hljs-comment">// &#x27;policy&#x27; is the policy generator to which the rules are going to be added.</span><br>  <span class="hljs-comment">// 使用low-level policy来evaluate一个high-level FILE IO policy rule</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">GenerateRules</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                            TargetPolicy::Semantics semantics,</span></span><br><span class="hljs-params"><span class="hljs-function">                            LowLevelPolicy* policy)</span></span>;<br><br>  <span class="hljs-comment">// Add basic file system rules.</span><br>  <span class="hljs-comment">// 基础的文件系统rule添加接口</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">SetInitialRules</span><span class="hljs-params">(LowLevelPolicy* policy)</span></span>;<br><br>  <span class="hljs-comment">// Performs the desired policy action on a create request with an</span><br>  <span class="hljs-comment">// API that is compatible with the IPC-received parameters.</span><br>  <span class="hljs-comment">// &#x27;client_info&#x27; : the target process that is making the request.</span><br>  <span class="hljs-comment">// &#x27;eval_result&#x27; : The desired policy action to accomplish.</span><br>  <span class="hljs-comment">// &#x27;file&#x27; : The target file or directory.</span><br>  <span class="hljs-comment">// 通过IPC收到的create request</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">CreateFileAction</span><span class="hljs-params">(EvalResult eval_result,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">const</span> base::string16&amp; file,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">uint32_t</span> attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">uint32_t</span> file_attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">uint32_t</span> share_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">uint32_t</span> create_disposition,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">uint32_t</span> create_options,</span></span><br><span class="hljs-params"><span class="hljs-function">                               HANDLE* handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                               NTSTATUS* nt_status,</span></span><br><span class="hljs-params"><span class="hljs-function">                               ULONG_PTR* io_information)</span></span>;<br><br>  <span class="hljs-comment">// Performs the desired policy action on an open request with an</span><br>  <span class="hljs-comment">// API that is compatible with the IPC-received parameters.</span><br>  <span class="hljs-comment">// &#x27;client_info&#x27; : the target process that is making the request.</span><br>  <span class="hljs-comment">// &#x27;eval_result&#x27; : The desired policy action to accomplish.</span><br>  <span class="hljs-comment">// &#x27;file&#x27; : The target file or directory.</span><br>  <span class="hljs-comment">// IPC收到的open request</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">OpenFileAction</span><span class="hljs-params">(EvalResult eval_result,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> base::string16&amp; file,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">uint32_t</span> attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">uint32_t</span> share_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">uint32_t</span> open_options,</span></span><br><span class="hljs-params"><span class="hljs-function">                             HANDLE* handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                             NTSTATUS* nt_status,</span></span><br><span class="hljs-params"><span class="hljs-function">                             ULONG_PTR* io_information)</span></span>;<br><br>  <span class="hljs-comment">// Performs the desired policy action on a query request with an</span><br>  <span class="hljs-comment">// API that is compatible with the IPC-received parameters.</span><br>  <span class="hljs-comment">// IPC收到的query request</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">QueryAttributesFileAction</span><span class="hljs-params">(EvalResult eval_result,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">const</span> base::string16&amp; file,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">uint32_t</span> attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        FILE_BASIC_INFORMATION* file_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        NTSTATUS* nt_status)</span></span>;<br><br>  <span class="hljs-comment">// Performs the desired policy action on a query request with an</span><br>  <span class="hljs-comment">// API that is compatible with the IPC-received parameters.</span><br>  <span class="hljs-comment">// IPC收到的query full request</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">QueryFullAttributesFileAction</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      EvalResult eval_result,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">const</span> base::string16&amp; file,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">uint32_t</span> attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">      FILE_NETWORK_OPEN_INFORMATION* file_info,</span></span><br><span class="hljs-params"><span class="hljs-function">      NTSTATUS* nt_status)</span></span>;<br><br>  <span class="hljs-comment">// Performs the desired policy action on a set_info request with an</span><br>  <span class="hljs-comment">// API that is compatible with the IPC-received parameters.</span><br>  <span class="hljs-comment">// IPC收到的set_info request</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">SetInformationFileAction</span><span class="hljs-params">(EvalResult eval_result,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       HANDLE target_file_handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">void</span>* file_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">uint32_t</span> length,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">uint32_t</span> info_class,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       IO_STATUS_BLOCK* io_block,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       NTSTATUS* nt_status)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>实际上就是文件系统中，几种对文件操作的broker端审判，而请求由target发起。二者通过IPC通信。</p><p>注意到所有的成员都是static函数，类的定义仅仅是为了结构上的封装。这些函数全部由外部对象调用。</p><h3 id="generaterules"><code>GenerateRules</code></h3><p>在分析该函数前，我们先看看这个函数在哪里被调用，通过交叉引用，我们发现，在<code>PolicyBase::AddRuleInternal</code>中存在调用关系。而这个函数实际上是<code>PolicyBase::AddRule</code>的helper函数。而<code>AddRule</code>这个函数我们清楚，它是<code>PolicyBase</code>对broker提供的调用接口，用于添加一个规则。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::AddRule</span><span class="hljs-params">(SubSystem subsystem,<span class="hljs-comment">// 哪个子系统的规则</span></span></span><br><span class="hljs-params"><span class="hljs-function">                               Semantics semantics,<span class="hljs-comment">// rule匹配时允许的语义</span></span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* pattern)</span> </span>&#123;<br>  ResultCode result = <span class="hljs-built_in">AddRuleInternal</span>(subsystem, semantics, pattern);<br>  <span class="hljs-built_in">LOG_IF</span>(ERROR, result != SBOX_ALL_OK)<br>      &lt;&lt; <span class="hljs-string">&quot;Failed to add sandbox rule.&quot;</span><br>      &lt;&lt; <span class="hljs-string">&quot; error = &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-string">&quot;, subsystem = &quot;</span> &lt;&lt; subsystem<br>      &lt;&lt; <span class="hljs-string">&quot;, semantics = &quot;</span> &lt;&lt; semantics &lt;&lt; <span class="hljs-string">&quot;, pattern = &#x27;&quot;</span> &lt;&lt; pattern &lt;&lt; <span class="hljs-string">&quot;&#x27;&quot;</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于我们本次分析的filesystem子系统来说，<code>SubSystem</code>就是<code>SUBSYS_FILES</code>，而<code>Semantics</code>有这几个值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FILES_ALLOW_ANY,       <span class="hljs-comment">// Allows open or create for any kind of access that</span><br> <span class="hljs-comment">// the file system supports.</span><br>FILES_ALLOW_READONLY,  <span class="hljs-comment">// Allows open or create with read access only.</span><br>FILES_ALLOW_QUERY,     <span class="hljs-comment">// Allows access to query the attributes of a file.</span><br>FILES_ALLOW_DIR_ANY,   <span class="hljs-comment">// Allows open or create with directory semantics</span><br> <span class="hljs-comment">// only.</span><br></code></pre></td></tr></table></figure><p>再看helper函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::AddRuleInternal</span><span class="hljs-params">(SubSystem subsystem,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       Semantics semantics,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* pattern)</span> </span>&#123;<br>  <span class="hljs-comment">// policy_是PolicyGlobal成员，我们现在知道了它是存放所有PolicyBuffer的buffer</span><br>  <span class="hljs-keyword">if</span> (!policy_) &#123;<br>    <span class="hljs-comment">// 如果还没准备，就先make一个4096*14尺寸的PolicyGlobal</span><br>    policy_ = <span class="hljs-built_in">MakeBrokerPolicyMemory</span>();<br>    <span class="hljs-built_in">DCHECK</span>(policy_);<br>    <span class="hljs-comment">// 使用该PolicyGlobal new出一个LowLevelPolicy</span><br>    policy_maker_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LowLevelPolicy</span>(policy_);<br>    <span class="hljs-built_in">DCHECK</span>(policy_maker_);<br>  &#125;<br><br>  <span class="hljs-keyword">switch</span> (subsystem) &#123;<br>    <span class="hljs-keyword">case</span> SUBSYS_FILES: &#123;<br>      <span class="hljs-comment">// 文件子系统会进到这里，一开始file_system_init_是false</span><br>      <span class="hljs-keyword">if</span> (!file_system_init_) &#123;<br>        <span class="hljs-comment">// 执行完SetInitialRules后，file_system_init_置true，即SetInitialRules只执行一次</span><br>        <span class="hljs-keyword">if</span> (!FileSystemPolicy::<span class="hljs-built_in">SetInitialRules</span>(policy_maker_))<br>          <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>        file_system_init_ = <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-comment">// 根据传入的pattern,semantics，用LowLevelPolicy生成一个rule</span><br>      <span class="hljs-keyword">if</span> (!FileSystemPolicy::<span class="hljs-built_in">GenerateRules</span>(pattern, semantics, policy_maker_)) &#123;<br>        <span class="hljs-built_in">NOTREACHED</span>();<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> SUBSYS_SYNC: &#123;<br>      <span class="hljs-keyword">if</span> (!SyncPolicy::<span class="hljs-built_in">GenerateRules</span>(pattern, semantics, policy_maker_)) &#123;<br>        <span class="hljs-built_in">NOTREACHED</span>();<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> SUBSYS_PROCESS: &#123;<br>      <span class="hljs-keyword">if</span> (lockdown_level_ &lt; USER_INTERACTIVE &amp;&amp;<br>          TargetPolicy::PROCESS_ALL_EXEC == semantics) &#123;<br>        <span class="hljs-comment">// This is unsupported. This is a huge security risk to give full access</span><br>        <span class="hljs-comment">// to a process handle.</span><br>        <span class="hljs-keyword">return</span> SBOX_ERROR_UNSUPPORTED;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!ProcessPolicy::<span class="hljs-built_in">GenerateRules</span>(pattern, semantics, policy_maker_)) &#123;<br>        <span class="hljs-built_in">NOTREACHED</span>();<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> SUBSYS_NAMED_PIPES: &#123;<br>      <span class="hljs-keyword">if</span> (!NamedPipePolicy::<span class="hljs-built_in">GenerateRules</span>(pattern, semantics, policy_maker_)) &#123;<br>        <span class="hljs-built_in">NOTREACHED</span>();<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> SUBSYS_REGISTRY: &#123;<br>      <span class="hljs-keyword">if</span> (!RegistryPolicy::<span class="hljs-built_in">GenerateRules</span>(pattern, semantics, policy_maker_)) &#123;<br>        <span class="hljs-built_in">NOTREACHED</span>();<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> SUBSYS_WIN32K_LOCKDOWN: &#123;<br>      <span class="hljs-keyword">if</span> (!ProcessMitigationsWin32KLockdownPolicy::<span class="hljs-built_in">GenerateRules</span>(<br>              pattern, semantics, policy_maker_)) &#123;<br>        <span class="hljs-built_in">NOTREACHED</span>();<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">default</span>: &#123; <span class="hljs-keyword">return</span> SBOX_ERROR_UNSUPPORTED; &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>不仅可以看到<code>GenerateRules</code>，还可以看到<code>SetInitialRules</code>调用的时机，我们先分析前者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FileSystemPolicy::GenerateRules</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     TargetPolicy::Semantics semantics,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     LowLevelPolicy* policy)</span> </span>&#123;<br>  <span class="hljs-comment">// 对文件子系统来说，传过来的pattern也就是name实际上是文件名称</span><br>  <span class="hljs-function">base::string16 <span class="hljs-title">mod_name</span><span class="hljs-params">(name)</span></span>;<br>  <span class="hljs-keyword">if</span> (mod_name.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 处理reparse(..)，就是把当前路径&#x27;.&#x27;，上一路径&#x27;..&#x27;这些先处理一下</span><br>  <span class="hljs-comment">// 内部调用的是ConvertToLongPath接IsReparsePoint，我们此前见过</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PreProcessName</span>(&amp;mod_name)) &#123;<br>    <span class="hljs-comment">// The path to be added might contain a reparse point.</span><br>    <span class="hljs-built_in">NOTREACHED</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// TODO(cpu) bug 32224: This prefix add is a hack because we don&#x27;t have the</span><br>  <span class="hljs-comment">// infrastructure to normalize names. In any case we need to escape the</span><br>  <span class="hljs-comment">// question marks.</span><br>  <span class="hljs-comment">// 对&quot;\\Device\\&quot;前缀的一个patch，具体原因得参考bug 32224，这里不是我们研究的主题，先pass</span><br>  <span class="hljs-keyword">if</span> (_wcsnicmp(mod_name.<span class="hljs-built_in">c_str</span>(), kNTDevicePrefix, kNTDevicePrefixLen)) &#123;<br>    mod_name = <span class="hljs-built_in">FixNTPrefixForMatch</span>(mod_name);<br>    name = mod_name.<span class="hljs-built_in">c_str</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 生成的rule的action opcode是ASK_BROKER</span><br>  EvalResult result = ASK_BROKER;<br><br>  <span class="hljs-comment">// List of supported calls for the filesystem.</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> kCallNtCreateFile = <span class="hljs-number">0x1</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> kCallNtOpenFile = <span class="hljs-number">0x2</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> kCallNtQueryAttributesFile = <span class="hljs-number">0x4</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> kCallNtQueryFullAttributesFile = <span class="hljs-number">0x8</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> kCallNtSetInfoRename = <span class="hljs-number">0x10</span>;<br><br>  DWORD rule_to_add = kCallNtOpenFile | kCallNtCreateFile |<br>                      kCallNtQueryAttributesFile |<br>                      kCallNtQueryFullAttributesFile | kCallNtSetInfoRename;<br><br>  <span class="hljs-comment">// 新建了5个PolicyRule，分别管制5种请求，action为ASK_BROKER</span><br>  <span class="hljs-function">PolicyRule <span class="hljs-title">create</span><span class="hljs-params">(result)</span></span>;<br>  <span class="hljs-function">PolicyRule <span class="hljs-title">open</span><span class="hljs-params">(result)</span></span>;<br>  <span class="hljs-function">PolicyRule <span class="hljs-title">query</span><span class="hljs-params">(result)</span></span>;<br>  <span class="hljs-function">PolicyRule <span class="hljs-title">query_full</span><span class="hljs-params">(result)</span></span>;<br>  <span class="hljs-function">PolicyRule <span class="hljs-title">rename</span><span class="hljs-params">(result)</span></span>;<br><br>  <span class="hljs-comment">//根据semantics处理分支</span><br>  <span class="hljs-keyword">switch</span> (semantics) &#123;<br>    <span class="hljs-keyword">case</span> TargetPolicy::FILES_ALLOW_DIR_ANY: &#123;<br>      <span class="hljs-comment">// 只能打开目录，这种情况就对open和create两套规则的OpenFile::OPTIONS parameter_</span><br>      <span class="hljs-comment">// 设置值为FILE_DIRECTORY_FILE的按位与匹配</span><br>      open.<span class="hljs-built_in">AddNumberMatch</span>(IF, OpenFile::OPTIONS, FILE_DIRECTORY_FILE, AND);<br>      create.<span class="hljs-built_in">AddNumberMatch</span>(IF, OpenFile::OPTIONS, FILE_DIRECTORY_FILE, AND);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> TargetPolicy::FILES_ALLOW_READONLY: &#123;<br>      <span class="hljs-comment">// We consider all flags that are not known to be readonly as potentially</span><br>      <span class="hljs-comment">// used for write.</span><br>      <span class="hljs-comment">// 只读方式打开，所以对OpenFile::ACCESS来说，allowed_flags以外的任何flag都不能设置</span><br>      <span class="hljs-comment">// 而OpenFile::DISPOSITION则必须得是FILE_OPEN</span><br>      DWORD allowed_flags = FILE_READ_DATA | FILE_READ_ATTRIBUTES |<br>                            FILE_READ_EA | SYNCHRONIZE | FILE_EXECUTE |<br>                            GENERIC_READ | GENERIC_EXECUTE | READ_CONTROL;<br>      DWORD restricted_flags = ~allowed_flags;<br>      open.<span class="hljs-built_in">AddNumberMatch</span>(IF_NOT, OpenFile::ACCESS, restricted_flags, AND);<br>      open.<span class="hljs-built_in">AddNumberMatch</span>(IF, OpenFile::DISPOSITION, FILE_OPEN, EQUAL);<br>      create.<span class="hljs-built_in">AddNumberMatch</span>(IF_NOT, OpenFile::ACCESS, restricted_flags, AND);<br>      create.<span class="hljs-built_in">AddNumberMatch</span>(IF, OpenFile::DISPOSITION, FILE_OPEN, EQUAL);<br><br>      <span class="hljs-comment">// Read only access don&#x27;t work for rename.</span><br>      <span class="hljs-comment">// 移除Rename的rule，本次不设置</span><br>      rule_to_add &amp;= ~kCallNtSetInfoRename;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> TargetPolicy::FILES_ALLOW_QUERY: &#123;<br>      <span class="hljs-comment">// Here we don&#x27;t want to add policy for the open or the create.</span><br>      <span class="hljs-comment">// 允许对某个文件属性的query，本次open/create/rename也就无需设置了</span><br>      rule_to_add &amp;=<br>          ~(kCallNtOpenFile | kCallNtCreateFile | kCallNtSetInfoRename);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> TargetPolicy::FILES_ALLOW_ANY: &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">default</span>: &#123;<br>      <span class="hljs-built_in">NOTREACHED</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 根据当前rule_to_add的状态，把OpenFile::NAME这一参数进行设置</span><br>  <span class="hljs-comment">// PolicyRule add好以后，就通过policy-&gt;AddRule添加到LowLevelPolicy中</span><br>  <span class="hljs-comment">// 注意AddRule时会绑定service id和PolicyRule</span><br>  <span class="hljs-comment">// filesystem子系统占用了5个service id，分别对应open, create, rename, query, queryFull</span><br>  <span class="hljs-keyword">if</span> ((rule_to_add &amp; kCallNtCreateFile) &amp;&amp;<br>      (!create.<span class="hljs-built_in">AddStringMatch</span>(IF, OpenFile::NAME, name, CASE_INSENSITIVE) ||<br>       !policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTCREATEFILE_TAG, &amp;create))) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ((rule_to_add &amp; kCallNtOpenFile) &amp;&amp;<br>      (!open.<span class="hljs-built_in">AddStringMatch</span>(IF, OpenFile::NAME, name, CASE_INSENSITIVE) ||<br>       !policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTOPENFILE_TAG, &amp;open))) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ((rule_to_add &amp; kCallNtQueryAttributesFile) &amp;&amp;<br>      (!query.<span class="hljs-built_in">AddStringMatch</span>(IF, FileName::NAME, name, CASE_INSENSITIVE) ||<br>       !policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTQUERYATTRIBUTESFILE_TAG, &amp;query))) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ((rule_to_add &amp; kCallNtQueryFullAttributesFile) &amp;&amp;<br>      (!query_full.<span class="hljs-built_in">AddStringMatch</span>(IF, FileName::NAME, name, CASE_INSENSITIVE) ||<br>       !policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTQUERYFULLATTRIBUTESFILE_TAG, &amp;query_full))) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ((rule_to_add &amp; kCallNtSetInfoRename) &amp;&amp;<br>      (!rename.<span class="hljs-built_in">AddStringMatch</span>(IF, FileName::NAME, name, CASE_INSENSITIVE) ||<br>       !policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTSETINFO_RENAME_TAG, &amp;rename))) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="setinitialrules"><code>SetInitialRules</code></h3><p>初始化基本Rule的<code>SetInitialRules</code>在第一次<code>PolicyBase::AddRuleInternal</code>时处理filesystem类别时调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Right now we insert two rules, to be evaluated before any user supplied rule:</span><br><span class="hljs-comment">// - go to the broker if the path doesn&#x27;t look like the paths that we push on</span><br><span class="hljs-comment">//    the policy (namely \??\something).</span><br><span class="hljs-comment">// - go to the broker if it looks like this is a short-name path.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// It is possible to add a rule to go to the broker in any case; it would look</span><br><span class="hljs-comment">// something like:</span><br><span class="hljs-comment">//    rule = new PolicyRule(ASK_BROKER);</span><br><span class="hljs-comment">//    rule-&gt;AddNumberMatch(IF_NOT, FileName::BROKER, true, AND);</span><br><span class="hljs-comment">//    policy-&gt;AddRule(service, rule);</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FileSystemPolicy::SetInitialRules</span><span class="hljs-params">(LowLevelPolicy* policy)</span> </span>&#123;<br>  <span class="hljs-comment">// 两个ASK_BROKER的action rule</span><br>  <span class="hljs-function">PolicyRule <span class="hljs-title">format</span><span class="hljs-params">(ASK_BROKER)</span></span>;<br>  <span class="hljs-function">PolicyRule <span class="hljs-title">short_name</span><span class="hljs-params">(ASK_BROKER)</span></span>;<br><br>  <span class="hljs-comment">// format按位与匹配FileName::BROKER没有BROKER_TRUE标志位</span><br>  <span class="hljs-type">bool</span> rv = format.<span class="hljs-built_in">AddNumberMatch</span>(IF_NOT, FileName::BROKER, BROKER_TRUE, AND);<br>  <span class="hljs-comment">// 匹配FileName::NAME不能为L&quot;\\/?/?\\*&quot;</span><br>  rv &amp;= format.<span class="hljs-built_in">AddStringMatch</span>(IF_NOT, FileName::NAME, <span class="hljs-string">L&quot;\\/?/?\\*&quot;</span>,<br>                              CASE_SENSITIVE);<br><br>  <span class="hljs-comment">// shortname按位与匹配FileName::BROKER没有BROKER_TRUE标志位</span><br>  rv &amp;= short_name.<span class="hljs-built_in">AddNumberMatch</span>(IF_NOT, FileName::BROKER, BROKER_TRUE, AND);<br>  <span class="hljs-comment">// 匹配FileName::NAME为L&quot;*~*&quot;</span><br>  rv &amp;= short_name.<span class="hljs-built_in">AddStringMatch</span>(IF, FileName::NAME, <span class="hljs-string">L&quot;*~*&quot;</span>, CASE_SENSITIVE);<br><br>  <span class="hljs-comment">// 为5个service id，各添加这两个rule到LowLevelPolicy</span><br>  <span class="hljs-keyword">if</span> (!rv || !policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTCREATEFILE_TAG, &amp;format))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (!policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTCREATEFILE_TAG, &amp;short_name))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (!policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTOPENFILE_TAG, &amp;format))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (!policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTOPENFILE_TAG, &amp;short_name))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (!policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTQUERYATTRIBUTESFILE_TAG, &amp;format))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (!policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTQUERYATTRIBUTESFILE_TAG, &amp;short_name))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (!policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTQUERYFULLATTRIBUTESFILE_TAG, &amp;format))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (!policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTQUERYFULLATTRIBUTESFILE_TAG, &amp;short_name))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (!policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTSETINFO_RENAME_TAG, &amp;format))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (!policy-&gt;<span class="hljs-built_in">AddRule</span>(IPC_NTSETINFO_RENAME_TAG, &amp;short_name))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上是对<code>L"\\/?/?\\*</code>"和<code>L"*~*"</code>的额外处理，这两个在windows下都是特殊地址标识符。</p><p>###5个请求处理函数</p><p>剩下的5个对应create, open, rename, query,queryFull五种请求的处理函数，展开看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FileSystemPolicy::CreateFileAction</span><span class="hljs-params">(EvalResult eval_result,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">const</span> ClientInfo&amp; client_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">const</span> base::string16&amp; file,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">uint32_t</span> attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">uint32_t</span> file_attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">uint32_t</span> share_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">uint32_t</span> create_disposition,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">uint32_t</span> create_options,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        HANDLE* handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        NTSTATUS* nt_status,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        ULONG_PTR* io_information)</span> </span>&#123;<br>  *handle = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// The only action supported is ASK_BROKER which means create the requested</span><br>  <span class="hljs-comment">// file as specified.</span><br>  <span class="hljs-comment">// 对open来说，eval_result只可能是ASK_BROKER</span><br>  <span class="hljs-keyword">if</span> (ASK_BROKER != eval_result) &#123;<br>    *nt_status = STATUS_ACCESS_DENIED;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  IO_STATUS_BLOCK io_block = &#123;&#125;;<br>  UNICODE_STRING uni_name = &#123;&#125;;<br>  OBJECT_ATTRIBUTES obj_attributes = &#123;&#125;;<br>  SECURITY_QUALITY_OF_SERVICE security_qos = <span class="hljs-built_in">GetAnonymousQOS</span>();<br><br>  <span class="hljs-comment">// 填充obj_attributes</span><br>  <span class="hljs-built_in">InitObjectAttribs</span>(file, attributes, <span class="hljs-literal">nullptr</span>, &amp;obj_attributes, &amp;uni_name,<br>                    <span class="hljs-built_in">IsPipe</span>(file) ? &amp;security_qos : <span class="hljs-literal">nullptr</span>);<br>  *nt_status =<br>      <span class="hljs-built_in">NtCreateFileInTarget</span>(handle, desired_access, &amp;obj_attributes, &amp;io_block,<br>                           file_attributes, share_access, create_disposition,<br>                           create_options, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, client_info.process);<br><br>  *io_information = io_block.Information;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>展开NtCreateFileInTarget看看吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">NtCreateFileInTarget</span><span class="hljs-params">(HANDLE* target_file_handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                              ACCESS_MASK desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                              OBJECT_ATTRIBUTES* obj_attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                              IO_STATUS_BLOCK* io_status_block,</span></span><br><span class="hljs-params"><span class="hljs-function">                              ULONG file_attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                              ULONG share_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                              ULONG create_disposition,</span></span><br><span class="hljs-params"><span class="hljs-function">                              ULONG create_options,</span></span><br><span class="hljs-params"><span class="hljs-function">                              PVOID ea_buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                              ULONG ea_length,</span></span><br><span class="hljs-params"><span class="hljs-function">                              HANDLE target_process)</span> </span>&#123;<br>  <span class="hljs-comment">// 获取到NtCreateFile函数地址</span><br>  NtCreateFileFunction NtCreateFile = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-built_in">ResolveNTFunctionPtr</span>(<span class="hljs-string">&quot;NtCreateFile&quot;</span>, &amp;NtCreateFile);<span class="hljs-comment">// 实际上是GetProcAddress</span><br><br>  <span class="hljs-comment">// 调用NtCreateFile</span><br>  HANDLE local_handle = INVALID_HANDLE_VALUE;<br>  NTSTATUS status =<br>      <span class="hljs-built_in">NtCreateFile</span>(&amp;local_handle, desired_access, obj_attributes,<br>                   io_status_block, <span class="hljs-literal">nullptr</span>, file_attributes, share_access,<br>                   create_disposition, create_options, ea_buffer, ea_length);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(status)) &#123;<br>    <span class="hljs-keyword">return</span> status;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!sandbox::<span class="hljs-built_in">SameObject</span>(local_handle, obj_attributes-&gt;ObjectName-&gt;Buffer)) &#123;<br>    <span class="hljs-comment">// The handle points somewhere else. Fail the operation.</span><br>    ::<span class="hljs-built_in">CloseHandle</span>(local_handle);<br>    <span class="hljs-keyword">return</span> STATUS_ACCESS_DENIED;<br>  &#125;<br><br>  <span class="hljs-comment">// 拷贝handle给target_process的target_file_handle</span><br>  <span class="hljs-comment">// 这个target_file_handle的值在返回到FilesystemDispatcher::NtCreateFile时</span><br>  <span class="hljs-comment">// 会拷贝到ipc的CrossCallReturn中，传递给target进程，我们下面分析dispatcher时会看到</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), local_handle, target_process,<br>                         target_file_handle, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>,<br>                         DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS)) &#123;<br>    <span class="hljs-keyword">return</span> STATUS_ACCESS_DENIED;<br>  &#125;<br>  <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上create的操作是在broker端得到了执行，而将返回的句柄复制给了target进程传过来的target_file_handle。</p><p>其他的action函数也类似，都是对API的一层封装，它们并没有做检查处理，因为policyrule对请求的检查要优先于此（实际上是<code>EvalPolicy</code>操作）。这些请求处理函数的调用位置在<code>FilesystemDispatcher</code>中。</p><p>其他的就不一一枚举了。</p><p><strong>小结</strong></p><p><strong>FileSystem的low-level policy部分做了两件事：</strong></p><ol type="1"><li><strong>为<code>PolicyBase::AddRule</code>提供了该子系统5个service或者叫action的Rule制定接口。</strong></li><li><strong>编写了broker端5个请求的处理，在broker端调用了对应的API函数。</strong></li></ol><h2 id="dispatcher">Dispatcher</h2><p>Dispatcher处理的是target发起的IPC请求。我们此前分析<code>Dispatcher</code>类时就发现，它是个基类，而对应每一个子系统，都有一个具体的派生类。对于filesystem来说，这个派生类就是<code>FilesystemDispatcher</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This class handles file system-related IPC calls.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FilesystemDispatcher</span> : <span class="hljs-keyword">public</span> Dispatcher &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 构造器关联PolicyBase对象</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">FilesystemDispatcher</span><span class="hljs-params">(PolicyBase* policy_base)</span></span>;<br>  ~<span class="hljs-built_in">FilesystemDispatcher</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br>  <span class="hljs-comment">// Dispatcher interface.</span><br>  <span class="hljs-comment">// 与InterceptionManager对接之处</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetupService</span><span class="hljs-params">(InterceptionManager* manager, <span class="hljs-type">int</span> service)</span> <span class="hljs-keyword">override</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// target的各种IPC请求，target在call这5个API时会发起IPC请求</span><br>  <span class="hljs-comment">// Processes IPC requests coming from calls to NtCreateFile in the target.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NtCreateFile</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                    base::string16* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">uint32_t</span> attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">uint32_t</span> file_attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">uint32_t</span> share_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">uint32_t</span> create_disposition,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">uint32_t</span> create_options)</span></span>;<br><br>  <span class="hljs-comment">// Processes IPC requests coming from calls to NtOpenFile in the target.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NtOpenFile</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                  base::string16* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">uint32_t</span> attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">uint32_t</span> share_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">uint32_t</span> create_options)</span></span>;<br><br>  <span class="hljs-comment">// Processes IPC requests coming from calls to NtQueryAttributesFile in the</span><br>  <span class="hljs-comment">// target.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NtQueryAttributesFile</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                             base::string16* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">uint32_t</span> attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                             CountedBuffer* info)</span></span>;<br><br>  <span class="hljs-comment">// Processes IPC requests coming from calls to NtQueryFullAttributesFile in</span><br>  <span class="hljs-comment">// the target.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NtQueryFullAttributesFile</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 base::string16* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">uint32_t</span> attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 CountedBuffer* info)</span></span>;<br><br>  <span class="hljs-comment">// Processes IPC requests coming from calls to NtSetInformationFile with the</span><br>  <span class="hljs-comment">// rename information class.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NtSetInformationFile</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                            HANDLE handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                            CountedBuffer* status,</span></span><br><span class="hljs-params"><span class="hljs-function">                            CountedBuffer* info,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">uint32_t</span> length,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">uint32_t</span> info_class)</span></span>;<br><br>  PolicyBase* policy_base_;<br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(FilesystemDispatcher);<br>&#125;;<br></code></pre></td></tr></table></figure><p>###构造器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FilesystemDispatcher::<span class="hljs-built_in">FilesystemDispatcher</span>(PolicyBase* policy_base)<br>    : <span class="hljs-built_in">policy_base_</span>(policy_base) &#123;<br>  <span class="hljs-comment">// 把相关的几个IPCCall全部实体化，这里完成各个service id与callback的绑定</span><br>  <span class="hljs-comment">// 绑定的函数就是类内部定义的几个接口处理函数</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> IPCCall create_params = &#123;<br>      &#123;IPC_NTCREATEFILE_TAG,<br>       &#123;WCHAR_TYPE, UINT32_TYPE, UINT32_TYPE, UINT32_TYPE, UINT32_TYPE,<br>        UINT32_TYPE, UINT32_TYPE&#125;&#125;,<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;CallbackGeneric&gt;(&amp;FilesystemDispatcher::NtCreateFile)&#125;;<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> IPCCall open_file = &#123;<br>      &#123;IPC_NTOPENFILE_TAG,<br>       &#123;WCHAR_TYPE, UINT32_TYPE, UINT32_TYPE, UINT32_TYPE, UINT32_TYPE&#125;&#125;,<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;CallbackGeneric&gt;(&amp;FilesystemDispatcher::NtOpenFile)&#125;;<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> IPCCall attribs = &#123;<br>      &#123;IPC_NTQUERYATTRIBUTESFILE_TAG, &#123;WCHAR_TYPE, UINT32_TYPE, INOUTPTR_TYPE&#125;&#125;,<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;CallbackGeneric&gt;(<br>          &amp;FilesystemDispatcher::NtQueryAttributesFile)&#125;;<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> IPCCall full_attribs = &#123;<br>      &#123;IPC_NTQUERYFULLATTRIBUTESFILE_TAG,<br>       &#123;WCHAR_TYPE, UINT32_TYPE, INOUTPTR_TYPE&#125;&#125;,<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;CallbackGeneric&gt;(<br>          &amp;FilesystemDispatcher::NtQueryFullAttributesFile)&#125;;<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> IPCCall set_info = &#123;<br>      &#123;IPC_NTSETINFO_RENAME_TAG,<br>       &#123;VOIDPTR_TYPE, INOUTPTR_TYPE, INOUTPTR_TYPE, UINT32_TYPE, UINT32_TYPE&#125;&#125;,<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;CallbackGeneric&gt;(<br>          &amp;FilesystemDispatcher::NtSetInformationFile)&#125;;<br><br>  <span class="hljs-comment">// 全部置入ipc_calls_中维护</span><br>  ipc_calls_.<span class="hljs-built_in">push_back</span>(create_params);<br>  ipc_calls_.<span class="hljs-built_in">push_back</span>(open_file);<br>  ipc_calls_.<span class="hljs-built_in">push_back</span>(attribs);<br>  ipc_calls_.<span class="hljs-built_in">push_back</span>(full_attribs);<br>  ipc_calls_.<span class="hljs-built_in">push_back</span>(set_info);<br>&#125;<br></code></pre></td></tr></table></figure><p>而SetupService则是该对象的灵魂了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FilesystemDispatcher::SetupService</span><span class="hljs-params">(InterceptionManager* manager,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">int</span> service)</span> </span>&#123;<br>  <span class="hljs-comment">// 根据service id，找到是哪个IPCCall</span><br>  <span class="hljs-keyword">switch</span> (service) &#123;<br>    <span class="hljs-keyword">case</span> IPC_NTCREATEFILE_TAG:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">INTERCEPT_NT</span>(manager, NtCreateFile, CREATE_FILE_ID, <span class="hljs-number">48</span>);<br><br>    <span class="hljs-keyword">case</span> IPC_NTOPENFILE_TAG:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">INTERCEPT_NT</span>(manager, NtOpenFile, OPEN_FILE_ID, <span class="hljs-number">28</span>);<br><br>    <span class="hljs-keyword">case</span> IPC_NTQUERYATTRIBUTESFILE_TAG:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">INTERCEPT_NT</span>(manager, NtQueryAttributesFile, QUERY_ATTRIB_FILE_ID,<br>                          <span class="hljs-number">12</span>);<br><br>    <span class="hljs-keyword">case</span> IPC_NTQUERYFULLATTRIBUTESFILE_TAG:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">INTERCEPT_NT</span>(manager, NtQueryFullAttributesFile,<br>                          QUERY_FULL_ATTRIB_FILE_ID, <span class="hljs-number">12</span>);<br><br>    <span class="hljs-keyword">case</span> IPC_NTSETINFO_RENAME_TAG:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">INTERCEPT_NT</span>(manager, NtSetInformationFile, SET_INFO_FILE_ID, <span class="hljs-number">24</span>);<br><br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将宏展开：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERCEPT_NT(manager, service, id, num_params) \</span><br><span class="hljs-meta">  manager-&gt;ADD_NT_INTERCEPTION(service, id, num_params)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD_NT_INTERCEPTION(service, id, num_params)            \</span><br><span class="hljs-meta">  AddToPatchedFunctions(                                        \</span><br><span class="hljs-meta">      kNtdllName, #service, sandbox::INTERCEPTION_SERVICE_CALL, \</span><br><span class="hljs-meta">      reinterpret_cast<span class="hljs-string">&lt;void*&gt;</span>(MAKE_SERVICE_NAME(service)), id)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_SERVICE_NAME(service) &amp;Target##service##64</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_SERVICE_NAME(service) &amp;Target##service</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>以<code>NtCreateFile</code>为例，实际上最终使用<code>AddToPatchedFunctions</code>将<code>NtCreateFile</code>替换成了<code>TargetNtCreateFile</code>（32位），<code>SetupService</code>这一操作，完成了这5个系统调用的Interception的部署。</p><p>另外，系统调用类型的函数是在broker端处理的。</p><p>那么Target开头的函数从哪儿来，总不能凭空捏造吧，其实他们在filesystem的Interceptions中定义。</p><blockquote><p>我只找到了32位的几个Target函数，64位的没有找到，貌似对这几个servicecall的Interceptions并没有在x64上实现，尽管servicecall的Interceptions提供了这种机制。</p></blockquote><p>还记得此前resolver的处理流程吗，<code>TopLevelDispatcher</code>中有一个<code>Dispatcher*</code>数组，每个IPC请求对应一个成员，其中有5个和filesystem子系统相关的成员指向了同一个构造器new出来的<code>FilesystemDispatcher</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Dispatcher* dispatcher;<br><br>dispatcher = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FilesystemDispatcher</span>(policy_);<br>ipc_targets_[IPC_NTCREATEFILE_TAG] = dispatcher;<br>ipc_targets_[IPC_NTOPENFILE_TAG] = dispatcher;<br>ipc_targets_[IPC_NTSETINFO_RENAME_TAG] = dispatcher;<br>ipc_targets_[IPC_NTQUERYATTRIBUTESFILE_TAG] = dispatcher;<br>ipc_targets_[IPC_NTQUERYFULLATTRIBUTESFILE_TAG] = dispatcher;<br><span class="hljs-comment">// filesystem_dispatcher是TopLevelDispatcher的成员，从此就有了FilesystemDispatcher对象</span><br>filesystem_dispatcher_.<span class="hljs-built_in">reset</span>(dispatcher);<br></code></pre></td></tr></table></figure><p>而broker作为IPC的server端，处理IPC请求的过程是这样的：</p><ol type="1"><li><code>SharedMemIPCServer::Init</code>中会用<code>ThreadProvider</code>注册一个等待ping事件的<code>ThreadPingEventReady</code>，注册时使用的参数的<code>dispatcher</code>绑定了构造器中关联的<code>call_dispatcher_</code>。</li><li>client发起IPC请求时，会signaledping，此后broker进入<code>ThreadPingEventReady</code></li><li><code>ThreadPingEventReady</code>中会调用<code>InvokeCallback</code>匹配callback</li><li><code>InvokeCallback</code>内部调用dispatcher的<code>OnMessageReady</code>。遍历该dispatcher中的<code>IPCParam</code>来找到绑定的callback。</li></ol><p>到此，我们就把filesystem的整个过程联系了起来，对于<code>IPC_NTCREATEFILE_TAG</code>等5种IPC请求，最终会找到<code>filesystem_dispatcher</code>这个具体的dispatcher，而它早在构造器中将<code>IPCParam</code>和5个callback函数绑定了。</p><p>所以下一步，就会调用某个callback，比如<code>NtCreateFile</code>。我们就展开看看这个callback<code>NtCreateFile</code>干了什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FilesystemDispatcher::NtCreateFile</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        base::string16* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">uint32_t</span> attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">uint32_t</span> desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">uint32_t</span> file_attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">uint32_t</span> share_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">uint32_t</span> create_disposition,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">uint32_t</span> create_options)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PreProcessName</span>(name)) &#123;<br>    <span class="hljs-comment">// The path requested might contain a reparse point.</span><br>    ipc-&gt;return_info.nt_status = STATUS_ACCESS_DENIED;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* filename = name-&gt;<span class="hljs-built_in">c_str</span>();<br><br>  <span class="hljs-comment">// 把target传过来的参数值全部置入到CountedParameterSet中</span><br>  <span class="hljs-type">uint32_t</span> broker = BROKER_TRUE;<br>  CountedParameterSet&lt;OpenFile&gt; params;<br>  params[OpenFile::NAME] = <span class="hljs-built_in">ParamPickerMake</span>(filename);<br>  params[OpenFile::ACCESS] = <span class="hljs-built_in">ParamPickerMake</span>(desired_access);<br>  params[OpenFile::DISPOSITION] = <span class="hljs-built_in">ParamPickerMake</span>(create_disposition);<br>  params[OpenFile::OPTIONS] = <span class="hljs-built_in">ParamPickerMake</span>(create_options);<br>  params[OpenFile::BROKER] = <span class="hljs-built_in">ParamPickerMake</span>(broker);<br><br>  <span class="hljs-comment">// To evaluate the policy we need to call back to the policy object. We</span><br>  <span class="hljs-comment">// are just middlemen in the operation since is the FileSystemPolicy which</span><br>  <span class="hljs-comment">// knows what to do.</span><br>  <span class="hljs-comment">// EvalPolicy检查各种rules是否通过，这些rules此前已通过PolicyBase::AddRules设置好了</span><br>  <span class="hljs-comment">// 然后去找Policy模块的CreateFileAction来干实事，也就是前面分析的</span><br>  <span class="hljs-comment">// FileSystemPolicy::CreateFileAction</span><br>  EvalResult result =<br>      policy_base_-&gt;<span class="hljs-built_in">EvalPolicy</span>(IPC_NTCREATEFILE_TAG, params.<span class="hljs-built_in">GetBase</span>());<br>  HANDLE handle;<br>  ULONG_PTR io_information = <span class="hljs-number">0</span>;<br>  NTSTATUS nt_status;<br>  <span class="hljs-comment">// 在这内部，会判断result是否是ASK_BROKER，如果是说明匹配到了rule，那就执行API</span><br>  <span class="hljs-comment">// 如果不是说明凉凉</span><br>  <span class="hljs-keyword">if</span> (!FileSystemPolicy::<span class="hljs-built_in">CreateFileAction</span>(<br>          result, *ipc-&gt;client_info, *name, attributes, desired_access,<br>          file_attributes, share_access, create_disposition, create_options,<br>          &amp;handle, &amp;nt_status, &amp;io_information)) &#123;<br>    ipc-&gt;return_info.nt_status = STATUS_ACCESS_DENIED;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 把返回的结果给IPC调用的CrossCallReturn结构，用于指示target client端</span><br>  <span class="hljs-comment">// Return operation status on the IPC.</span><br>  ipc-&gt;return_info.extended[<span class="hljs-number">0</span>].ulong_ptr = io_information;<br>  ipc-&gt;return_info.nt_status = nt_status;<br>  ipc-&gt;return_info.handle = handle;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，filesystem相关的5个IPC请求在broker端处理的整个链条就清楚了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">EvalResult <span class="hljs-title">PolicyBase::EvalPolicy</span><span class="hljs-params">(<span class="hljs-type">int</span> service,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  CountedParameterSetBase* params)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (policy_) &#123;<br>    <span class="hljs-comment">// 找到PolicyGlobal中对应的entry[service]一项</span><br>    <span class="hljs-keyword">if</span> (!policy_-&gt;entry[service]) &#123;<br>      <span class="hljs-comment">// There is no policy for this particular service. This is not a big</span><br>      <span class="hljs-comment">// deal.</span><br>      <span class="hljs-keyword">return</span> DENY_ACCESS;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; params-&gt;count; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!params-&gt;parameters[i].<span class="hljs-built_in">IsValid</span>()) &#123;<br>        <span class="hljs-built_in">NOTREACHED</span>();<br>        <span class="hljs-keyword">return</span> SIGNAL_ALARM;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 基于policy_-&gt;entry[service]这个PolicyBuffer建一个PolicyProcessor</span><br>    <span class="hljs-function">PolicyProcessor <span class="hljs-title">pol_evaluator</span><span class="hljs-params">(policy_-&gt;entry[service])</span></span>;<br>    <span class="hljs-comment">// 逐group进行evaluate</span><br>    PolicyResult result =<br>        pol_evaluator.<span class="hljs-built_in">Evaluate</span>(kShortEval, params-&gt;parameters, params-&gt;count);<br>    <span class="hljs-comment">// 如果匹配到了，就获取这一group的action</span><br>    <span class="hljs-keyword">if</span> (POLICY_MATCH == result) &#123;<br>      <span class="hljs-keyword">return</span> pol_evaluator.<span class="hljs-built_in">GetAction</span>();<br>    &#125;<br>    <span class="hljs-built_in">DCHECK</span>(POLICY_ERROR != result);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> DENY_ACCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结</strong></p><p><strong>filesystem的<code>FilesystemDispatcher</code>负责三件事：</strong></p><ol type="1"><li><strong>受<code>TopLevelDispatcher</code>的驱使，处理5个filesystem相关的IPC请求</strong></li><li><strong>绑定5个callback函数，每个函数内部执行<code>EvalPolicy</code>审判，然后将参数和结果通通丢给policy的5个处理函数。</strong></li><li><strong>负责5个ntdll.dll中对应的系统调用的拦截器安装。</strong></li></ol><h2 id="interception">Interception</h2><p>那么这个拦截函数就有点意思了，实际上这5个API函数在target端都不能直接调用，target想要调用<code>CreateFile</code>时，要先起一个对应id的IPC请求给broker，broker通过前面的重重处理，最终在<code>FileSystemDispatcher::NtCreateFile</code>中执行<code>EvalPolicy</code>审判，然后调用<code>FileSystemPolicy::CreateFileAction</code>。</p><p>而在具体的action处理内部，审判结果需要是<code>ASK_BROKER</code>才会调用<code>NtCreateFile</code>这个系统调用。</p><p>而对target端，broker已经通过<code>FilesystemDispatcher::SetupService</code>为target部署好了5个系统调用的拦截器，当target进程调用<code>NtCreateFile</code>时，实际上调用到的是<code>TargetNtCreateFile</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS WINAPI <span class="hljs-title">TargetNtCreateFile</span><span class="hljs-params">(NtCreateFileFunction orig_CreateFile,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   PHANDLE file,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   ACCESS_MASK desired_access,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   POBJECT_ATTRIBUTES object_attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   PIO_STATUS_BLOCK io_status,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   PLARGE_INTEGER allocation_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   ULONG file_attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   ULONG sharing,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   ULONG disposition,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   ULONG options,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   PVOID ea_buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   ULONG ea_length)</span> </span>&#123;<br>  <span class="hljs-comment">// Check if the process can open it first.</span><br>  <span class="hljs-comment">// x86的第一个参数是original function地址，先试试能不能打开这个文件，如果不是STATUS_ACCESS_DENIED</span><br>  <span class="hljs-comment">// 就直接调用返回status就行了，无需请求IPC</span><br>  NTSTATUS status = <span class="hljs-built_in">orig_CreateFile</span>(<br>      file, desired_access, object_attributes, io_status, allocation_size,<br>      file_attributes, sharing, disposition, options, ea_buffer, ea_length);<br>  <span class="hljs-keyword">if</span> (STATUS_ACCESS_DENIED != status)<br>    <span class="hljs-keyword">return</span> status;<br><br>  <span class="hljs-comment">// 确保IPC已经可用</span><br>  <span class="hljs-comment">// We don&#x27;t trust that the IPC can work this early.</span><br>  <span class="hljs-keyword">if</span> (!SandboxFactory::<span class="hljs-built_in">GetTargetServices</span>()-&gt;<span class="hljs-built_in">GetState</span>()-&gt;<span class="hljs-built_in">InitCalled</span>())<br>    <span class="hljs-keyword">return</span> status;<br><br>  <span class="hljs-type">wchar_t</span>* name = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ValidParameter</span>(file, <span class="hljs-built_in">sizeof</span>(HANDLE), WRITE))<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ValidParameter</span>(io_status, <span class="hljs-built_in">sizeof</span>(IO_STATUS_BLOCK), WRITE))<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 获取SharedMemory IPC的全局内存空间指针g_shared_IPC_memory</span><br>    <span class="hljs-type">void</span>* memory = <span class="hljs-built_in">GetGlobalIPCMemory</span>();<br>    <span class="hljs-keyword">if</span> (!memory)<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 设置文件属性</span><br>    <span class="hljs-type">uint32_t</span> attributes = <span class="hljs-number">0</span>;<br>    NTSTATUS ret =<br>        <span class="hljs-built_in">AllocAndCopyName</span>(object_attributes, &amp;name, &amp;attributes, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret) || !name)<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 设置其他参数</span><br>    <span class="hljs-type">uint32_t</span> desired_access_uint32 = desired_access;<br>    <span class="hljs-type">uint32_t</span> options_uint32 = options;<br>    <span class="hljs-type">uint32_t</span> disposition_uint32 = disposition;<br>    <span class="hljs-type">uint32_t</span> broker = BROKER_FALSE;<br><br>    <span class="hljs-comment">// 做出一个CountedParameterSet&lt;OpenFile&gt;，按索引调用ParamPickerMake填充参数</span><br>    CountedParameterSet&lt;OpenFile&gt; params;<br>    params[OpenFile::NAME] = <span class="hljs-built_in">ParamPickerMake</span>(name);<br>    params[OpenFile::ACCESS] = <span class="hljs-built_in">ParamPickerMake</span>(desired_access_uint32);<br>    params[OpenFile::DISPOSITION] = <span class="hljs-built_in">ParamPickerMake</span>(disposition_uint32);<br>    params[OpenFile::OPTIONS] = <span class="hljs-built_in">ParamPickerMake</span>(options_uint32);<br>    params[OpenFile::BROKER] = <span class="hljs-built_in">ParamPickerMake</span>(broker);<br><br>    <span class="hljs-comment">// 内部会获取承载PolicyBuffer的g_shared_policy_memory</span><br>    <span class="hljs-comment">// 找到PolicyBuffer并架设一个PolicyProcessor来对CountedParameterSet&lt;OpenFile&gt;进行Evaluate</span><br>    <span class="hljs-comment">// 如果匹配rule且action为ASK_BROKER，才继续发起IPC请求</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">QueryBroker</span>(IPC_NTCREATEFILE_TAG, params.<span class="hljs-built_in">GetBase</span>()))<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-function">SharedMemIPCClient <span class="hljs-title">ipc</span><span class="hljs-params">(memory)</span></span>;<br>    CrossCallReturn answer = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">// The following call must match in the parameters with</span><br>    <span class="hljs-comment">// FilesystemDispatcher::ProcessNtCreateFile.</span><br>    <span class="hljs-comment">// 发起IPC请求，填充这些参数</span><br>    ResultCode code = <span class="hljs-built_in">CrossCall</span>(ipc, IPC_NTCREATEFILE_TAG, name, attributes,<br>                                desired_access_uint32, file_attributes, sharing,<br>                                disposition, options_uint32, &amp;answer);<br>    <span class="hljs-keyword">if</span> (SBOX_ALL_OK != code)<br>      <span class="hljs-keyword">break</span>;<br><br>    status = answer.nt_status;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(answer.nt_status))<br>      <span class="hljs-keyword">break</span>;<br><br>    __try &#123;<br>      *file = answer.handle;<br>      io_status-&gt;Status = answer.nt_status;<br>      io_status-&gt;Information = answer.extended[<span class="hljs-number">0</span>].ulong_ptr;<br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">if</span> (name)<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(name, NT_ALLOC)</span></span>;<br><br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QueryBroker</span><span class="hljs-params">(<span class="hljs-type">int</span> ipc_id, CountedParameterSetBase* params)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_NT</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(ipc_id) &lt; kMaxServiceCount);<br>  <span class="hljs-built_in">DCHECK_NT</span>(g_shared_policy_memory);<br>  <span class="hljs-built_in">DCHECK_NT</span>(g_shared_policy_size &gt; <span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(ipc_id) &gt;= kMaxServiceCount)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// g_shared_policy_memory我们知道是怎么设置共享的</span><br>  <span class="hljs-comment">// 但是broker的PolicyGlobal是内部在堆上new的，和这里的PolicyGlobal应该不是一片内存空间</span><br>  <span class="hljs-comment">// 那么应该有某种同步的机制</span><br>  PolicyGlobal* global_policy =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;PolicyGlobal*&gt;(g_shared_policy_memory);<br><br>  <span class="hljs-keyword">if</span> (!global_policy-&gt;entry[ipc_id])<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  PolicyBuffer* policy = <span class="hljs-built_in">reinterpret_cast</span>&lt;PolicyBuffer*&gt;(<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(g_shared_policy_memory) +<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(global_policy-&gt;entry[ipc_id]));<br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(global_policy-&gt;entry[ipc_id]) &gt;<br>       global_policy-&gt;data_size) ||<br>      (g_shared_policy_size &lt; global_policy-&gt;data_size)) &#123;<br>    <span class="hljs-built_in">NOTREACHED_NT</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; params-&gt;count; i++) &#123;<br>    <span class="hljs-keyword">if</span> (!params-&gt;parameters[i].<span class="hljs-built_in">IsValid</span>()) &#123;<br>      <span class="hljs-built_in">NOTREACHED_NT</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function">PolicyProcessor <span class="hljs-title">processor</span><span class="hljs-params">(policy)</span></span>;<br>  PolicyResult result =<br>      processor.<span class="hljs-built_in">Evaluate</span>(kShortEval, params-&gt;parameters, params-&gt;count);<br>  <span class="hljs-built_in">DCHECK_NT</span>(POLICY_ERROR != result);<br><br>  <span class="hljs-keyword">return</span> POLICY_MATCH == result &amp;&amp; ASK_BROKER == processor.<span class="hljs-built_in">GetAction</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>搜索<code>g_shared_policy_memory</code>相关，在<code>CopyPolicyToTarget</code>中发现端倪：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CopyPolicyToTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* source, <span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span>* dest)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!source || !size)<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-built_in">memcpy</span>(dest, source, size);<br>  sandbox::PolicyGlobal* policy =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;sandbox::PolicyGlobal*&gt;(dest);<br><br>  <span class="hljs-type">size_t</span> offset = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(source);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; sandbox::kMaxServiceCount; i++) &#123;<br>    <span class="hljs-comment">// PolicyBuffer要修正offset</span><br>    <span class="hljs-type">size_t</span> buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(policy-&gt;entry[i]);<br>    <span class="hljs-keyword">if</span> (buffer) &#123;<br>      buffer -= offset;<br>      policy-&gt;entry[i] = <span class="hljs-built_in">reinterpret_cast</span>&lt;sandbox::PolicyBuffer*&gt;(buffer);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数由<code>IPC_Leak</code>调用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SBOX_TESTS_COMMAND <span class="hljs-type">int</span> <span class="hljs-title">IPC_Leak</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">wchar_t</span>** argv)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> SBOX_TEST_FAILED;<br><br>  <span class="hljs-comment">// Replace current target policy with one that forwards all interceptions to</span><br>  <span class="hljs-comment">// broker.</span><br>  PolicyGlobal* policy = <span class="hljs-built_in">GenerateBlankPolicy</span>();<br>  PolicyGlobal* current_policy =<br>      (PolicyGlobal*)sandbox::<span class="hljs-built_in">GetGlobalPolicyMemory</span>();<br>  <span class="hljs-built_in">CopyPolicyToTarget</span>(policy, policy-&gt;data_size + <span class="hljs-built_in">sizeof</span>(PolicyGlobal),<br>                     current_policy);<br>  ...<br></code></pre></td></tr></table></figure><p>回到target发起IPC请求的地方，这里可以看到target自身也进行了一次对参数的审判。如果不过审干脆不回发起IPC调用。而broker端的审判是必须的，因为它不能依赖target的自审，无论target是否自审，broker端都需要进行一次审判，这也是一种合乎安全性的设计。</p>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-LowLevelPolicy-analysis</title>
    <link href="/2018/06/03/chromium-sandbox-LowLevelPolicy-analysis/"/>
    <url>/2018/06/03/chromium-sandbox-LowLevelPolicy-analysis/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第十三篇，主要分析了架设在PolicyEngine之上的low-levelPolicy机制。Low-levelpolicy为TargetPolicy（实际上是PolicyBase）所用，用以evaluatehigh-level操作的可行性（job+alternative desktop+stricted token(includeIL/AC)几乎把target的路堵死了，所以需要借助一种渠道来执行一些操作，于是就有了子系统三大组件）。阅读本篇前，请先阅读前四篇及第十到十二篇。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-lowlevelpolicy-analysis">chromium-sandbox-LowLevelPolicy-analysis</h1><p>在了解了<code>PolicyOpcode</code>,<code>OpcodeFactory</code>以及<code>ParameterSet</code>的机理以后，终于可以看看架在其上的low-levelpolicy。low-levelpolicy与dispatcher和interception共同构成了子系统的三大组件。</p><p>low-levelpolicy在policy_low_level.h中定义。chromium封装了两个类：<code>LowLevelPolicy</code>和<code>PolicyRule</code>。在头文件中已经给出了low-levelpolicy的说明，以及简单的使用示例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Low level policy classes.</span><br><span class="hljs-comment">// Built on top of the PolicyOpcode and OpcodeFatory, the low level policy</span><br><span class="hljs-comment">// provides a way to define rules on strings and numbers but it is unaware</span><br><span class="hljs-comment">// of Windows specific details or how the Interceptions must be set up.</span><br><span class="hljs-comment">// To use these classes you construct one or more rules and add them to the</span><br><span class="hljs-comment">// LowLevelPolicy object like this:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 我们此前在OpcodeFactory的单元测试代码中看到过rule</span><br><span class="hljs-comment">// low-level policy只是提供了定义rule的接口，它对于windows的特定细节以及Interceptions如何被安装</span><br><span class="hljs-comment">// 并不关心。使用的套路就是定义多个PolicyRule对象，每个对象代表一组rule，添加match的opcode，然后</span><br><span class="hljs-comment">// add到管理者LowLevelPolicy对象，同样是add/fire的设计模式。</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">//   PolicyRule rule1(ASK_BROKER);</span><br><span class="hljs-comment">//   rule1.AddStringMatch(IF, 0, L&quot;\\\\/?/?\\c:\\*Microsoft*\\*.exe&quot;, true);</span><br><span class="hljs-comment">//   rule1.AddNumberMatch(IF_NOT, 1, CREATE_ALWAYS, EQUAL);</span><br><span class="hljs-comment">//   rule1.AddNumberMatch(IF, 2, FILE_ATTRIBUTE_NORMAL, EQUAL);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   PolicyRule rule2(FAKE_SUCCESS);</span><br><span class="hljs-comment">//   rule2.AddStringMatch(IF, 0, L&quot;\\\\/?/?\\Pipe\\Chrome.*&quot;, false));</span><br><span class="hljs-comment">//   rule2.AddNumberMatch(IF, 1, OPEN_EXISTING, EQUAL));</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   LowLevelPolicy policyGen(*policy_memory);</span><br><span class="hljs-comment">//   policyGen.AddRule(kNtCreateFileSvc, &amp;rule1);</span><br><span class="hljs-comment">//   policyGen.AddRule(kNtCreateFileSvc, &amp;rule2);</span><br><span class="hljs-comment">//   policyGen.Done();</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// At this point (error checking omitted) the policy_memory can be copied</span><br><span class="hljs-comment">// to the target process where it can be evaluated.</span><br><span class="hljs-comment">// 根据注释的说明，LowLevelPolicy是由broker控制的，在fire之后，需要把policy_memory传给target进程。</span><br></code></pre></td></tr></table></figure><h2 id="lowlevelpolicy"><code>LowLevelPolicy</code></h2><p>类头定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Provides the means to collect rules into a policy store (memory)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LowLevelPolicy</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// policy_store: must contain allocated memory and the internal</span><br>  <span class="hljs-comment">// size fields set to correct values.</span><br>  <span class="hljs-comment">// policy_store是个PolicyGlobal指针，这理应是个由外部分配的内存空间，具有某种设计的结构</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">LowLevelPolicy</span><span class="hljs-params">(PolicyGlobal* policy_store)</span></span>;<br><br>  <span class="hljs-comment">// Destroys all the policy rules.</span><br>  ~<span class="hljs-built_in">LowLevelPolicy</span>();<br><br>  <span class="hljs-comment">// Adds a rule to be generated when Done() is called.</span><br>  <span class="hljs-comment">// service: The id of the service that this rule is associated with,</span><br>  <span class="hljs-comment">// for example the &#x27;Open Thread&#x27; service or the &quot;Create File&quot; service.</span><br>  <span class="hljs-comment">// returns false on error.</span><br>  <span class="hljs-comment">// 增加rule的方法</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AddRule</span><span class="hljs-params">(<span class="hljs-type">int</span> service, PolicyRule* rule)</span></span>;<br><br>  <span class="hljs-comment">// Generates all the rules added with AddRule() into the memory area</span><br>  <span class="hljs-comment">// passed on the constructor. Returns false on error.</span><br>  <span class="hljs-comment">// 生成所有由AddRule添加的rule，导入到policy_store_</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Done</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">RuleNode</span> &#123;<br>    <span class="hljs-type">const</span> PolicyRule* rule;<br>    <span class="hljs-type">int</span> service;<br>  &#125;;<br>  std::list&lt;RuleNode&gt; rules_;<span class="hljs-comment">//规则RuleNode链表</span><br>  PolicyGlobal* policy_store_;<span class="hljs-comment">//依赖于构造器传入的外部PolicyGlobal对象指针</span><br>  <span class="hljs-built_in">DISALLOW_IMPLICIT_CONSTRUCTORS</span>(LowLevelPolicy);<br>&#125;;<br></code></pre></td></tr></table></figure><p>根据头的设计，我们可以轻易的判断出，<code>rules_</code>是负责处理add操作，而fire时再把<code>rules_</code>的内容倒换到<code>policy_store_</code>中。<code>policy_store_</code>是broker需要copy到target的buffer。</p><p><code>RuleNode</code>的设计已经很清楚了，只是关联了<code>PolicyRule</code>和<code>service</code>，那么<code>PolicyGloabl</code>是什么样的设计呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Defines the memory layout of the policy. This memory is filled by</span><br><span class="hljs-comment">// LowLevelPolicy object.</span><br><span class="hljs-comment">// For example:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  [Service 0] --points to---\</span><br><span class="hljs-comment">//  [Service 1] --------------|-----\</span><br><span class="hljs-comment">//   ......                   |     |</span><br><span class="hljs-comment">//  [Service N]               |     |</span><br><span class="hljs-comment">//  [data_size]               |     |</span><br><span class="hljs-comment">//  [Policy Buffer 0] &lt;-------/     |</span><br><span class="hljs-comment">//  [opcodes of]                    |</span><br><span class="hljs-comment">//  .......                         |</span><br><span class="hljs-comment">//  [Policy Buffer 1] &lt;-------------/</span><br><span class="hljs-comment">//  [opcodes]</span><br><span class="hljs-comment">//  .......</span><br><span class="hljs-comment">//  .......</span><br><span class="hljs-comment">//  [Policy Buffer N]</span><br><span class="hljs-comment">//  [opcodes]</span><br><span class="hljs-comment">//  .......</span><br><span class="hljs-comment">//   &lt;possibly unused space here&gt;</span><br><span class="hljs-comment">//  .......</span><br><span class="hljs-comment">//  [opcode string ]</span><br><span class="hljs-comment">//  [opcode string ]</span><br><span class="hljs-comment">//  .......</span><br><span class="hljs-comment">//  [opcode string ]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PolicyGlobal</span> &#123;<br>  PolicyBuffer* entry[kMaxServiceCount];<span class="hljs-comment">// kMaxServiceCount是个const，值为64</span><br>  <span class="hljs-type">size_t</span> data_size;<br>  PolicyBuffer data[<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>PolicyBuffer</code>我们上一篇已经了解了，实际上是若干<code>PolicyOpcode</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PolicyBuffer</span> &#123;<br>  <span class="hljs-type">size_t</span> opcode_count;<br>  PolicyOpcode opcodes[<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>那么这一设计就很明显了，因为我们知道<code>PolicyBuffer</code>是不定长的，所以不能简单的通过<code>PolicyGlobal.data[index]</code>方式来定位<code>PolicyBuffer</code>，所以<code>PolicyGlobal</code>中有一个entry指针数组，用以索引每个<code>PolicyBuffer</code>。</p><p>而上面的图示已经描摹的很清楚了。另一点要注意的就是<code>kMaxServiceCount</code>这个值，看起来它和crosscall机制中的service有关系，每个service对应一个<code>PolicyBuffer</code>，至于他们具体是如何联系的，等分析具体子系统时就会看到。</p><h3 id="构造析构器">构造/析构器</h3><p>其实都没什么好说的，无非就是成员的初始化和清理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LowLevelPolicy::<span class="hljs-built_in">LowLevelPolicy</span>(PolicyGlobal* policy_store)<br>    : <span class="hljs-built_in">policy_store_</span>(policy_store) &#123;&#125;<br><br>LowLevelPolicy::~<span class="hljs-built_in">LowLevelPolicy</span>() &#123;<br>  <span class="hljs-comment">// Delete all the rules.</span><br>  <span class="hljs-keyword">typedef</span> std::list&lt;RuleNode&gt; RuleNodes;<br>  <span class="hljs-keyword">for</span> (RuleNodes::iterator it = rules_.<span class="hljs-built_in">begin</span>(); it != rules_.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    <span class="hljs-keyword">delete</span> it-&gt;rule;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="add"><code>Add</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Adding a rule is nothing more than pushing it into an stl container. Done()</span><br><span class="hljs-comment">// is called for the rule in case the code that made the rule in the first</span><br><span class="hljs-comment">// place has not done it.</span><br><span class="hljs-comment">// add方法不过是把PolicyRule和service二元组置入容器中</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LowLevelPolicy::AddRule</span><span class="hljs-params">(<span class="hljs-type">int</span> service, PolicyRule* rule)</span> </span>&#123;<br>  <span class="hljs-comment">// 如果已经fire了，那就不能再add了</span><br>  <span class="hljs-keyword">if</span> (!rule-&gt;<span class="hljs-built_in">Done</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 看起来PolicyRule支持复制构造，也就是说rules_容器中存储的不是传入的PolicyRule本体</span><br>  <span class="hljs-comment">// 而是一个复制对象，等到我们分析PolicyRule时再看看是否有显式定义复制构造器</span><br>  PolicyRule* local_rule = <span class="hljs-keyword">new</span> <span class="hljs-built_in">PolicyRule</span>(*rule);<br>  RuleNode node = &#123;local_rule, service&#125;;<br>  rules_.<span class="hljs-built_in">push_back</span>(node);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="done"><code>Done</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Here is where the heavy byte shuffling is done. We take all the rules and</span><br><span class="hljs-comment">// &#x27;compile&#x27; them into a single memory region. Now, the rules are in random</span><br><span class="hljs-comment">// order so the first step is to reorganize them into a stl map that is keyed</span><br><span class="hljs-comment">// by the service id and as a value contains a list with all the rules that</span><br><span class="hljs-comment">// belong to that service. Then we enter the big for-loop where we carve a</span><br><span class="hljs-comment">// memory zone for the opcodes and the data and call RebindCopy on each rule</span><br><span class="hljs-comment">// so they all end up nicely packed in the policy_store_.</span><br><span class="hljs-comment">// 把rules_部署到PolicyGlobal中，经历了一个stl map的整理以及copy到最终的memory的过程</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LowLevelPolicy::Done</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">typedef</span> std::list&lt;RuleNode&gt; RuleNodes;<br>  <span class="hljs-keyword">typedef</span> std::list&lt;<span class="hljs-type">const</span> PolicyRule*&gt; RuleList;<br>  <span class="hljs-keyword">typedef</span> std::map&lt;<span class="hljs-type">uint32_t</span>, RuleList&gt; Mmap;<br>  Mmap mmap;<span class="hljs-comment">// 整理所用map，service id做键，RuleList存储一堆PolicyRule</span><br><br>  <span class="hljs-comment">// 简单的迭代，把rules_打入到mmap</span><br>  <span class="hljs-keyword">for</span> (RuleNodes::iterator it = rules_.<span class="hljs-built_in">begin</span>(); it != rules_.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    mmap[it-&gt;service].<span class="hljs-built_in">push_back</span>(it-&gt;rule);<br>  &#125;<br><br>  <span class="hljs-comment">// 定位到PolicyGlobal中第一个PolicyBuffer处</span><br>  PolicyBuffer* current_buffer = &amp;policy_store_-&gt;data[<span class="hljs-number">0</span>];<br>  <span class="hljs-comment">// buffer_end指向这块memory的末尾，用于后续尺寸检查防止溢出</span><br>  <span class="hljs-type">char</span>* buffer_end =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(current_buffer) + policy_store_-&gt;data_size;<br>  <span class="hljs-type">size_t</span> avail_size = policy_store_-&gt;data_size;<br><br>  <span class="hljs-comment">// 对mmap迭代</span><br>  <span class="hljs-keyword">for</span> (Mmap::iterator it = mmap.<span class="hljs-built_in">begin</span>(); it != mmap.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    <span class="hljs-type">uint32_t</span> service = (*it).first;<br>    <span class="hljs-comment">// 首先service的id不应该超过kMaxServiceCount，否则无处安放，一个id一个坑</span><br>    <span class="hljs-keyword">if</span> (service &gt;= kMaxServiceCount) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 调整entry[service]指针指向第一个坑位，也就是data[0]</span><br>    policy_store_-&gt;entry[service] = current_buffer;<br><br>    RuleList::iterator rules_it = (*it).second.<span class="hljs-built_in">begin</span>();<br>    RuleList::iterator rules_it_end = (*it).second.<span class="hljs-built_in">end</span>();<br><br>    <span class="hljs-type">size_t</span> svc_opcode_count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 迭代该service id的PolicyRule</span><br>    <span class="hljs-keyword">for</span> (; rules_it != rules_it_end; ++rules_it) &#123;<br>      <span class="hljs-type">const</span> PolicyRule* rule = (*rules_it);<br>      <span class="hljs-comment">// 获取本次PolicyRule的opcode个数</span><br>      <span class="hljs-type">size_t</span> op_count = rule-&gt;<span class="hljs-built_in">GetOpcodeCount</span>();<br><br>      <span class="hljs-comment">// 算出opcode的尺寸</span><br>      <span class="hljs-type">size_t</span> opcodes_size = op_count * <span class="hljs-built_in">sizeof</span>(PolicyOpcode);<br>      <span class="hljs-comment">// 剩余的可用空间是否足以容纳opcodes</span><br>      <span class="hljs-keyword">if</span> (avail_size &lt; opcodes_size) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-comment">// 扣除opcodes本身的尺寸</span><br>      <span class="hljs-type">size_t</span> data_size = avail_size - opcodes_size;<br>      <span class="hljs-comment">// 索引到本次处理的PolicyBuffer中第svc_opcode_count个PolicyOpcode</span><br>      <span class="hljs-comment">// 存储opcode，opcodes在rule中维护，所以copy是它的事情。buffer_end和data_size应该是用于</span><br>      <span class="hljs-comment">// 防止溢出和回置data使用的尺寸</span><br>      PolicyOpcode* opcodes_start = &amp;current_buffer-&gt;opcodes[svc_opcode_count];<br>      <span class="hljs-keyword">if</span> (!rule-&gt;<span class="hljs-built_in">RebindCopy</span>(opcodes_start, opcodes_size, buffer_end,<br>                            &amp;data_size)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-comment">// 再度扣除data尺寸，调整buffer_end和avail_size</span><br>      <span class="hljs-type">size_t</span> used = avail_size - data_size;<br>      buffer_end -= used;<br>      avail_size -= used;<br>      svc_opcode_count += op_count;<span class="hljs-comment">// 每处理一个PolicyRule，都会存一组PolicyOpcode</span><br>        <span class="hljs-comment">// 所以不是简单的自增1，而是自增op_count</span><br>    &#125;<br><br>    current_buffer-&gt;opcode_count += svc_opcode_count;<br>    <span class="hljs-comment">// 这里计算的方式有点奇怪，current_buffer[0]的尺寸应该是一个PolicyOpcode+size_t的大小</span><br>    <span class="hljs-comment">// 而svc_opcode_count * sizeof(PolicyOpcode)是svc_opcode_count个PolicyOpcode的大小</span><br>    <span class="hljs-comment">// 假设svc_opcode_count是N个，那么就是</span><br>    <span class="hljs-comment">// (N * sizeof(PolicyOpcode) / (sizeof(PolicyOpcode)+4))</span><br>    <span class="hljs-comment">// 此时算出来的值会小于N，而current_buffer在调整位置时也很奇怪</span><br>    <span class="hljs-comment">// 如果是按照我的理解，应该写成：</span><br>    <span class="hljs-comment">// current_buffer = &amp;(current_buffer-&gt;opcodes[svc_opcode_count]);</span><br>    <span class="hljs-comment">// 但这里是把PolicyOpcode的尺寸换成了PolicyBuffer单位个</span><br>    <span class="hljs-comment">// current_buffer[policy_byte_count+1]中多出来的1个应该是给current_buffer-&gt;opcode_count</span><br>    <span class="hljs-comment">// 这样的计算就会导致新的current_buffer和上一次数据的结尾之间会有一段空白</span><br>    <span class="hljs-comment">// 而另一方面，rule-&gt;RebindCopy设置的data_size就很关键了，它是否和此处计算的一致呢</span><br>    <span class="hljs-comment">// 到目前为止，看起来这是个bug</span><br>    <span class="hljs-type">size_t</span> policy_byte_count =<br>        (svc_opcode_count * <span class="hljs-built_in">sizeof</span>(PolicyOpcode)) / <span class="hljs-built_in">sizeof</span>(current_buffer[<span class="hljs-number">0</span>]);<br>    current_buffer = &amp;current_buffer[policy_byte_count + <span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="policyrule"><code>PolicyRule</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Provides the means to collect a set of comparisons into a single</span><br><span class="hljs-comment">// rule and its associated action.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PolicyRule</span> &#123;<br>  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LowLevelPolicy</span>;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">PolicyRule</span><span class="hljs-params">(EvalResult action)</span></span>;<br>  <span class="hljs-built_in">PolicyRule</span>(<span class="hljs-type">const</span> PolicyRule&amp; other);<br>  ~<span class="hljs-built_in">PolicyRule</span>();<br><br>  <span class="hljs-comment">// Adds a string comparison to the rule.</span><br>  <span class="hljs-comment">// rule_type: possible values are IF and IF_NOT.</span><br>  <span class="hljs-comment">// parameter: the expected index of the argument for this rule. For example</span><br>  <span class="hljs-comment">// in a &#x27;create file&#x27; service the file name argument can be at index 0.</span><br>  <span class="hljs-comment">// string: is the desired matching pattern.</span><br>  <span class="hljs-comment">// match_opts: if the pattern matching is case sensitive or not.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AddStringMatch</span><span class="hljs-params">(RuleType rule_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">int16_t</span> parameter,</span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* string,</span></span><br><span class="hljs-params"><span class="hljs-function">                      StringMatchOptions match_opts)</span></span>;<br><br>  <span class="hljs-comment">// Adds a number match comparison to the rule.</span><br>  <span class="hljs-comment">// rule_type: possible values are IF and IF_NOT.</span><br>  <span class="hljs-comment">// parameter: the expected index of the argument for this rule.</span><br>  <span class="hljs-comment">// number: the value to compare the input to.</span><br>  <span class="hljs-comment">// comparison_op: the comparison kind (equal, logical and, etc).</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AddNumberMatch</span><span class="hljs-params">(RuleType rule_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">int16_t</span> parameter,</span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">uint32_t</span> number,</span></span><br><span class="hljs-params"><span class="hljs-function">                      RuleOp comparison_op)</span></span>;<br><br>  <span class="hljs-comment">// Returns the number of opcodes generated so far.</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetOpcodeCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> buffer_-&gt;opcode_count; &#125;<br><br>  <span class="hljs-comment">// Called when there is no more comparisons to add. Internally it generates</span><br>  <span class="hljs-comment">// the last opcode (the action opcode). Returns false if this operation fails.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Done</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PolicyRule&amp;);<br>  <span class="hljs-comment">// Called in a loop from AddStringMatch to generate the required string</span><br>  <span class="hljs-comment">// match opcodes. rule_type, match_opts and parameter are the same as</span><br>  <span class="hljs-comment">// in AddStringMatch.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GenStringOpcode</span><span class="hljs-params">(RuleType rule_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                       StringMatchOptions match_opts,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">uint16_t</span> parameter,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">int</span> state,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">bool</span> last_call,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">int</span>* skip_count,</span></span><br><span class="hljs-params"><span class="hljs-function">                       base::string16* fragment)</span></span>;<br><br>  <span class="hljs-comment">// Loop over all generated opcodes and copy them to increasing memory</span><br>  <span class="hljs-comment">// addresses from opcode_start and copy the extra data (strings usually) into</span><br>  <span class="hljs-comment">// decreasing addresses from data_start. Extra data is only present in the</span><br>  <span class="hljs-comment">// string evaluation opcodes.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">RebindCopy</span><span class="hljs-params">(PolicyOpcode* opcode_start,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">size_t</span> opcode_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">char</span>* data_start,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">size_t</span>* data_size)</span> <span class="hljs-type">const</span></span>;<br>  PolicyBuffer* buffer_;<span class="hljs-comment">// 内部当然得有一个PolicyBuffer来承载opcode groups</span><br>  OpcodeFactory* opcode_factory_;<span class="hljs-comment">// 指向管理这个group的工厂类</span><br>  EvalResult action_;<br>  <span class="hljs-type">bool</span> done_;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>Add</code>和<code>Done</code>接口，单从函数参数来看，其用意已十分明显。值得注意的是该类重载了赋值操作符，但注意它是private权限，即只能在内部使用。</p><h3 id="构造析构器-1">构造/析构器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PolicyRule::<span class="hljs-built_in">PolicyRule</span>(EvalResult action) : <span class="hljs-built_in">action_</span>(action), <span class="hljs-built_in">done_</span>(<span class="hljs-literal">false</span>) &#123;<br>  <span class="hljs-comment">// memory是size_t + PolicyOpcode + 4096的大小</span><br>  <span class="hljs-type">char</span>* memory = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">sizeof</span>(PolicyBuffer) + kRuleBufferSize];<br>  buffer_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;PolicyBuffer*&gt;(memory);<br>  buffer_-&gt;opcode_count = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// new出一个工厂类，top是buffer_-&gt;opcodes[0]，bottom是memory[sizeof(PolicyBuffer) + kRuleBufferSize]</span><br>  <span class="hljs-comment">// 使用的是第一个参数为PolicyBuffer *的构造器</span><br>  opcode_factory_ =<br>      <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpcodeFactory</span>(buffer_, kRuleBufferSize + <span class="hljs-built_in">sizeof</span>(PolicyOpcode));<br>&#125;<br><br>PolicyRule::~<span class="hljs-built_in">PolicyRule</span>() &#123;<br>  <span class="hljs-keyword">delete</span>[] <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(buffer_);<br>  <span class="hljs-keyword">delete</span> opcode_factory_;<br>&#125;<br></code></pre></td></tr></table></figure><p>复制构造有点意思：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PolicyRule::<span class="hljs-built_in">PolicyRule</span>(<span class="hljs-type">const</span> PolicyRule&amp; other) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other)<br>    <span class="hljs-keyword">return</span>;<br>  action_ = other.action_;<br>  done_ = other.done_;<br>  <span class="hljs-comment">// buffer_size是size_t + PolicyOpcode + 4096的大小，这和构造器中的计算一致</span><br>  <span class="hljs-type">size_t</span> buffer_size = <span class="hljs-built_in">sizeof</span>(PolicyBuffer) + kRuleBufferSize;<br>  <span class="hljs-type">char</span>* memory = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[buffer_size];<br>  <span class="hljs-comment">// 需要重新开辟memory，然后深拷贝，所以要显式定义复制构造</span><br>  buffer_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;PolicyBuffer*&gt;(memory);<br>  <span class="hljs-built_in">memcpy</span>(buffer_, other.buffer_, buffer_size);<br><br>  <span class="hljs-comment">// opcode_buffer指向的是PolicyOpcode</span><br>  <span class="hljs-comment">// next_opcode指向的是所有的PolicyOpcode的末尾</span><br>  <span class="hljs-type">char</span>* opcode_buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(&amp;buffer_-&gt;opcodes[<span class="hljs-number">0</span>]);<br>  <span class="hljs-type">char</span>* next_opcode = &amp;opcode_buffer[<span class="hljs-built_in">GetOpcodeCount</span>() * <span class="hljs-built_in">sizeof</span>(PolicyOpcode)];<br>  <span class="hljs-comment">// 新的工厂类使用的是上一次剩余的那部分free空间</span><br>  <span class="hljs-comment">// 所以next_opcode指向上一次的top，而other.opcode_factory_-&gt;memory_size()是上一次剩余的free大小</span><br>  <span class="hljs-comment">// 新的工厂类的top和bottom实际上是上一次的free空间</span><br>  opcode_factory_ =<br>      <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpcodeFactory</span>(next_opcode, other.opcode_factory_-&gt;<span class="hljs-built_in">memory_size</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>教科书般的复制构造，两个点都注意到了：一是buffer的深拷贝，二是工厂类对象。</p><h3 id="两个add">两个<code>Add</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// There are &#x27;if&#x27; rules and &#x27;if not&#x27; comparisons</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">RuleType</span> &#123;<br>  IF = <span class="hljs-number">0</span>,<br>  IF_NOT = <span class="hljs-number">1</span>,<br>&#125;;<br><br><span class="hljs-comment">// Possible comparisons for numbers</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">RuleOp</span> &#123;<br>  EQUAL,<br>  AND,<br>  RANGE  <span class="hljs-comment">// TODO(cpu): Implement this option.</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PolicyRule::AddNumberMatch</span><span class="hljs-params">(RuleType rule_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">int16_t</span> parameter,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">uint32_t</span> number,</span></span><br><span class="hljs-params"><span class="hljs-function">                                RuleOp comparison_op)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (done_) &#123;<br>    <span class="hljs-comment">// Do not allow to add more rules after generating the action opcode.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// rule_type映射成kPolNegateEval标记</span><br>  <span class="hljs-type">uint32_t</span> opts = (rule_type == IF_NOT) ? kPolNegateEval : kPolNone;<br><br>  <span class="hljs-comment">// comparison_op映射成整型match的类别，是相等还是逻辑与还是范围(这个还没实现)</span><br>  <span class="hljs-comment">// 然后调用工厂类的具体make接口做出PolicyOpcode</span><br>  <span class="hljs-keyword">if</span> (EQUAL == comparison_op) &#123;<br>    <span class="hljs-keyword">if</span> (!opcode_factory_-&gt;<span class="hljs-built_in">MakeOpNumberMatch</span>(parameter, number, opts))<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (AND == comparison_op) &#123;<br>    <span class="hljs-keyword">if</span> (!opcode_factory_-&gt;<span class="hljs-built_in">MakeOpNumberAndMatch</span>(parameter, number, opts))<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  ++buffer_-&gt;opcode_count;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">StringMatchOptions</span> &#123;<br>  CASE_SENSITIVE = <span class="hljs-number">0</span>,    <span class="hljs-comment">// Pay or Not attention to the case as defined by</span><br>  CASE_INSENSITIVE = <span class="hljs-number">1</span>,  <span class="hljs-comment">// RtlCompareUnicodeString windows API.</span><br>  EXACT_LENGTH = <span class="hljs-number">2</span>       <span class="hljs-comment">// Don&#x27;t do substring match. Do full string match.</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PolicyRule::AddStringMatch</span><span class="hljs-params">(RuleType rule_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">int16_t</span> parameter,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* string,</span></span><br><span class="hljs-params"><span class="hljs-function">                                StringMatchOptions match_opts)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (done_) &#123;<br>    <span class="hljs-comment">// Do not allow to add more rules after generating the action opcode.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* current_char = string;<br>  <span class="hljs-type">uint32_t</span> last_char = kLastCharIsNone;<br>  <span class="hljs-type">int</span> state = PENDING_NONE;<br>  <span class="hljs-type">int</span> skip_count = <span class="hljs-number">0</span>;       <span class="hljs-comment">// counts how many &#x27;?&#x27; we have seen in a row.</span><br>  base::string16 fragment;  <span class="hljs-comment">// accumulates the non-wildcard part.</span><br><br>  <span class="hljs-comment">// 这里是处理windows路径转义的操作，算法就不细说了，工厂类的Make封装在GenStringOpcode</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-string">L&#x27;\0&#x27;</span> != *current_char) &#123;<br>    <span class="hljs-keyword">switch</span> (*current_char) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">L&#x27;*&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (kLastCharIsWild &amp; last_char) &#123;<br>          <span class="hljs-comment">// &#x27;**&#x27; and &#x27;&amp;*&#x27; is an error.</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GenStringOpcode</span>(rule_type, match_opts, parameter, state, <span class="hljs-literal">false</span>,<br>                             &amp;skip_count, &amp;fragment)) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        last_char = kLastCharIsAsterisk;<br>        state = PENDING_ASTERISK;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">L&#x27;?&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (kLastCharIsAsterisk == last_char) &#123;<br>          <span class="hljs-comment">// &#x27;*?&#x27; is an error.</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GenStringOpcode</span>(rule_type, match_opts, parameter, state, <span class="hljs-literal">false</span>,<br>                             &amp;skip_count, &amp;fragment)) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        ++skip_count;<br>        last_char = kLastCharIsQuestionM;<br>        state = PENDING_QMARK;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">L&#x27;/&#x27;</span>:<br>        <span class="hljs-comment">// Note: &quot;/?&quot; is an escaped &#x27;?&#x27;. Eat the slash and fall through.</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">L&#x27;?&#x27;</span> == current_char[<span class="hljs-number">1</span>]) &#123;<br>          ++current_char;<br>        &#125;<br>        FALLTHROUGH;<br>      <span class="hljs-keyword">default</span>:<br>        fragment += *current_char;<br>        last_char = kLastCharIsAlpha;<br>    &#125;<br>    ++current_char;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GenStringOpcode</span>(rule_type, match_opts, parameter, state, <span class="hljs-literal">true</span>,<br>                       &amp;skip_count, &amp;fragment)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>内部的<code>GenStringOpcode</code>private函数才是调用工厂类Make接口的关键：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This function get called from a simple state machine implemented in</span><br><span class="hljs-comment">// AddStringMatch() which passes the current state (in state) and it passes</span><br><span class="hljs-comment">// true in last_call if AddStringMatch() has finished processing the input</span><br><span class="hljs-comment">// pattern string and this would be the last call to generate any pending</span><br><span class="hljs-comment">// opcode. The skip_count is the currently accumulated number of &#x27;?&#x27; seen so</span><br><span class="hljs-comment">// far and once the associated opcode is generated this function sets it back</span><br><span class="hljs-comment">// to zero.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PolicyRule::GenStringOpcode</span><span class="hljs-params">(RuleType rule_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 StringMatchOptions match_opts,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">uint16_t</span> parameter,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">int</span> state,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">bool</span> last_call,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">int</span>* skip_count,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 base::string16* fragment)</span> </span>&#123;<br>  <span class="hljs-comment">// The last opcode must:</span><br>  <span class="hljs-comment">//   1) Always clear the context.</span><br>  <span class="hljs-comment">//   2) Preserve the negation.</span><br>  <span class="hljs-comment">//   3) Remove the &#x27;OR&#x27; mode flag.</span><br>  <span class="hljs-comment">// 根据传入的参数，设置相应的标记</span><br>  <span class="hljs-type">uint32_t</span> options = kPolNone;<br>  <span class="hljs-keyword">if</span> (last_call) &#123;<br>    <span class="hljs-keyword">if</span> (IF_NOT == rule_type) &#123;<br>      options = kPolClearContext | kPolNegateEval;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      options = kPolClearContext;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (IF_NOT == rule_type) &#123;<br>    options = kPolUseOREval | kPolNegateEval;<br>  &#125;<br><br>  PolicyOpcode* op = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-comment">// The fragment string contains the accumulated characters to match with, it</span><br>  <span class="hljs-comment">// never contains wildcards (unless they have been escaped) and while there</span><br>  <span class="hljs-comment">// is no fragment there is no new string match opcode to generate.</span><br>  <span class="hljs-keyword">if</span> (fragment-&gt;<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-comment">// There is no new opcode to generate but in the last call we have to fix</span><br>    <span class="hljs-comment">// the previous opcode because it was really the last but we did not know</span><br>    <span class="hljs-comment">// it at that time.</span><br>    <span class="hljs-keyword">if</span> (last_call &amp;&amp; (buffer_-&gt;opcode_count &gt; <span class="hljs-number">0</span>)) &#123;<br>      op = &amp;buffer_-&gt;opcodes[buffer_-&gt;opcode_count - <span class="hljs-number">1</span>];<br>      op-&gt;<span class="hljs-built_in">SetOptions</span>(options);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 这里各找各妈，根据state状态传参调用Make</span><br>  <span class="hljs-keyword">if</span> (PENDING_ASTERISK == state) &#123;<br>    <span class="hljs-keyword">if</span> (last_call) &#123;<br>      op = opcode_factory_-&gt;<span class="hljs-built_in">MakeOpWStringMatch</span>(parameter, fragment-&gt;<span class="hljs-built_in">c_str</span>(),<br>                                               kSeekToEnd, match_opts, options);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      op = opcode_factory_-&gt;<span class="hljs-built_in">MakeOpWStringMatch</span>(<br>          parameter, fragment-&gt;<span class="hljs-built_in">c_str</span>(), kSeekForward, match_opts, options);<br>    &#125;<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (PENDING_QMARK == state) &#123;<br>    op = opcode_factory_-&gt;<span class="hljs-built_in">MakeOpWStringMatch</span>(parameter, fragment-&gt;<span class="hljs-built_in">c_str</span>(),<br>                                             *skip_count, match_opts, options);<br>    *skip_count = <span class="hljs-number">0</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (last_call) &#123;<br>      match_opts = <span class="hljs-built_in">static_cast</span>&lt;StringMatchOptions&gt;(EXACT_LENGTH | match_opts);<br>    &#125;<br>    op = opcode_factory_-&gt;<span class="hljs-built_in">MakeOpWStringMatch</span>(parameter, fragment-&gt;<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0</span>,<br>                                             match_opts, options);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!op)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  ++buffer_-&gt;opcode_count;<br>  fragment-&gt;<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="done-1"><code>Done</code></h3><p>这个函数就很简单了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PolicyRule::Done</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (done_) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!opcode_factory_-&gt;<span class="hljs-built_in">MakeOpAction</span>(action_, kPolNone))<span class="hljs-comment">// action是构造器中传入的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  ++buffer_-&gt;opcode_count;<br>  done_ = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一组<code>AddXXX</code>操作后跟一个<code>Done</code>表示一个opcodegroup设置完毕。</p><h3 id="rebindcopy"><code>RebindCopy</code></h3><p>此前在分析<code>LowLevelPolicy::Done</code>时，我们了解到将<code>PolicyRule</code>的buffer拷贝到<code>LowLevelPolicy</code>的<code>PolicyGlobal</code>的操作就是由它来完成的，其中还留下了一个疑问，即<code>data_size</code>的尺寸计算是否和<code>LowLevelPolicy::Done</code>最终的<code>current_buffer</code>挪移单位相吻合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PolicyRule::RebindCopy</span><span class="hljs-params">(PolicyOpcode* opcode_start,<span class="hljs-comment">// 用于存储PolicyOpcode的buffer起始</span></span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">size_t</span> opcode_size,<span class="hljs-comment">// 要存储多少个PolicyOpcode</span></span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">char</span>* data_start,<span class="hljs-comment">// 存储buffer的末尾</span></span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">size_t</span>* data_size)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-comment">// 这一组有多少个opcode</span><br>  <span class="hljs-type">size_t</span> count = buffer_-&gt;opcode_count;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> ix = <span class="hljs-number">0</span>; ix != count; ++ix) &#123;<br>    <span class="hljs-keyword">if</span> (opcode_size &lt; <span class="hljs-built_in">sizeof</span>(PolicyOpcode)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    PolicyOpcode&amp; opcode = buffer_-&gt;opcodes[ix];<br>    <span class="hljs-comment">// 这里又调用了PolicyOpcode的复制构造</span><br>    *opcode_start = opcode;<br>    <span class="hljs-keyword">if</span> (OP_WSTRING_MATCH == opcode.<span class="hljs-built_in">GetID</span>()) &#123;<br>      <span class="hljs-comment">// For this opcode argument 0 is a delta to the string and argument 1</span><br>      <span class="hljs-comment">// is the length (in chars) of the string.</span><br>      <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* str = opcode.<span class="hljs-built_in">GetRelativeString</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-type">size_t</span> str_len;<br>      opcode.<span class="hljs-built_in">GetArgument</span>(<span class="hljs-number">1</span>, &amp;str_len);<br>      str_len = str_len * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>);<br>      <span class="hljs-keyword">if</span> ((*data_size) &lt; str_len) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-comment">// data_size扣除了字符串的尺寸</span><br>      *data_size -= str_len;<br>      data_start -= str_len;<br>      <span class="hljs-comment">// 如果是字符串匹配的话，还要把字符串拷贝到GlobalPolicy的末尾</span><br>      <span class="hljs-built_in">memcpy</span>(data_start, str, str_len);<br>      <span class="hljs-comment">// Recompute the string displacement</span><br>      <span class="hljs-type">ptrdiff_t</span> delta = data_start - <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(opcode_start);<br>      <span class="hljs-comment">// arguments_[0]保存的始终是offset，这里要重新调整opcode_start的arguments_[0]</span><br>      opcode_start-&gt;<span class="hljs-built_in">SetArgument</span>(<span class="hljs-number">0</span>, delta);<br>    &#125;<br>    ++opcode_start;<br>    opcode_size -= <span class="hljs-built_in">sizeof</span>(PolicyOpcode);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再回到<code>LowLevelPolicy::Done</code>中，看看上下文：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">size_t</span> data_size = avail_size - opcodes_size;<br>PolicyOpcode* opcodes_start = &amp;current_buffer-&gt;opcodes[svc_opcode_count];<br><span class="hljs-keyword">if</span> (!rule-&gt;<span class="hljs-built_in">RebindCopy</span>(opcodes_start, opcodes_size, buffer_end,<br>                      &amp;data_size)) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// used表示的是多个PolicyOpcode和字符串共用的尺寸</span><br><span class="hljs-type">size_t</span> used = avail_size - data_size;<br><span class="hljs-comment">// 这里buffer_end向前调整了used，我觉着也有问题，应该只减去字符串占用的长度吧</span><br><span class="hljs-comment">// 如果减掉used尺寸这意味着浪费了大量的空间，而且avail_size的扣除就有问题了，这种处理实际上应该减去</span><br><span class="hljs-comment">// 2倍的opcodes_size</span><br>buffer_end -= used;<br>avail_size -= used;<br>svc_opcode_count += op_count;<br></code></pre></td></tr></table></figure><p>data_size只是在内部扣除了string的尺寸，所以和下面的计算也并不一致：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">current_buffer-&gt;opcode_count += svc_opcode_count;<br><span class="hljs-type">size_t</span> policy_byte_count =<br>  (svc_opcode_count * <span class="hljs-built_in">sizeof</span>(PolicyOpcode)) / <span class="hljs-built_in">sizeof</span>(current_buffer[<span class="hljs-number">0</span>]);<br>current_buffer = &amp;current_buffer[policy_byte_count + <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>另外，在<code>Done</code>中，内层循环执行一轮之后，<code>avail_size</code>理应再扣除<code>PolicyBuffer</code>的<code>opcode_count</code>大小，但在源码中却没有看到。</p><p>此后，就是之前阅读时，发现的最为奇怪的<code>PolicyBuffer</code>向后移动操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这一句是没有问题的</span><br>current_buffer-&gt;opcode_count += svc_opcode_count;<br><span class="hljs-comment">// 莫名其妙的计算，假设PolicyOpcode尺寸为S,count为N，那就是</span><br><span class="hljs-comment">// N*S/(S+4)，完全不知道他在算什么。结果估计是N-1，假设它是N-1，我们再看</span><br><span class="hljs-comment">// 此后调整current_buffer向后移动，指向了current_buffer[N]，向后移动了N个</span><br><span class="hljs-comment">// 如此调整，current_buffer和前面的数据之间势必有存在空隙，avail_size就更不对了</span><br><span class="hljs-comment">// 这写的什么东西啊。。。</span><br><span class="hljs-type">size_t</span> policy_byte_count =<br>  (svc_opcode_count * <span class="hljs-built_in">sizeof</span>(PolicyOpcode)) / <span class="hljs-built_in">sizeof</span>(current_buffer[<span class="hljs-number">0</span>]);<br>current_buffer = &amp;current_buffer[policy_byte_count + <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>感觉这个<code>Done</code>的处理问题很大，不知道是怎么过的审。后续需要调试来确定不是我分析有误，而是本来写的就有问题。</p>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-PolicyEngine-analysis</title>
    <link href="/2018/05/26/chromium-sandbox-PolicyEngine-analysis/"/>
    <url>/2018/05/26/chromium-sandbox-PolicyEngine-analysis/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第十二篇，主要分析了windows平台下，Chromiumsandbox中子系统三大组件构成中的第三大组件——low-levelpolicy的基础设施PolicyEngine。阅读本篇前，请先阅读前四篇。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-policyengine-analysis">chromium-sandbox-PolicyEngine-analysis</h1><p>子系统共有三大组件：负责IPC请求分发的Dispatcher、对敏感函数拦截的Interception+Resolver、low-level-policy。此前已经分析过前两个组件，本篇开始分析low-level-policy，来看看low-level-policy究竟是什么。</p><p>定位源代码时，发现low-level-policy这套机制是建立在policy_engine之上的，所以分析low-level-policy之前，首先要搞懂policy_engine的方方面面。</p><h2 id="opcodes">opcodes</h2><p>policy_engine由两部分组成：opcodes和processor。先研究一下opcodes。</p><p>何为opcodes？实际上头文件给出的功能描述已经相当详尽了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The low-level policy is implemented using the concept of policy &#x27;opcodes&#x27;.</span><br><span class="hljs-comment">// An opcode is a structure that contains enough information to perform one</span><br><span class="hljs-comment">// comparison against one single input parameter. For example, an opcode can</span><br><span class="hljs-comment">// encode just one of the following comparison:</span><br><span class="hljs-comment">// low-level policy是基于opcodes概念实现的</span><br><span class="hljs-comment">// opcode是一种包含了充分信息的结构用来与单一输入参数进行比较</span><br><span class="hljs-comment">// 下面给出了几个比较的范例：</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// - Is input parameter 3 not equal to nullptr?</span><br><span class="hljs-comment">// - Does input parameter 2 start with L&quot;c:\\&quot;?</span><br><span class="hljs-comment">// - Is input parameter 5, bit 3 is equal 1?</span><br><span class="hljs-comment">// 看起来opcode可以裁决某个输入参数的值是否是理想值</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// Each opcode is in fact equivalent to a function invocation where all</span><br><span class="hljs-comment">// the parameters are known by the opcode except one. So say you have a</span><br><span class="hljs-comment">// function of this form:</span><br><span class="hljs-comment">//      bool fn(a, b, c, d)  with 4 arguments</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Then an opcode is:</span><br><span class="hljs-comment">//      op(fn, b, c, d)</span><br><span class="hljs-comment">// Which stores the function to call and its 3 last arguments</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Then and opcode evaluation is:</span><br><span class="hljs-comment">//      op.eval(a)  ------------------------&gt; fn(a,b,c,d)</span><br><span class="hljs-comment">//                        internally calls</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The idea is that complex policy rules can be split into streams of</span><br><span class="hljs-comment">// opcodes which are evaluated in sequence. The evaluation is done in</span><br><span class="hljs-comment">// groups of opcodes that have N comparison opcodes plus 1 action opcode:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// [comparison 1][comparison 2]...[comparison N][action][comparison 1]...</span><br><span class="hljs-comment">//    ----- evaluation order-----------&gt;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Each opcode group encodes one high-level policy rule. The rule applies</span><br><span class="hljs-comment">// only if all the conditions on the group evaluate to true. The action</span><br><span class="hljs-comment">// opcode contains the policy outcome for that particular rule.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Note that this header contains the main building blocks of low-level policy</span><br><span class="hljs-comment">// but not the low level policy class.</span><br></code></pre></td></tr></table></figure><p>尽管描述详尽，但仅凭现有的信息和猜想，还无法理解如此复杂的设计，我们继续往下看。</p><p>头文件中定义了几个关键的结构体和常量，以及两个非常重要的类：<code>OpcodePolicy</code>和<code>OpcodeFactory</code>。</p><h3 id="structure-const">structure &amp; const</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// These are the possible policy outcomes. Note that some of them might</span><br><span class="hljs-comment">// not apply and can be removed. Also note that The following values only</span><br><span class="hljs-comment">// specify what to do, not how to do it and it is acceptable given specific</span><br><span class="hljs-comment">// cases to ignore the policy outcome.</span><br><span class="hljs-comment">// 仅仅表示应该怎样处理，但并未规范如何处理。对于特殊情景，可以不采纳输出的结果。</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">EvalResult</span> &#123;<br>  <span class="hljs-comment">// Comparison opcode values:</span><br>  <span class="hljs-comment">// 参考头注释的说明，group是以多个comparison+一个action组成</span><br>  <span class="hljs-comment">// 这三个result是comparison的结果</span><br>  EVAL_TRUE,   <span class="hljs-comment">// Opcode condition evaluated true.</span><br>  EVAL_FALSE,  <span class="hljs-comment">// Opcode condition evaluated false.</span><br>  EVAL_ERROR,  <span class="hljs-comment">// Opcode condition generated an error while evaluating.</span><br>  <span class="hljs-comment">// Action opcode values:</span><br>  <span class="hljs-comment">// 这些都是action的值，表示裁决的行动</span><br>  ASK_BROKER,   <span class="hljs-comment">// The target must generate an IPC to the broker. On the broker</span><br>                <span class="hljs-comment">// side, this means grant access to the resource.</span><br>  DENY_ACCESS,  <span class="hljs-comment">// No access granted to the resource.</span><br>  GIVE_READONLY,   <span class="hljs-comment">// Give readonly access to the resource.</span><br>  GIVE_ALLACCESS,  <span class="hljs-comment">// Give full access to the resource.</span><br>  GIVE_CACHED,     <span class="hljs-comment">// IPC is not required. Target can return a cached handle.</span><br>  GIVE_FIRST,      <span class="hljs-comment">// TODO(cpu)</span><br>  SIGNAL_ALARM,    <span class="hljs-comment">// Unusual activity. Generate an alarm.</span><br>  FAKE_SUCCESS,    <span class="hljs-comment">// Do not call original function. Just return &#x27;success&#x27;.</span><br>  FAKE_ACCESS_DENIED,  <span class="hljs-comment">// Do not call original function. Just return &#x27;denied&#x27;</span><br>                       <span class="hljs-comment">// and do not do IPC.</span><br>  TERMINATE_PROCESS,   <span class="hljs-comment">// Destroy target process. Do IPC as well.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>根据<code>EvalResult</code>的枚举值，能够猜想到comparison是一次比较，但comparison本身是怎样的结构，还不清楚。而action则是最终的审判。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The following are the implemented opcodes.</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">OpcodeID</span> &#123;<br>  <span class="hljs-comment">// 前6个都是具体的比较方式</span><br>  OP_ALWAYS_FALSE,        <span class="hljs-comment">// Evaluates to false (EVAL_FALSE).</span><br>  OP_ALWAYS_TRUE,         <span class="hljs-comment">// Evaluates to true (EVAL_TRUE).</span><br>  OP_NUMBER_MATCH,        <span class="hljs-comment">// Match a 32-bit integer as n == a.</span><br>  OP_NUMBER_MATCH_RANGE,  <span class="hljs-comment">// Match a 32-bit integer as a &lt;= n &lt;= b.</span><br>  OP_NUMBER_AND_MATCH,    <span class="hljs-comment">// Match using bitwise AND; as in: n &amp; a != 0.</span><br>  OP_WSTRING_MATCH,       <span class="hljs-comment">// Match a string for equality.</span><br>  <span class="hljs-comment">// 后1个应该是标志action所用</span><br>  OP_ACTION               <span class="hljs-comment">// Evaluates to an action opcode.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>comparison看起来会是一种具体的比较类别，各不相同，要么返回FALSE/TRUE，要么比较<code>int</code>、<code>string</code>值等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 下面的几个应该都是标志位，从某个角度来影响裁决结果或过程</span><br><span class="hljs-comment">// Options that apply to every opcode. They are specified when creating</span><br><span class="hljs-comment">// each opcode using OpcodeFactory::MakeOpXXXXX() family of functions</span><br><span class="hljs-comment">// Do nothing special.</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kPolNone = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// Convert EVAL_TRUE into EVAL_FALSE and vice-versa. This allows to express</span><br><span class="hljs-comment">// negated conditions such as if ( a &amp;&amp; !b).</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kPolNegateEval = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// Zero the MatchContext context structure. This happens after the opcode</span><br><span class="hljs-comment">// is evaluated.</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kPolClearContext = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// Use OR when evaluating this set of opcodes. The policy evaluator by default</span><br><span class="hljs-comment">// uses AND when evaluating. Very helpful when</span><br><span class="hljs-comment">// used with kPolNegateEval. For example if you have a condition best expressed</span><br><span class="hljs-comment">// as if(! (a &amp;&amp; b &amp;&amp; c)), the use of this flags allows it to be expressed as</span><br><span class="hljs-comment">// if ((!a) || (!b) || (!c)).</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kPolUseOREval = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>一个专门为连续字符串匹配定制的专属结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Keeps the evaluation state between opcode evaluations. This is used</span><br><span class="hljs-comment">// for string matching where the next opcode needs to continue matching</span><br><span class="hljs-comment">// from the last character position from the current opcode. The match</span><br><span class="hljs-comment">// context is preserved across opcode evaluation unless an opcode specifies</span><br><span class="hljs-comment">// as an option kPolClearContext.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MatchContext</span> &#123;<br>  <span class="hljs-type">size_t</span> position;<br>  <span class="hljs-type">uint32_t</span> options;<br><br>  <span class="hljs-built_in">MatchContext</span>() &#123; <span class="hljs-built_in">Clear</span>(); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clear</span><span class="hljs-params">()</span> </span>&#123;<br>    position = <span class="hljs-number">0</span>;<br>    options = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>看起来<code>kPolClearContext</code>这个标记和连续匹配字符串有关。</p><h3 id="policyopcode"><code>PolicyOpcode</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Models a policy opcode; that is a condition evaluation were all the</span><br><span class="hljs-comment">// arguments but one are stored in objects of this class. Use OpcodeFactory</span><br><span class="hljs-comment">// to create objects of this type.</span><br><span class="hljs-comment">// policy opcode是基于此运营的，除了第一个参数都存储在此对象中进行裁决。</span><br><span class="hljs-comment">// OpcodeFactory工厂类负责创建该类型对象。</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// This class is just an implementation artifact and not exposed to the</span><br><span class="hljs-comment">// API clients or visible in the intercepted service. Internally, an</span><br><span class="hljs-comment">// opcode is just:</span><br><span class="hljs-comment">//  - An integer that identifies the actual opcode.</span><br><span class="hljs-comment">//  - An index to indicate which one is the input argument</span><br><span class="hljs-comment">//  - An array of arguments.</span><br><span class="hljs-comment">// 该类仅仅是抽象体，不对外暴露（client/service）。</span><br><span class="hljs-comment">// 操作码的三个组成</span><br><span class="hljs-comment">// - opcode的id</span><br><span class="hljs-comment">// - 一个index索引表示哪个是输入参数</span><br><span class="hljs-comment">// - 一个参数数组</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// While an OO hierarchy of objects would have been a natural choice, the fact</span><br><span class="hljs-comment">// that 1) this code can execute before the CRT is loaded, presents serious</span><br><span class="hljs-comment">// problems in terms of guarantees about the actual state of the vtables and</span><br><span class="hljs-comment">// 2) because the opcode objects are generated in the broker process, we need to</span><br><span class="hljs-comment">// use plain objects. To preserve some minimal type safety templates are used</span><br><span class="hljs-comment">// when possible.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PolicyOpcode</span> &#123;<br>  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OpcodeFactory</span>;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Evaluates the opcode. For a typical comparison opcode the return value</span><br>  <span class="hljs-comment">// is EVAL_TRUE or EVAL_FALSE. If there was an error in the evaluation the</span><br>  <span class="hljs-comment">// the return is EVAL_ERROR. If the opcode is an action opcode then the</span><br>  <span class="hljs-comment">// return can take other values such as ASK_BROKER.</span><br>  <span class="hljs-comment">// 这个函数就是裁决的执行，根据opcode是comparison还是action，返回两类结果</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// parameters: An array of all input parameters. This argument is normally</span><br>  <span class="hljs-comment">// created by the macros POLPARAMS_BEGIN() POLPARAMS_END.</span><br>  <span class="hljs-comment">// count: The number of parameters passed as first argument.</span><br>  <span class="hljs-comment">// match: The match context that is persisted across the opcode evaluation</span><br>  <span class="hljs-comment">// sequence.</span><br>  <span class="hljs-comment">// 可以看到参数数组是个ParameterSet结构，这个结构在policy_engine_params.h中定义</span><br>  <span class="hljs-comment">// 一会儿展开看看。count表示参数个数，match是一个辅助结构，用于支持连续字符串匹配用的</span><br>  <span class="hljs-function">EvalResult <span class="hljs-title">Evaluate</span><span class="hljs-params">(<span class="hljs-type">const</span> ParameterSet* parameters,</span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">size_t</span> count,</span></span><br><span class="hljs-params"><span class="hljs-function">                      MatchContext* match)</span></span>;<br><br>  <span class="hljs-comment">// 一目了然的三个set/get方法</span><br>  <span class="hljs-comment">// Retrieves a stored argument by index. Valid index values are</span><br>  <span class="hljs-comment">// from 0 to &lt; kArgumentCount.</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetArgument</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index, T* argument)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(T) &lt;= <span class="hljs-built_in">sizeof</span>(arguments_[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;invalid size&quot;</span>);<br>    *argument = *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> T*&gt;(&amp;arguments_[index].mem);<br>  &#125;<br><br>  <span class="hljs-comment">// Sets a stored argument by index. Valid index values are</span><br>  <span class="hljs-comment">// from 0 to &lt; kArgumentCount.</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetArgument</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index, <span class="hljs-type">const</span> T&amp; argument)</span> </span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(T) &lt;= <span class="hljs-built_in">sizeof</span>(arguments_[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;invalid size&quot;</span>);<br>    *<span class="hljs-built_in">reinterpret_cast</span>&lt;T*&gt;(&amp;arguments_[index].mem) = argument;<br>  &#125;<br><br>  <span class="hljs-comment">// Retrieves the actual address of an string argument. When using</span><br>  <span class="hljs-comment">// GetArgument() to retrieve an index that contains a string, the returned</span><br>  <span class="hljs-comment">// value is just an offset to the actual string.</span><br>  <span class="hljs-comment">// index: the stored string index. Valid values are from 0</span><br>  <span class="hljs-comment">// to &lt; kArgumentCount.</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* <span class="hljs-title">GetRelativeString</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-type">ptrdiff_t</span> str_delta = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">GetArgument</span>(index, &amp;str_delta);<br>    <span class="hljs-comment">// 字符串的GetArgument返回的是一个offset</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* delta = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(<span class="hljs-keyword">this</span>) + str_delta;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt;(delta);<br>  &#125;<br><br>  <span class="hljs-comment">// OpcodeID相关</span><br>  <span class="hljs-comment">// Returns true if this opcode is an action opcode without actually</span><br>  <span class="hljs-comment">// evaluating it. Used to do a quick scan forward to the next opcode group.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsAction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> (OP_ACTION == opcode_id_); &#125;<br><br>  <span class="hljs-comment">// Returns the opcode type.</span><br>  <span class="hljs-function">OpcodeID <span class="hljs-title">GetID</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> opcode_id_; &#125;<br><br>  <span class="hljs-comment">// Returns the stored options such as kPolNegateEval and others.</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetOptions</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> options_; &#125;<br><br>  <span class="hljs-comment">// Sets the stored options such as kPolNegateEval.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetOptions</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> options)</span> </span>&#123;<br>    options_ = base::<span class="hljs-built_in">checked_cast</span>&lt;<span class="hljs-type">uint16_t</span>&gt;(options);<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kArgumentCount = <span class="hljs-number">4</span>;  <span class="hljs-comment">// The number of supported argument.</span><br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OpcodeArgument</span> &#123;<br>    UINT_PTR mem;<br>  &#125;;<br><br>  <span class="hljs-comment">// Better define placement new in the class instead of relying on the</span><br>  <span class="hljs-comment">// global definition which seems to be fubared.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>, <span class="hljs-type">void</span>* location)</span> </span>&#123; <span class="hljs-keyword">return</span> location; &#125;<br><br>  <span class="hljs-comment">// Helper function to evaluate the opcode. The parameters have the same</span><br>  <span class="hljs-comment">// meaning that in Evaluate().</span><br>  <span class="hljs-comment">// 这个应该是真正的裁决处理helper函数</span><br>  <span class="hljs-function">EvalResult <span class="hljs-title">EvaluateHelper</span><span class="hljs-params">(<span class="hljs-type">const</span> ParameterSet* parameters,</span></span><br><span class="hljs-params"><span class="hljs-function">                            MatchContext* match)</span></span>;<br>  OpcodeID opcode_id_;<br>  <span class="hljs-type">int16_t</span> parameter_;<br>  <span class="hljs-comment">// TODO(cpu): Making |options_| a uint32_t would avoid casting, but causes</span><br>  <span class="hljs-comment">// test failures.  Somewhere code is relying on the size of this struct.</span><br>  <span class="hljs-comment">// http://crbug.com/420296</span><br>  <span class="hljs-type">uint16_t</span> options_;<br>  OpcodeArgument arguments_[PolicyOpcode::kArgumentCount]; <span class="hljs-comment">// 其实就是4个指针，供参数get/set用</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>除了<code>Evaluate</code>以外，其他基本都在类头定义了。暂且不管<code>ParamterSet</code>参数，看看处理的逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Opcode evaluation dispatchers.</span><br><br><span class="hljs-comment">// This function is the one and only entry for evaluating any opcode. It is</span><br><span class="hljs-comment">// in charge of applying any relevant opcode options and calling EvaluateInner</span><br><span class="hljs-comment">// were the actual dispatch-by-id is made. It would seem at first glance that</span><br><span class="hljs-comment">// the dispatch should be done by virtual function (vtable) calls but you have</span><br><span class="hljs-comment">// to remember that the opcodes are made in the broker process and copied as</span><br><span class="hljs-comment">// raw memory to the target process.</span><br><br><span class="hljs-function">EvalResult <span class="hljs-title">PolicyOpcode::Evaluate</span><span class="hljs-params">(<span class="hljs-type">const</span> ParameterSet* call_params,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">size_t</span> param_count,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  MatchContext* match)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!call_params)<br>    <span class="hljs-keyword">return</span> EVAL_ERROR;<br>  <span class="hljs-type">const</span> ParameterSet* selected_param = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (parameter_ &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(parameter_) &gt;= param_count) &#123;<br>      <span class="hljs-keyword">return</span> EVAL_ERROR;<br>    &#125;<br>    <span class="hljs-comment">// 看来PolicyOpcode的parameter_成员是个索引，call_params是个ParameterSet数组</span><br>    <span class="hljs-comment">// selected_param借助parameter_的值找到本次想要处理的ParameterSet</span><br>    selected_param = &amp;call_params[parameter_];<br>  &#125;<br>  <span class="hljs-comment">// 这里干大事</span><br>  EvalResult result = <span class="hljs-built_in">EvaluateHelper</span>(selected_param, match);<br><br>  <span class="hljs-comment">// Apply the general options regardless of the particular type of opcode.</span><br>  <span class="hljs-comment">// 如果本PolicyOpcode的标记为kPolNone，直接返回结果，什么也不做</span><br>  <span class="hljs-keyword">if</span> (kPolNone == options_) &#123;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果本PolicyOpcode的标记了kPolNegateEval位，那么就要对结果取反（ERROR不管）</span><br>  <span class="hljs-keyword">if</span> (options_ &amp; kPolNegateEval) &#123;<br>    <span class="hljs-keyword">if</span> (EVAL_TRUE == result) &#123;<br>      result = EVAL_FALSE;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (EVAL_FALSE == result) &#123;<br>      result = EVAL_TRUE;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (EVAL_ERROR != result) &#123;<br>      result = EVAL_ERROR;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (match) &#123;<br>    <span class="hljs-comment">// 如果标记了kPolClearContext位，那么要对辅助结构MatchContext进行清理工作</span><br>    <span class="hljs-keyword">if</span> (options_ &amp; kPolClearContext)<br>      match-&gt;<span class="hljs-built_in">Clear</span>();<br>    <span class="hljs-comment">// 如果标记了kPolUseOREval，那么就对辅助结构MatchContext打上标记</span><br>    <span class="hljs-keyword">if</span> (options_ &amp; kPolUseOREval)<br>      match-&gt;options = kPolUseOREval;<span class="hljs-comment">//默认是用AND来裁决，该标记表示用OR</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OPCODE_EVAL(op, x, y, z) \</span><br><span class="hljs-meta">  case op:                       \</span><br><span class="hljs-meta">    return OpcodeEval<span class="hljs-string">&lt;op&gt;</span>(x, y, z)</span><br><br><span class="hljs-function">EvalResult <span class="hljs-title">PolicyOpcode::EvaluateHelper</span><span class="hljs-params">(<span class="hljs-type">const</span> ParameterSet* parameters,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        MatchContext* match)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (opcode_id_) &#123;<br>    <span class="hljs-built_in">OPCODE_EVAL</span>(OP_ALWAYS_FALSE, <span class="hljs-keyword">this</span>, parameters, match);<br>    <span class="hljs-built_in">OPCODE_EVAL</span>(OP_ALWAYS_TRUE, <span class="hljs-keyword">this</span>, parameters, match);<br>    <span class="hljs-built_in">OPCODE_EVAL</span>(OP_NUMBER_MATCH, <span class="hljs-keyword">this</span>, parameters, match);<br>    <span class="hljs-built_in">OPCODE_EVAL</span>(OP_NUMBER_MATCH_RANGE, <span class="hljs-keyword">this</span>, parameters, match);<br>    <span class="hljs-built_in">OPCODE_EVAL</span>(OP_NUMBER_AND_MATCH, <span class="hljs-keyword">this</span>, parameters, match);<br>    <span class="hljs-built_in">OPCODE_EVAL</span>(OP_WSTRING_MATCH, <span class="hljs-keyword">this</span>, parameters, match);<br>    <span class="hljs-built_in">OPCODE_EVAL</span>(OP_ACTION, <span class="hljs-keyword">this</span>, parameters, match);<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> EVAL_ERROR;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据<code>opcode_id_</code>分类，helper函数内部做了类别分发。这里<code>OpcodeEval</code>是个函数模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span>&gt;<br><span class="hljs-function">EvalResult <span class="hljs-title">OpcodeEval</span><span class="hljs-params">(PolicyOpcode* opcode,</span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">const</span> ParameterSet* pp,</span></span><br><span class="hljs-params"><span class="hljs-function">                      MatchContext* match)</span></span>;<br></code></pre></td></tr></table></figure><p>对应每种opcode_id_，都有一个具体的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;&gt;<br>EvalResult <span class="hljs-built_in">OpcodeEval</span>&lt;OP_ALWAYS_FALSE&gt;(PolicyOpcode* opcode,<br>                                       <span class="hljs-type">const</span> ParameterSet* param,<br>                                       MatchContext* context) &#123;<br>  <span class="hljs-keyword">return</span> EVAL_FALSE;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br>EvalResult <span class="hljs-built_in">OpcodeEval</span>&lt;OP_ALWAYS_TRUE&gt;(PolicyOpcode* opcode,<br>                                      <span class="hljs-type">const</span> ParameterSet* param,<br>                                      MatchContext* context) &#123;<br>  <span class="hljs-keyword">return</span> EVAL_TRUE;<br>&#125;<br><span class="hljs-comment">// 前两个没啥好说的，根本不用比，对于id为OP_ALWAYS_FALSE或OP_ALWAYS_TRUE的PolicyOpcode</span><br><span class="hljs-comment">// 直接返回值结果就行了</span><br><span class="hljs-comment">// opcode id为action的比较特别，它的值在argumetnts_[0].mem保存</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br>EvalResult <span class="hljs-built_in">OpcodeEval</span>&lt;OP_ACTION&gt;(PolicyOpcode* opcode,<br>                                 <span class="hljs-type">const</span> ParameterSet* param,<br>                                 MatchContext* context) &#123;<br>  <span class="hljs-type">int</span> action = <span class="hljs-number">0</span>;<br>  opcode-&gt;<span class="hljs-built_in">GetArgument</span>(<span class="hljs-number">0</span>, &amp;action);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;EvalResult&gt;(action);<br>&#125;<br><br><span class="hljs-comment">// uint32比较有两种情况，param可以是一个uint32值，也可以是一个指针</span><br><span class="hljs-comment">// 无论哪一种，都是把输入的值和该PolicyOpcode中的arguments_[0].mem进行比较</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br>EvalResult <span class="hljs-built_in">OpcodeEval</span>&lt;OP_NUMBER_MATCH&gt;(PolicyOpcode* opcode,<br>                                       <span class="hljs-type">const</span> ParameterSet* param,<br>                                       MatchContext* context) &#123;<br>  <span class="hljs-type">uint32_t</span> value_uint32 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (param-&gt;<span class="hljs-built_in">Get</span>(&amp;value_uint32)) &#123;<br>    <span class="hljs-type">uint32_t</span> match_uint32 = <span class="hljs-number">0</span>;<br>    opcode-&gt;<span class="hljs-built_in">GetArgument</span>(<span class="hljs-number">0</span>, &amp;match_uint32);<br>    <span class="hljs-keyword">return</span> (match_uint32 != value_uint32) ? EVAL_FALSE : EVAL_TRUE;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>* value_ptr = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (param-&gt;<span class="hljs-built_in">Get</span>(&amp;value_ptr)) &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-type">void</span>* match_ptr = <span class="hljs-literal">nullptr</span>;<br>      opcode-&gt;<span class="hljs-built_in">GetArgument</span>(<span class="hljs-number">0</span>, &amp;match_ptr);<br>      <span class="hljs-keyword">return</span> (match_ptr != value_ptr) ? EVAL_FALSE : EVAL_TRUE;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> EVAL_ERROR;<br>&#125;<br><br><span class="hljs-comment">// 和uint32类似，但此时该PolicyOpcode的arguments_中0成员是下限，1成员是上限值</span><br><span class="hljs-comment">// 此时的param中承载的是值，而不是指针</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br>EvalResult <span class="hljs-built_in">OpcodeEval</span>&lt;OP_NUMBER_MATCH_RANGE&gt;(PolicyOpcode* opcode,<br>                                             <span class="hljs-type">const</span> ParameterSet* param,<br>                                             MatchContext* context) &#123;<br>  <span class="hljs-type">uint32_t</span> value = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (!param-&gt;<span class="hljs-built_in">Get</span>(&amp;value))<br>    <span class="hljs-keyword">return</span> EVAL_ERROR;<br><br>  <span class="hljs-type">uint32_t</span> lower_bound = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">uint32_t</span> upper_bound = <span class="hljs-number">0</span>;<br>  opcode-&gt;<span class="hljs-built_in">GetArgument</span>(<span class="hljs-number">0</span>, &amp;lower_bound);<br>  opcode-&gt;<span class="hljs-built_in">GetArgument</span>(<span class="hljs-number">1</span>, &amp;upper_bound);<br>  <span class="hljs-keyword">return</span> ((lower_bound &lt;= value) &amp;&amp; (upper_bound &gt;= value)) ? EVAL_TRUE<br>                                                            : EVAL_FALSE;<br>&#125;<br><br><span class="hljs-comment">// 这个是按位与的结果，param中的也是值</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br>EvalResult <span class="hljs-built_in">OpcodeEval</span>&lt;OP_NUMBER_AND_MATCH&gt;(PolicyOpcode* opcode,<br>                                           <span class="hljs-type">const</span> ParameterSet* param,<br>                                           MatchContext* context) &#123;<br>  <span class="hljs-type">uint32_t</span> value = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (!param-&gt;<span class="hljs-built_in">Get</span>(&amp;value))<br>    <span class="hljs-keyword">return</span> EVAL_ERROR;<br><br>  <span class="hljs-type">uint32_t</span> number = <span class="hljs-number">0</span>;<br>  opcode-&gt;<span class="hljs-built_in">GetArgument</span>(<span class="hljs-number">0</span>, &amp;number);<br>  <span class="hljs-keyword">return</span> (number &amp; value) ? EVAL_TRUE : EVAL_FALSE;<br>&#125;<br><br><span class="hljs-comment">// 这个复杂些</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br>EvalResult <span class="hljs-built_in">OpcodeEval</span>&lt;OP_WSTRING_MATCH&gt;(PolicyOpcode* opcode,<br>                                        <span class="hljs-type">const</span> ParameterSet* param,<br>                                        MatchContext* context) &#123;<br>  <span class="hljs-comment">// 对于字符串的比较，需要用到传入的辅助结构MatchContext</span><br>  <span class="hljs-keyword">if</span> (!context) &#123;<br>    <span class="hljs-keyword">return</span> EVAL_ERROR;<br>  &#125;<br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* source_str = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (!param-&gt;<span class="hljs-built_in">Get</span>(&amp;source_str))<br>    <span class="hljs-keyword">return</span> EVAL_ERROR;<br><br>  <span class="hljs-type">int</span> start_position = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> match_len = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> match_opts = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// PolicyOpcode中的arguments_[1,2,3]成员分别是比较的长度、起始位置和比较时的选项</span><br>  opcode-&gt;<span class="hljs-built_in">GetArgument</span>(<span class="hljs-number">1</span>, &amp;match_len);<br>  opcode-&gt;<span class="hljs-built_in">GetArgument</span>(<span class="hljs-number">2</span>, &amp;start_position);<br>  opcode-&gt;<span class="hljs-built_in">GetArgument</span>(<span class="hljs-number">3</span>, &amp;match_opts);<br><br>  <span class="hljs-comment">// PolicyOpcode中的arguments_[0]是字符串的offset，通过GetRelativeString才能转成真实地址</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* match_str = opcode-&gt;<span class="hljs-built_in">GetRelativeString</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// Advance the source string to the last successfully evaluated position</span><br>  <span class="hljs-comment">// according to the match context.</span><br>  <span class="hljs-comment">// 如果是首次匹配字符串，context-&gt;position应该是0，如果是连续匹配source字符串，那就表示下一个串的位置</span><br>  source_str = &amp;source_str[context-&gt;position];<br>  <span class="hljs-comment">// 每个串都有终结符，计算出本次待比较的长度</span><br>  <span class="hljs-type">int</span> source_len = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(g_nt.<span class="hljs-built_in">wcslen</span>(source_str));<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == source_len) &#123;<br>    <span class="hljs-comment">// If we reached the end of the source string there is nothing we can</span><br>    <span class="hljs-comment">// match against.</span><br>    <span class="hljs-keyword">return</span> EVAL_FALSE;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (match_len &gt; source_len) &#123;<br>    <span class="hljs-comment">// There can&#x27;t be a positive match when the target string is bigger than</span><br>    <span class="hljs-comment">// the source string</span><br>    <span class="hljs-keyword">return</span> EVAL_FALSE;<br>  &#125;<br><br>  <span class="hljs-comment">// 看看match_opts里是否指明了大小写敏感</span><br>  BOOLEAN case_sensitive = (match_opts &amp; CASE_INSENSITIVE) ? TRUE : FALSE;<br><br>  <span class="hljs-comment">// We have three cases, depending on the value of start_pos:</span><br>  <span class="hljs-comment">// Case 1. We skip N characters and compare once.</span><br>  <span class="hljs-comment">// Case 2: We skip to the end and compare once.</span><br>  <span class="hljs-comment">// Case 3: We match the first substring (if we find any).</span><br>  <span class="hljs-comment">// 具体的子串匹配，基操勿6</span><br>  <span class="hljs-keyword">if</span> (start_position &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (kSeekToEnd == start_position) &#123;<br>      start_position = source_len - match_len;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match_opts &amp; EXACT_LENGTH) &#123;<br>      <span class="hljs-comment">// A sub-case of case 3 is when the EXACT_LENGTH flag is on</span><br>      <span class="hljs-comment">// the match needs to be not just substring but full match.</span><br>      <span class="hljs-keyword">if</span> ((match_len + start_position) != source_len) &#123;<br>        <span class="hljs-keyword">return</span> EVAL_FALSE;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Advance start_pos characters. Warning! this does not consider</span><br>    <span class="hljs-comment">// utf16 encodings (surrogate pairs) or other Unicode &#x27;features&#x27;.</span><br>    source_str += start_position;<br><br>    <span class="hljs-comment">// Since we skipped, lets reevaluate just the lengths again.</span><br>    <span class="hljs-keyword">if</span> ((match_len + start_position) &gt; source_len) &#123;<br>      <span class="hljs-keyword">return</span> EVAL_FALSE;<br>    &#125;<br><br>    UNICODE_STRING match_ustr;<br>    UNICODE_STRING source_ustr;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">InitStringUnicode</span>(match_str, match_len, &amp;match_ustr) ||<br>        !<span class="hljs-built_in">InitStringUnicode</span>(source_str, match_len, &amp;source_ustr))<br>      <span class="hljs-keyword">return</span> EVAL_ERROR;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == g_nt.<span class="hljs-built_in">RtlCompareUnicodeString</span>(&amp;match_ustr, &amp;source_ustr,<br>                                          case_sensitive)) &#123;<br>      <span class="hljs-comment">// Match! update the match context.</span><br>      <span class="hljs-comment">// 更新context的索引</span><br>      context-&gt;position += start_position + match_len;<br>      <span class="hljs-keyword">return</span> EVAL_TRUE;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> EVAL_FALSE;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start_position &lt; <span class="hljs-number">0</span>) &#123;<br>    UNICODE_STRING match_ustr;<br>    UNICODE_STRING source_ustr;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">InitStringUnicode</span>(match_str, match_len, &amp;match_ustr) ||<br>        !<span class="hljs-built_in">InitStringUnicode</span>(source_str, match_len, &amp;source_ustr))<br>      <span class="hljs-keyword">return</span> EVAL_ERROR;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == g_nt.<span class="hljs-built_in">RtlCompareUnicodeString</span>(&amp;match_ustr, &amp;source_ustr,<br>                                            case_sensitive)) &#123;<br>        <span class="hljs-comment">// Match! update the match context.</span><br>        <span class="hljs-comment">// 更新context的索引</span><br>        context-&gt;position += (source_ustr.Buffer - source_str) + match_len;<br>        <span class="hljs-keyword">return</span> EVAL_TRUE;<br>      &#125;<br>      ++source_ustr.Buffer;<br>      --source_len;<br>    &#125; <span class="hljs-keyword">while</span> (source_len &gt;= match_len);<br>  &#125;<br>  <span class="hljs-keyword">return</span> EVAL_FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><p>无论是哪种比较，本质上都是<code>param</code>和<code>opcode</code>中Argument的比较，而<code>opcode</code>是在<code>OpcodeFactory</code>中配置的。</p><p>另一方面也可以看出，<code>PolicyOpcode::Evaluate</code>一次仅仅是比较了参数集中的一个参数，它是一个下层的接口，整个参数集的裁决需要依赖使用者的正确性。</p><h3 id="opcodefactory"><code>OpcodeFactory</code></h3><p>研究一下它的工厂类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Opcodes that do string comparisons take a parameter that is the starting</span><br><span class="hljs-comment">// position to perform the comparison so we can do substring matching. There</span><br><span class="hljs-comment">// are two special values:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Start from the current position and compare strings advancing forward until</span><br><span class="hljs-comment">// a match is found if any. Similar to CRT strstr().</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kSeekForward = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// Perform a match with the end of the string. It only does a single comparison.</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kSeekToEnd = <span class="hljs-number">0xfffff</span>;<br><br><span class="hljs-comment">// A PolicyBuffer is a variable size structure that contains all the opcodes</span><br><span class="hljs-comment">// that are to be created or evaluated in sequence.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PolicyBuffer</span> &#123;<br>  <span class="hljs-type">size_t</span> opcode_count;<br>  PolicyOpcode opcodes[<span class="hljs-number">1</span>];<span class="hljs-comment">// 又见flexible</span><br>&#125;;<br><br><span class="hljs-comment">// Helper class to create any opcode sequence. This class is normally invoked</span><br><span class="hljs-comment">// only by the high level policy module or when you need to handcraft a special</span><br><span class="hljs-comment">// policy.</span><br><span class="hljs-comment">// The factory works by creating the opcodes using a chunk of memory given</span><br><span class="hljs-comment">// in the constructor. The opcodes themselves are allocated from the beginning</span><br><span class="hljs-comment">// (top) of the memory, while any string that an opcode needs is allocated from</span><br><span class="hljs-comment">// the end (bottom) of the memory.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// In essence:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   low address ---&gt; [opcode 1]</span><br><span class="hljs-comment">//                    [opcode 2]</span><br><span class="hljs-comment">//                    [opcode 3]</span><br><span class="hljs-comment">//                    |        | &lt;--- memory_top_</span><br><span class="hljs-comment">//                    | free   |</span><br><span class="hljs-comment">//                    |        |</span><br><span class="hljs-comment">//                    |        | &lt;--- memory_bottom_</span><br><span class="hljs-comment">//                    [string 1]</span><br><span class="hljs-comment">//   high address --&gt; [string 2]</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Note that this class does not keep track of the number of opcodes made and</span><br><span class="hljs-comment">// it is designed to be a building block for low-level policy.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Note that any of the MakeOpXXXXX member functions below can return nullptr on</span><br><span class="hljs-comment">// failure. When that happens opcode sequence creation must be aborted.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OpcodeFactory</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// memory: base pointer to a chunk of memory where the opcodes are created.</span><br>  <span class="hljs-comment">// memory_size: the size in bytes of the memory chunk.</span><br>  <span class="hljs-comment">// OpcodeFactory维护了一堆组织好的PolicyOpcode，所以需要一个buffer来存储</span><br>  <span class="hljs-comment">// 构造器先对buffer的顶和底进行初始化，memory_top_和memory_bottom_</span><br>  <span class="hljs-comment">// 根据头注释，这个buffer应该是双向增长的，共用中间的free空间</span><br>  <span class="hljs-built_in">OpcodeFactory</span>(<span class="hljs-type">char</span>* memory, <span class="hljs-type">size_t</span> memory_size) : <span class="hljs-built_in">memory_top_</span>(memory) &#123;<br>    memory_bottom_ = &amp;memory_top_[memory_size];<br>  &#125;<br><br>  <span class="hljs-comment">// policy: contains the raw memory where the opcodes are created.</span><br>  <span class="hljs-comment">// memory_size: contains the actual size of the policy argument.</span><br>  <span class="hljs-comment">// 传PolicyBuffer进来，与上面不同的地方在于，memory_top_一开始跳过了前4个opcode_count字节</span><br>  <span class="hljs-built_in">OpcodeFactory</span>(PolicyBuffer* policy, <span class="hljs-type">size_t</span> memory_size) &#123;<br>    memory_top_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(&amp;policy-&gt;opcodes[<span class="hljs-number">0</span>]);<br>    memory_bottom_ = &amp;memory_top_[memory_size];<br>  &#125;<br><br>  <span class="hljs-comment">// Returns the available memory to make opcodes.</span><br>  <span class="hljs-comment">// 看看free还有多大</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">memory_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-built_in">DCHECK_GE</span>(memory_bottom_, memory_top_);<br>    <span class="hljs-keyword">return</span> memory_bottom_ - memory_top_;<br>  &#125;<br><br>  <span class="hljs-comment">// 荷枪实弹</span><br>  <span class="hljs-comment">// Creates an OpAlwaysFalse opcode.</span><br>  <span class="hljs-function">PolicyOpcode* <span class="hljs-title">MakeOpAlwaysFalse</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> options)</span></span>;<br><br>  <span class="hljs-comment">// Creates an OpAlwaysFalse opcode.</span><br>  <span class="hljs-function">PolicyOpcode* <span class="hljs-title">MakeOpAlwaysTrue</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> options)</span></span>;<br><br>  <span class="hljs-comment">// Creates an OpAction opcode.</span><br>  <span class="hljs-comment">// action: The action to return when Evaluate() is called.</span><br>  <span class="hljs-function">PolicyOpcode* <span class="hljs-title">MakeOpAction</span><span class="hljs-params">(EvalResult action, <span class="hljs-type">uint32_t</span> options)</span></span>;<br><br>  <span class="hljs-comment">// Creates an OpNumberMatch opcode.</span><br>  <span class="hljs-comment">// selected_param: index of the input argument. It must be a uint32_t or the</span><br>  <span class="hljs-comment">// evaluation result will generate a EVAL_ERROR.</span><br>  <span class="hljs-comment">// match: the number to compare against the selected_param.</span><br>  <span class="hljs-function">PolicyOpcode* <span class="hljs-title">MakeOpNumberMatch</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> selected_param,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">uint32_t</span> match,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">uint32_t</span> options)</span></span>;<br><br>  <span class="hljs-comment">// Creates an OpNumberMatch opcode (void pointers are cast to numbers).</span><br>  <span class="hljs-comment">// selected_param: index of the input argument. It must be an void* or the</span><br>  <span class="hljs-comment">// evaluation result will generate a EVAL_ERROR.</span><br>  <span class="hljs-comment">// match: the pointer numeric value to compare against selected_param.</span><br>  <span class="hljs-function">PolicyOpcode* <span class="hljs-title">MakeOpVoidPtrMatch</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> selected_param,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">const</span> <span class="hljs-type">void</span>* match,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">uint32_t</span> options)</span></span>;<br><br>  <span class="hljs-comment">// Creates an OpNumberMatchRange opcode using the memory passed in the ctor.</span><br>  <span class="hljs-comment">// selected_param: index of the input argument. It must be a uint32_t or the</span><br>  <span class="hljs-comment">// evaluation result will generate a EVAL_ERROR.</span><br>  <span class="hljs-comment">// lower_bound, upper_bound: the range to compare against selected_param.</span><br>  <span class="hljs-function">PolicyOpcode* <span class="hljs-title">MakeOpNumberMatchRange</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> selected_param,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">uint32_t</span> lower_bound,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">uint32_t</span> upper_bound,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">uint32_t</span> options)</span></span>;<br><br>  <span class="hljs-comment">// Creates an OpWStringMatch opcode using the raw memory passed in the ctor.</span><br>  <span class="hljs-comment">// selected_param: index of the input argument. It must be a wide string</span><br>  <span class="hljs-comment">// pointer or the evaluation result will generate a EVAL_ERROR.</span><br>  <span class="hljs-comment">// match_str: string to compare against selected_param.</span><br>  <span class="hljs-comment">// start_position: when its value is from 0 to &lt; 0x7fff it indicates an</span><br>  <span class="hljs-comment">// offset from the selected_param string where to perform the comparison. If</span><br>  <span class="hljs-comment">// the value is SeekForward  then a substring search is performed. If the</span><br>  <span class="hljs-comment">// value is SeekToEnd the comparison is performed against the last part of</span><br>  <span class="hljs-comment">// the selected_param string.</span><br>  <span class="hljs-comment">// Note that the range in the position (0 to 0x7fff) is dictated by the</span><br>  <span class="hljs-comment">// current implementation.</span><br>  <span class="hljs-comment">// match_opts: Indicates additional matching flags. Currently CaseInsensitive</span><br>  <span class="hljs-comment">// is supported.</span><br>  <span class="hljs-function">PolicyOpcode* <span class="hljs-title">MakeOpWStringMatch</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> selected_param,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* match_str,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">int</span> start_position,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   StringMatchOptions match_opts,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">uint32_t</span> options)</span></span>;<br><br>  <span class="hljs-comment">// Creates an OpNumberAndMatch opcode using the raw memory passed in the ctor.</span><br>  <span class="hljs-comment">// selected_param: index of the input argument. It must be uint32_t or the</span><br>  <span class="hljs-comment">// evaluation result will generate a EVAL_ERROR.</span><br>  <span class="hljs-comment">// match: the value to bitwise AND against selected_param.</span><br>  <span class="hljs-function">PolicyOpcode* <span class="hljs-title">MakeOpNumberAndMatch</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> selected_param,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">uint32_t</span> match,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">uint32_t</span> options)</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Constructs the common part of every opcode. selected_param is the index</span><br>  <span class="hljs-comment">// of the input param to use when evaluating the opcode. Pass -1 in</span><br>  <span class="hljs-comment">// selected_param to indicate that no input parameter is required.</span><br>  <span class="hljs-function">PolicyOpcode* <span class="hljs-title">MakeBase</span><span class="hljs-params">(OpcodeID opcode_id,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">uint32_t</span> options,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">int16_t</span> selected_param)</span></span>;<br><br>  <span class="hljs-comment">// Allocates (and copies) a string (of size length) inside the buffer and</span><br>  <span class="hljs-comment">// returns the displacement with respect to start.</span><br>  <span class="hljs-function"><span class="hljs-type">ptrdiff_t</span> <span class="hljs-title">AllocRelative</span><span class="hljs-params">(<span class="hljs-type">void</span>* start, <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* str, <span class="hljs-type">size_t</span> length)</span></span>;<br><br>  <span class="hljs-comment">// Points to the lowest currently available address of the memory</span><br>  <span class="hljs-comment">// used to make the opcodes. This pointer increments as opcodes are made.</span><br>  <span class="hljs-type">char</span>* memory_top_;<br><br>  <span class="hljs-comment">// Points to the highest currently available address of the memory</span><br>  <span class="hljs-comment">// used to make the opcodes. This pointer decrements as opcode strings are</span><br>  <span class="hljs-comment">// allocated.</span><br>  <span class="hljs-type">char</span>* memory_bottom_;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(OpcodeFactory);<br>&#125;;<br></code></pre></td></tr></table></figure><p>荷枪实弹的几个实装方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Opcode OpAlwaysFalse:</span><br><span class="hljs-comment">// Does not require input parameter.</span><br><br><span class="hljs-function">PolicyOpcode* <span class="hljs-title">OpcodeFactory::MakeOpAlwaysFalse</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> options)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">MakeBase</span>(OP_ALWAYS_FALSE, options, <span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Opcode OpAlwaysTrue:</span><br><span class="hljs-comment">// Does not require input parameter.</span><br><br><span class="hljs-function">PolicyOpcode* <span class="hljs-title">OpcodeFactory::MakeOpAlwaysTrue</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> options)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">MakeBase</span>(OP_ALWAYS_TRUE, options, <span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Opcode OpAction:</span><br><span class="hljs-comment">// Does not require input parameter.</span><br><span class="hljs-comment">// Argument 0 contains the actual action to return.</span><br><br><span class="hljs-function">PolicyOpcode* <span class="hljs-title">OpcodeFactory::MakeOpAction</span><span class="hljs-params">(EvalResult action, <span class="hljs-type">uint32_t</span> options)</span> </span>&#123;<br>  PolicyOpcode* opcode = <span class="hljs-built_in">MakeBase</span>(OP_ACTION, options, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (!opcode)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// 这就与OpcodeEval&lt;OP_ACTION&gt;的处理对上了，action的确是放在arguments_[0]的</span><br>  opcode-&gt;<span class="hljs-built_in">SetArgument</span>(<span class="hljs-number">0</span>, action);<br>  <span class="hljs-keyword">return</span> opcode;<br>&#125;<br><br><span class="hljs-comment">// 剩下的这些也都和OpcodeEval&lt;xxx&gt;一一对上，就不多说了</span><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Opcode OpNumberMatch:</span><br><span class="hljs-comment">// Requires a uint32_t or void* in selected_param</span><br><span class="hljs-comment">// Argument 0 is the stored number to match.</span><br><span class="hljs-comment">// Argument 1 is the C++ type of the 0th argument.</span><br><br><span class="hljs-function">PolicyOpcode* <span class="hljs-title">OpcodeFactory::MakeOpNumberMatch</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> selected_param,</span></span><br><span class="hljs-params"><span class="hljs-function">                                               <span class="hljs-type">uint32_t</span> match,</span></span><br><span class="hljs-params"><span class="hljs-function">                                               <span class="hljs-type">uint32_t</span> options)</span> </span>&#123;<br>  PolicyOpcode* opcode = <span class="hljs-built_in">MakeBase</span>(OP_NUMBER_MATCH, options, selected_param);<br>  <span class="hljs-keyword">if</span> (!opcode)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  opcode-&gt;<span class="hljs-built_in">SetArgument</span>(<span class="hljs-number">0</span>, match);<br>  opcode-&gt;<span class="hljs-built_in">SetArgument</span>(<span class="hljs-number">1</span>, UINT32_TYPE);<br>  <span class="hljs-keyword">return</span> opcode;<br>&#125;<br><br><span class="hljs-function">PolicyOpcode* <span class="hljs-title">OpcodeFactory::MakeOpVoidPtrMatch</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> selected_param,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">const</span> <span class="hljs-type">void</span>* match,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">uint32_t</span> options)</span> </span>&#123;<br>  PolicyOpcode* opcode = <span class="hljs-built_in">MakeBase</span>(OP_NUMBER_MATCH, options, selected_param);<br>  <span class="hljs-keyword">if</span> (!opcode)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  opcode-&gt;<span class="hljs-built_in">SetArgument</span>(<span class="hljs-number">0</span>, match);<br>  opcode-&gt;<span class="hljs-built_in">SetArgument</span>(<span class="hljs-number">1</span>, VOIDPTR_TYPE);<br>  <span class="hljs-keyword">return</span> opcode;<br>&#125;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Opcode OpNumberMatchRange</span><br><span class="hljs-comment">// Requires a uint32_t in selected_param.</span><br><span class="hljs-comment">// Argument 0 is the stored lower bound to match.</span><br><span class="hljs-comment">// Argument 1 is the stored upper bound to match.</span><br><br><span class="hljs-function">PolicyOpcode* <span class="hljs-title">OpcodeFactory::MakeOpNumberMatchRange</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> selected_param,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                    <span class="hljs-type">uint32_t</span> lower_bound,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                    <span class="hljs-type">uint32_t</span> upper_bound,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                    <span class="hljs-type">uint32_t</span> options)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (lower_bound &gt; upper_bound) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  PolicyOpcode* opcode =<br>      <span class="hljs-built_in">MakeBase</span>(OP_NUMBER_MATCH_RANGE, options, selected_param);<br>  <span class="hljs-keyword">if</span> (!opcode)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  opcode-&gt;<span class="hljs-built_in">SetArgument</span>(<span class="hljs-number">0</span>, lower_bound);<br>  opcode-&gt;<span class="hljs-built_in">SetArgument</span>(<span class="hljs-number">1</span>, upper_bound);<br>  <span class="hljs-keyword">return</span> opcode;<br>&#125;<br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Opcode OpNumberAndMatch:</span><br><span class="hljs-comment">// Requires a uint32_t in selected_param.</span><br><span class="hljs-comment">// Argument 0 is the stored number to match.</span><br><br><span class="hljs-function">PolicyOpcode* <span class="hljs-title">OpcodeFactory::MakeOpNumberAndMatch</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> selected_param,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                  <span class="hljs-type">uint32_t</span> match,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                  <span class="hljs-type">uint32_t</span> options)</span> </span>&#123;<br>  PolicyOpcode* opcode = <span class="hljs-built_in">MakeBase</span>(OP_NUMBER_AND_MATCH, options, selected_param);<br>  <span class="hljs-keyword">if</span> (!opcode)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  opcode-&gt;<span class="hljs-built_in">SetArgument</span>(<span class="hljs-number">0</span>, match);<br>  <span class="hljs-keyword">return</span> opcode;<br>&#125;<br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Opcode OpWStringMatch:</span><br><span class="hljs-comment">// Requires a wchar_t* in selected_param.</span><br><span class="hljs-comment">// Argument 0 is the byte displacement of the stored string.</span><br><span class="hljs-comment">// Argument 1 is the length in chars of the stored string.</span><br><span class="hljs-comment">// Argument 2 is the offset to apply on the input string. It has special values.</span><br><span class="hljs-comment">// as noted in the header file.</span><br><span class="hljs-comment">// Argument 3 is the string matching options.</span><br><br><span class="hljs-function">PolicyOpcode* <span class="hljs-title">OpcodeFactory::MakeOpWStringMatch</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> selected_param,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* match_str,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">int</span> start_position,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                StringMatchOptions match_opts,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">uint32_t</span> options)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!match_str)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;\0&#x27;</span> == match_str[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-type">int</span> length = <span class="hljs-built_in">lstrlenW</span>(match_str);<br><br>  PolicyOpcode* opcode = <span class="hljs-built_in">MakeBase</span>(OP_WSTRING_MATCH, options, selected_param);<br>  <span class="hljs-keyword">if</span> (!opcode)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// 字符串分配在buffer尾部，从bottom向上抬</span><br>  <span class="hljs-type">ptrdiff_t</span> delta_str = <span class="hljs-built_in">AllocRelative</span>(opcode, match_str, <span class="hljs-built_in">wcslen</span>(match_str) + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == delta_str)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// 注意这个delta_str只是个偏移，所以OpcodeEval&lt;OP_WSTRING_MATCH&gt;时使用的是GetRelativeString</span><br>  <span class="hljs-comment">// 而不是GetArgument</span><br>  opcode-&gt;<span class="hljs-built_in">SetArgument</span>(<span class="hljs-number">0</span>, delta_str);<br>  opcode-&gt;<span class="hljs-built_in">SetArgument</span>(<span class="hljs-number">1</span>, length);<br>  opcode-&gt;<span class="hljs-built_in">SetArgument</span>(<span class="hljs-number">2</span>, start_position);<br>  opcode-&gt;<span class="hljs-built_in">SetArgument</span>(<span class="hljs-number">3</span>, match_opts);<br>  <span class="hljs-keyword">return</span> opcode;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个Make方法都是new了一个<code>PolicyOpcode</code>对象，把实装的信息填充到<code>PolicyOpcode</code>对象中。在new出一个<code>PolicyOpcode</code>对象时，都使用了一个相同的基准方法<code>MakeBase</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// OpcodeMaker (other member functions).</span><br><br><span class="hljs-function">PolicyOpcode* <span class="hljs-title">OpcodeFactory::MakeBase</span><span class="hljs-params">(OpcodeID opcode_id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">uint32_t</span> options,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">int16_t</span> selected_param)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memory_size</span>() &lt; <span class="hljs-built_in">sizeof</span>(PolicyOpcode))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-comment">// opcode从top开始向下占用buffer</span><br>  <span class="hljs-comment">// Create opcode using placement-new on the buffer memory.</span><br>  PolicyOpcode* opcode = <span class="hljs-built_in">new</span> (memory_top_) <span class="hljs-built_in">PolicyOpcode</span>();<br><br>  <span class="hljs-comment">// Fill in the standard fields, that every opcode has.</span><br>  memory_top_ += <span class="hljs-built_in">sizeof</span>(PolicyOpcode);<br>  opcode-&gt;opcode_id_ = opcode_id;<span class="hljs-comment">// 哪种opcode</span><br>  opcode-&gt;<span class="hljs-built_in">SetOptions</span>(options);<span class="hljs-comment">// 哪些标记</span><br>  <span class="hljs-comment">// 传入的selected_param表示用于和该PolicyOpcode比较的参数在ParameterSet中是第几个，也就是索引</span><br>  <span class="hljs-comment">// 看到这里也就明白了Evaluate中为什么直接读用parameter_做索引了，因为早在Make的时候已经设置好了</span><br>  opcode-&gt;parameter_ = selected_param;<br>  <span class="hljs-keyword">return</span> opcode;<br>&#125;<br></code></pre></td></tr></table></figure><p>字符串的匹配比较特殊，除了要保存一个<code>PolicyOpcode</code>对象以外，还要额外存储一个字符串pattern。这个字符串在尾端分配：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ptrdiff_t</span> <span class="hljs-title">OpcodeFactory::AllocRelative</span><span class="hljs-params">(<span class="hljs-type">void</span>* start,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* str,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">size_t</span> length)</span> </span>&#123;<br>  <span class="hljs-type">size_t</span> bytes = length * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memory_size</span>() &lt; bytes)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  memory_bottom_ -= bytes;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">reinterpret_cast</span>&lt;UINT_PTR&gt;(memory_bottom_) &amp; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// TODO(cpu) replace this for something better.</span><br>    ::<span class="hljs-built_in">DebugBreak</span>();<br>  &#125;<br>  <span class="hljs-built_in">memcpy</span>(memory_bottom_, str, bytes);<br>  <span class="hljs-type">ptrdiff_t</span> delta = memory_bottom_ - <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(start);<br>  <span class="hljs-keyword">return</span> delta;<br>&#125;<br></code></pre></td></tr></table></figure><p>工厂类的分析可以对接上<code>PolicyOpcode</code>本身的一些接口，到此我们也十分清楚工厂类的使用者在为某个函数设置policy时，会为每个参数调用一系列的Make函数，设置理想的裁决值。</p><p>但究竟是谁在用<code>OpcodeFactory</code>，又是如何操纵另一个重要的<code>ParameterSet</code>呢？现在还不得而知。猜想应该就是engine_processor。</p><h3 id="parameterset"><code>ParameterSet</code></h3><p>移步processor前，我们先分析被比较的<code>ParameterSet</code>都提供了哪些接口，至少我们已经不止一次的看到了它的Get。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Models the set of interesting parameters of an intercepted system call</span><br><span class="hljs-comment">// normally you don&#x27;t create objects of this class directly, instead you</span><br><span class="hljs-comment">// use the POLPARAMS_XXX macros.</span><br><span class="hljs-comment">// For example, if an intercepted function has the following signature:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// NTSTATUS NtOpenFileFunction (PHANDLE FileHandle,</span><br><span class="hljs-comment">//                              ACCESS_MASK DesiredAccess,</span><br><span class="hljs-comment">//                              POBJECT_ATTRIBUTES ObjectAttributes,</span><br><span class="hljs-comment">//                              PIO_STATUS_BLOCK IoStatusBlock,</span><br><span class="hljs-comment">//                              ULONG ShareAccess,</span><br><span class="hljs-comment">//                              ULONG OpenOptions);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// You could say that the following parameters are of interest to policy:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   POLPARAMS_BEGIN(open_params)</span><br><span class="hljs-comment">//      POLPARAM(DESIRED_ACCESS)</span><br><span class="hljs-comment">//      POLPARAM(OBJECT_NAME)</span><br><span class="hljs-comment">//      POLPARAM(SECURITY_DESCRIPTOR)</span><br><span class="hljs-comment">//      POLPARAM(IO_STATUS)</span><br><span class="hljs-comment">//      POLPARAM(OPEN_OPTIONS)</span><br><span class="hljs-comment">//   POLPARAMS_END;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// and the actual code will use this for defining the parameters:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   CountedParameterSet&lt;open_params&gt; p;</span><br><span class="hljs-comment">//   p[open_params::DESIRED_ACCESS] = ParamPickerMake(DesiredAccess);</span><br><span class="hljs-comment">//   p[open_params::OBJECT_NAME] =</span><br><span class="hljs-comment">//       ParamPickerMake(ObjectAttributes-&gt;ObjectName);</span><br><span class="hljs-comment">//   p[open_params::SECURITY_DESCRIPTOR] =</span><br><span class="hljs-comment">//       ParamPickerMake(ObjectAttributes-&gt;SecurityDescriptor);</span><br><span class="hljs-comment">//   p[open_params::IO_STATUS] = ParamPickerMake(IoStatusBlock);</span><br><span class="hljs-comment">//   p[open_params::OPEN_OPTIONS] = ParamPickerMake(OpenOptions);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  These will create an stack-allocated array of ParameterSet objects which</span><br><span class="hljs-comment">//  have each 1) the address of the parameter 2) a numeric id that encodes the</span><br><span class="hljs-comment">//  original C++ type. This allows the policy to treat any set of supported</span><br><span class="hljs-comment">//  argument types uniformily and with some type safety.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  TODO(cpu): support not fully implemented yet for unicode string and will</span><br><span class="hljs-comment">//  probably add other types as well.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterSet</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ParameterSet</span>() : <span class="hljs-built_in">real_type_</span>(INVALID_TYPE), <span class="hljs-built_in">address_</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>  <span class="hljs-comment">// real_type的3种类型对应的重载Get方法，real_type_来判定</span><br>  <span class="hljs-comment">// Retrieve the stored parameter. If the type does not match ulong fail.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Get</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span>* destination)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (real_type_ != UINT32_TYPE) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *destination = <span class="hljs-built_in">Void2TypePointerCopy</span>&lt;<span class="hljs-type">uint32_t</span>&gt;();<span class="hljs-comment">//返回的实际上是address_成员的地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Retrieve the stored parameter. If the type does not match void* fail.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Get</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>** destination)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (real_type_ != VOIDPTR_TYPE) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *destination = <span class="hljs-built_in">Void2TypePointerCopy</span>&lt;<span class="hljs-type">void</span>*&gt;();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Retrieve the stored parameter. If the type does not match wchar_t* fail.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Get</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>** destination)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (real_type_ != WCHAR_TYPE) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *destination = <span class="hljs-built_in">Void2TypePointerCopy</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt;();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// False if the parameter is not properly initialized.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsValid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> real_type_ != INVALID_TYPE; &#125;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// The constructor can only be called by derived types, which should</span><br>  <span class="hljs-comment">// safely provide the real_type and the address of the argument.</span><br>  <span class="hljs-comment">// 所以他才是关键，真正有用的构造函数，以address赋给address_，实际上参数的buffer</span><br>  <span class="hljs-comment">// 可以看出由外部维护，ParameterSet只是架在上面的操纵者罢了</span><br>  <span class="hljs-comment">// protected权限又表示外部使用该对象时，必须得间接用派生对象</span><br>  <span class="hljs-built_in">ParameterSet</span>(ArgType real_type, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* address)<br>      : <span class="hljs-built_in">real_type_</span>(real_type), <span class="hljs-built_in">address_</span>(address) &#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// This template provides the same functionality as bits_cast but</span><br>  <span class="hljs-comment">// it works with pointer while the former works only with references.</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-function">T <span class="hljs-title">Void2TypePointerCopy</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> T*&gt;(address_));<span class="hljs-comment">//类型转换模板</span><br>  &#125;<br><br>  ArgType real_type_;<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* address_;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="parametersetex"><code>ParameterSetEx</code></h3><p>protected权限的构造器也就表明了派生类的存在意义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// To safely infer the type, we use a set of template specializations</span><br><span class="hljs-comment">// in ParameterSetEx with a template function ParamPickerMake to do the</span><br><span class="hljs-comment">// parameter type deduction.</span><br><br><span class="hljs-comment">// Base template class. Not implemented so using unsupported types should</span><br><span class="hljs-comment">// fail to compile.</span><br><span class="hljs-comment">// 使用ParameterSetEx类模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterSetEx</span> : <span class="hljs-keyword">public</span> ParameterSet &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ParameterSetEx</span>(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* address);<br>&#125;;<br><br><span class="hljs-comment">// 一串不同typename对应的实现体</span><br><span class="hljs-comment">// 实际上差别仅在于设置不同的ArgType</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterSetEx</span>&lt;<span class="hljs-type">void</span> <span class="hljs-type">const</span>*&gt; : <span class="hljs-keyword">public</span> ParameterSet &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ParameterSetEx</span>(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* address) : <span class="hljs-built_in">ParameterSet</span>(VOIDPTR_TYPE, address) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterSetEx</span>&lt;<span class="hljs-type">void</span>*&gt; : <span class="hljs-keyword">public</span> ParameterSet &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ParameterSetEx</span>(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* address) : <span class="hljs-built_in">ParameterSet</span>(VOIDPTR_TYPE, address) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterSetEx</span>&lt;<span class="hljs-type">wchar_t</span>*&gt; : <span class="hljs-keyword">public</span> ParameterSet &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ParameterSetEx</span>(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* address) : <span class="hljs-built_in">ParameterSet</span>(WCHAR_TYPE, address) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterSetEx</span>&lt;<span class="hljs-type">wchar_t</span> <span class="hljs-type">const</span>*&gt; : <span class="hljs-keyword">public</span> ParameterSet &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ParameterSetEx</span>(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* address) : <span class="hljs-built_in">ParameterSet</span>(WCHAR_TYPE, address) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterSetEx</span>&lt;<span class="hljs-type">uint32_t</span>&gt; : <span class="hljs-keyword">public</span> ParameterSet &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ParameterSetEx</span>(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* address) : <span class="hljs-built_in">ParameterSet</span>(UINT32_TYPE, address) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterSetEx</span>&lt;UNICODE_STRING&gt; : <span class="hljs-keyword">public</span> ParameterSet &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ParameterSetEx</span>(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* address) : <span class="hljs-built_in">ParameterSet</span>(UNISTR_TYPE, address) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>根据父类的<code>ArgType</code>型参数，派生类的每个实现体指明了具体的类型，此时<code>real_type_</code>就有效了。</p><p>当然，<code>ParameterSetEx</code>实现体太多了，为了使用方便，又定义了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">ParameterSet <span class="hljs-title">ParamPickerMake</span><span class="hljs-params">(T&amp; parameter)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ParameterSetEx</span>&lt;T&gt;(&amp;parameter);<br>&#125;;<br></code></pre></td></tr></table></figure><p>非常简单的一个转换适配器函数模板，各找各妈。</p><h3 id="countedparameterset"><code>CountedParameterSet</code></h3><p>一个<code>ParameterSet</code>的集合，每一种interception对应一个这样的policyparameters串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This template defines the actual list of policy parameters for a given</span><br><span class="hljs-comment">// interception.</span><br><span class="hljs-comment">// Warning: This template stores the address to the actual variables, in</span><br><span class="hljs-comment">// other words, the values are not copied.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CountedParameterSet</span> &#123;<br>  <span class="hljs-built_in">CountedParameterSet</span>() : <span class="hljs-built_in">count</span>(T::PolParamLast) &#123;&#125;<br><br>  <span class="hljs-comment">// 重载了[]操作符，对此操作时就可以直接返回选择的ParameterSet对象</span><br>  ParameterSet&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">typename</span> T::Args n) &#123; <span class="hljs-keyword">return</span> parameters[n]; &#125;<br><br>  <span class="hljs-comment">// 其实就是count的起始地址</span><br>  <span class="hljs-function">CountedParameterSetBase* <span class="hljs-title">GetBase</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;CountedParameterSetBase*&gt;(<span class="hljs-keyword">this</span>);<br>  &#125;<br><br>  <span class="hljs-type">size_t</span> count;<br>  ParameterSet parameters[T::PolParamLast];<span class="hljs-comment">//这个T::PolParamLast源于T</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>ParameterSet</code>相关的定义能够暗示一些操纵者的用法，但还不够明朗。我们接下来就研究一下processor这个操纵者是如何驾驭<code>ParameterSet</code>和<code>OpcodeFactory</code>的。</p><h2 id="processor">processor</h2><p>文件头的描述已经相当详细了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This header contains the core policy evaluator. In its simplest form</span><br><span class="hljs-comment">// it evaluates a stream of opcodes assuming that they are laid out in</span><br><span class="hljs-comment">// memory as opcode groups.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// An opcode group has N comparison opcodes plus 1 action opcode. For</span><br><span class="hljs-comment">// example here we have 3 opcode groups (A, B,C):</span><br><span class="hljs-comment">// 一个opcode组由N个comparison opcodes加上一个action opcode组成</span><br><span class="hljs-comment">// 这里是个3组的示范：</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// [comparison 1]  &lt;-- group A start</span><br><span class="hljs-comment">// [comparison 2]</span><br><span class="hljs-comment">// [comparison 3]</span><br><span class="hljs-comment">// [action A    ]</span><br><span class="hljs-comment">// [comparison 1]  &lt;-- group B start</span><br><span class="hljs-comment">// [action B    ]</span><br><span class="hljs-comment">// [comparison 1]  &lt;-- group C start</span><br><span class="hljs-comment">// [comparison 2]</span><br><span class="hljs-comment">// [action C    ]</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The opcode evaluator proceeds from the top, evaluating each opcode in</span><br><span class="hljs-comment">// sequence. An opcode group is evaluated until the first comparison that</span><br><span class="hljs-comment">// returns false. At that point the rest of the group is skipped and evaluation</span><br><span class="hljs-comment">// resumes with the first comparison of the next group. When all the comparisons</span><br><span class="hljs-comment">// in a group have evaluated to true and the action is reached. The group is</span><br><span class="hljs-comment">// considered a matching group.</span><br><span class="hljs-comment">// 裁决从top开始，逐个opcode进行evaluate。</span><br><span class="hljs-comment">// 一组opcode设定的条件只有全部满足时，才继续下一组的匹配，否则就不必继续审判了</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// In the &#x27;ShortEval&#x27; mode evaluation stops when it reaches the end or the first</span><br><span class="hljs-comment">// matching group. The action opcode from this group is the resulting policy</span><br><span class="hljs-comment">// action.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// In the &#x27;RankedEval&#x27; mode evaluation stops only when it reaches the end of the</span><br><span class="hljs-comment">// the opcode stream. In the process all matching groups are saved and at the</span><br><span class="hljs-comment">// end the &#x27;best&#x27; group is selected (what makes the best is TBD) and the action</span><br><span class="hljs-comment">// from this group is the resulting policy action.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// As explained above, the policy evaluation of a group is a logical AND of</span><br><span class="hljs-comment">// the evaluation of each opcode. However an opcode can request kPolUseOREval</span><br><span class="hljs-comment">// which makes the evaluation to use logical OR. Given that each opcode can</span><br><span class="hljs-comment">// request its evaluation result to be negated with kPolNegateEval you can</span><br><span class="hljs-comment">// achieve the negation of the total group evaluation. This means that if you</span><br><span class="hljs-comment">// need to express:</span><br><span class="hljs-comment">// 对一组opcode的裁决，默认每个comparsion都是AND操作，可以通过kPolUseOREval来置成</span><br><span class="hljs-comment">// OR操作</span><br><span class="hljs-comment">//             if (!(c1 &amp;&amp; c2 &amp;&amp; c3))</span><br><span class="hljs-comment">// You can do it by:</span><br><span class="hljs-comment">//             if ((!c1) || (!c2) || (!c3))</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-comment">// Possible outcomes of policy evaluation.</span><br></code></pre></td></tr></table></figure><p>一些常量、枚举：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Possible outcomes of policy evaluation.</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PolicyResult</span> &#123; NO_POLICY_MATCH, POLICY_MATCH, POLICY_ERROR &#125;;<br><br><span class="hljs-comment">// Policy evaluation flags</span><br><span class="hljs-comment">// TODO(cpu): implement the options kStopOnErrors &amp; kRankedEval.</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// Stop evaluating as soon as an error is encountered.</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kStopOnErrors = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// Ignore all non fatal opcode evaluation errors.</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kIgnoreErrors = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// Short-circuit evaluation: Only evaluate until opcode group that</span><br><span class="hljs-comment">// evaluated to true has been found.</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kShortEval = <span class="hljs-number">4</span>;<br><span class="hljs-comment">// Discussed briefly at the policy design meeting. It will evaluate</span><br><span class="hljs-comment">// all rules and then return the &#x27;best&#x27; rule that evaluated true.</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kRankedEval = <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><h3 id="policyprocessor"><code>PolicyProcessor</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This class evaluates a policy-opcode stream given the memory where the</span><br><span class="hljs-comment">// opcodes are and an input &#x27;parameter set&#x27;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This class is designed to be callable from interception points</span><br><span class="hljs-comment">// as low as the NtXXXX service level (it is not currently safe, but</span><br><span class="hljs-comment">// it is designed to be made safe).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Its usage in an interception is:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   POLPARAMS_BEGIN(eval_params)</span><br><span class="hljs-comment">//     POLPARAM(param1)</span><br><span class="hljs-comment">//     POLPARAM(param2)</span><br><span class="hljs-comment">//     POLPARAM(param3)</span><br><span class="hljs-comment">//     POLPARAM(param4)</span><br><span class="hljs-comment">//     POLPARAM(param5)</span><br><span class="hljs-comment">//   POLPARAMS_END;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   PolicyProcessor pol_evaluator(policy_memory);</span><br><span class="hljs-comment">//   PolicyResult pr = pol_evaluator.Evaluate(ShortEval, eval_params,</span><br><span class="hljs-comment">//                                            _countof(eval_params));</span><br><span class="hljs-comment">//   if (NO_POLICY_MATCH == pr) &#123;</span><br><span class="hljs-comment">//     EvalResult policy_action =  pol_evaluator.GetAction();</span><br><span class="hljs-comment">//     // apply policy here...</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Where the POLPARAM() arguments are derived from the intercepted function</span><br><span class="hljs-comment">// arguments, and represent all the &#x27;interesting&#x27; policy inputs, and</span><br><span class="hljs-comment">// policy_memory is a memory buffer containing the opcode stream that is the</span><br><span class="hljs-comment">// relevant policy for this intercept.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PolicyProcessor</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// policy_buffer contains opcodes made with OpcodeFactory. They are usually</span><br>  <span class="hljs-comment">// created in the broker process and evaluated in the target process.</span><br><br>  <span class="hljs-comment">// This constructor is just a variant of the previous constructor.</span><br>  <span class="hljs-comment">// 该构造器把PolicyBuffer传入，存储PolicyOpcode的容器与操纵者关联</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">PolicyProcessor</span><span class="hljs-params">(PolicyBuffer* policy)</span> : policy_(policy) &#123;</span><br>    <span class="hljs-built_in">SetInternalState</span>(<span class="hljs-number">0</span>, EVAL_FALSE);<br>  &#125;<br><br>  <span class="hljs-comment">// Evaluates a policy-opcode stream. See the comments at the top of this</span><br>  <span class="hljs-comment">// class for more info. Returns POLICY_MATCH if a rule set was found that</span><br>  <span class="hljs-comment">// matches an active policy.</span><br>  <span class="hljs-comment">// 这个就是某个函数所有参数的Evaluate，传递了ParameterSet和count进去，其内部理应对每个参数进行</span><br>  <span class="hljs-comment">// PolicyOpcode::Evaluate</span><br>  <span class="hljs-function">PolicyResult <span class="hljs-title">Evaluate</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> options,</span></span><br><span class="hljs-params"><span class="hljs-function">                        ParameterSet* parameters,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">size_t</span> parameter_count)</span></span>;<br><br>  <span class="hljs-comment">// If the result of Evaluate() was POLICY_MATCH, calling this function returns</span><br>  <span class="hljs-comment">// the recommended policy action.</span><br>  <span class="hljs-function">EvalResult <span class="hljs-title">GetAction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">size_t</span> current_index_;<br>    EvalResult current_result_;<br>  &#125; state_;<br><br>  <span class="hljs-comment">// Sets the currently matching action result.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetInternalState</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index, EvalResult result)</span></span>;<br><br>  PolicyBuffer* policy_;<br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(PolicyProcessor);<br>&#125;;<br></code></pre></td></tr></table></figure><p>关键的Evaluate，处理函数的parameters。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">PolicyResult <span class="hljs-title">PolicyProcessor::Evaluate</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> options,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       ParameterSet* parameters,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">size_t</span> param_count)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!policy_)<br>    <span class="hljs-keyword">return</span> NO_POLICY_MATCH;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == policy_-&gt;opcode_count)<br>    <span class="hljs-keyword">return</span> NO_POLICY_MATCH;<br>  <span class="hljs-comment">// 至少得置位kShortEval</span><br>  <span class="hljs-keyword">if</span> (!(kShortEval &amp; options))<br>    <span class="hljs-keyword">return</span> POLICY_ERROR;<br><br>  MatchContext context;<br>  <span class="hljs-type">bool</span> evaluation = <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">bool</span> skip_group = <span class="hljs-literal">false</span>;<br>  <span class="hljs-built_in">SetInternalState</span>(<span class="hljs-number">0</span>, EVAL_FALSE);<br>  <span class="hljs-type">size_t</span> count = policy_-&gt;opcode_count;<br>  <span class="hljs-comment">// 共有count个opcode待处理，它们由comparsion和action组成</span><br>  <span class="hljs-comment">// action作为组的定界</span><br>  <br>  <span class="hljs-comment">// Loop over all the opcodes Evaluating in sequence. Since we only support</span><br>  <span class="hljs-comment">// short circuit evaluation, we stop as soon as we find an &#x27;action&#x27; opcode</span><br>  <span class="hljs-comment">// and the current evaluation is true.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Skipping opcodes can happen when we are in AND mode (!kPolUseOREval) and</span><br>  <span class="hljs-comment">// have got EVAL_FALSE or when we are in OR mode (kPolUseOREval) and got</span><br>  <span class="hljs-comment">// EVAL_TRUE. Skipping will stop at the next action opcode or at the opcode</span><br>  <span class="hljs-comment">// after the action depending on kPolUseOREval.</span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> ix = <span class="hljs-number">0</span>; ix != count; ++ix) &#123;<br>    PolicyOpcode&amp; opcode = policy_-&gt;opcodes[ix];<br>    <span class="hljs-comment">// Skipping block.</span><br>    <span class="hljs-keyword">if</span> (skip_group) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SkipOpcode</span>(opcode, &amp;context, &amp;skip_group))<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">// Evaluation block.</span><br>    <span class="hljs-comment">// 这里使用具体的PolicyOpcode::Evaluate来对parameters中某个参数进行匹配</span><br>    EvalResult result = opcode.<span class="hljs-built_in">Evaluate</span>(parameters, param_count, &amp;context);<br>    <span class="hljs-keyword">switch</span> (result) &#123;<br>      <span class="hljs-keyword">case</span> EVAL_FALSE:<br>        evaluation = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果某一个参数匹配失败了，那么看看是否设置了OR型匹配，如果没设置，就跳过本组</span><br>        <span class="hljs-comment">// 因为本组已经失败了，说明传递进来的参数不匹配本组</span><br>        <span class="hljs-keyword">if</span> (kPolUseOREval != context.options)<br>          skip_group = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> EVAL_ERROR:<br>        <span class="hljs-keyword">if</span> (kStopOnErrors &amp; options)<br>          <span class="hljs-keyword">return</span> POLICY_ERROR;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> EVAL_TRUE:<br>        evaluation = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 如果某个匹配成功了，且设置了OR型匹配，那么本组就不必继续了，因为已经成功了</span><br>        <span class="hljs-comment">// 这说明本组也不是想要找的参数匹配组</span><br>        <span class="hljs-keyword">if</span> (kPolUseOREval == context.options)<br>          skip_group = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// We have evaluated an action.</span><br>        <span class="hljs-comment">// action opcode返回类型是action而非comparison，这说明本组匹配成功</span><br>    <span class="hljs-comment">// 这时要对第ix组进行结果的设置，然后返回</span><br>        <span class="hljs-built_in">SetInternalState</span>(ix, result);<br>        <span class="hljs-keyword">return</span> POLICY_MATCH;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (evaluation) &#123;<br>    <span class="hljs-comment">// Reaching the end of the policy with a positive evaluation is probably</span><br>    <span class="hljs-comment">// an error: we did not find a final action opcode?</span><br>    <span class="hljs-keyword">return</span> POLICY_ERROR;<br>  &#125;<br>  <span class="hljs-keyword">return</span> NO_POLICY_MATCH;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SkipOpcode</code>非常简单，闭着眼睛都知道怎么处理的，当然是根据定界的action来移动：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Decides if an opcode can be skipped (not evaluated) or not. The function</span><br><span class="hljs-comment">// takes as inputs the opcode and the current evaluation context and returns</span><br><span class="hljs-comment">// true if the opcode should be skipped or not and also can set keep_skipping</span><br><span class="hljs-comment">// to false to signal that the current instruction should be skipped but not</span><br><span class="hljs-comment">// the next after the current one.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SkipOpcode</span><span class="hljs-params">(<span class="hljs-type">const</span> PolicyOpcode&amp; opcode,</span></span><br><span class="hljs-params"><span class="hljs-function">                MatchContext* context,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">bool</span>* keep_skipping)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (opcode.<span class="hljs-built_in">IsAction</span>()) &#123;<br>    <span class="hljs-type">uint32_t</span> options = context-&gt;options;<br>    context-&gt;<span class="hljs-built_in">Clear</span>();<br>    *keep_skipping = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> (kPolUseOREval != options);<br>  &#125;<br>  *keep_skipping = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="管中窥豹">管中窥豹</h3><p>无论是opcode相关，还是操纵opcodegroup与<code>ParameterSet</code>的processor，他们都只是联合提供了一整套机制，封装成API供上层的某个组件使用。在头文件的描述中，我们已经知道了这个组件是low-levelpolicy。low-levelpolicy本身有一定篇幅，我们本节就不再继续深入，留到下一节分析。但抛开low-levelpolicy，从policy_engine_unittest.cc和policy_opcodes_unittest.cc这两个单元测试代码中亦能可见一斑。</p><p>先看一下opcode的单元测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这个TEST是测试ParameterSet的构造器和Get方法是否奏效</span><br><span class="hljs-built_in">TEST</span>(PolicyEngineTest, ParameterSetTest) &#123;<br>  <span class="hljs-comment">// 做出两个ParameterSet，设置对应的realType_和address_成员</span><br>  <span class="hljs-type">void</span>* pv1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(<span class="hljs-number">0x477EAA5</span>);<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* pv2 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(<span class="hljs-number">0x987654</span>);<br>  ParameterSet pset1 = <span class="hljs-built_in">ParamPickerMake</span>(pv1);<br>  ParameterSet pset2 = <span class="hljs-built_in">ParamPickerMake</span>(pv2);<br><br>  <span class="hljs-comment">// Test that we can store and retrieve a void pointer:</span><br>  <span class="hljs-comment">// 先确认ParameterSet本身没毛病</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* result1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">uint32_t</span> result2 = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">EXPECT_TRUE</span>(pset1.<span class="hljs-built_in">Get</span>(&amp;result1));<br>  <span class="hljs-built_in">EXPECT_TRUE</span>(pv1 == result1);<br>  <span class="hljs-built_in">EXPECT_FALSE</span>(pset1.<span class="hljs-built_in">Get</span>(&amp;result2));<br>  <span class="hljs-built_in">EXPECT_TRUE</span>(pset2.<span class="hljs-built_in">Get</span>(&amp;result1));<br>  <span class="hljs-built_in">EXPECT_TRUE</span>(pv2 == result1);<br>  <span class="hljs-built_in">EXPECT_FALSE</span>(pset2.<span class="hljs-built_in">Get</span>(&amp;result2));<br><br>  <span class="hljs-comment">// Test that we can store and retrieve a uint32_t:</span><br>  <span class="hljs-comment">// 确保ParameterSet对uint32_t类型的处理是正确的（它是兼容uint32_t和指针两种处理的）</span><br>  <span class="hljs-type">uint32_t</span> number = <span class="hljs-number">12747</span>;<br>  ParameterSet pset3 = <span class="hljs-built_in">ParamPickerMake</span>(number);<br>  <span class="hljs-built_in">EXPECT_FALSE</span>(pset3.<span class="hljs-built_in">Get</span>(&amp;result1));<span class="hljs-comment">// Get方法有多个重载，这里因为TYPE对不上理应返会false</span><br>  <span class="hljs-built_in">EXPECT_TRUE</span>(pset3.<span class="hljs-built_in">Get</span>(&amp;result2));<span class="hljs-comment">// 这个则应该返回true</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(number, result2);<br><br>  <span class="hljs-comment">// Test that we can store and retrieve a string:</span><br>  <span class="hljs-comment">// 测试字符串的ParameterSet有没有毛病</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* txt = <span class="hljs-string">L&quot;S231L&quot;</span>;<br>  ParameterSet pset4 = <span class="hljs-built_in">ParamPickerMake</span>(txt);<br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* result3 = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-built_in">EXPECT_TRUE</span>(pset4.<span class="hljs-built_in">Get</span>(&amp;result3));<br>  <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">wcscmp</span>(txt, result3));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ParameterSet</code>的设计很有灵性，对于上面的测试代码，完全能够理解。</p><p>再看对true/false两种opcode的测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">TEST</span>(PolicyEngineTest, TrueFalseOpcodes) &#123;<br>  <span class="hljs-type">void</span>* dummy = <span class="hljs-literal">nullptr</span>;<br>  ParameterSet ppb1 = <span class="hljs-built_in">ParamPickerMake</span>(dummy);<br>  <span class="hljs-comment">// 先做出一个工厂，memory作为PolicyOpcode+string的buffer</span><br>  <span class="hljs-type">char</span> memory[kOpcodeMemory];<br>  <span class="hljs-function">OpcodeFactory <span class="hljs-title">opcode_maker</span><span class="hljs-params">(memory, <span class="hljs-keyword">sizeof</span>(memory))</span></span>;<br><br>  <span class="hljs-comment">// This opcode always evaluates to true.</span><br>  <span class="hljs-comment">// op1是一个永远返回FALSE的opcode</span><br>  PolicyOpcode* op1 = opcode_maker.<span class="hljs-built_in">MakeOpAlwaysFalse</span>(kPolNone);<br>  <span class="hljs-built_in">ASSERT_NE</span>(<span class="hljs-literal">nullptr</span>, op1);<br>  <span class="hljs-comment">// op1的evaluate一定是返回false</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_FALSE, op1-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;ppb1, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-comment">// op1是comparsion，不是action</span><br>  <span class="hljs-built_in">EXPECT_FALSE</span>(op1-&gt;<span class="hljs-built_in">IsAction</span>());<br><br>  <span class="hljs-comment">// This opcode always evaluates to false.</span><br>  <span class="hljs-comment">// op2永远返回true</span><br>  PolicyOpcode* op2 = opcode_maker.<span class="hljs-built_in">MakeOpAlwaysTrue</span>(kPolNone);<br>  <span class="hljs-built_in">ASSERT_NE</span>(<span class="hljs-literal">nullptr</span>, op2);<br>  <span class="hljs-comment">// 这里应该返回true</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_TRUE, op2-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;ppb1, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br><br>  <span class="hljs-comment">// Nulls not allowed on the params.</span><br>  <span class="hljs-comment">// 参数是null的情况，会返回ERROR（此时不会返回裁决值 true或false）</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_ERROR, op2-&gt;<span class="hljs-built_in">Evaluate</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_ERROR, op2-&gt;<span class="hljs-built_in">Evaluate</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br><br>  <span class="hljs-comment">// True and False opcodes do not &#x27;require&#x27; a number of parameters</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_TRUE, op2-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;ppb1, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_TRUE, op2-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;ppb1, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br><br>  <span class="hljs-comment">// Test Inverting the logic. Note that inversion is done outside</span><br>  <span class="hljs-comment">// any particular opcode evaluation so no need to repeat for all</span><br>  <span class="hljs-comment">// opcodes.</span><br>  <span class="hljs-comment">// 设置一个有着kPolNegateEval标记位得永远返回false的opcode</span><br>  PolicyOpcode* op3 = opcode_maker.<span class="hljs-built_in">MakeOpAlwaysFalse</span>(kPolNegateEval);<br>  <span class="hljs-built_in">ASSERT_NE</span>(<span class="hljs-literal">nullptr</span>, op3);<br>  <span class="hljs-comment">// 由于kPolNegateEval，所以永远返回True</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_TRUE, op3-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;ppb1, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br>  PolicyOpcode* op4 = opcode_maker.<span class="hljs-built_in">MakeOpAlwaysTrue</span>(kPolNegateEval);<br>  <span class="hljs-built_in">ASSERT_NE</span>(<span class="hljs-literal">nullptr</span>, op4);<br>  <span class="hljs-comment">// 这个就永远返回false</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_FALSE, op4-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;ppb1, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br><br>  <span class="hljs-comment">// Test that we clear the match context</span><br>  PolicyOpcode* op5 = opcode_maker.<span class="hljs-built_in">MakeOpAlwaysTrue</span>(kPolClearContext);<br>  <span class="hljs-built_in">ASSERT_NE</span>(<span class="hljs-literal">nullptr</span>, op5);<br>  MatchContext context;<br>  context.position = <span class="hljs-number">1</span>;<br>  context.options = kPolUseOREval;<br>  <span class="hljs-comment">// 对字符串连续匹配所用的辅助结构context的测试，实际上这里是用不到的</span><br>  <span class="hljs-comment">// 只是单纯的测试options的值是否会正确的设置给context</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_TRUE, op5-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;ppb1, <span class="hljs-number">1</span>, &amp;context));<br>  <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-number">0u</span>, context.position);<br>  MatchContext context2;<br>  <span class="hljs-built_in">EXPECT_EQ</span>(context2.options, context.options);<br>&#125;<br></code></pre></td></tr></table></figure><p>对工厂类的测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">TEST</span>(PolicyEngineTest, OpcodeMakerCase1) &#123;<br>  <span class="hljs-comment">// Testing that the opcode maker does not overrun the</span><br>  <span class="hljs-comment">// supplied buffer. It should only be able to make &#x27;count&#x27; opcodes.</span><br>  <span class="hljs-type">void</span>* dummy = <span class="hljs-literal">nullptr</span>;<br>  ParameterSet ppb1 = <span class="hljs-built_in">ParamPickerMake</span>(dummy);<br><br>  <span class="hljs-type">char</span> memory[kOpcodeMemory];<br>  <span class="hljs-function">OpcodeFactory <span class="hljs-title">opcode_maker</span><span class="hljs-params">(memory, <span class="hljs-keyword">sizeof</span>(memory))</span></span>;<br>  <span class="hljs-type">size_t</span> count = <span class="hljs-built_in">sizeof</span>(memory) / <span class="hljs-built_in">sizeof</span>(PolicyOpcode);<br><br>  <span class="hljs-comment">// 放置count个false comparsion opcode到buffer中</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> ix = <span class="hljs-number">0</span>; ix != count; ++ix) &#123;<br>    PolicyOpcode* op = opcode_maker.<span class="hljs-built_in">MakeOpAlwaysFalse</span>(kPolNone);<br>    <span class="hljs-built_in">ASSERT_NE</span>(<span class="hljs-literal">nullptr</span>, op);<br>    <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_FALSE, op-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;ppb1, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br>  &#125;<br>  <span class="hljs-comment">// There should be no room more another opcode:</span><br>  PolicyOpcode* op1 = opcode_maker.<span class="hljs-built_in">MakeOpAlwaysFalse</span>(kPolNone);<br>  <span class="hljs-built_in">ASSERT_EQ</span>(<span class="hljs-literal">nullptr</span>, op1);<br>&#125;<br><br><span class="hljs-built_in">TEST</span>(PolicyEngineTest, OpcodeMakerCase2) &#123;<br>  <span class="hljs-built_in">SetupNtdllImports</span>();<br>  <span class="hljs-comment">// Testing that the opcode maker does not overrun the</span><br>  <span class="hljs-comment">// supplied buffer. It should only be able to make &#x27;count&#x27; opcodes.</span><br>  <span class="hljs-comment">// The difference with the previous test is that this opcodes allocate</span><br>  <span class="hljs-comment">// the string &#x27;txt2&#x27; inside the same buffer.</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* txt1 = <span class="hljs-string">L&quot;1234&quot;</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> txt2[] = <span class="hljs-string">L&quot;123&quot;</span>;<br><br>  ParameterSet ppb1 = <span class="hljs-built_in">ParamPickerMake</span>(txt1);<br>  MatchContext mc1;<br><br>  <span class="hljs-type">char</span> memory[kOpcodeMemory];<br>  <span class="hljs-function">OpcodeFactory <span class="hljs-title">opcode_maker</span><span class="hljs-params">(memory, <span class="hljs-keyword">sizeof</span>(memory))</span></span>;<br>  <span class="hljs-type">size_t</span> count = <span class="hljs-built_in">sizeof</span>(memory) / (<span class="hljs-built_in">sizeof</span>(PolicyOpcode) + <span class="hljs-built_in">sizeof</span>(txt2));<br><br>  <span class="hljs-comment">// Test that it does not overrun the buffer.</span><br>  <span class="hljs-comment">// 放置count个字符串比较opcode到buffer</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> ix = <span class="hljs-number">0</span>; ix != count; ++ix) &#123;<br>    PolicyOpcode* op = opcode_maker.<span class="hljs-built_in">MakeOpWStringMatch</span>(<br>        <span class="hljs-number">0</span>, txt2, <span class="hljs-number">0</span>, CASE_SENSITIVE, kPolClearContext);<br>    <span class="hljs-built_in">ASSERT_NE</span>(<span class="hljs-literal">nullptr</span>, op);<br>    <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_TRUE, op-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;ppb1, <span class="hljs-number">1</span>, &amp;mc1));<br>  &#125;<br><br>  <span class="hljs-comment">// There should be no room more another opcode:</span><br>  PolicyOpcode* op1 =<br>      opcode_maker.<span class="hljs-built_in">MakeOpWStringMatch</span>(<span class="hljs-number">0</span>, txt2, <span class="hljs-number">0</span>, CASE_SENSITIVE, kPolNone);<br>  <span class="hljs-built_in">ASSERT_EQ</span>(<span class="hljs-literal">nullptr</span>, op1);<br>&#125;<br></code></pre></td></tr></table></figure><p>继续测试各种comparison opcode的正确性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">TEST</span>(PolicyEngineTest, IntegerOpcodes) &#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* txt = <span class="hljs-string">L&quot;abcdef&quot;</span>;<br>  <span class="hljs-type">uint32_t</span> num1 = <span class="hljs-number">42</span>;<br>  <span class="hljs-type">uint32_t</span> num2 = <span class="hljs-number">113377</span>;<br><br>  <span class="hljs-comment">// make三个ParameterSet，1个字符串两个uint32</span><br>  ParameterSet pp_wrong1 = <span class="hljs-built_in">ParamPickerMake</span>(txt);<br>  ParameterSet pp_num1 = <span class="hljs-built_in">ParamPickerMake</span>(num1);<br>  ParameterSet pp_num2 = <span class="hljs-built_in">ParamPickerMake</span>(num2);<br><br>  <span class="hljs-type">char</span> memory[kOpcodeMemory];<br>  <span class="hljs-comment">// opcode工厂类</span><br>  <span class="hljs-function">OpcodeFactory <span class="hljs-title">opcode_maker</span><span class="hljs-params">(memory, <span class="hljs-keyword">sizeof</span>(memory))</span></span>;<br><br>  <span class="hljs-comment">// Test basic match for uint32s 42 == 42 and 42 != 113377.</span><br>  <span class="hljs-comment">// 放入一个匹配uint32值为42、参数索引为0、标记为kPolNone的PolicyOpcode</span><br>  <span class="hljs-comment">// 参数索引表示的是在ParameterSet数组中的索引，这里是单参数测试的，所以只有0</span><br>  <span class="hljs-comment">// 这个索引是为了上层的匹配ParameterSet数组而设置的</span><br>  PolicyOpcode* op_m42 = opcode_maker.<span class="hljs-built_in">MakeOpNumberMatch</span>(<span class="hljs-number">0</span>, <span class="hljs-number">42UL</span>, kPolNone);<br>  <span class="hljs-built_in">ASSERT_NE</span>(<span class="hljs-literal">nullptr</span>, op_m42);<br>  <span class="hljs-comment">// 匹配pp_num1应该是返回true的，匹配pp_num2应该返回false，而匹配字符串因为类型不一致，会返回ERROR</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_TRUE, op_m42-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;pp_num1, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_FALSE, op_m42-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;pp_num2, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_ERROR, op_m42-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;pp_wrong1, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br><br>  <span class="hljs-comment">// Test basic match for void pointers.</span><br>  <span class="hljs-comment">// void指针的匹配，同上</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* vp = <span class="hljs-literal">nullptr</span>;<br>  ParameterSet pp_num3 = <span class="hljs-built_in">ParamPickerMake</span>(vp);<br>  PolicyOpcode* op_vp_null =<br>      opcode_maker.<span class="hljs-built_in">MakeOpVoidPtrMatch</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, kPolNone);<br>  <span class="hljs-built_in">ASSERT_NE</span>(<span class="hljs-literal">nullptr</span>, op_vp_null);<br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_TRUE, op_vp_null-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;pp_num3, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_FALSE, op_vp_null-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;pp_num1, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_ERROR, op_vp_null-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;pp_wrong1, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br><br>  <span class="hljs-comment">// Basic range test [41 43] (inclusive).</span><br>  PolicyOpcode* op_range1 =<br>      opcode_maker.<span class="hljs-built_in">MakeOpNumberMatchRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">41</span>, <span class="hljs-number">43</span>, kPolNone);<br>  <span class="hljs-built_in">ASSERT_NE</span>(<span class="hljs-literal">nullptr</span>, op_range1);<br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_TRUE, op_range1-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;pp_num1, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_FALSE, op_range1-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;pp_num2, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-built_in">EXPECT_EQ</span>(EVAL_ERROR, op_range1-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;pp_wrong1, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>其他的测试用例都差不多，就不一一展开了，我们理解了<code>PolicyOpcode</code>，<code>OpcodeFactory</code>以及<code>ParameterSet</code>的使用即达到目的。</p><p>再看整个engine的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">TEST</span>(PolicyEngineTest, Rules1) &#123;<br>  <span class="hljs-built_in">SetupNtdllImports</span>();<br><br>  <span class="hljs-comment">// Construct two policy rules that say:</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// #1</span><br>  <span class="hljs-comment">// If the path is c:\\documents and settings\\* AND</span><br>  <span class="hljs-comment">// If the creation mode is &#x27;open existing&#x27; AND</span><br>  <span class="hljs-comment">// If the security descriptor is null THEN</span><br>  <span class="hljs-comment">// Ask the broker.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// #2</span><br>  <span class="hljs-comment">// If the security descriptor is null AND</span><br>  <span class="hljs-comment">// If the path ends with *.txt AND</span><br>  <span class="hljs-comment">// If the creation mode is not &#x27;create new&#x27; THEN</span><br>  <span class="hljs-comment">// return Access Denied.</span><br>  <span class="hljs-comment">// 构造了两个rule：</span><br>  <span class="hljs-comment">// 第一个规则的判断条件：</span><br>  <span class="hljs-comment">// path得是c:\\documents and settings\\*且创建模式是open existing且安全描述符是null</span><br>  <span class="hljs-comment">// 满足则action为ASK_BROKER</span><br>  <span class="hljs-comment">// 第二个规则的判断条件：</span><br>  <span class="hljs-comment">// 安全描述符是null且path以*.txt结尾且创建模式不是`create new`</span><br>  <span class="hljs-comment">// 满足则action为Access Denied</span><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-comment">// 这几个参数就是要进行裁决的ParameterSet[]</span><br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">FileCreateArgs</span> &#123;<br>    FileNameArg,<br>    CreationDispositionArg,<br>    FlagsAndAttributesArg,<br>    SecurityAttributes<br>  &#125;;<br><br>  <span class="hljs-comment">// 这里使用PolicyBuffer来new一个OpcodeFactory</span><br>  <span class="hljs-comment">// 尺寸为1024，这里构造器的尺寸减去了0x40，我个人觉着减去0x4就可以了吧，不清楚是否是笔误</span><br>  <span class="hljs-comment">// 当然无论是0x40还是0x4都不会影响正确性，仅仅是浪费了点空间</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> policy_sz = <span class="hljs-number">1024</span>;<br>  PolicyBuffer* policy = <span class="hljs-built_in">reinterpret_cast</span>&lt;PolicyBuffer*&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[policy_sz]);<br>  <span class="hljs-function">OpcodeFactory <span class="hljs-title">opcode_maker</span><span class="hljs-params">(policy, policy_sz - <span class="hljs-number">0x40</span>)</span></span>;<br><br>  <span class="hljs-comment">// Add rule set #1</span><br>  <span class="hljs-comment">// 工厂类中添加第一套rule</span><br>  <span class="hljs-comment">// 参数索引为1，值为L&quot;c:\\documents and settings\\&quot;，字符串起始位置0，大小写敏感，标记为kPolNone</span><br>  opcode_maker.<span class="hljs-built_in">MakeOpWStringMatch</span>(FileNameArg, <span class="hljs-string">L&quot;c:\\documents and settings\\&quot;</span>,<br>                                  <span class="hljs-number">0</span>, CASE_INSENSITIVE, kPolNone);<br>  <span class="hljs-comment">// 参数索引为2，值为OPEN_EXISTING，标记为kPolNone</span><br>  opcode_maker.<span class="hljs-built_in">MakeOpNumberMatch</span>(CreationDispositionArg, OPEN_EXISTING,<br>                                 kPolNone);<br>  <span class="hljs-comment">// 参数索引为3，值为nullptr，标记为kPolNone</span><br>  opcode_maker.<span class="hljs-built_in">MakeOpVoidPtrMatch</span>(SecurityAttributes, <span class="hljs-literal">nullptr</span>, kPolNone);<br>  <span class="hljs-comment">// 这一group的comparsion opcode设置完毕了，接上满足匹配时的审判，这里是ASK_BROKER</span><br>  opcode_maker.<span class="hljs-built_in">MakeOpAction</span>(ASK_BROKER, kPolNone);<br><br>  <span class="hljs-comment">// Add rule set #2</span><br>  <span class="hljs-comment">// 第二套规则仅仅判断两个参数</span><br>  opcode_maker.<span class="hljs-built_in">MakeOpWStringMatch</span>(FileNameArg, <span class="hljs-string">L&quot;.TXT&quot;</span>, kSeekToEnd,<br>                                  CASE_INSENSITIVE, kPolNone);<br>  opcode_maker.<span class="hljs-built_in">MakeOpNumberMatch</span>(CreationDispositionArg, CREATE_NEW,<br>                                 kPolNegateEval);<br>  <span class="hljs-comment">// 满足匹配时审判结果为FAKE_ACCESS_DENIED</span><br>  opcode_maker.<span class="hljs-built_in">MakeOpAction</span>(FAKE_ACCESS_DENIED, kPolNone);<br>  <span class="hljs-comment">// 更新count值</span><br>  policy-&gt;opcode_count = <span class="hljs-number">7</span>;<br><br>  <span class="hljs-comment">// 设置一组参数</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* filename = <span class="hljs-string">L&quot;c:\\Documents and Settings\\Microsoft\\BLAH.txt&quot;</span>;<br>  <span class="hljs-type">uint32_t</span> creation_mode = OPEN_EXISTING;<br>  <span class="hljs-type">uint32_t</span> flags = FILE_ATTRIBUTE_NORMAL;<br>  <span class="hljs-type">void</span>* security_descriptor = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-comment">// 这套宏非常关键，我们此前在注释中就看过了，应该是用于生成ParameterSet数组</span><br>  <span class="hljs-built_in">POLPARAMS_BEGIN</span>(eval_params)<br>    <span class="hljs-built_in">POLPARAM</span>(filename)<br>    <span class="hljs-built_in">POLPARAM</span>(creation_mode)<br>    <span class="hljs-built_in">POLPARAM</span>(flags)<br>    <span class="hljs-built_in">POLPARAM</span>(security_descriptor)<br>  POLPARAMS_END;<br><br>  PolicyResult pr;<br>  <span class="hljs-function">PolicyProcessor <span class="hljs-title">pol_ev</span><span class="hljs-params">(policy)</span></span>;<span class="hljs-comment">// 架在PolicyBuffer上的processor，操纵者</span><br><br>  <span class="hljs-comment">// Test should match the first rule set.</span><br>  <span class="hljs-comment">// 看起来eval_params就是ParameterSet数组，这一组参数理应匹配到第一套规则</span><br>  <span class="hljs-comment">// 设置kShortEval模式，匹配到了一个就会返回</span><br>  pr = pol_ev.<span class="hljs-built_in">Evaluate</span>(kShortEval, eval_params, _countof(eval_params));<br>  <span class="hljs-comment">// 结果应该是匹配到</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(POLICY_MATCH, pr);、<br>  <span class="hljs-comment">// 结果应该是ASK_BROKER</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(ASK_BROKER, pol_ev.<span class="hljs-built_in">GetAction</span>());<br><br>  <span class="hljs-comment">// Test should still match the first rule set.</span><br>  <span class="hljs-comment">// 再次审判，结果应该还是一样的</span><br>  pr = pol_ev.<span class="hljs-built_in">Evaluate</span>(kShortEval, eval_params, _countof(eval_params));<br>  <span class="hljs-built_in">EXPECT_EQ</span>(POLICY_MATCH, pr);<br>  <span class="hljs-built_in">EXPECT_EQ</span>(ASK_BROKER, pol_ev.<span class="hljs-built_in">GetAction</span>());<br><br>  <span class="hljs-comment">// Changing creation_mode such that evaluation should not match any rule.</span><br>  <span class="hljs-comment">// 修改一下参数的值，此时应该匹配不到规则</span><br>  creation_mode = CREATE_NEW;<br>  pr = pol_ev.<span class="hljs-built_in">Evaluate</span>(kShortEval, eval_params, _countof(eval_params));<br>  <span class="hljs-built_in">EXPECT_EQ</span>(NO_POLICY_MATCH, pr);<br><br>  <span class="hljs-comment">// Changing creation_mode such that evaluation should match rule #2.</span><br>  <span class="hljs-comment">// 再次修改一个参数值，此时应该匹配到第二套规则</span><br>  creation_mode = OPEN_ALWAYS;<br>  pr = pol_ev.<span class="hljs-built_in">Evaluate</span>(kShortEval, eval_params, _countof(eval_params));<br>  <span class="hljs-built_in">EXPECT_EQ</span>(POLICY_MATCH, pr);<br>  <span class="hljs-built_in">EXPECT_EQ</span>(FAKE_ACCESS_DENIED, pol_ev.<span class="hljs-built_in">GetAction</span>());<br><br>  <span class="hljs-keyword">delete</span>[] <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(policy);<br>&#125;<br></code></pre></td></tr></table></figure><p>唯一的一点就是<code>POLPARAMS_BEGIN</code>等一整套宏机制了。在policy_params.h中找到了定义，算是本次分析之旅的漏网之鱼：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Warning: The following macros store the address to the actual variables, in</span><br><span class="hljs-comment">// other words, the values are not copied.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLPARAMS_BEGIN(type) class type &#123; public: enum Args &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLPARAM(arg) arg,</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLPARAMS_END(type) PolParamLast &#125;; &#125;; \</span><br><span class="hljs-meta">  typedef sandbox::ParameterSet type##Array [type::PolParamLast];</span><br></code></pre></td></tr></table></figure><p>而测试代码中使用的套路和此前看到的注释是有些差别的，因为测试代码做了简化，自己重写了这套宏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLPARAMS_BEGIN(x) sandbox::ParameterSet x[] = &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLPARAM(p) sandbox::ParamPickerMake(p),</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLPARAMS_END &#125;</span><br></code></pre></td></tr></table></figure><p>用它展开上面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sandbox::ParameterSet eval_params[] = &#123;<br>  sandbox::<span class="hljs-built_in">ParamPickerMake</span>(filename),<br>  sandbox::<span class="hljs-built_in">ParamPickerMake</span>(creation_mode),<br>  sandbox::<span class="hljs-built_in">ParamPickerMake</span>(flags),<br>  sandbox::<span class="hljs-built_in">ParamPickerMake</span>(security_descriptor),<br>&#125;<br><br><span class="hljs-comment">// ParamPickerMake(&amp;parameter) =&gt; ParameterSetEx&lt;type&gt;(address) =&gt; ParameterSet(ArgType, address)</span><br></code></pre></td></tr></table></figure><p>相比较policy_params.h的定义，省去了类型的定义，直接使用了<code>ParameterSet</code>数组。</p><p>到此，通过对测试用例的解读，我们已经了解了使用这套policyengine的套路。下一节我们去看看它的上层操纵者：low-level policy。</p>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-Resolver-analysis</title>
    <link href="/2018/05/26/chromium-sandbox-Resolver-analysis/"/>
    <url>/2018/05/26/chromium-sandbox-Resolver-analysis/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第十一篇，承接了上一篇Interception的分析。Resolver是负责操纵Interceptions的相关模块。阅读本篇前，请先阅读前四篇及第十篇。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-resolver-analysis">chromium-sandbox-Resolver-analysis</h1><p>本节分析负责执行Interceptions的相关类。</p><p>不跟你多BB，直接从上一节的疑问看起。也就是<code>ResolverThunk</code>类。</p><h2 id="resolverthunk"><code>ResolverThunk</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A resolver is the object in charge of performing the actual interception of</span><br><span class="hljs-comment">// a function. There should be a concrete implementation of a resolver roughly</span><br><span class="hljs-comment">// per type of interception.</span><br><span class="hljs-comment">// resolver负责处理某个函数具体的拦截，每种类型的interception都应该有一个具体的resolver对象</span><br><span class="hljs-comment">// 这也就是上一节看到的，resolver对应每个的3个类型都有着一个派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResolverThunk</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ResolverThunk</span>() &#123;&#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ResolverThunk</span>() &#123;&#125;<br><br>  <span class="hljs-comment">// Performs the actual interception of a function.</span><br>  <span class="hljs-comment">// target_name is an exported function from the module loaded at</span><br>  <span class="hljs-comment">// target_module, and must be replaced by interceptor_name, exported from</span><br>  <span class="hljs-comment">// interceptor_module. interceptor_entry_point can be provided instead of</span><br>  <span class="hljs-comment">// interceptor_name / interceptor_module.</span><br>  <span class="hljs-comment">// thunk_storage must point to a buffer on the child&#x27;s address space, to hold</span><br>  <span class="hljs-comment">// the patch thunk, and related data. If provided, storage_used will receive</span><br>  <span class="hljs-comment">// the number of bytes used from thunk_storage.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Example: (without error checking)</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// size_t size = resolver.GetThunkSize();</span><br>  <span class="hljs-comment">// char* buffer = ::VirtualAllocEx(child_process, nullptr, size,</span><br>  <span class="hljs-comment">//                                 MEM_COMMIT, PAGE_READWRITE);</span><br>  <span class="hljs-comment">// resolver.Setup(ntdll_module, nullptr, L&quot;NtCreateFile&quot;, nullptr,</span><br>  <span class="hljs-comment">//                &amp;MyReplacementFunction, buffer, size, nullptr);</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// In general, the idea is to allocate a single big buffer for all</span><br>  <span class="hljs-comment">// interceptions on the same dll, and call Setup n times.</span><br>  <span class="hljs-comment">// WARNING: This means that any data member that is specific to a single</span><br>  <span class="hljs-comment">// interception must be reset within this method.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> NTSTATUS <span class="hljs-title">Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,<span class="hljs-comment">//函数所在dll</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,<span class="hljs-comment">//hook函数所在dll</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,<span class="hljs-comment">//original函数名称</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,<span class="hljs-comment">//hook函数名称</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,<span class="hljs-comment">//hook入口地址</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">void</span>* thunk_storage,<span class="hljs-comment">//存储thunk的buffer</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">size_t</span> storage_bytes,<span class="hljs-comment">//buffer的大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">size_t</span>* storage_used)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 下面两个函数用于确定hook和original函数的地址</span><br>  <span class="hljs-comment">// Gets the address of function_name inside module (main exe).</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> NTSTATUS <span class="hljs-title">ResolveInterceptor</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">void</span>** address)</span></span>;<br><br>  <span class="hljs-comment">// Gets the address of an exported function_name inside module.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> NTSTATUS <span class="hljs-title">ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">void</span>** address)</span></span>;<br><br>  <span class="hljs-comment">// Gets the required buffer size for this type of thunk.</span><br>  <span class="hljs-comment">// 计算该thunk需要的buffer大小</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">size_t</span> <span class="hljs-title">GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// Performs basic initialization on behalf of a concrete instance of a</span><br>  <span class="hljs-comment">// resolver. That is, parameter validation and resolution of the target</span><br>  <span class="hljs-comment">// and the interceptor into the member variables.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// target_name is an exported function from the module loaded at</span><br>  <span class="hljs-comment">// target_module, and must be replaced by interceptor_name, exported from</span><br>  <span class="hljs-comment">// interceptor_module. interceptor_entry_point can be provided instead of</span><br>  <span class="hljs-comment">// interceptor_name / interceptor_module.</span><br>  <span class="hljs-comment">// thunk_storage must point to a buffer on the child&#x27;s address space, to hold</span><br>  <span class="hljs-comment">// the patch thunk, and related data.</span><br>  <span class="hljs-comment">// 常规套路init</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> NTSTATUS <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">size_t</span> storage_bytes)</span></span>;<br><br>  <span class="hljs-comment">// Gets the required buffer size for the internal part of the thunk.</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetInternalThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Initializes the internal part of the thunk.</span><br>  <span class="hljs-comment">// interceptor is the function to be called instead of original_function.</span><br>  <span class="hljs-comment">// 调用此接口来用interceptor替换original的调用</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetInternalThunk</span><span class="hljs-params">(<span class="hljs-type">void</span>* storage, <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> <span class="hljs-type">void</span>* original_function, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor)</span></span>;<br><br>  <span class="hljs-comment">// Holds the resolved interception target.</span><br>  <span class="hljs-type">void</span>* target_;<span class="hljs-comment">//这个对应original function地址</span><br>  <span class="hljs-comment">// Holds the resolved interception interceptor.</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_;<span class="hljs-comment">//对应hook函数地址</span><br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(ResolverThunk);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="init"><code>Init</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">ResolverThunk::Init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">size_t</span> storage_bytes)</span> </span>&#123;<br>  <span class="hljs-comment">// 传入的这些值必须得有效</span><br>  <span class="hljs-keyword">if</span> (!thunk_storage || <span class="hljs-number">0</span> == storage_bytes || !target_module || !target_name)<br>    <span class="hljs-keyword">return</span> STATUS_INVALID_PARAMETER;<br><br>  <span class="hljs-keyword">if</span> (storage_bytes &lt; <span class="hljs-built_in">GetThunkSize</span>())<br>    <span class="hljs-keyword">return</span> STATUS_BUFFER_TOO_SMALL;<br><br>  NTSTATUS ret = STATUS_SUCCESS;<br>  <span class="hljs-comment">// InterceptionManager中看到的两个Add方法，其中一个写入的是interceptor_entry_point，没有interceptor_name。</span><br>  <span class="hljs-comment">// 这种情况刚刚好，我们要的就是地址（毕竟不是非要用已知的函数来hook另一个函数，大可以diy）</span><br>  <span class="hljs-comment">// 而另一个Add传入的是interceptor_name，此时也必然有interceptor_module。</span><br>  <span class="hljs-comment">// 这时用interceptor_module和interceptor_name解析出interceptor_entry_point</span><br>  <span class="hljs-keyword">if</span> (!interceptor_entry_point) &#123;<br>    ret = <span class="hljs-built_in">ResolveInterceptor</span>(interceptor_module, interceptor_name,<br>                             &amp;interceptor_entry_point);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>      <span class="hljs-keyword">return</span> ret;<br>  &#125;<br><br>  <span class="hljs-comment">// 解析出original函数的地址</span><br>  <span class="hljs-comment">// original函数地址给到target_成员</span><br>  <span class="hljs-comment">// interceptor地址给到interceptor_成员</span><br>  ret = <span class="hljs-built_in">ResolveTarget</span>(target_module, target_name, &amp;target_);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  interceptor_ = interceptor_entry_point;<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>展开看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">ResolverThunk::ResolveInterceptor</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> <span class="hljs-type">void</span>** address)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_NT</span>(address);<br>  <span class="hljs-keyword">if</span> (!interceptor_module)<br>    <span class="hljs-keyword">return</span> STATUS_INVALID_PARAMETER;<br><br>  <span class="hljs-comment">// 基础代码中对PE文件结构的封装</span><br>  base::<span class="hljs-function">win::PEImage <span class="hljs-title">pe</span><span class="hljs-params">(interceptor_module)</span></span>;<br>  <span class="hljs-comment">// 验证是否是有效PE</span><br>  <span class="hljs-keyword">if</span> (!pe.<span class="hljs-built_in">VerifyMagic</span>())<br>    <span class="hljs-keyword">return</span> STATUS_INVALID_IMAGE_FORMAT;<br><br>  <span class="hljs-comment">// 获取interceptor_name的地址</span><br>  *address = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(pe.<span class="hljs-built_in">GetProcAddress</span>(interceptor_name));<br><br>  <span class="hljs-keyword">if</span> (!(*address))<br>    <span class="hljs-keyword">return</span> STATUS_PROCEDURE_NOT_FOUND;<br><br>  <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br><br><span class="hljs-function">NTSTATUS <span class="hljs-title">ResolverThunk::ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">void</span>** address)</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>** casted = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>**&gt;(address);<br>  <span class="hljs-keyword">return</span> ResolverThunk::<span class="hljs-built_in">ResolveInterceptor</span>(<span class="hljs-keyword">module</span>, function_name, casted);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到基类的两个Resolve方法实际上都是<code>PEImage</code>中<code>GetProcAddress</code>。</p><h3 id="x86-internalthunk">x86: <code>InternalThunk</code></h3><p>再继续分析前，我们需要看一些基础设施，防止后续分析时一脸懵逼。</p><p>在resolver_32.cc中有一个非常漂亮的内联汇编payload：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push, 1)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InternalThunk</span> &#123;<br>  <span class="hljs-comment">// This struct contains roughly the following code:</span><br>  <span class="hljs-comment">// sub esp, 8                             // Create working space</span><br>  <span class="hljs-comment">// push edx                               // Save register</span><br>  <span class="hljs-comment">// mov edx, [esp + 0xc]                   // Get return adddress</span><br>  <span class="hljs-comment">// mov [esp + 8], edx                     // Store return address</span><br>  <span class="hljs-comment">// mov dword ptr [esp + 0xc], 0x7c401200  // Store extra argument</span><br>  <span class="hljs-comment">// mov dword ptr [esp + 4], 0x40010203    // Store address to jump to</span><br>  <span class="hljs-comment">// pop edx                                // Restore register</span><br>  <span class="hljs-comment">// ret                                    // Jump to interceptor</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// This code only modifies esp and eip so it must work with to normal calling</span><br>  <span class="hljs-comment">// convention. It is assembled as:</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// 00 83ec08           sub     esp,8</span><br>  <span class="hljs-comment">// 03 52               push    edx</span><br>  <span class="hljs-comment">// 04 8b54240c         mov     edx,dword ptr [esp + 0Ch]</span><br>  <span class="hljs-comment">// 08 89542408         mov     dword ptr [esp + 8], edx</span><br>  <span class="hljs-comment">// 0c c744240c0012407c mov     dword ptr [esp + 0Ch], 7C401200h</span><br>  <span class="hljs-comment">// 14 c744240403020140 mov     dword ptr [esp + 4], 40010203h</span><br>  <span class="hljs-comment">// 1c 5a               pop     edx</span><br>  <span class="hljs-comment">// 1d c3               ret</span><br>  <span class="hljs-built_in">InternalThunk</span>() &#123;<br>    opcodes_1 = <span class="hljs-number">0x5208ec83</span>;<br>    opcodes_2 = <span class="hljs-number">0x0c24548b</span>;<br>    opcodes_3 = <span class="hljs-number">0x08245489</span>;<br>    opcodes_4 = <span class="hljs-number">0x0c2444c7</span>; <br>    opcodes_5 = <span class="hljs-number">0x042444c7</span>;<br>    opcodes_6 = <span class="hljs-number">0xc35a</span>;<br>    extra_argument = <span class="hljs-number">0</span>;<br>    interceptor_function = <span class="hljs-number">0</span>;<br>  &#125;;<br>  ULONG opcodes_1;  <span class="hljs-comment">// = 0x5208ec83</span><br>  ULONG opcodes_2;  <span class="hljs-comment">// = 0x0c24548b</span><br>  ULONG opcodes_3;  <span class="hljs-comment">// = 0x08245489</span><br>  ULONG opcodes_4;  <span class="hljs-comment">// = 0x0c2444c7</span><br>  ULONG extra_argument;<br>  ULONG opcodes_5;  <span class="hljs-comment">// = 0x042444c7</span><br>  ULONG interceptor_function;<br>  USHORT opcodes_6;  <span class="hljs-comment">// = 0xc35a</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(pop)</span><br></code></pre></td></tr></table></figure><p>关于它的作用，一图胜千言：</p><p><img src="/images/internal_thunk.png" /></p><p>通过这一thunk，就实现了先调用interceptor，interceptor返回后再回到retaddr，interceptor调用期间，多了一个参数，这个参数实际上就是originalfunction。</p><p><code>extra_argument</code>和<code>interceptor_function</code>是外部传入的，在构造<code>InternalThunk</code>对象时，填充即可。此时<code>InternalThunk</code>的payload就正确了。典型的把Data看成Code的范例。</p><p><code>InternalThunk</code>对象在<code>SetInternalThunk</code>中使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ResolverThunk::SetInternalThunk</span><span class="hljs-params">(<span class="hljs-type">void</span>* storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* original_function,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor)</span> </span>&#123;<br>  <span class="hljs-comment">// 存储thunk的空间是否放得下InternalThunk</span><br>  <span class="hljs-keyword">if</span> (storage_bytes &lt; <span class="hljs-built_in">sizeof</span>(InternalThunk))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 在thunk buffer上部署InternalThunk</span><br>  InternalThunk* thunk = <span class="hljs-built_in">new</span> (storage) InternalThunk;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(push)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(disable : 4311)</span><br>  <span class="hljs-comment">// These casts generate warnings because they are 32 bit specific.</span><br>  <span class="hljs-comment">// 这两个一填充，就达成了interceptor(original_function, xxx) -&gt; ret addr的效果</span><br>  <span class="hljs-comment">// 那么关键的就在于interceptor内部要如何处理这个extra参数了</span><br>  thunk-&gt;interceptor_function = <span class="hljs-built_in">reinterpret_cast</span>&lt;ULONG&gt;(interceptor);<br>  thunk-&gt;extra_argument = <span class="hljs-built_in">reinterpret_cast</span>&lt;ULONG&gt;(original_function);<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(pop)</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ResolverThunk::GetInternalThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(InternalThunk);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="x64-internalthunk">x64: <code>InternalThunk</code></h3><p>x64因为全盘使用的<code>g_originals</code>而非将originalfunction地址作为hook的第一个参数，所以要简单得多。只需要把interceptor地址传入即可，thunk所做的仅仅是jmp到该地址，至于interceptorfunction如何处理original function，那就是interceptor的事儿了。</p><p>这里的thunk没有动调用栈帧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InternalThunk</span> &#123;<br>  <span class="hljs-comment">// This struct contains roughly the following code:</span><br>  <span class="hljs-comment">// 01 48b8f0debc9a78563412  mov   rax,123456789ABCDEF0h</span><br>  <span class="hljs-comment">// ff e0                    jmp   rax</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The code modifies rax, but that&#x27;s fine for x64 ABI.</span><br><br>  <span class="hljs-built_in">InternalThunk</span>() &#123;<br>    mov_rax = kMovRax;<br>    jmp_rax = kJmpRax;<br>    interceptor_function = <span class="hljs-number">0</span>;<br>  &#125;;<br>  USHORT mov_rax;  <span class="hljs-comment">// = 48 B8</span><br>  ULONG_PTR interceptor_function;<br>  USHORT jmp_rax;  <span class="hljs-comment">// = ff e0</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>与x86接口一致：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ResolverThunk::SetInternalThunk</span><span class="hljs-params">(<span class="hljs-type">void</span>* storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* original_function,<span class="hljs-comment">// 没有用到</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (storage_bytes &lt; <span class="hljs-built_in">sizeof</span>(InternalThunk))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 在thunk buffer处部署了payload，关联interceptor</span><br>  InternalThunk* thunk = <span class="hljs-built_in">new</span> (storage) InternalThunk;<br>  thunk-&gt;interceptor_function = <span class="hljs-built_in">reinterpret_cast</span>&lt;ULONG_PTR&gt;(interceptor);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ResolverThunk::GetInternalThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(InternalThunk);<br>&#125;<br></code></pre></td></tr></table></figure><p>有趣的是x64的<code>ResolveTarget</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">ResolverThunk::ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">void</span>** address)</span> </span>&#123;<br>  <span class="hljs-comment">// We don&#x27;t support sidestep &amp; co.</span><br>  <span class="hljs-comment">// 看起来基类的这个函数会被sidestep类型的interception用到，而x64不支持这种类型，所以也就不实现</span><br>  <span class="hljs-comment">// 那么其他类型呢，x64总有Eat类型吧。可能Eat类型有自己的ResolveTarget override。</span><br>  <span class="hljs-keyword">return</span> STATUS_NOT_IMPLEMENTED;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，基类相关的内容都已经过了一遍，想要把Interception和Resolver挂钩，还需要逐个分析各种类型的派生类。</p><h2 id="eatresolverthunk"><code>EatResolverThunk</code></h2><p>此前我们在<code>InterceptionAgent::PatchDll</code>中看到了resolver的使用，根据前面的分析，我们知道<code>PatchDll</code>是在target进程加载感兴趣dll的时候执行的，执行期间，会根据broker传过来的<code>DllPatchInfo</code>，对该dll的所有感兴趣的function进行处理，而此时借助的就是对应类型的resolver来处理，通过Setup方法传入了相关的<code>FunctionInfo</code>信息和thunkdata在dll上的buffer（实际上就是<code>base_address</code>）。</p><p>待加载dll的<code>base_address</code>处布置了一个<code>DllInterceptionData</code>对象，它内部的<code>ThunkData</code>数组即对应所有感兴趣的函数的thunkdata，而data的实装应该是由<code>xxxResolver::Setup</code>来完成的。</p><p>我们暂且假定target要加载一个感兴趣的dll，这个dll中的感兴趣的函数既有eat类型，也有sidestep类型（target端不会有servicecall类型，这个在broker中处理）。</p><p>我们先分析Eat类型的执行流程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is the concrete resolver used to perform exports table interceptions.</span><br><span class="hljs-comment">// Eat类型是指对导出表函数的拦截？看来此前的猜想有误。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EatResolverThunk</span> : <span class="hljs-keyword">public</span> ResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">EatResolverThunk</span>() : <span class="hljs-built_in">eat_entry_</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>  ~<span class="hljs-built_in">EatResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br>  <span class="hljs-comment">// Implementation of Resolver::Setup.</span><br>  <span class="hljs-comment">// 纯虚函数的override，父类显然不清楚子类是如何把控thunk和相关info的</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span>* storage_used)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// Implementation of Resolver::ResolveTarget.</span><br>  <span class="hljs-comment">// eat类型需要这个函数，这里还要override父类函数</span><br>  <span class="hljs-comment">// 我们已经知道了父类的这个函数实际上是间接调用ResolveInterceptor</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">void</span>** address)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// Implementation of Resolver::GetThunkSize.</span><br>  <span class="hljs-comment">// 父类的这个函数是纯虚函数，这说明不同类型的interception，其thunk尺寸的计算各不相同</span><br>  <span class="hljs-comment">// 父类本身是不可能知道派生类对thunk的设计需求的，同Setup</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// The entry to patch.</span><br>  DWORD* eat_entry_;<span class="hljs-comment">// patch入口</span><br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(EatResolverThunk);<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>eat_entry_</code>是唯一的一个扩展成员，我们在下面要盯住它的使用。</p><h3 id="setup"><code>Setup</code></h3><p>看看最为关键的Setup：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">EatResolverThunk::Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">size_t</span>* storage_used)</span> </span>&#123;<br>  <span class="hljs-comment">// 先进行Init，调用父类的方法</span><br>  <span class="hljs-comment">// 回忆一下父类的流程，先是判断ThunkData这个64字节的坑够不够放下thunk data</span><br>  <span class="hljs-comment">// 对于Eat类型来说，它所需要的thunk size，对于x86就是GetInternalThunkSize()</span><br>  <span class="hljs-comment">// x64要乘2（尽管乘2也比x86小），为什么需要两次jmp呢？我们继续往下看。</span><br>  <span class="hljs-comment">// 而InternalThunk我们已经很清楚了，就是那段payload，它作为eat类型的thunk data</span><br>  <span class="hljs-comment">// 在Init内部，对Eat类型来说，ThunkData[i]这个坑位显然放得下，于是Init会继续解析出</span><br>  <span class="hljs-comment">// Interceptor的地址（如果传入的是名称的话）和Target的地址</span><br>  <span class="hljs-comment">// Interceptor没什么好说的，Eat类型的ResolveTarget做了override，使用的是导出表的那套机制</span><br>  NTSTATUS ret =<br>      <span class="hljs-built_in">Init</span>(target_module, interceptor_module, target_name, interceptor_name,<br>           interceptor_entry_point, thunk_storage, storage_bytes);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-keyword">if</span> (!eat_entry_)<br>    <span class="hljs-keyword">return</span> STATUS_INVALID_PARAMETER;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64)</span><br>  <span class="hljs-comment">// We have two thunks, in order: the return path and the forward path.</span><br>  <span class="hljs-comment">// x64有两个thunk，一来一回</span><br>  <span class="hljs-comment">// x64用不到第三个参数，在x86的设计中它表示original地址</span><br>  <span class="hljs-comment">// 这里在ThunkData[i]处先放置了第一个跳转到original地址的thunk data</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetInternalThunk</span>(thunk_storage, storage_bytes, <span class="hljs-literal">nullptr</span>, target_))<br>    <span class="hljs-keyword">return</span> STATUS_BUFFER_TOO_SMALL;<br><br>  <span class="hljs-comment">// thunk_storage向后挪动，指向需要部署第二个InternalThunk的位置</span><br>  <span class="hljs-type">size_t</span> thunk_bytes = <span class="hljs-built_in">GetInternalThunkSize</span>();<br>  storage_bytes -= thunk_bytes;<br>  thunk_storage = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(thunk_storage) + thunk_bytes;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">// 对x86来说，这里实现了interceptor_(target_, xxx)替换target(xxx)的效果</span><br>  <span class="hljs-comment">// 当外部call ThunkData[i]位置的时候，通过执行InternalThunk的指令，最后会调用interceptor_(target_, xxx)</span><br>  <span class="hljs-comment">// 当然这种机制依赖两个外部条件：</span><br>  <span class="hljs-comment">// 1. interceptor要外部提供，利用上origin参数</span><br>  <span class="hljs-comment">// 2. 在调用一个函数时，不直接call target而是call ThunkData[i]</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// 对x64来说，这里相当于第二次设置，第三个参数是没意义的，仅仅是把jmp interceptor_放在了</span><br>  <span class="hljs-comment">// 第一个InternalThunk(jmp original)的正后方</span><br>  <span class="hljs-comment">// 这样看来x64的thunk比较奇怪，应该是call ThunkData[i]+sizeof(InternalThunk)去调用</span><br>  <span class="hljs-comment">// interceptor，interceptor内部再去call ThunkData[i]来调用original</span><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetInternalThunk</span>(thunk_storage, storage_bytes, target_, interceptor_))<br>    <span class="hljs-keyword">return</span> STATUS_BUFFER_TOO_SMALL;<br><br>  AutoProtectMemory memory;<br>  ret = memory.<span class="hljs-built_in">ChangeProtection</span>(eat_entry_, <span class="hljs-built_in">sizeof</span>(DWORD), PAGE_READWRITE);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// Perform the patch.</span><br>  <span class="hljs-comment">// 看到这里就明白了为什么x64要把jmp original放在前面</span><br>  <span class="hljs-comment">// 无论是x64还是x86，此时eat_entry是original函数的导出表地址，我们只需要把这个导出表地址</span><br>  <span class="hljs-comment">// 替换成Interceptor的地址就行了。</span><br>  <span class="hljs-comment">// 这里就解决了上面的一个外部条件的达成：调用dll导出表函数时，此后不会call target，而是</span><br>  <span class="hljs-comment">// call ThunkData[i]，此外之所以要减去基地址是因为导出表存的是RVA</span><br>  *eat_entry_ = <span class="hljs-built_in">static_cast</span>&lt;DWORD&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(thunk_storage)) -<br>                <span class="hljs-built_in">static_cast</span>&lt;DWORD&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(target_module));<br><br>  <span class="hljs-comment">// OUT型参数回置使用的thunk data大小</span><br>  <span class="hljs-keyword">if</span> (storage_used)<br>    *storage_used = <span class="hljs-built_in">GetThunkSize</span>();<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="resolvetarget"><code>ResolveTarget</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">EatResolverThunk::ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         <span class="hljs-type">void</span>** address)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_NT</span>(address);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">module</span>)<br>    <span class="hljs-keyword">return</span> STATUS_INVALID_PARAMETER;<br><br>  base::<span class="hljs-function">win::PEImage <span class="hljs-title">pe</span><span class="hljs-params">(<span class="hljs-keyword">module</span>)</span></span>;<br>  <span class="hljs-keyword">if</span> (!pe.<span class="hljs-built_in">VerifyMagic</span>())<br>    <span class="hljs-keyword">return</span> STATUS_INVALID_IMAGE_FORMAT;<br><br>  <span class="hljs-comment">// 直接从导出表拿了，所以eat_entry是导出表中的地址，是个RVA</span><br>  <span class="hljs-comment">// 而该函数是在Init时调用的，这说明eat_entry_已经有值了</span><br>  eat_entry_ = pe.<span class="hljs-built_in">GetExportEntry</span>(function_name);<br><br>  <span class="hljs-keyword">if</span> (!eat_entry_)<br>    <span class="hljs-keyword">return</span> STATUS_PROCEDURE_NOT_FOUND;<br><br>  <span class="hljs-comment">// RVA到addr，给回address，实际上address就是original函数地址</span><br>  *address = pe.<span class="hljs-built_in">RVAToAddr</span>(*eat_entry_);<br><br>  <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>所以，我们此前对Eat类型的猜想是错误的。Eat类型实际上是用于处理Dll导出表函数的resolver，它的做法是用<code>InternalThunk</code>来部署<code>interceptor</code>，并且把它的地址RVA替换导出表的函数地址，以实现interception。</strong></p><h2 id="sidestepresolverthunk"><code>SidestepResolverThunk</code></h2><p>在target中，x86还会用到两种Resolver，分别是<code>SidestepResolverThunk</code>和<code>SmartSidestepResolverThunk</code>。</p><p>先看一下头：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is the concrete resolver used to perform sidestep interceptions.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SidestepResolverThunk</span> : <span class="hljs-keyword">public</span> ResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">SidestepResolverThunk</span>() &#123;&#125;<br>  ~<span class="hljs-built_in">SidestepResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br>  <span class="hljs-comment">// Setup和GetThunkSize作为两大核心接口，是子类必须override的纯虚函数</span><br>  <span class="hljs-comment">// Implementation of Resolver::Setup.</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span>* storage_used)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// Implementation of Resolver::GetThunkSize.</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(SidestepResolverThunk);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="getthunksize"><code>GetThunkSize</code></h3><p>在分析之前，我们还是得先看看sidestep使用的Thunk是什么。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">SidestepResolverThunk::GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-comment">// 除了InternalThunk以外，还有一个额外的kSizeOfSidestepStub，这个值是32</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetInternalThunkSize</span>() + kSizeOfSidestepStub;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么额外的32个字节是用来干什么的呢？根据注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Maximum size of the preamble stub. We overwrite at least the first 5</span><br><span class="hljs-comment">// bytes of the function. Considering the worst case scenario, we need 4</span><br><span class="hljs-comment">// bytes + the max instruction size + 5 more bytes for our jump back to</span><br><span class="hljs-comment">// the original code. With that in mind, 32 is a good number :)</span><br><span class="hljs-comment">// 所以看起来sidestep是inline hook，它会覆盖original头至少5个字节。</span><br><span class="hljs-comment">// 最坏的情况下，我们需要4个字节 + 最大指令长度 + 用于跳回到original代码的5个额外字节</span><br><span class="hljs-comment">// 为了对齐就用了32.</span><br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kMaxPreambleStubSize = <span class="hljs-number">32</span>;<br></code></pre></td></tr></table></figure><h3 id="setup-1"><code>Setup</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">SidestepResolverThunk::Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">size_t</span>* storage_used)</span> </span>&#123;<br>  <span class="hljs-comment">// 常规init，注意sidestep类型没有自己override ResolveTarget，使用的是父类的函数</span><br>  <span class="hljs-comment">// 而这个函数和ResolveInterception是一样的，通过GetProcAddress取得</span><br>  NTSTATUS ret =<br>      <span class="hljs-built_in">Init</span>(target_module, interceptor_module, target_name, interceptor_name,<br>           interceptor_entry_point, thunk_storage, storage_bytes);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// sidestep类型的resolver，把传入的ThunkData[i]存储空间看成SidestepThunk</span><br>  <span class="hljs-comment">// 为什么要设计个类型呢？从GetThunkSize中我们就可以看到，sidestep的ThunkData由两部分构成</span><br>  <span class="hljs-comment">// 前32个字节是inline stub，ThunkData[i]的32个字节之后存储InternalThunk</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  struct SidestepThunk &#123;</span><br><span class="hljs-comment">      char sidestep[kSizeOfSidestepStub];  // Storage for the sidestep stub.</span><br><span class="hljs-comment">      int internal_thunk;  // Dummy member to the beginning of the internal thunk.</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">  */</span><br>  SidestepThunk* thunk = <span class="hljs-built_in">reinterpret_cast</span>&lt;SidestepThunk*&gt;(thunk_storage);<br><br>  <span class="hljs-type">size_t</span> internal_bytes = storage_bytes - kSizeOfSidestepStub;<br>  <span class="hljs-comment">// 别担心，SetInternalThunk内部会检查剩余的空间够不够存放InternalThunk，这里64-32=32是够放的</span><br>  <span class="hljs-comment">// 调用后，32个字节之后的InternalThunk就安排好了</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetInternalThunk</span>(&amp;thunk-&gt;internal_thunk, internal_bytes, thunk_storage,<br>                        interceptor_))<br>    <span class="hljs-keyword">return</span> STATUS_BUFFER_TOO_SMALL;<br><br>  AutoProtectMemory memory;<br>  ret = memory.<span class="hljs-built_in">ChangeProtection</span>(target_, kSizeOfSidestepStub, PAGE_READWRITE);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// 前面32个字节的处理借助了PreamblePatcher这个对象的Patch方法</span><br>  <span class="hljs-comment">// 我们下面展开来看他的用途</span><br>  sidestep::SideStepError rv = sidestep::PreamblePatcher::<span class="hljs-built_in">Patch</span>(<br>      target_, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;thunk-&gt;internal_thunk), thunk_storage,<br>      kSizeOfSidestepStub);<br><br>  <span class="hljs-keyword">if</span> (sidestep::SIDESTEP_INSUFFICIENT_BUFFER == rv)<br>    <span class="hljs-keyword">return</span> STATUS_BUFFER_TOO_SMALL;<br><br>  <span class="hljs-keyword">if</span> (sidestep::SIDESTEP_SUCCESS != rv)<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br><br>  <span class="hljs-keyword">if</span> (storage_used)<br>    *storage_used = <span class="hljs-built_in">GetThunkSize</span>();<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="preamblepatcher"><code>PreamblePatcher</code></h3><p>命名空间是<code>sidestep</code>，很明显是供sidestepresolver自身使用的helper接口。先看一下头部定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Implements a patching mechanism that overwrites the first few bytes of</span><br><span class="hljs-comment">// a function preamble with a jump to our hook function, which is then</span><br><span class="hljs-comment">// able to call the original function via a specially-made preamble-stub</span><br><span class="hljs-comment">// that imitates the action of the original preamble.</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// inline hook的局限性与危险性说明：</span><br><span class="hljs-comment">// Note that there are a number of ways that this method of patching can</span><br><span class="hljs-comment">// fail.  The most common are:</span><br><span class="hljs-comment">//    - If there is a jump (jxx) instruction in the first 5 bytes of</span><br><span class="hljs-comment">//    the function being patched, we cannot patch it because in the</span><br><span class="hljs-comment">//    current implementation we do not know how to rewrite relative</span><br><span class="hljs-comment">//    jumps after relocating them to the preamble-stub.  Note that</span><br><span class="hljs-comment">//    if you really really need to patch a function like this, it</span><br><span class="hljs-comment">//    would be possible to add this functionality (but at some cost).</span><br><span class="hljs-comment">//    - If there is a return (ret) instruction in the first 5 bytes</span><br><span class="hljs-comment">//    we cannot patch the function because it may not be long enough</span><br><span class="hljs-comment">//    for the jmp instruction we use to inject our patch.</span><br><span class="hljs-comment">//    - If there is another thread currently executing within the bytes</span><br><span class="hljs-comment">//    that are copied to the preamble stub, it will crash in an undefined</span><br><span class="hljs-comment">//    way.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If you get any other error than the above, you&#x27;re either pointing the</span><br><span class="hljs-comment">// patcher at an invalid instruction (e.g. into the middle of a multi-</span><br><span class="hljs-comment">// byte instruction, or not at memory containing executable instructions)</span><br><span class="hljs-comment">// or, there may be a bug in the disassembler we use to find</span><br><span class="hljs-comment">// instruction boundaries.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PreamblePatcher</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Patches target_function to point to replacement_function using a provided</span><br>  <span class="hljs-comment">// preamble_stub of stub_size bytes.</span><br>  <span class="hljs-comment">// Returns An error code indicating the result of patching.</span><br>  <span class="hljs-comment">// 函数模板，其实target_function和replacement_function都设void *应该就可以</span><br>  <span class="hljs-comment">// 我没有get到为什么要设一个模板在这里，为了便于扩展？</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>  <span class="hljs-function"><span class="hljs-type">static</span> SideStepError <span class="hljs-title">Patch</span><span class="hljs-params">(T target_function,</span></span><br><span class="hljs-params"><span class="hljs-function">                             T replacement_function,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">void</span>* preamble_stub,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">size_t</span> stub_size)</span> </span>&#123;<br>    <span class="hljs-comment">// 而且这个函数不是模板，是明确的参数void *</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">RawPatchWithStub</span>(target_function, replacement_function,<br>                            <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(preamble_stub),<br>                            stub_size, <span class="hljs-literal">nullptr</span>);<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Patches a function by overwriting its first few bytes with</span><br>  <span class="hljs-comment">// a jump to a different function.  This is similar to the RawPatch</span><br>  <span class="hljs-comment">// function except that it uses the stub allocated by the caller</span><br>  <span class="hljs-comment">// instead of allocating it.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// To use this function, you first have to call VirtualProtect to make the</span><br>  <span class="hljs-comment">// target function writable at least for the duration of the call.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// target_function: A pointer to the function that should be</span><br>  <span class="hljs-comment">// patched.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// replacement_function: A pointer to the function that should</span><br>  <span class="hljs-comment">// replace the target function.  The replacement function must have</span><br>  <span class="hljs-comment">// exactly the same calling convention and parameters as the original</span><br>  <span class="hljs-comment">// function.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// preamble_stub: A pointer to a buffer where the preamble stub</span><br>  <span class="hljs-comment">// should be copied. The size of the buffer should be sufficient to</span><br>  <span class="hljs-comment">// hold the preamble bytes.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// stub_size: Size in bytes of the buffer allocated for the</span><br>  <span class="hljs-comment">// preamble_stub</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// bytes_needed: Pointer to a variable that receives the minimum</span><br>  <span class="hljs-comment">// number of bytes required for the stub.  Can be set to nullptr if you&#x27;re</span><br>  <span class="hljs-comment">// not interested.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Returns An error code indicating the result of patching.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> SideStepError <span class="hljs-title">RawPatchWithStub</span><span class="hljs-params">(<span class="hljs-type">void</span>* target_function,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* replacement_function,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* preamble_stub,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">size_t</span> stub_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">size_t</span>* bytes_needed)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>展开看看<code>RawPatchWithStub</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SideStepError <span class="hljs-title">PreamblePatcher::RawPatchWithStub</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span>* target_function,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span>* replacement_function,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* preamble_stub,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">size_t</span> stub_size,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">size_t</span>* bytes_needed)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-literal">NULL</span> == target_function) ||<br>      (<span class="hljs-literal">NULL</span> == replacement_function) ||<br>      (<span class="hljs-literal">NULL</span> == preamble_stub)) &#123;<br>    <span class="hljs-built_in">ASSERT</span>(<span class="hljs-literal">false</span>, (<span class="hljs-string">L&quot;Invalid parameters - either pTargetFunction or &quot;</span><br>                   <span class="hljs-string">L&quot;pReplacementFunction or pPreambleStub were NULL.&quot;</span>));<br>    <span class="hljs-keyword">return</span> SIDESTEP_INVALID_PARAMETER;<br>  &#125;<br><br>  <span class="hljs-comment">// TODO(V7:joi) Siggi and I just had a discussion and decided that both</span><br>  <span class="hljs-comment">// patching and unpatching are actually unsafe.  We also discussed a</span><br>  <span class="hljs-comment">// method of making it safe, which is to freeze all other threads in the</span><br>  <span class="hljs-comment">// process, check their thread context to see if their eip is currently</span><br>  <span class="hljs-comment">// inside the block of instructions we need to copy to the stub, and if so</span><br>  <span class="hljs-comment">// wait a bit and try again, then unfreeze all threads once we&#x27;ve patched.</span><br>  <span class="hljs-comment">// Not implementing this for now since we&#x27;re only using SideStep for unit</span><br>  <span class="hljs-comment">// testing, but if we ever use it for production code this is what we</span><br>  <span class="hljs-comment">// should do.</span><br>  <span class="hljs-comment">// 这个sidestep目前还没有投入到产品，所以线程的安全性处理还没做，开发者还是很谨小慎微的</span><br>  <span class="hljs-comment">// 说不定这个东西问世的时候会带来安全隐患</span><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Stoyan suggests we can write 8 or even 10 bytes atomically using</span><br>  <span class="hljs-comment">// FPU instructions, and on newer processors we could use cmpxchg8b or</span><br>  <span class="hljs-comment">// cmpxchg16b. So it might be possible to do the patching/unpatching</span><br>  <span class="hljs-comment">// atomically and avoid having to freeze other threads.  Note though, that</span><br>  <span class="hljs-comment">// doing it atomically does not help if one of the other threads happens</span><br>  <span class="hljs-comment">// to have its eip in the middle of the bytes you change while you change</span><br>  <span class="hljs-comment">// them.</span><br>  <span class="hljs-comment">// original函数地址</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* target = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(target_function);<br><br>  <span class="hljs-comment">// Let&#x27;s disassemble the preamble of the target function to see if we can</span><br>  <span class="hljs-comment">// patch, and to see how much of the preamble we need to take.  We need 5</span><br>  <span class="hljs-comment">// bytes for our jmp instruction, so let&#x27;s find the minimum number of</span><br>  <span class="hljs-comment">// instructions to get 5 bytes.</span><br>  <span class="hljs-comment">// 通过反汇编original函数来看看是否能够patch，需要patch多少个字节。</span><br>  <span class="hljs-comment">// 注意jmp指令需要5个字节</span><br>  MiniDisassembler disassembler;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> preamble_bytes = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (preamble_bytes &lt; <span class="hljs-number">5</span>) &#123;<br>    InstructionType instruction_type =<br>      disassembler.<span class="hljs-built_in">Disassemble</span>(target + preamble_bytes, &amp;preamble_bytes);<br>    <span class="hljs-keyword">if</span> (IT_JUMP == instruction_type) &#123;<br>      <span class="hljs-comment">// 如果前5个字节有jmp系列指令，是没办法hook的</span><br>      <span class="hljs-built_in">ASSERT</span>(<span class="hljs-literal">false</span>, (<span class="hljs-string">L&quot;Unable to patch because there is a jump instruction &quot;</span><br>                     <span class="hljs-string">L&quot;in the first 5 bytes.&quot;</span>));<br>      <span class="hljs-keyword">return</span> SIDESTEP_JUMP_INSTRUCTION;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (IT_RETURN == instruction_type) &#123;<br>      <span class="hljs-comment">// 如果前5个字节有ret系列指令，那么函数太短了，不够patch一个jmp</span><br>      <span class="hljs-built_in">ASSERT</span>(<span class="hljs-literal">false</span>, (<span class="hljs-string">L&quot;Unable to patch because function is too short&quot;</span>));<br>      <span class="hljs-keyword">return</span> SIDESTEP_FUNCTION_TOO_SMALL;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (IT_GENERIC != instruction_type) &#123;<br>      <span class="hljs-comment">// 这种是异端的情况，指令不认识。。。</span><br>      <span class="hljs-built_in">ASSERT</span>(<span class="hljs-literal">false</span>, (<span class="hljs-string">L&quot;Disassembler encountered unsupported instruction &quot;</span><br>                     <span class="hljs-string">L&quot;(either unused or unknown&quot;</span>));<br>      <span class="hljs-keyword">return</span> SIDESTEP_UNSUPPORTED_INSTRUCTION;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 这个作为OUT型参数返回需要用到的字节数，5表示额外的jmp指令字节数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != bytes_needed)<br>    *bytes_needed = preamble_bytes + <span class="hljs-number">5</span>;<br><br>  <span class="hljs-comment">// Inv: preamble_bytes is the number of bytes (at least 5) that we need to</span><br>  <span class="hljs-comment">// take from the preamble to have whole instructions that are 5 bytes or more</span><br>  <span class="hljs-comment">// in size total. The size of the stub required is cbPreamble + size of</span><br>  <span class="hljs-comment">// jmp (5)</span><br>  <span class="hljs-keyword">if</span> (preamble_bytes + <span class="hljs-number">5</span> &gt; stub_size) &#123;<br>    <span class="hljs-built_in">NOTREACHED_NT</span>();<br>    <span class="hljs-keyword">return</span> SIDESTEP_INSUFFICIENT_BUFFER;<br>  &#125;<br><br>  <span class="hljs-comment">// First, copy the preamble that we will overwrite.</span><br>  <span class="hljs-comment">// 把要被覆盖的首字节序列copy出来，这个RawMemcpy是逐字节copy，没有用crt</span><br>  <span class="hljs-built_in">RawMemcpy</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(preamble_stub),<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(target), preamble_bytes);<br><br>  <span class="hljs-comment">// Now, make a jmp instruction to the rest of the target function (minus the</span><br>  <span class="hljs-comment">// preamble bytes we moved into the stub) and copy it into our preamble-stub.</span><br>  <span class="hljs-comment">// find address to jump to, relative to next address after jmp instruction</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(push)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(disable:4244)</span><br>  <span class="hljs-comment">// This assignment generates a warning because it is 32 bit specific.</span><br>  <span class="hljs-comment">// 计算original剩下的指令相对preamble_stub+preamble_bytes+5的偏移</span><br>  <span class="hljs-type">int</span> relative_offset_to_target_rest<br>    = ((<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(target) + preamble_bytes) -<br>        (preamble_stub + preamble_bytes + <span class="hljs-number">5</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(pop)</span><br>  <span class="hljs-comment">// jmp (Jump near, relative, displacement relative to next instruction)</span><br>  <span class="hljs-comment">// 这里放上jmp</span><br>  preamble_stub[preamble_bytes] = ASM_JMP32REL;<br>  <span class="hljs-comment">// copy the address</span><br>  <span class="hljs-comment">// jmp后跟上4个字节的相对跳转地址，此时jmp就跳到了overwrite之后的rest code</span><br>  <span class="hljs-built_in">RawMemcpy</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(preamble_stub + preamble_bytes + <span class="hljs-number">1</span>),<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;relative_offset_to_target_rest), <span class="hljs-number">4</span>);<br><br>  <span class="hljs-comment">// Inv: preamble_stub points to assembly code that will execute the</span><br>  <span class="hljs-comment">// original function by first executing the first cbPreamble bytes of the</span><br>  <span class="hljs-comment">// preamble, then jumping to the rest of the function.</span><br><br>  <span class="hljs-comment">// Overwrite the first 5 bytes of the target function with a jump to our</span><br>  <span class="hljs-comment">// replacement function.</span><br>  <span class="hljs-comment">// (Jump near, relative, displacement relative to next instruction)</span><br>  <span class="hljs-comment">// 修改original起始地址，做出一个jmp</span><br>  target[<span class="hljs-number">0</span>] = ASM_JMP32REL;<br><br>  <span class="hljs-comment">// Find offset from instruction after jmp, to the replacement function.</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(push)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(disable:4244)</span><br>  <span class="hljs-type">int</span> offset_to_replacement_function =<br>    <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(replacement_function) -<br>    <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(target) - <span class="hljs-number">5</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(pop)</span><br>  <span class="hljs-comment">// complete the jmp instruction</span><br>  <span class="hljs-built_in">RawMemcpy</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(target + <span class="hljs-number">1</span>),<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;offset_to_replacement_function), <span class="hljs-number">4</span>);<br>  <span class="hljs-comment">// 此时original的入口就变成了jmp到InternalThunk处</span><br>  <span class="hljs-comment">// Set any remaining bytes that were moved to the preamble-stub to INT3 so</span><br>  <span class="hljs-comment">// as not to cause confusion (otherwise you might see some strange</span><br>  <span class="hljs-comment">// instructions if you look at the disassembly, or even invalid</span><br>  <span class="hljs-comment">// instructions). Also, by doing this, we will break into the debugger if</span><br>  <span class="hljs-comment">// some code calls into this portion of the code.  If this happens, it</span><br>  <span class="hljs-comment">// means that this function cannot be patched using this patcher without</span><br>  <span class="hljs-comment">// further thought.</span><br>  <span class="hljs-comment">// 如果overwrite的字节数比5要多，就用0xcc填充剩下的部分</span><br>  <span class="hljs-keyword">if</span> (preamble_bytes &gt; <span class="hljs-number">5</span>) &#123;<br>    <span class="hljs-built_in">RawMemset</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(target + <span class="hljs-number">5</span>), ASM_INT3,<br>              preamble_bytes - <span class="hljs-number">5</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Inv: The memory pointed to by target_function now points to a relative</span><br>  <span class="hljs-comment">// jump instruction that jumps over to the preamble_stub.  The preamble</span><br>  <span class="hljs-comment">// stub contains the first stub_size bytes of the original target</span><br>  <span class="hljs-comment">// function&#x27;s preamble code, followed by a relative jump back to the next</span><br>  <span class="hljs-comment">// instruction after the first cbPreamble bytes.</span><br><br>  <span class="hljs-keyword">return</span> SIDESTEP_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>至于<code>MiniDisassembler</code>就不展开分析了，起始看到这里，已经明白了这个sidestep类型的resolver是如何patch的了。实际上，就是对原始的函数进行了inlinehook，此后，当calloriginal时，会jmp到<code>InternalThunk</code>，而<code>InternalThunk</code>中的<code>extra_argument</code>实际上是<code>ThunkData[i]</code>前面的32个字节，也就是copy出来的<code>preamble_stub</code>+<code>jmp original_rest</code>，当<code>interceptor_</code>执行完毕后再调用original时，就会找到这里执行copy出来的original原本的首指令序列并jmp到rest部分。</p><p>可以看出这个sidestep实现的inline hook非常的复杂。</p><h2id="smartsidestepresolverthunk"><code>SmartSidestepResolverThunk</code></h2><p>还有个以sidestep类型为基础的smart_sidestep类型。我们一并看了吧，找找不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is the concrete resolver used to perform smart sidestep interceptions.</span><br><span class="hljs-comment">// This means basically a sidestep interception that skips the interceptor when</span><br><span class="hljs-comment">// the caller resides on the same dll being intercepted. It is intended as</span><br><span class="hljs-comment">// a helper only, because that determination is not infallible.</span><br><span class="hljs-comment">// SidestepResolverThunk的派生类</span><br><span class="hljs-comment">// 看起来是当call的发起者与被拦截的dll是同一个时，会跳过interceptor的执行</span><br><span class="hljs-comment">// 也就是说dll本体上的调用不会触发hook</span><br><span class="hljs-comment">// 好吧，我们此前猜测的完全不对。。。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartSidestepResolverThunk</span> : <span class="hljs-keyword">public</span> SidestepResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">SmartSidestepResolverThunk</span>() &#123;&#125;<br>  ~<span class="hljs-built_in">SmartSidestepResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br>  <span class="hljs-comment">// Implementation of Resolver::Setup.</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span>* storage_used)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// Implementation of Resolver::GetThunkSize.</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Performs the actual call to the interceptor if the conditions are correct</span><br>  <span class="hljs-comment">// (as determined by IsInternalCall).</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SmartStub</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Returns true if return_address is inside the module loaded at base.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">IsInternalCall</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* base, <span class="hljs-type">void</span>* return_address)</span></span>;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(SmartSidestepResolverThunk);<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看出来这个类多了两个private函数用于判断caller是内部还是外部以及stub的处理。</p><p>先看看两个private：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SmartSidestepResolverThunk::IsInternalCall</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* base,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">void</span>* return_address)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_NT</span>(base);<br>  <span class="hljs-built_in">DCHECK_NT</span>(return_address);<br><br>  <span class="hljs-comment">// 其实很简单，找找address是否在该PE上就知道了</span><br>  base::<span class="hljs-function">win::PEImage <span class="hljs-title">pe</span><span class="hljs-params">(base)</span></span>;<br>  <span class="hljs-keyword">if</span> (pe.<span class="hljs-built_in">GetImageSectionFromAddr</span>(return_address))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// This code must basically either call the intended interceptor or skip the</span><br><span class="hljs-comment">// call and invoke instead the original function. In any case, we are saving</span><br><span class="hljs-comment">// the registers that may be trashed by our c++ code.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function is called with a first parameter inserted by us, that points</span><br><span class="hljs-comment">// to our SmartThunk. When we call the interceptor we have to replace this</span><br><span class="hljs-comment">// parameter with the one expected by that function (stored inside our</span><br><span class="hljs-comment">// structure); on the other hand, when we skip the interceptor we have to remove</span><br><span class="hljs-comment">// that extra argument before calling the original function.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// When we skip the interceptor, the transformation of the stack looks like:</span><br><span class="hljs-comment">//  On Entry:                         On Use:                     On Exit:</span><br><span class="hljs-comment">//  [param 2] = first real argument   [param 2] (esp+1c)          [param 2]</span><br><span class="hljs-comment">//  [param 1] = our SmartThunk        [param 1] (esp+18)          [ret address]</span><br><span class="hljs-comment">//  [ret address] = real caller       [ret address] (esp+14)      [xxx]</span><br><span class="hljs-comment">//  [xxx]                             [addr to jump to] (esp+10)  [xxx]</span><br><span class="hljs-comment">//  [xxx]                             [saved eax]                 [xxx]</span><br><span class="hljs-comment">//  [xxx]                             [saved ebx]                 [xxx]</span><br><span class="hljs-comment">//  [xxx]                             [saved ecx]                 [xxx]</span><br><span class="hljs-comment">//  [xxx]                             [saved edx]                 [xxx]</span><br>__declspec(naked)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SmartSidestepResolverThunk::SmartStub</span><span class="hljs-params">()</span> </span>&#123;<br>  __asm &#123;<br>    push eax                  <span class="hljs-comment">// Space for the jump.</span><br>    push eax                  <span class="hljs-comment">// Save registers.</span><br>    push ebx<br>    push ecx<br>    push edx<br>    mov ebx, [esp + <span class="hljs-number">0x18</span>]     <span class="hljs-comment">// First parameter = SmartThunk.</span><br>    mov edx, [esp + <span class="hljs-number">0x14</span>]     <span class="hljs-comment">// Get the return address.</span><br>    mov eax, [ebx]SmartThunk.module_base<br>    push edx<br>    push eax<br>    call SmartSidestepResolverThunk::IsInternalCall<span class="hljs-comment">// 这里判断一下是否是internal</span><br>    add esp, <span class="hljs-number">8</span><br><br>    test eax, eax  <span class="hljs-comment">// 如果是的话，就直接call original就行了</span><br>    lea edx, [ebx]SmartThunk.sidestep   <span class="hljs-comment">// The original function. 盯住这个edx</span><br>    jz call_interceptor   <span class="hljs-comment">// 如果不是internal，就得部署interceptor</span><br><br>    <span class="hljs-comment">// Skip this call</span><br>    mov ecx, [esp + <span class="hljs-number">0x14</span>]               <span class="hljs-comment">// Return address.</span><br>    mov [esp + <span class="hljs-number">0x18</span>], ecx               <span class="hljs-comment">// Remove first parameter.</span><br>    mov [esp + <span class="hljs-number">0x10</span>], edx   <span class="hljs-comment">// edx是original function，这个位置作为ret时的返回地址</span><br>    pop edx                             <span class="hljs-comment">// Restore registers.</span><br>    pop ecx<br>    pop ebx<br>    pop eax<br>    ret <span class="hljs-number">4</span>                               <span class="hljs-comment">// Jump to original function.</span><br><br>  call_interceptor:<br>    mov ecx, [ebx]SmartThunk.interceptor<br>    mov [esp + <span class="hljs-number">0x18</span>], edx               <span class="hljs-comment">// Replace first parameter. orignal地址成了第一个参数</span><br>    mov [esp + <span class="hljs-number">0x10</span>], ecx<span class="hljs-comment">// interceptor地址变成了ret addr</span><br>    pop edx                             <span class="hljs-comment">// Restore registers.</span><br>    pop ecx<br>    pop ebx<br>    pop eax<br>    ret                                 <span class="hljs-comment">// Jump to original function. 这个理应是jmp interceptor</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实看了这些就基本理清了，展开<code>GetThunkSize</code>和<code>Setup</code>印证一下想法：</p><h3 id="getthunksize-1"><code>GetThunkSize</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">SmartSidestepResolverThunk::GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetInternalThunkSize</span>() + kSizeOfSidestepStub +<br>         <span class="hljs-built_in">offsetof</span>(SmartThunk, sidestep);<span class="hljs-comment">// SmartThunk包含了SidestepThunk</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SmartThunk</span> &#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* module_base;  <span class="hljs-comment">// Target module&#x27;s base.</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor;  <span class="hljs-comment">// Real interceptor.</span><br>  SidestepThunk sidestep;   <span class="hljs-comment">// Standard sidestep thunk.</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="setup-2"><code>Setup</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is basically a wrapper around the normal sidestep patch that extends</span><br><span class="hljs-comment">// the thunk to use a chained interceptor. It uses the fact that</span><br><span class="hljs-comment">// SetInternalThunk generates the code to pass as the first parameter whatever</span><br><span class="hljs-comment">// it receives as original_function; we let SidestepResolverThunk set this value</span><br><span class="hljs-comment">// to its saved code, and then we change it to our thunk data.</span><br><span class="hljs-function">NTSTATUS <span class="hljs-title">SmartSidestepResolverThunk::Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">size_t</span>* storage_used)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (storage_bytes &lt; <span class="hljs-built_in">GetThunkSize</span>())<br>    <span class="hljs-keyword">return</span> STATUS_BUFFER_TOO_SMALL;<br><br>  <span class="hljs-comment">// 看出SmartThunk，填充module_base，SmartStub中会用到</span><br>  SmartThunk* thunk = <span class="hljs-built_in">reinterpret_cast</span>&lt;SmartThunk*&gt;(thunk_storage);<br>  thunk-&gt;module_base = target_module;<br><br>  NTSTATUS ret;<br>  <span class="hljs-comment">// 填充interceptor，SmartStub中会用到</span><br>  <span class="hljs-keyword">if</span> (interceptor_entry_point) &#123;<br>    thunk-&gt;interceptor = interceptor_entry_point;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ret = <span class="hljs-built_in">ResolveInterceptor</span>(interceptor_module, interceptor_name,<br>                             &amp;thunk-&gt;interceptor);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>      <span class="hljs-keyword">return</span> ret;<br>  &#125;<br><br>  <span class="hljs-comment">// Perform a standard sidestep patch on the last part of the thunk, but point</span><br>  <span class="hljs-comment">// to our internal smart interceptor.</span><br>  <span class="hljs-type">size_t</span> standard_bytes = storage_bytes - <span class="hljs-built_in">offsetof</span>(SmartThunk, sidestep);<br>  <span class="hljs-comment">// SmartThunk的SodestepThunk的填充和基类SidestepResolverThunk一致</span><br>  <span class="hljs-comment">// 但注意interceptor_entry_point此时不再是interceptor的地址，而是SmartStub地址</span><br>  <span class="hljs-comment">// 相当于在interceptor的基础上用SmartStub又拦了一次，而SmartStub会根据internal caller</span><br>  <span class="hljs-comment">// 的判断跳转到interceptor的分支或original分支，interceptor在thunk_storage中记录了</span><br>  ret = SidestepResolverThunk::<span class="hljs-built_in">Setup</span>(target_module, interceptor_module,<br>                                     target_name, <span class="hljs-literal">nullptr</span>,<br>                                     <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;SmartStub),<br>                                     &amp;thunk-&gt;sidestep, standard_bytes, <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// Fix the internal thunk to pass the whole buffer to the interceptor.</span><br>  <span class="hljs-comment">// 这里SmartStub地址作为了拦截器，而原本的一大坨thunk_storage作为original，它相当于一个代理</span><br>  <span class="hljs-built_in">SetInternalThunk</span>(&amp;thunk-&gt;sidestep.internal_thunk, <span class="hljs-built_in">GetInternalThunkSize</span>(),<br>                   thunk_storage, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;SmartStub));<br><br>  <span class="hljs-keyword">if</span> (storage_used)<br>    *storage_used = <span class="hljs-built_in">GetThunkSize</span>();<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="serviceresolverthunk"><code>ServiceResolverThunk</code></h2><p>我们分析过了三种target进程使用的Resolver，还有一种broker使用的Resolver类型——系统调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is the concrete resolver used to perform service-call type functions</span><br><span class="hljs-comment">// inside ntdll.dll.</span><br><span class="hljs-comment">// 用于执行ntdll中的系统调用类型函数的拦截</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceResolverThunk</span> : <span class="hljs-keyword">public</span> ResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// The service resolver needs a child process to write to.</span><br>  <span class="hljs-built_in">ServiceResolverThunk</span>(HANDLE process, <span class="hljs-type">bool</span> relaxed)<br>      : <span class="hljs-built_in">ntdll_base_</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">process_</span>(process),<br>        <span class="hljs-built_in">relaxed_</span>(relaxed),<br>        <span class="hljs-built_in">relative_jump_</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>  ~<span class="hljs-built_in">ServiceResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br>  <span class="hljs-comment">// Implementation of Resolver::Setup.</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span>* storage_used)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// 可以看到两个resolve都override了</span><br>  <span class="hljs-comment">// Implementation of Resolver::ResolveInterceptor.</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">ResolveInterceptor</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> <span class="hljs-type">void</span>** address)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// Implementation of Resolver::ResolveTarget.</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">void</span>** address)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// Implementation of Resolver::GetThunkSize.</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// 这几个居然还是virtual，看来还有派生类</span><br>  <span class="hljs-comment">// Call this to set up ntdll_base_ which will allow for local patches.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">AllowLocalPatches</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Verifies that the function specified by |target_name| in |target_module| is</span><br>  <span class="hljs-comment">// a service and copies the data from that function into |thunk_storage|. If</span><br>  <span class="hljs-comment">// |storage_bytes| is too small, then the method fails.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> NTSTATUS <span class="hljs-title">CopyThunk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             BYTE* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">size_t</span>* storage_used)</span></span>;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// The unit test will use this member to allow local patch on a buffer.</span><br>  HMODULE ntdll_base_;<br><br>  <span class="hljs-comment">// Handle of the child process.</span><br>  HANDLE process_;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Returns true if the code pointer by target_ corresponds to the expected</span><br>  <span class="hljs-comment">// type of function. Saves that code on the first part of the thunk pointed</span><br>  <span class="hljs-comment">// by local_thunk (should be directly accessible from the parent).</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">IsFunctionAService</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Performs the actual patch of target_.</span><br>  <span class="hljs-comment">// local_thunk must be already fully initialized, and the first part must</span><br>  <span class="hljs-comment">// contain the original code. The real type of this buffer is ServiceFullThunk</span><br>  <span class="hljs-comment">// (yes, private). remote_thunk (real type ServiceFullThunk), must be</span><br>  <span class="hljs-comment">// allocated on the child, and will contain the thunk data, after this call.</span><br>  <span class="hljs-comment">// Returns the apropriate status code.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> NTSTATUS <span class="hljs-title">PerformPatch</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk, <span class="hljs-type">void</span>* remote_thunk)</span></span>;<br><br>  <span class="hljs-comment">// Provides basically the same functionality as IsFunctionAService but it</span><br>  <span class="hljs-comment">// continues even if it does not recognize the function code. remote_thunk</span><br>  <span class="hljs-comment">// is the address of our memory on the child.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SaveOriginalFunction</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk, <span class="hljs-type">void</span>* remote_thunk)</span></span>;<br><br>  <span class="hljs-comment">// true if we are allowed to patch already-patched functions.</span><br>  <span class="hljs-type">bool</span> relaxed_;<br>  ULONG relative_jump_;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(ServiceResolverThunk);<br>&#125;;<br></code></pre></td></tr></table></figure><p>显然，和前面分析的3个resolver不是一套体系的，这个要复杂得多。</p><p>service_resolver.h中也可以看到根据不同系统，以及位数进行了分类，定义了<code>ServiceResolverThunk</code>的众多子类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is the concrete resolver used to perform service-call type functions</span><br><span class="hljs-comment">// inside ntdll.dll on WOW64 (32 bit ntdll on 64 bit Vista).</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wow64ResolverThunk</span> : <span class="hljs-keyword">public</span> ServiceResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// The service resolver needs a child process to write to.</span><br>  <span class="hljs-built_in">Wow64ResolverThunk</span>(HANDLE process, <span class="hljs-type">bool</span> relaxed)<br>      : <span class="hljs-built_in">ServiceResolverThunk</span>(process, relaxed) &#123;&#125;<br>  ~<span class="hljs-built_in">Wow64ResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFunctionAService</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(Wow64ResolverThunk);<br>&#125;;<br><br><span class="hljs-comment">// This is the concrete resolver used to perform service-call type functions</span><br><span class="hljs-comment">// inside ntdll.dll on WOW64 for Windows 8.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wow64W8ResolverThunk</span> : <span class="hljs-keyword">public</span> ServiceResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// The service resolver needs a child process to write to.</span><br>  <span class="hljs-built_in">Wow64W8ResolverThunk</span>(HANDLE process, <span class="hljs-type">bool</span> relaxed)<br>      : <span class="hljs-built_in">ServiceResolverThunk</span>(process, relaxed) &#123;&#125;<br>  ~<span class="hljs-built_in">Wow64W8ResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFunctionAService</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(Wow64W8ResolverThunk);<br>&#125;;<br><br><span class="hljs-comment">// This is the concrete resolver used to perform service-call type functions</span><br><span class="hljs-comment">// inside ntdll.dll on Windows 8.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Win8ResolverThunk</span> : <span class="hljs-keyword">public</span> ServiceResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// The service resolver needs a child process to write to.</span><br>  <span class="hljs-built_in">Win8ResolverThunk</span>(HANDLE process, <span class="hljs-type">bool</span> relaxed)<br>      : <span class="hljs-built_in">ServiceResolverThunk</span>(process, relaxed) &#123;&#125;<br>  ~<span class="hljs-built_in">Win8ResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFunctionAService</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(Win8ResolverThunk);<br>&#125;;<br><br><span class="hljs-comment">// This is the concrete resolver used to perform service-call type functions</span><br><span class="hljs-comment">// inside ntdll.dll on WOW64 for Windows 10.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wow64W10ResolverThunk</span> : <span class="hljs-keyword">public</span> ServiceResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// The service resolver needs a child process to write to.</span><br>  <span class="hljs-built_in">Wow64W10ResolverThunk</span>(HANDLE process, <span class="hljs-type">bool</span> relaxed)<br>      : <span class="hljs-built_in">ServiceResolverThunk</span>(process, relaxed) &#123;&#125;<br>  ~<span class="hljs-built_in">Wow64W10ResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFunctionAService</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(Wow64W10ResolverThunk);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这些子类都override了<code>IsFunctionAService</code>，这是因为不同系统版本位数对系统调用的判断条件是不同的。</p><p>但是父类的另外几个虚函数，没有找到身影。</p><h3 id="两个resolve">两个resolve</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">ServiceResolverThunk::ResolveInterceptor</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">void</span>** address)</span> </span>&#123;<br>  <span class="hljs-comment">// After all, we are using a locally mapped version of the exe, so the</span><br>  <span class="hljs-comment">// action is the same as for a target function.</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ResolveTarget</span>(interceptor_module, interceptor_name,<br>                       <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">void</span>**&gt;(address));<br>&#125;<br><br><span class="hljs-comment">// In this case all the work is done from the parent, so resolve is</span><br><span class="hljs-comment">// just a simple GetProcAddress.</span><br><span class="hljs-function">NTSTATUS <span class="hljs-title">ServiceResolverThunk::ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">void</span>** address)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">module</span>)<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br><br>  <span class="hljs-comment">// 还是老套路，没啥好说的</span><br>  base::<span class="hljs-function">win::PEImage <span class="hljs-title">module_image</span><span class="hljs-params">(<span class="hljs-keyword">module</span>)</span></span>;<br>  *address =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(module_image.<span class="hljs-built_in">GetProcAddress</span>(function_name));<br><br>  <span class="hljs-keyword">if</span> (!*address) &#123;<br>    <span class="hljs-built_in">NOTREACHED_NT</span>();<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟基类的原理是一样的，但这里和基类的两个resolve却是反过来的，基类是target-&gt;interceptor，而这里却是interceptor-&gt;target。</p><p>不太清楚是否有什么禁忌在其中。</p><h3 id="x86-servicefullthunk"><code>x86 ServiceFullThunk</code></h3><p>在研究<code>Setup</code>之前，还是按照惯例先研究Thunk：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceFullThunk</span> &#123;<br>  <span class="hljs-keyword">union</span> &#123;<br>    ServiceEntry original;<br>    ServiceEntryW8 original_w8;<br>    Wow64Entry wow_64;<br>    Wow64EntryW8 wow_64_w8;<br>  &#125;;<br>  <span class="hljs-type">int</span> internal_thunk;  <span class="hljs-comment">// Dummy member to the beginning of the internal thunk.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>内部是个union，说明有4种不同的Thunk，对应到不同的系统版本和位数。我们先研究一下各版本的Entry。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Service code for 32 bit systems.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> on win2003 &quot;call dword ptr [edx]&quot; is &quot;call edx&quot;.</span><br><span class="hljs-comment">// 这个是32位系统调用样例</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceEntry</span> &#123;<br>  <span class="hljs-comment">// This struct contains roughly the following code:</span><br>  <span class="hljs-comment">// 00 mov     eax,25h</span><br>  <span class="hljs-comment">// 05 mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)</span><br>  <span class="hljs-comment">// 0a call    dword ptr [edx]</span><br>  <span class="hljs-comment">// 0c ret     2Ch</span><br>  <span class="hljs-comment">// 0f nop</span><br>  BYTE mov_eax;         <span class="hljs-comment">// = B8</span><br>  ULONG service_id;<br>  BYTE mov_edx;         <span class="hljs-comment">// = BA</span><br>  ULONG stub;<br>  USHORT call_ptr_edx;  <span class="hljs-comment">// = FF 12</span><br>  BYTE ret;             <span class="hljs-comment">// = C2</span><br>  USHORT num_params;<br>  BYTE nop;<br>&#125;;<br><br><span class="hljs-comment">// Service code for 32 bit Windows 8.</span><br><span class="hljs-comment">// 32位win8的service code入口</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceEntryW8</span> &#123;<br>  <span class="hljs-comment">// This struct contains the following code:</span><br>  <span class="hljs-comment">// 00 b825000000      mov     eax,25h</span><br>  <span class="hljs-comment">// 05 e803000000      call    eip+3</span><br>  <span class="hljs-comment">// 0a c22c00          ret     2Ch</span><br>  <span class="hljs-comment">// 0d 8bd4            mov     edx,esp</span><br>  <span class="hljs-comment">// 0f 0f34            sysenter</span><br>  <span class="hljs-comment">// 11 c3              ret</span><br>  <span class="hljs-comment">// 12 8bff            mov     edi,edi</span><br>  BYTE mov_eax;         <span class="hljs-comment">// = B8</span><br>  ULONG service_id;<br>  BYTE call_eip;        <span class="hljs-comment">// = E8</span><br>  ULONG call_offset;<br>  BYTE ret_p;           <span class="hljs-comment">// = C2</span><br>  USHORT num_params;<br>  USHORT mov_edx_esp;   <span class="hljs-comment">// = BD D4</span><br>  USHORT sysenter;      <span class="hljs-comment">// = 0F 34</span><br>  BYTE ret;             <span class="hljs-comment">// = C3</span><br>  USHORT nop;<br>&#125;;<br><br><span class="hljs-comment">// Service code for a 32 bit process running on a 64 bit os.</span><br><span class="hljs-comment">// 32位进程在64位os上运行的service code</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wow64Entry</span> &#123;<br>  <span class="hljs-comment">// This struct may contain one of two versions of code:</span><br>  <span class="hljs-comment">// 1. For XP, Vista and 2K3:</span><br>  <span class="hljs-comment">// 00 b825000000      mov     eax, 25h</span><br>  <span class="hljs-comment">// 05 33c9            xor     ecx, ecx</span><br>  <span class="hljs-comment">// 07 8d542404        lea     edx, [esp + 4]</span><br>  <span class="hljs-comment">// 0b 64ff15c0000000  call    dword ptr fs:[0C0h]</span><br>  <span class="hljs-comment">// 12 c22c00          ret     2Ch</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// 2. For Windows 7:</span><br>  <span class="hljs-comment">// 00 b825000000      mov     eax, 25h</span><br>  <span class="hljs-comment">// 05 33c9            xor     ecx, ecx</span><br>  <span class="hljs-comment">// 07 8d542404        lea     edx, [esp + 4]</span><br>  <span class="hljs-comment">// 0b 64ff15c0000000  call    dword ptr fs:[0C0h]</span><br>  <span class="hljs-comment">// 12 83c404          add     esp, 4</span><br>  <span class="hljs-comment">// 15 c22c00          ret     2Ch</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// So we base the structure on the bigger one:</span><br>  BYTE mov_eax;         <span class="hljs-comment">// = B8</span><br>  ULONG service_id;<br>  USHORT xor_ecx;       <span class="hljs-comment">// = 33 C9</span><br>  ULONG lea_edx;        <span class="hljs-comment">// = 8D 54 24 04</span><br>  ULONG call_fs1;       <span class="hljs-comment">// = 64 FF 15 C0</span><br>  USHORT call_fs2;      <span class="hljs-comment">// = 00 00</span><br>  BYTE call_fs3;        <span class="hljs-comment">// = 00</span><br>  BYTE add_esp1;        <span class="hljs-comment">// = 83             or ret</span><br>  USHORT add_esp2;      <span class="hljs-comment">// = C4 04          or num_params</span><br>  BYTE ret;             <span class="hljs-comment">// = C2</span><br>  USHORT num_params;<span class="hljs-comment">// 这个得算，根据当前是哪种情况</span><br>&#125;;<br><br><span class="hljs-comment">// Service code for a 32 bit process running on 64 bit Windows 8.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wow64EntryW8</span> &#123;<br>  <span class="hljs-comment">// 00 b825000000      mov     eax, 25h</span><br>  <span class="hljs-comment">// 05 64ff15c0000000  call    dword ptr fs:[0C0h]</span><br>  <span class="hljs-comment">// 0b c22c00          ret     2Ch</span><br>  <span class="hljs-comment">// 0f 90              nop</span><br>  BYTE mov_eax;         <span class="hljs-comment">// = B8</span><br>  ULONG service_id;<br>  ULONG call_fs1;       <span class="hljs-comment">// = 64 FF 15 C0</span><br>  USHORT call_fs2;      <span class="hljs-comment">// = 00 00</span><br>  BYTE call_fs3;        <span class="hljs-comment">// = 00</span><br>  BYTE ret;             <span class="hljs-comment">// = C2</span><br>  USHORT num_params;<br>  BYTE nop;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="x64-servicefullthunk"><code>x64 ServiceFullThunk</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// We don&#x27;t have an internal thunk for x64.</span><br><span class="hljs-comment">// x64看来不需要internal thunk</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceFullThunk</span> &#123;<br>  <span class="hljs-keyword">union</span> &#123;<br>    ServiceEntry original;<br>    ServiceEntryW8 original_w8;<br>    ServiceEntryWithInt2E original_int2e_fallback;<br>  &#125;;<br>&#125;;<br><br><span class="hljs-comment">// Service code for 64 bit systems.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceEntry</span> &#123;<br>  <span class="hljs-comment">// This struct contains roughly the following code:</span><br>  <span class="hljs-comment">// 00 mov     r10,rcx</span><br>  <span class="hljs-comment">// 03 mov     eax,52h</span><br>  <span class="hljs-comment">// 08 syscall</span><br>  <span class="hljs-comment">// 0a ret</span><br>  <span class="hljs-comment">// 0b xchg    ax,ax</span><br>  <span class="hljs-comment">// 0e xchg    ax,ax</span><br><br>  ULONG mov_r10_rcx_mov_eax;  <span class="hljs-comment">// = 4C 8B D1 B8</span><br>  ULONG service_id;<br>  USHORT syscall;             <span class="hljs-comment">// = 0F 05</span><br>  BYTE ret;                   <span class="hljs-comment">// = C3</span><br>  BYTE pad;                   <span class="hljs-comment">// = 66</span><br>  USHORT xchg_ax_ax1;         <span class="hljs-comment">// = 66 90</span><br>  USHORT xchg_ax_ax2;         <span class="hljs-comment">// = 66 90</span><br>&#125;;<br><br><span class="hljs-comment">// Service code for 64 bit Windows 8.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceEntryW8</span> &#123;<br>  <span class="hljs-comment">// This struct contains the following code:</span><br>  <span class="hljs-comment">// 00 48894c2408      mov     [rsp+8], rcx</span><br>  <span class="hljs-comment">// 05 4889542410      mov     [rsp+10], rdx</span><br>  <span class="hljs-comment">// 0a 4c89442418      mov     [rsp+18], r8</span><br>  <span class="hljs-comment">// 0f 4c894c2420      mov     [rsp+20], r9</span><br>  <span class="hljs-comment">// 14 4c8bd1          mov     r10,rcx</span><br>  <span class="hljs-comment">// 17 b825000000      mov     eax,25h</span><br>  <span class="hljs-comment">// 1c 0f05            syscall</span><br>  <span class="hljs-comment">// 1e c3              ret</span><br>  <span class="hljs-comment">// 1f 90              nop</span><br><br>  ULONG64 mov_1;              <span class="hljs-comment">// = 48 89 4C 24 08 48 89 54</span><br>  ULONG64 mov_2;              <span class="hljs-comment">// = 24 10 4C 89 44 24 18 4C</span><br>  ULONG mov_3;                <span class="hljs-comment">// = 89 4C 24 20</span><br>  ULONG mov_r10_rcx_mov_eax;  <span class="hljs-comment">// = 4C 8B D1 B8</span><br>  ULONG service_id;<br>  USHORT syscall;             <span class="hljs-comment">// = 0F 05</span><br>  BYTE ret;                   <span class="hljs-comment">// = C3</span><br>  BYTE nop;                   <span class="hljs-comment">// = 90</span><br>&#125;;<br><br><span class="hljs-comment">// Service code for 64 bit systems with int 2e fallback.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceEntryWithInt2E</span> &#123;<br>  <span class="hljs-comment">// This struct contains roughly the following code:</span><br>  <span class="hljs-comment">// 00 4c8bd1           mov     r10,rcx</span><br>  <span class="hljs-comment">// 03 b855000000       mov     eax,52h</span><br>  <span class="hljs-comment">// 08 f604250803fe7f01 test byte ptr SharedUserData!308, 1</span><br>  <span class="hljs-comment">// 10 7503             jne [over syscall]</span><br>  <span class="hljs-comment">// 12 0f05             syscall</span><br>  <span class="hljs-comment">// 14 c3               ret</span><br>  <span class="hljs-comment">// 15 cd2e             int 2e</span><br>  <span class="hljs-comment">// 17 c3               ret</span><br><br>  ULONG mov_r10_rcx_mov_eax;  <span class="hljs-comment">// = 4C 8B D1 B8</span><br>  ULONG service_id;<br>  USHORT test_byte;           <span class="hljs-comment">// = F6 04</span><br>  BYTE ptr;                   <span class="hljs-comment">// = 25</span><br>  ULONG user_shared_data_ptr;<br>  BYTE one;                   <span class="hljs-comment">// = 01</span><br>  USHORT jne_over_syscall;    <span class="hljs-comment">// = 75 03</span><br>  USHORT syscall;             <span class="hljs-comment">// = 0F 05</span><br>  BYTE ret;                   <span class="hljs-comment">// = C3</span><br>  USHORT int2e;               <span class="hljs-comment">// = CD 2E</span><br>  BYTE ret2;                  <span class="hljs-comment">// = C3</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="getthunksize-2"><code>GetThunkSize</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// x86的结构是ServiceFullThunk接一个InternalThunk</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ServiceResolverThunk::GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">offsetof</span>(ServiceFullThunk, internal_thunk) + <span class="hljs-built_in">GetInternalThunkSize</span>();<br>&#125;<br><br><span class="hljs-comment">// x64结构只有一个ServiceFullThunk，没用InternalThunk</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ServiceResolverThunk::GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(ServiceFullThunk);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="x86-setup"><code>x86 Setup</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// x86的Setup</span><br><span class="hljs-function">NTSTATUS <span class="hljs-title">ServiceResolverThunk::Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">size_t</span>* storage_used)</span> </span>&#123;<br>  NTSTATUS ret =<br>      <span class="hljs-built_in">Init</span>(target_module, interceptor_module, target_name, interceptor_name,<br>           interceptor_entry_point, thunk_storage, storage_bytes);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  relative_jump_ = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">size_t</span> thunk_bytes = <span class="hljs-built_in">GetThunkSize</span>();<br>  <span class="hljs-comment">// thunk buffer是内部new出来的</span><br>  <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">char</span>[]&gt; <span class="hljs-title">thunk_buffer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[thunk_bytes])</span></span>;<br>  <span class="hljs-comment">// 部署成ServiceFullThunk结构</span><br>  ServiceFullThunk* thunk =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;ServiceFullThunk*&gt;(thunk_buffer.<span class="hljs-built_in">get</span>());<br><br>  <span class="hljs-comment">// 检查一下想要被hook的函数是否是系统调用</span><br>  <span class="hljs-comment">// SaveOriginalFunction是什么？暂时不清楚</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsFunctionAService</span>(&amp;thunk-&gt;original) &amp;&amp;<br>      (!relaxed_ || !<span class="hljs-built_in">SaveOriginalFunction</span>(&amp;thunk-&gt;original, thunk_storage))) &#123;<br>    <span class="hljs-keyword">return</span> STATUS_OBJECT_NAME_COLLISION;<br>  &#125;<br><br>  <span class="hljs-comment">// 关键call，这里进行了patch实装</span><br>  ret = <span class="hljs-built_in">PerformPatch</span>(thunk, thunk_storage);<br><br>  <span class="hljs-keyword">if</span> (storage_used)<br>    *storage_used = thunk_bytes;<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>IsFunctionAService</code>顾名思义，就是读取target进程的original函数的字节码与<code>ServiceEntry</code>进行比较（对于<code>ServiceResolverThunk</code>来说用的是<code>ServiceEntry</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ServiceResolverThunk::IsFunctionAService</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk)</span> <span class="hljs-type">const</span> </span>&#123;<br>  ServiceEntry function_code;<br>  SIZE_T read;<br>  <span class="hljs-comment">// 读取target进程上的original函数字节码，长度为ServiceEntry的尺寸</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">ReadProcessMemory</span>(process_, target_, &amp;function_code,<br>                           <span class="hljs-built_in">sizeof</span>(function_code), &amp;read)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(function_code) != read)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 开始逐字节比较，固定的几处字节码如果有误的话，说明不是一个系统调用</span><br>  <span class="hljs-keyword">if</span> (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||<br>      (kCallPtrEdx != function_code.call_ptr_edx &amp;&amp;<span class="hljs-comment">// 这里的&amp;&amp;是因为win2003上是call edx</span><br>       kCallEdx != function_code.call_ptr_edx) ||<br>      kRet != function_code.ret) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Find the system call pointer if we don&#x27;t already have it.</span><br>  <span class="hljs-comment">// 如果是call dword ptr [edx]的话，要读取出[edx]</span><br>  <span class="hljs-keyword">if</span> (kCallEdx != function_code.call_ptr_edx) &#123;<br>    DWORD ki_system_call;<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">ReadProcessMemory</span>(process_,<br>                             <span class="hljs-built_in">bit_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(function_code.stub),<br>                             &amp;ki_system_call, <span class="hljs-built_in">sizeof</span>(ki_system_call), &amp;read)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(ki_system_call) != read)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    HMODULE module_1, module_2;<br>    <span class="hljs-comment">// 检查一下读取到的ki_system_call的module和original函数的module是否一致</span><br>    <span class="hljs-comment">// last check, call_stub should point to a KiXXSystemCall function on ntdll</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetModuleHandleEx</span>(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |<br>                               GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,<br>                           <span class="hljs-built_in">bit_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt;(ki_system_call),<br>                           &amp;module_1)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ntdll_base_) &#123;<br>      <span class="hljs-comment">// This path is only taken when running the unit tests. We want to be</span><br>      <span class="hljs-comment">// able to patch a buffer in memory, so target_ is not inside ntdll.</span><br>      module_2 = ntdll_base_;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetModuleHandleEx</span>(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |<br>                                 GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,<br>                             <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt;(target_),<br>                             &amp;module_2))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (module_1 != module_2)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Save the verified code</span><br>  <span class="hljs-comment">// 此时Setup中的ServiceFullThunk的ServiceEntry成员就正确填充了</span><br>  <span class="hljs-built_in">memcpy</span>(local_thunk, &amp;function_code, <span class="hljs-built_in">sizeof</span>(function_code));<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<code>IsFunctionAService</code>不仅判断了是否是servicecall，还拷贝了originalfunction的字节码给了Setup传递进来的<code>ServiceEntry</code>。继续展开<code>SaveOriginalFunction</code>看看本地填充好的<code>ServiceEntry</code>是如何与外部传进来的<code>thunk_storage</code>建立联系的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ServiceResolverThunk::SaveOriginalFunction</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">void</span>* remote_thunk)</span> </span>&#123;<br>  ServiceEntry function_code;<br>  SIZE_T read;<br>  <span class="hljs-comment">// 又去读了一遍</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">ReadProcessMemory</span>(process_, target_, &amp;function_code,<br>                           <span class="hljs-built_in">sizeof</span>(function_code), &amp;read)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(function_code) != read)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 进到这个函数就表示，Resolver是允许repatch的，那么第一次patch之后其后再次的patch</span><br>  <span class="hljs-comment">// 首字节就不再是mov eax,xx而是jmp xxx了</span><br>  <span class="hljs-keyword">if</span> (kJmp32 == function_code.mov_eax) &#123;<br>    <span class="hljs-comment">// Plain old entry point patch. The relative jump address follows it.</span><br>    <span class="hljs-comment">// 读出来上一次patch的jmp到的地址</span><br>    ULONG relative = function_code.service_id;<br><br>    <span class="hljs-comment">// First, fix our copy of their patch.</span><br>    <span class="hljs-comment">// 修正地址</span><br>    relative += <span class="hljs-built_in">bit_cast</span>&lt;ULONG&gt;(target_) - <span class="hljs-built_in">bit_cast</span>&lt;ULONG&gt;(remote_thunk);<br><br>    function_code.service_id = relative;<br><br>    <span class="hljs-comment">// And now, remember how to re-patch it.</span><br>    <span class="hljs-comment">// 这里处理repatch，remote_thunk是个ServiceFullThunk结构</span><br>    ServiceFullThunk* full_thunk =<br>        <span class="hljs-built_in">reinterpret_cast</span>&lt;ServiceFullThunk*&gt;(remote_thunk);<br><br>    <span class="hljs-type">const</span> ULONG kJmp32Size = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">// internal_thunk指向的是InternalThunk，它的地址减去original的地址再扣除5个jmp的尺寸</span><br>    <span class="hljs-comment">// 就是最终的跳转的地址偏移量，更新对象的成员relative_jump_，它用于从InternalThunk调用</span><br>    <span class="hljs-comment">// original时跳转到original</span><br>    relative_jump_ = <span class="hljs-built_in">bit_cast</span>&lt;ULONG&gt;(&amp;full_thunk-&gt;internal_thunk) -<br>                     <span class="hljs-built_in">bit_cast</span>&lt;ULONG&gt;(target_) - kJmp32Size;<br>  &#125;<br><br>  <span class="hljs-comment">// Save the verified code</span><br>  <span class="hljs-comment">// 如果不是首次进入，就把更新了jmp地址的ServiceEntry拷贝给local_thunk</span><br>  <span class="hljs-comment">// 如果是首次的话，实际上是copy出了original的字节码</span><br>  <span class="hljs-built_in">memcpy</span>(local_thunk, &amp;function_code, <span class="hljs-built_in">sizeof</span>(function_code));<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是最后的patch实装：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">ServiceResolverThunk::PerformPatch</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">void</span>* remote_thunk)</span> </span>&#123;<br>  ServiceEntry intercepted_code;<br>  <span class="hljs-type">size_t</span> bytes_to_write = <span class="hljs-built_in">sizeof</span>(intercepted_code);<br>  ServiceFullThunk* full_local_thunk =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;ServiceFullThunk*&gt;(local_thunk);<br>  ServiceFullThunk* full_remote_thunk =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;ServiceFullThunk*&gt;(remote_thunk);<br><br>  <span class="hljs-comment">// patch the original code</span><br>  <span class="hljs-comment">// original字节码拷贝给local buffer</span><br>  <span class="hljs-built_in">memcpy</span>(&amp;intercepted_code, &amp;full_local_thunk-&gt;original,<br>         <span class="hljs-built_in">sizeof</span>(intercepted_code));<br>  intercepted_code.mov_eax = kMovEax;<br>  intercepted_code.service_id = full_local_thunk-&gt;original.service_id;<br>  intercepted_code.mov_edx = kMovEdx;<br>  intercepted_code.stub = <span class="hljs-built_in">bit_cast</span>&lt;ULONG&gt;(&amp;full_remote_thunk-&gt;internal_thunk);<br>  intercepted_code.call_ptr_edx = kJmpEdx;<br>  bytes_to_write = kMinServiceSize;<br><br>  <span class="hljs-comment">// 如果relative_jump_有效，说明不是首次patch的实装，此时就要修正local buffer中的字节码为正确</span><br>  <span class="hljs-comment">// 的jmp relative_jump_，这个偏移量是remote buffer中InternalThunk的地址减去original函数的地址</span><br>  <span class="hljs-comment">// 再扣除5个字节的jmp</span><br>  <span class="hljs-keyword">if</span> (relative_jump_) &#123;<br>    intercepted_code.mov_eax = kJmp32;<br>    intercepted_code.service_id = relative_jump_;<br>    bytes_to_write = <span class="hljs-built_in">offsetof</span>(ServiceEntry, mov_edx);<br>  &#125;<br><br>  <span class="hljs-comment">// setup the thunk</span><br>  <span class="hljs-comment">// 部署InternalThunk，InternalThunk的效果是interceptor_(remote_thunk,xxx)</span><br>  <span class="hljs-comment">// 也就是跳到remote_thunk的起始ServiceEntry处，而不是original</span><br>  <span class="hljs-built_in">SetInternalThunk</span>(&amp;full_local_thunk-&gt;internal_thunk, <span class="hljs-built_in">GetInternalThunkSize</span>(),<br>                   remote_thunk, interceptor_);<br><br>  <span class="hljs-type">size_t</span> thunk_size = <span class="hljs-built_in">GetThunkSize</span>();<br><br>  <span class="hljs-comment">// copy the local thunk buffer to the child</span><br>  <span class="hljs-comment">// local buffer给了remote_thunk的ServiceEntry</span><br>  <span class="hljs-comment">// 所以当interceptor_跳到这里时会执行jmp xxx（存在repatch）或者执行original原本的代码序列（没有repatch）</span><br>  SIZE_T written;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">WriteProcessMemory</span>(process_, remote_thunk, local_thunk, thunk_size,<br>                            &amp;written)) &#123;<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (thunk_size != written)<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br><br>  <span class="hljs-comment">// and now change the function to intercept, on the child</span><br>  <span class="hljs-comment">// 现在要处理的就是把原本的original函数开头的那一段内容修改成interceptor_</span><br>  <span class="hljs-comment">// 实现call original时实际上是call interceptor_，以此完成了整个hook链</span><br>  <span class="hljs-keyword">if</span> (ntdll_base_) &#123;<br>    <span class="hljs-comment">// running a unit test</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">WriteProcessMemory</span>(process_, target_, &amp;intercepted_code,<br>                              bytes_to_write, &amp;written))<br>      <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WriteProtectedChildMemory</span>(process_, target_, &amp;intercepted_code,<br>                                   bytes_to_write))<br>      <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="x64-setup"><code>x64 Setup</code></h3><p>至于x64就比较简单了，因为它的设计并不是interceptor_(original,xxx)，所以也就没有这么复杂的Thunk实装过程，它的<code>InternalThunk</code>仅仅是:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InternalThunk</span> &#123;<br>  <span class="hljs-comment">// This struct contains roughly the following code:</span><br>  <span class="hljs-comment">// 01 48b8f0debc9a78563412  mov   rax,123456789ABCDEF0h</span><br>  <span class="hljs-comment">// ff e0                    jmp   rax</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The code modifies rax, but that&#x27;s fine for x64 ABI.</span><br><br>  <span class="hljs-built_in">InternalThunk</span>() &#123;<br>    mov_rax = kMovRax;<br>    jmp_rax = kJmpRax;<br>    interceptor_function = <span class="hljs-number">0</span>;<br>  &#125;;<br>  USHORT mov_rax;  <span class="hljs-comment">// = 48 B8</span><br>  ULONG_PTR interceptor_function;<br>  USHORT jmp_rax;  <span class="hljs-comment">// = ff e0</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>也是通过<code>WriteChildProcessMemory</code>把original的入口改写成Thunk的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">ServiceResolverThunk::Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">size_t</span>* storage_used)</span> </span>&#123;<br>  NTSTATUS ret =<br>      <span class="hljs-built_in">Init</span>(target_module, interceptor_module, target_name, interceptor_name,<br>           interceptor_entry_point, thunk_storage, storage_bytes);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-type">size_t</span> thunk_bytes = <span class="hljs-built_in">GetThunkSize</span>();<br>  <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">char</span>[]&gt; <span class="hljs-title">thunk_buffer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[thunk_bytes])</span></span>;<br>  ServiceFullThunk* thunk =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;ServiceFullThunk*&gt;(thunk_buffer.<span class="hljs-built_in">get</span>());<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsFunctionAService</span>(&amp;thunk-&gt;original))<br>    <span class="hljs-keyword">return</span> STATUS_OBJECT_NAME_COLLISION;<br><br>  ret = <span class="hljs-built_in">PerformPatch</span>(thunk, thunk_storage);<br><br>  <span class="hljs-keyword">if</span> (storage_used)<br>    *storage_used = thunk_bytes;<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function">NTSTATUS <span class="hljs-title">ServiceResolverThunk::PerformPatch</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">void</span>* remote_thunk)</span> </span>&#123;<br>  <span class="hljs-comment">// Patch the original code.</span><br>  ServiceEntry local_service;<br>  <span class="hljs-built_in">DCHECK_NT</span>(<span class="hljs-built_in">GetInternalThunkSize</span>() &lt;= <span class="hljs-built_in">sizeof</span>(local_service));<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetInternalThunk</span>(&amp;local_service, <span class="hljs-built_in">sizeof</span>(local_service), <span class="hljs-literal">nullptr</span>,<br>                        interceptor_))<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br><br>  <span class="hljs-comment">// Copy the local thunk buffer to the child.</span><br>  <span class="hljs-comment">// local thunk buffer存储的是original函数原本的指令序列，拷贝到了远端的remote_thunk</span><br>  SIZE_T actual;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">WriteProcessMemory</span>(process_, remote_thunk, local_thunk,<br>                            <span class="hljs-built_in">sizeof</span>(ServiceFullThunk), &amp;actual))<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(ServiceFullThunk) != actual)<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br><br>  <span class="hljs-comment">// And now change the function to intercept, on the child.</span><br>  <span class="hljs-keyword">if</span> (ntdll_base_) &#123;<br>    <span class="hljs-comment">// Running a unit test.</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">WriteProcessMemory</span>(process_, target_, &amp;local_service,<br>                              <span class="hljs-built_in">sizeof</span>(local_service), &amp;actual))<br>      <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 此时original函数面目全非，变成了InternalThunk的mov rax,interceptor;jmp rax;</span><br>    <span class="hljs-comment">// 至于如何从interceptor内部跳回remote_thunk，那就是interceptor的事了（g_orignal）</span><br>    <span class="hljs-comment">// 还记得InterceptionManager::PatchClientFunctions吗？</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WriteProtectedChildMemory</span>(process_, target_, &amp;local_service,<br>                                   <span class="hljs-built_in">sizeof</span>(local_service)))<br>      <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，我们终于可以明白<code>InterceptionManager::PatchClientFunctions</code>的意义了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">InterceptionManager::PatchClientFunctions</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    DllInterceptionData* thunks,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">size_t</span> thunk_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">    DllInterceptionData* dll_data)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(thunks);<br>  <span class="hljs-built_in">DCHECK</span>(dll_data);<br><br>  HMODULE ntdll_base = ::<span class="hljs-built_in">GetModuleHandle</span>(kNtdllName);<br>  <span class="hljs-keyword">if</span> (!ntdll_base)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_NO_HANDLE;<br><br>  <span class="hljs-type">char</span>* interceptor_base = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(SANDBOX_EXPORTS)</span><br>  interceptor_base = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(child_-&gt;<span class="hljs-built_in">MainModule</span>());<br>  <span class="hljs-function">base::ScopedNativeLibrary <span class="hljs-title">local_interceptor</span><span class="hljs-params">(::LoadLibrary(child_-&gt;Name()))</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// defined(SANDBOX_EXPORTS)</span></span><br><br>  std::unique_ptr&lt;ServiceResolverThunk&gt; thunk;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64)</span><br>  thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ServiceResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  base::win::OSInfo* os_info = base::win::OSInfo::<span class="hljs-built_in">GetInstance</span>();<br>  <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">wow64_status</span>() == base::win::OSInfo::WOW64_ENABLED) &#123;<br>    <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">version</span>() &gt;= base::win::VERSION_WIN10)<br>      thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Wow64W10ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">version</span>() &gt;= base::win::VERSION_WIN8)<br>      thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Wow64W8ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>    <span class="hljs-keyword">else</span><br>      thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Wow64ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">version</span>() &gt;= base::win::VERSION_WIN8) &#123;<br>    thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Win8ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ServiceResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> interception : interceptions_) &#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> base::string16 <span class="hljs-title">ntdll</span><span class="hljs-params">(kNtdllName)</span></span>;<br>    <span class="hljs-keyword">if</span> (interception.dll != ntdll)<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br>    <span class="hljs-keyword">if</span> (INTERCEPTION_SERVICE_CALL != interception.type)<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br>    <span class="hljs-comment">// 对每个service call类型的ntdll的拦截函数进行处理</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(SANDBOX_EXPORTS)</span><br>    <span class="hljs-comment">// We may be trying to patch by function name.</span><br>    <span class="hljs-keyword">if</span> (!interception.interceptor_address) &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* address;<br>      NTSTATUS ret = thunk-&gt;<span class="hljs-built_in">ResolveInterceptor</span>(<br>          local_interceptor.<span class="hljs-built_in">get</span>(), interception.interceptor.<span class="hljs-built_in">c_str</span>(),<br>          <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>**&gt;(&amp;address));<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret)) &#123;<br>        ::<span class="hljs-built_in">SetLastError</span>(<span class="hljs-built_in">GetLastErrorFromNtStatus</span>(ret));<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_RESOLVE_INTERCEPTION_THUNK;<br>      &#125;<br><br>      <span class="hljs-comment">// Translate the local address to an address on the child.</span><br>      interception.interceptor_address =<br>          interceptor_base +<br>          (address - <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(local_interceptor.<span class="hljs-built_in">get</span>()));<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// defined(SANDBOX_EXPORTS)</span></span><br>    <span class="hljs-comment">// 这里对&amp;thunks-&gt;thunks[dll_data-&gt;num_thunks]进行了实装</span><br>    <span class="hljs-comment">// 它是broker在target进程中开辟的内存空间，空间起始是DllInterceptionData</span><br>    <span class="hljs-comment">// 这里是某一个拦截函数的ThunkData</span><br>    NTSTATUS ret = thunk-&gt;<span class="hljs-built_in">Setup</span>(<br>        ntdll_base, interceptor_base, interception.function.<span class="hljs-built_in">c_str</span>(),<br>        interception.interceptor.<span class="hljs-built_in">c_str</span>(), interception.interceptor_address,<br>        &amp;thunks-&gt;thunks[dll_data-&gt;num_thunks],<br>        thunk_bytes - dll_data-&gt;used_bytes, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret)) &#123;<br>      ::<span class="hljs-built_in">SetLastError</span>(<span class="hljs-built_in">GetLastErrorFromNtStatus</span>(ret));<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_SETUP_INTERCEPTION_THUNK;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里更新了g_originals，使某个类型的interception指向正确的remote端内存地址</span><br>    <span class="hljs-comment">// 另一方面，g_originals的设计也暴露出来了拦截的函数实际上是固定的那些，凡是</span><br>    <span class="hljs-comment">// 使用到的拦截函数，在InterceptorId这个enum结构中都对应一个值</span><br>    <span class="hljs-built_in">DCHECK</span>(!g_originals[interception.id]);<br>    g_originals[interception.id] = &amp;thunks-&gt;thunks[dll_data-&gt;num_thunks];<br><br>    dll_data-&gt;num_thunks++;<br>    dll_data-&gt;used_bytes += <span class="hljs-built_in">sizeof</span>(ThunkData);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>Interception和Resolver是目前分析sandbox中最为复杂的部分，尽管一路上磕磕绊绊，但总算是缕清了分分毫毫。</p><p>子系统的三大组件中，我们已经分析过了用于分发IPC请求的dispatcher，也分析过了安装Hook的Interception和Resolver，下一节我们分析最后一个——Policy。</p>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-Interception-analysis</title>
    <link href="/2018/05/26/chromium-sandbox-Interception/"/>
    <url>/2018/05/26/chromium-sandbox-Interception/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第十篇，主要分析了windows平台下，Chromiumsandbox中子系统三大组件构成中的第二大组件——Interception。阅读本篇前，请先阅读前四篇。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-interception-analysis">chromium-sandbox-Interception-analysis</h1><p>此前已经看过了子系统的第一大组件<code>Dispatcher</code>，<code>Dispatcher</code>把IPC请求联系了起来，broker使用<code>TopLevelDispatcher</code>来分发给子系统具体的<code>xxxDispatcher</code>，然后进行server端处理的那些事儿。</p><p>今天来分析子系统三大组件中第二个——<code>Interception</code>。我们已经不止一次的在前面的分析之旅中见过<code>InterceptionManager</code>这个用来管理<code>Interception</code>的类了。</p><h2 id="interceptionmanager"><code>InterceptionManager</code></h2><p><code>InterceptionManager</code>类负责沙盒进程（target）各种拦截器的安装。</p><p>看一下类头定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The InterceptionManager executes on the parent application, and it is in</span><br><span class="hljs-comment">// charge of setting up the desired interceptions, and placing the Interception</span><br><span class="hljs-comment">// Agent into the child application.</span><br><span class="hljs-comment">// 这是个泛用说法，对应chrome，parent就是broker，child主要是renderer(target)。</span><br><span class="hljs-comment">// broker上运行的InterceptionManager实例负责安装Interception Agent到renderer上</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The exposed API consists of two methods: AddToPatchedFunctions to set up a</span><br><span class="hljs-comment">// particular interception, and InitializeInterceptions to actually go ahead and</span><br><span class="hljs-comment">// perform all interceptions and transfer data to the child application.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The typical usage is something like this:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// InterceptionManager interception_manager(child);</span><br><span class="hljs-comment">// if (!interception_manager.AddToPatchedFunctions(</span><br><span class="hljs-comment">//         L&quot;ntdll.dll&quot;, &quot;NtCreateFile&quot;,</span><br><span class="hljs-comment">//         sandbox::INTERCEPTION_SERVICE_CALL, &amp;MyNtCreateFile, MY_ID_1))</span><br><span class="hljs-comment">//   return false;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// if (!interception_manager.AddToPatchedFunctions(</span><br><span class="hljs-comment">//         L&quot;kernel32.dll&quot;, &quot;CreateDirectoryW&quot;,</span><br><span class="hljs-comment">//         sandbox::INTERCEPTION_EAT, L&quot;MyCreateDirectoryW@12&quot;, MY_ID_2))</span><br><span class="hljs-comment">//   return false;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// sandbox::ResultCode rc = interception_manager.InitializeInterceptions();</span><br><span class="hljs-comment">// if (rc != sandbox::SBOX_ALL_OK) &#123;</span><br><span class="hljs-comment">//   DWORD error = ::GetLastError();</span><br><span class="hljs-comment">//   return rc;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// Add-&gt;Add-&gt;Add-&gt;...-&gt;Init一波流</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Any required syncronization must be performed outside this class. Also, it is</span><br><span class="hljs-comment">// not possible to perform further interceptions after InitializeInterceptions</span><br><span class="hljs-comment">// is called.</span><br><span class="hljs-comment">// 一旦InitializeInterceptions后，就不能再添加interceptions了</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptionManager</span> &#123;<br>  <span class="hljs-comment">// The unit test will access private members.</span><br>  <span class="hljs-comment">// Allow tests to be marked DISABLED_. Note that FLAKY_ and FAILS_ prefixes</span><br>  <span class="hljs-comment">// do not work with sandbox tests.</span><br>  <span class="hljs-comment">// 单元测试的批量友元类，为了访问private，常见套路，这里不关心</span><br>  <span class="hljs-built_in">FRIEND_TEST_ALL_PREFIXES</span>(InterceptionManagerTest, BufferLayout1);<br>  <span class="hljs-built_in">FRIEND_TEST_ALL_PREFIXES</span>(InterceptionManagerTest, BufferLayout2);<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// An interception manager performs interceptions on a given child process.</span><br>  <span class="hljs-comment">// If we are allowed to intercept functions that have been patched by somebody</span><br>  <span class="hljs-comment">// else, relaxed should be set to true.</span><br>  <span class="hljs-comment">// Note: We increase the child&#x27;s reference count internally.</span><br>  <span class="hljs-comment">// 构造器关联了TargetProcess对象</span><br>  <span class="hljs-comment">// 如果relaxed置true则表示可以覆盖别人的patch</span><br>  <span class="hljs-built_in">InterceptionManager</span>(TargetProcess* child_process, <span class="hljs-type">bool</span> relaxed);<br>  ~<span class="hljs-built_in">InterceptionManager</span>();<br><br>  <span class="hljs-comment">// Patches function_name inside dll_name to point to replacement_code_address.</span><br>  <span class="hljs-comment">// function_name has to be an exported symbol of dll_name.</span><br>  <span class="hljs-comment">// Returns true on success.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The new function should match the prototype and calling convention of the</span><br>  <span class="hljs-comment">// function to intercept except for one extra argument (the first one) that</span><br>  <span class="hljs-comment">// contains a pointer to the original function, to simplify the development</span><br>  <span class="hljs-comment">// of interceptors (for IA32). In x64, there is no extra argument to the</span><br>  <span class="hljs-comment">// interceptor, so the provided InterceptorId is used to keep a table of</span><br>  <span class="hljs-comment">// intercepted functions so that the interceptor can index that table to get</span><br>  <span class="hljs-comment">// the pointer that would have been the first argument (g_originals[id]).</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// For example, to intercept NtClose, the following code could be used:</span><br>  <span class="hljs-comment">// x86和x64对hook函数的不同处理</span><br>  <span class="hljs-comment">// 下面给了一个对NtCloseFunction进行hook的方式，增加了一个原始函数指针的参数</span><br>  <span class="hljs-comment">// typedef NTSTATUS (WINAPI *NtCloseFunction) (IN HANDLE Handle);</span><br>  <span class="hljs-comment">// NTSTATUS WINAPI MyNtCose(IN NtCloseFunction OriginalClose,</span><br>  <span class="hljs-comment">//                          IN HANDLE Handle) &#123;</span><br>  <span class="hljs-comment">//   // do something</span><br>  <span class="hljs-comment">//   // call the original function</span><br>  <span class="hljs-comment">//   return OriginalClose(Handle);</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// And in x64:</span><br>  <span class="hljs-comment">// x64没有传参，而是使用了g_originals全局函数指针表</span><br>  <span class="hljs-comment">// typedef NTSTATUS (WINAPI *NtCloseFunction) (IN HANDLE Handle);</span><br>  <span class="hljs-comment">// NTSTATUS WINAPI MyNtCose64(IN HANDLE Handle) &#123;</span><br>  <span class="hljs-comment">//   // do something</span><br>  <span class="hljs-comment">//   // call the original function</span><br>  <span class="hljs-comment">//   NtCloseFunction OriginalClose = g_originals[NT_CLOSE_ID];</span><br>  <span class="hljs-comment">//   return OriginalClose(Handle);</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-comment">// add方法的几种重载</span><br>  <span class="hljs-comment">// 这个是把function_name的函数指针替换成replacement_code_address起始的地址</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AddToPatchedFunctions</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             InterceptionType interception_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">void</span>* replacement_code_address,</span></span><br><span class="hljs-params"><span class="hljs-function">                             InterceptorId id)</span></span>;<br><br>  <span class="hljs-comment">// Patches function_name inside dll_name to point to</span><br>  <span class="hljs-comment">// replacement_function_name.</span><br>  <span class="hljs-comment">// 用replacement_function_name来替换function_name</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AddToPatchedFunctions</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             InterceptionType interception_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* replacement_function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             InterceptorId id)</span></span>;<br><br>  <span class="hljs-comment">// The interception agent will unload the dll with dll_name.</span><br>  <span class="hljs-comment">// unload dll</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AddToUnloadModules</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name)</span></span>;<br><br>  <span class="hljs-comment">// Initializes all interceptions on the client.</span><br>  <span class="hljs-comment">// Returns SBOX_ALL_OK on success, or an appropriate error code.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The child process must be created suspended, and cannot be resumed until</span><br>  <span class="hljs-comment">// after this method returns. In addition, no action should be performed on</span><br>  <span class="hljs-comment">// the child that may cause it to resume momentarily, such as injecting</span><br>  <span class="hljs-comment">// threads or APCs.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// This function must be called only once, after all interceptions have been</span><br>  <span class="hljs-comment">// set up using AddToPatchedFunctions.</span><br>  <span class="hljs-comment">// 这个就是最后的fire</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">InitializeInterceptions</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Used to store the interception information until the actual set-up.</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">InterceptionData</span> &#123;<br>    <span class="hljs-built_in">InterceptionData</span>();<br>    <span class="hljs-built_in">InterceptionData</span>(<span class="hljs-type">const</span> InterceptionData&amp; other);<br>    ~<span class="hljs-built_in">InterceptionData</span>();<br><br>    <span class="hljs-comment">//这两个都是枚举量，id主要是用于划分给不同Dispatcher，type是某一种拦截类型</span><br>    <span class="hljs-comment">//这个结构体把所有有用的信息都封装好了</span><br>    InterceptionType type;            <span class="hljs-comment">// Interception type.</span><br>    InterceptorId id;                 <span class="hljs-comment">// Interceptor id.</span><br>    base::string16 dll;               <span class="hljs-comment">// Name of dll to intercept.</span><br>    std::string function;             <span class="hljs-comment">// Name of function to intercept.</span><br>    std::string interceptor;          <span class="hljs-comment">// Name of interceptor function.</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_address;  <span class="hljs-comment">// Interceptor&#x27;s entry point.</span><br>  &#125;;<br><br>  <span class="hljs-comment">// 计算config buffer的尺寸，InterceptionManager也需要一个buffer，这个buffer用于</span><br>  <span class="hljs-comment">// 承载安装的Interception，然后发给InterceptionAgent</span><br>  <span class="hljs-comment">// Calculates the size of the required configuration buffer.</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetBufferSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Rounds up the size of a given buffer, considering alignment (padding).</span><br>  <span class="hljs-comment">// value is the current size of the buffer, and alignment is specified in</span><br>  <span class="hljs-comment">// bytes.</span><br>  <span class="hljs-comment">// 向上对齐</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">RoundUpToMultiple</span><span class="hljs-params">(<span class="hljs-type">size_t</span> value, <span class="hljs-type">size_t</span> alignment)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((value + alignment - <span class="hljs-number">1</span>) / alignment) * alignment;<br>  &#125;<br><br>  <span class="hljs-comment">// Sets up a given buffer with all the information that has to be transfered</span><br>  <span class="hljs-comment">// to the child.</span><br>  <span class="hljs-comment">// Returns true on success.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The buffer size should be at least the value returned by GetBufferSize</span><br>  <span class="hljs-comment">// 部署config buffer</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetupConfigBuffer</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer, <span class="hljs-type">size_t</span> buffer_bytes)</span></span>;<br><br>  <span class="hljs-comment">// Fills up the part of the transfer buffer that corresponds to information</span><br>  <span class="hljs-comment">// about one dll to patch.</span><br>  <span class="hljs-comment">// data is the first recorded interception for this dll.</span><br>  <span class="hljs-comment">// Returns true on success.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// On successful return, buffer will be advanced from it&#x27;s current position</span><br>  <span class="hljs-comment">// to the point where the next block of configuration data should be written</span><br>  <span class="hljs-comment">// (the actual interception info), and the current size of the buffer will</span><br>  <span class="hljs-comment">// decrease to account the space used by this method.</span><br>  <span class="hljs-comment">// 部署某个被patch的dll的信息到buffer中，这里可以看出buffer中实际上是InterceptionData</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetupDllInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> InterceptionData&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">void</span>** buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">size_t</span>* buffer_bytes)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Fills up the part of the transfer buffer that corresponds to a single</span><br>  <span class="hljs-comment">// function to patch.</span><br>  <span class="hljs-comment">// dll_info points to the dll being updated with the interception stored on</span><br>  <span class="hljs-comment">// data. The buffer pointer and remaining size are updated by this call.</span><br>  <span class="hljs-comment">// Returns true on success.</span><br>  <span class="hljs-comment">// 部署某个单一函数patch的信息到buffer</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetupInterceptionInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> InterceptionData&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">void</span>** buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">size_t</span>* buffer_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                             DllPatchInfo* dll_info)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Returns true if this interception is to be performed by the child</span><br>  <span class="hljs-comment">// as opposed to from the parent.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInterceptionPerformedByChild</span><span class="hljs-params">(<span class="hljs-type">const</span> InterceptionData&amp; data)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Allocates a buffer on the child&#x27;s address space (returned on</span><br>  <span class="hljs-comment">// remote_buffer), and fills it with the contents of a local buffer.</span><br>  <span class="hljs-comment">// Returns SBOX_ALL_OK on success.</span><br>  <span class="hljs-comment">// 这个应该就是跨进程写数据的素质3连</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">CopyDataToChild</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* local_buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">size_t</span> buffer_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">void</span>** remote_buffer)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Performs the cold patch (from the parent) of ntdll.</span><br>  <span class="hljs-comment">// Returns SBOX_ALL_OK on success.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// This method will insert additional interceptions to launch the interceptor</span><br>  <span class="hljs-comment">// agent on the child process, if there are additional interceptions to do.</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">PatchNtdll</span><span class="hljs-params">(<span class="hljs-type">bool</span> hot_patch_needed)</span></span>;<br><br>  <span class="hljs-comment">// Peforms the actual interceptions on ntdll.</span><br>  <span class="hljs-comment">// thunks is the memory to store all the thunks for this dll (on the child),</span><br>  <span class="hljs-comment">// and dll_data is a local buffer to hold global dll interception info.</span><br>  <span class="hljs-comment">// Returns SBOX_ALL_OK on success.</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">PatchClientFunctions</span><span class="hljs-params">(DllInterceptionData* thunks,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">size_t</span> thunk_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  DllInterceptionData* dll_data)</span></span>;<br><br>  <span class="hljs-comment">// The process to intercept.</span><br>  <span class="hljs-comment">// 看起来一个Manager管理一个target进程</span><br>  TargetProcess* child_;<br>  <span class="hljs-comment">// Holds all interception info until the call to initialize (perform the</span><br>  <span class="hljs-comment">// actual patch).</span><br>  <span class="hljs-comment">// target进程所有待安装的拦截器</span><br>  std::list&lt;InterceptionData&gt; interceptions_;<br><br>  <span class="hljs-comment">// Keep track of patches added by name.</span><br>  <span class="hljs-type">bool</span> names_used_;<br><br>  <span class="hljs-comment">// true if we are allowed to patch already-patched functions.</span><br>  <span class="hljs-type">bool</span> relaxed_;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(InterceptionManager);<br>&#125;;<br></code></pre></td></tr></table></figure><p>### 构造/析构器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">InterceptionManager::<span class="hljs-built_in">InterceptionManager</span>(TargetProcess* child_process,<br>                                         <span class="hljs-type">bool</span> relaxed)<br>    : <span class="hljs-built_in">child_</span>(child_process), <span class="hljs-built_in">names_used_</span>(<span class="hljs-literal">false</span>), <span class="hljs-built_in">relaxed_</span>(relaxed) &#123;<br>  child_-&gt;<span class="hljs-built_in">AddRef</span>();<span class="hljs-comment">// 引用计数增加，因为InterceptionManager用到了TargetProcess对象</span><br>&#125;<br><br>InterceptionManager::~<span class="hljs-built_in">InterceptionManager</span>() &#123;<br>  child_-&gt;<span class="hljs-built_in">Release</span>();<span class="hljs-comment">// 引用计数减少</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="addtopatchedfunctions"><code>AddToPatchedFunctions</code></h3><p>构造和析构毫无营养，我们来看几个重要的接口，先看看重载的两个<code>AddToPatchedFunctions</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::AddToPatchedFunctions</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">    InterceptionType interception_type,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">void</span>* replacement_code_address,</span></span><br><span class="hljs-params"><span class="hljs-function">    InterceptorId id)</span> </span>&#123;<br>  <span class="hljs-comment">// 只是单纯的填充InterceptionData，注意interceptions_中存的不是指针，是InterceptionData对象</span><br>  InterceptionData function;<br>  function.type = interception_type;<br>  function.id = id;<br>  function.dll = dll_name;<br>  function.function = function_name;<br>  function.interceptor_address = replacement_code_address;<br><br>  <span class="hljs-comment">// 唯独没有填充interceptor，即拦截函数的名称，实际上也用不到</span><br>  interceptions_.<span class="hljs-built_in">push_back</span>(function);<span class="hljs-comment">//填充然后push back</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::AddToPatchedFunctions</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">    InterceptionType interception_type,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* replacement_function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">    InterceptorId id)</span> </span>&#123;<br>  InterceptionData function;<br>  function.type = interception_type;<br>  function.id = id;<br>  function.dll = dll_name;<br>  function.function = function_name;<br>  <span class="hljs-comment">// 这里赋值了拦截函数名称，而interceptor_address置为了nullptr</span><br>  function.interceptor = replacement_function_name;<br>  function.interceptor_address = <span class="hljs-literal">nullptr</span>;<br><br>  interceptions_.<span class="hljs-built_in">push_back</span>(function);<br>  names_used_ = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// unload实际上也是一种interception，它的type为固定的INTERCEPTION_UNLOAD_MODULE</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::AddToUnloadModules</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name)</span> </span>&#123;<br>  InterceptionData module_to_unload;<br>  module_to_unload.type = INTERCEPTION_UNLOAD_MODULE;<br>  module_to_unload.dll = dll_name;<br>  <span class="hljs-comment">// The next two are dummy values that make the structures regular, instead</span><br>  <span class="hljs-comment">// of having special cases. They should not be used.</span><br>  <span class="hljs-comment">// 这两个成员对于该对象来说没有实际意义，填充dummy数据</span><br>  module_to_unload.function = kUnloadDLLDummyFunction;<br>  module_to_unload.interceptor_address = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(<span class="hljs-number">1</span>);<br><br>  interceptions_.<span class="hljs-built_in">push_back</span>(module_to_unload);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先看看都有哪几种type：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">InterceptionType</span> &#123;<br>  INTERCEPTION_INVALID = <span class="hljs-number">0</span>,<br>  INTERCEPTION_SERVICE_CALL,  <span class="hljs-comment">// Trampoline of an NT native call</span><br>  INTERCEPTION_EAT,<br>  INTERCEPTION_SIDESTEP,        <span class="hljs-comment">// Preamble patch</span><br>  INTERCEPTION_SMART_SIDESTEP,  <span class="hljs-comment">// Preamble patch but bypass internal calls</span><br>  INTERCEPTION_UNLOAD_MODULE,   <span class="hljs-comment">// Unload the module (don&#x27;t patch)</span><br>  INTERCEPTION_LAST             <span class="hljs-comment">// Placeholder for last item in the enumeration</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>暂时只有<code>INTERCEPTION_UNLOAD_MODULE</code>的意义是明确的。</p><p>其他的几个我们给个猜想：</p><ol type="1"><li>SERVICE_CALL是对系统调用的hook，为什么说成是蹦床，暂不清楚。</li><li>EAT应该是取代本体</li><li>SIDESTEP应该是inline hook，执行序列后最终会跳回原始地址</li><li>SMART_SIDESTEP也是inline hook，但不会跳回</li></ol><p>根据以往对hook的理解，暂时给出这些猜想。</p><p>再看看id的分类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">InterceptorId</span> &#123;<br>  <span class="hljs-comment">// Internal use:</span><br>  MAP_VIEW_OF_SECTION_ID = <span class="hljs-number">0</span>,<br>  UNMAP_VIEW_OF_SECTION_ID,<br>  <span class="hljs-comment">// Policy broker:</span><br>  SET_INFORMATION_THREAD_ID,<br>  OPEN_THREAD_TOKEN_ID,<br>  OPEN_THREAD_TOKEN_EX_ID,<br>  OPEN_THREAD_ID,<br>  OPEN_PROCESS_ID,<br>  OPEN_PROCESS_TOKEN_ID,<br>  OPEN_PROCESS_TOKEN_EX_ID,<br>  <span class="hljs-comment">// Filesystem dispatcher:</span><br>  CREATE_FILE_ID,<br>  OPEN_FILE_ID,<br>  QUERY_ATTRIB_FILE_ID,<br>  QUERY_FULL_ATTRIB_FILE_ID,<br>  SET_INFO_FILE_ID,<br>  <span class="hljs-comment">// Named pipe dispatcher:</span><br>  CREATE_NAMED_PIPE_ID,<br>  <span class="hljs-comment">// Process-thread dispatcher:</span><br>  CREATE_PROCESSW_ID,<br>  CREATE_PROCESSA_ID,<br>  CREATE_THREAD_ID,<br>  <span class="hljs-comment">// Registry dispatcher:</span><br>  CREATE_KEY_ID,<br>  OPEN_KEY_ID,<br>  OPEN_KEY_EX_ID,<br>  <span class="hljs-comment">// Sync dispatcher:</span><br>  CREATE_EVENT_ID,<br>  OPEN_EVENT_ID,<br>  <span class="hljs-comment">// Process mitigations Win32k dispatcher:</span><br>  GDIINITIALIZE_ID,<br>  GETSTOCKOBJECT_ID,<br>  REGISTERCLASSW_ID,<br>  ENUMDISPLAYMONITORS_ID,<br>  ENUMDISPLAYDEVICESA_ID,<br>  GETMONITORINFOA_ID,<br>  GETMONITORINFOW_ID,<br>  CREATEOPMPROTECTEDOUTPUTS_ID,<br>  GETCERTIFICATE_ID,<br>  GETCERTIFICATESIZE_ID,<br>  GETCERTIFICATEBYHANDLE_ID,<br>  GETCERTIFICATESIZEBYHANDLE_ID,<br>  DESTROYOPMPROTECTEDOUTPUT_ID,<br>  CONFIGUREOPMPROTECTEDOUTPUT_ID,<br>  GETOPMINFORMATION_ID,<br>  GETOPMRANDOMNUMBER_ID,<br>  GETSUGGESTEDOPMPROTECTEDOUTPUTARRAYSIZE_ID,<br>  SETOPMSIGNINGKEYANDSEQUENCENUMBERS_ID,<br>  INTERCEPTOR_MAX_ID<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看出来是给每个子系统分派的。</p><h3id="initializeinterceptions"><code>InitializeInterceptions</code></h3><p>这个就是fire函数了，broker会把target自己需要按照的interceptions发过去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">InterceptionManager::InitializeInterceptions</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 如果没有拦截器，什么都不用做</span><br>  <span class="hljs-keyword">if</span> (interceptions_.<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span> SBOX_ALL_OK;  <span class="hljs-comment">// Nothing to do here</span><br><br>  <span class="hljs-comment">// 老套路，用GetBufferSize计算尺寸，new出一片天</span><br>  <span class="hljs-type">size_t</span> buffer_bytes = <span class="hljs-built_in">GetBufferSize</span>();<br>  <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">char</span>[]&gt; <span class="hljs-title">local_buffer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[buffer_bytes])</span></span>;<br><br>  <span class="hljs-comment">// 部署buffer</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetupConfigBuffer</span>(local_buffer.<span class="hljs-built_in">get</span>(), buffer_bytes))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_SETUP_INTERCEPTION_CONFIG_BUFFER;<br><br>  <span class="hljs-type">void</span>* remote_buffer;<br>  <span class="hljs-comment">// 关键Call，buffer是如何通过broker发给target进程的呢？</span><br>  <span class="hljs-comment">// 应该还是那个老套路，VirtualAlloc+WriteProcessMemory</span><br>  <span class="hljs-comment">// 然后接全局变量的TransferVariable为target索引内存空间</span><br>  ResultCode rc =<br>      <span class="hljs-built_in">CopyDataToChild</span>(local_buffer.<span class="hljs-built_in">get</span>(), buffer_bytes, &amp;remote_buffer);<br><br>  <span class="hljs-keyword">if</span> (rc != SBOX_ALL_OK)<br>    <span class="hljs-keyword">return</span> rc;<br><br>  <span class="hljs-comment">// 如果buffer不为空，就要打Ntdll 热补丁，这个函数暂时不清楚意义何在</span><br>  <span class="hljs-type">bool</span> hot_patch_needed = (<span class="hljs-number">0</span> != buffer_bytes);<br>  rc = <span class="hljs-built_in">PatchNtdll</span>(hot_patch_needed);<br><br>  <span class="hljs-keyword">if</span> (rc != SBOX_ALL_OK)<br>    <span class="hljs-keyword">return</span> rc;<br><br>  <span class="hljs-comment">// 果然有全局变量的值传递</span><br>  g_interceptions = <span class="hljs-built_in">reinterpret_cast</span>&lt;SharedMemory*&gt;(remote_buffer);<br>  rc = child_-&gt;<span class="hljs-built_in">TransferVariable</span>(<span class="hljs-string">&quot;g_interceptions&quot;</span>, &amp;g_interceptions,<br>                                <span class="hljs-built_in">sizeof</span>(g_interceptions));<br>  <span class="hljs-keyword">return</span> rc;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数内部实际上是各种其他成员函数的组合技，逐一审视：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">InterceptionManager::GetBufferSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  std::set&lt;base::string16&gt; dlls;<br>  <span class="hljs-type">size_t</span> buffer_bytes = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 迭代interception，interceptions_实际上是std::list&lt;InterceptionData&gt;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; interception : interceptions_) &#123;<br>    <span class="hljs-comment">// skip interceptions that are performed from the parent</span><br>    <span class="hljs-comment">// 设计上拦截器分两种，一种由broker来给target执行，另一种由target自己执行</span><br>    <span class="hljs-comment">// 前者就不需要传递给target进程了，所以这里做了skip</span><br>    <span class="hljs-comment">// 那么怎么分类呢？实际上是根据type来判定</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsInterceptionPerformedByChild</span>(interception))<br>      <span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-comment">// 如果本次interception的dll没有出现过，就把该dll的名称插入到dlls</span><br>    <span class="hljs-comment">// 同一个dll尽管出现多次，也只有一个DllPatchInfo结构</span><br>    <span class="hljs-keyword">if</span> (!dlls.<span class="hljs-built_in">count</span>(interception.dll)) &#123;<br>      <span class="hljs-comment">// NULL terminate the dll name on the structure</span><br>      <span class="hljs-type">size_t</span> dll_name_bytes = (interception.dll.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>);<br><br>      <span class="hljs-comment">// include the dll related size</span><br>      <span class="hljs-comment">// dll_name是DLLPatchInfo的最后一个成员，是个flexible数组，这里是计算出整个结构体真实的长度，且单位要对齐</span><br>      <span class="hljs-comment">// 我们mark一下DllPatchInfo结构体</span><br>      buffer_bytes += <span class="hljs-built_in">RoundUpToMultiple</span>(<br>          <span class="hljs-built_in">offsetof</span>(DllPatchInfo, dll_name) + dll_name_bytes, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>));<br>      dlls.<span class="hljs-built_in">insert</span>(interception.dll);<br>    &#125;<br><br>    <span class="hljs-comment">// we have to NULL terminate the strings on the structure</span><br>    <span class="hljs-comment">// 被拦截函数的名称尺寸以及拦截函数的尺寸，2表示两个终结符</span><br>    <span class="hljs-comment">// 但有个疑问在于我们观察两个重载的Add方法时，发现其中一个并没有设置interceptor</span><br>    <span class="hljs-comment">// 如果interceptor在这种情况下为空串，那么还好，但Add时并没有设置，所以可能存在隐患</span><br>    <span class="hljs-type">size_t</span> strings_chars =<br>        interception.function.<span class="hljs-built_in">size</span>() + interception.interceptor.<span class="hljs-built_in">size</span>() + <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// a new FunctionInfo is required per function</span><br>    <span class="hljs-comment">// FunctionInfo也类似DllPatchInfo，function是最后一个flexible数组成员，这个function是两个字符串，一个function，一个interception</span><br>    <span class="hljs-type">size_t</span> record_bytes = <span class="hljs-built_in">offsetof</span>(FunctionInfo, function) + strings_chars;<br>    record_bytes = <span class="hljs-built_in">RoundUpToMultiple</span>(record_bytes, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>));<br>    buffer_bytes += record_bytes;<br>  &#125;<br><br>  <span class="hljs-comment">// SharedMemory也是个类似的结构体，dll_list是最后一个DllPatchInfo flexible数组成员</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != buffer_bytes)<br>    <span class="hljs-comment">// add the part of SharedMemory that we have not counted yet</span><br>    buffer_bytes += <span class="hljs-built_in">offsetof</span>(SharedMemory, dll_list);<br><br>  <span class="hljs-keyword">return</span> buffer_bytes;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以到此可以看出，整个buffer的组成实际上是<code>SharedMemory</code>结构体起始，它的末尾会有多个<code>DllPatchInfo</code>，而每个<code>DllPatchInfo</code>的末尾都有一个<code>dll_name</code>接不定个数的<code>FunctionInfo</code>，每个<code>FunctionInfo</code>的末尾function由两个函数名称字符串组成。</p><p>每一个上层结构都有成员来维护不定个数的下层结构，这和我们之前看到的<code>HandleCloser</code>结构很相似。</p><p>我们看一下这几个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// All interceptions:</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SharedMemory</span> &#123;<br>  <span class="hljs-type">int</span> num_intercepted_dlls;<br>  <span class="hljs-type">void</span>* interceptor_base;<br>  DllPatchInfo dll_list[<span class="hljs-number">1</span>];  <span class="hljs-comment">// placeholder for the list of dlls</span><br>&#125;;<br><br><span class="hljs-comment">// A single dll:</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DllPatchInfo</span> &#123;<br>  <span class="hljs-type">size_t</span> record_bytes;  <span class="hljs-comment">// rounded to sizeof(size_t) bytes</span><br>  <span class="hljs-type">size_t</span> offset_to_functions;<br>  <span class="hljs-type">int</span> num_functions;<br>  <span class="hljs-type">bool</span> unload_module;<br>  <span class="hljs-type">wchar_t</span> dll_name[<span class="hljs-number">1</span>];  <span class="hljs-comment">// placeholder for null terminated name</span><br>  <span class="hljs-comment">// FunctionInfo function_info[] // followed by the functions to intercept</span><br>&#125;;<br><br><span class="hljs-comment">// Structures for the shared memory that contains patching information</span><br><span class="hljs-comment">// for the InterceptionAgent.</span><br><span class="hljs-comment">// A single interception:</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FunctionInfo</span> &#123;<br>  <span class="hljs-type">size_t</span> record_bytes;  <span class="hljs-comment">// rounded to sizeof(size_t) bytes</span><br>  InterceptionType type;<br>  InterceptorId id;<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_address;<br>  <span class="hljs-type">char</span> function[<span class="hljs-number">1</span>];  <span class="hljs-comment">// placeholder for null terminated name</span><br>  <span class="hljs-comment">// char interceptor[]           // followed by the interceptor function</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>成员里的两个注释成员也是很有灵性，注意他们对语法是不可见的。</p><p>计算出长度以后，在<code>InitializeInterceptions</code>的内部new出了这个buffer，此后进入到<code>SetupConfigBuffer</code>部署：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Basically, walk the list of interceptions moving them to the config buffer,</span><br><span class="hljs-comment">// but keeping together all interceptions that belong to the same dll.</span><br><span class="hljs-comment">// The config buffer is a local buffer, not the one allocated on the child.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::SetupConfigBuffer</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer, <span class="hljs-type">size_t</span> buffer_bytes)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == buffer_bytes)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-built_in">DCHECK</span>(buffer_bytes &gt; <span class="hljs-built_in">sizeof</span>(SharedMemory));<br><br>  <span class="hljs-comment">// 开始逐一解构</span><br>  SharedMemory* shared_memory = <span class="hljs-built_in">reinterpret_cast</span>&lt;SharedMemory*&gt;(buffer);<br>  DllPatchInfo* dll_info = shared_memory-&gt;dll_list;<br>  <span class="hljs-type">int</span> num_dlls = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 如果names_used_为真，就把target进程的入口地址作为拦截器的基址</span><br>  shared_memory-&gt;interceptor_base =<br>      names_used_ ? child_-&gt;<span class="hljs-built_in">MainModule</span>() : <span class="hljs-literal">nullptr</span>;<br><br>  buffer_bytes -= <span class="hljs-built_in">offsetof</span>(SharedMemory, dll_list);<br>  buffer = dll_info;<br><br>  <span class="hljs-comment">//开始了，抽离出每个dll，SetupDllInfo</span><br>  std::list&lt;InterceptionData&gt;::iterator it = interceptions_.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">for</span> (; it != interceptions_.<span class="hljs-built_in">end</span>();) &#123;<br>    <span class="hljs-comment">// skip interceptions that are performed from the parent</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsInterceptionPerformedByChild</span>(*it)) &#123;<br>      ++it;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 部署本次的dll</span><br>    <span class="hljs-type">const</span> base::string16 dll = it-&gt;dll;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetupDllInfo</span>(*it, &amp;buffer, &amp;buffer_bytes))<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// walk the interceptions from this point, saving the ones that are</span><br>    <span class="hljs-comment">// performed on this dll, and removing the entry from the list.</span><br>    <span class="hljs-comment">// advance the iterator before removing the element from the list</span><br>    <span class="hljs-comment">// 找到后面相同dll的interception，一并处理然后移除</span><br>    std::list&lt;InterceptionData&gt;::iterator rest = it;<br>    <span class="hljs-keyword">for</span> (; rest != interceptions_.<span class="hljs-built_in">end</span>();) &#123;<br>      <span class="hljs-keyword">if</span> (rest-&gt;dll == dll) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetupInterceptionInfo</span>(*rest, &amp;buffer, &amp;buffer_bytes, dll_info))<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (it == rest)<br>          ++it;<br>        rest = interceptions_.<span class="hljs-built_in">erase</span>(rest);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        ++rest;<br>      &#125;<br>    &#125;<br>    dll_info = <span class="hljs-built_in">reinterpret_cast</span>&lt;DllPatchInfo*&gt;(buffer);<br>    ++num_dlls;<br>  &#125;<br><br>  shared_memory-&gt;num_intercepted_dlls = num_dlls;<span class="hljs-comment">//此时信息就修正了</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<code>SetupConfigBuffer</code>旨在修正buffer中的各个成员。对<code>DllPatchInfo</code>的处理由两个函数协助完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Fills up just the part that depends on the dll, not the info that depends on</span><br><span class="hljs-comment">// the actual interception.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::SetupDllInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> InterceptionData&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">void</span>** buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">size_t</span>* buffer_bytes)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(buffer_bytes);<br>  <span class="hljs-built_in">DCHECK</span>(buffer);<br>  <span class="hljs-built_in">DCHECK</span>(*buffer);<br><br>  DllPatchInfo* dll_info = <span class="hljs-built_in">reinterpret_cast</span>&lt;DllPatchInfo*&gt;(*buffer);<br><br>  <span class="hljs-comment">// the strings have to be zero terminated</span><br>  <span class="hljs-type">size_t</span> required = <span class="hljs-built_in">offsetof</span>(DllPatchInfo, dll_name) +<br>                    (data.dll.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>);<br>  required = <span class="hljs-built_in">RoundUpToMultiple</span>(required, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>));<br>  <span class="hljs-keyword">if</span> (*buffer_bytes &lt; required)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  *buffer_bytes -= required;<br>  *buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(*buffer) + required;<br><br>  <span class="hljs-comment">// set up the dll info to be what we know about it at this time</span><br>  <span class="hljs-comment">// 首次处理一个dll时，仅仅填充了dll相关的信息，FunctionInfo还没有拉进来</span><br>  dll_info-&gt;unload_module = (data.type == INTERCEPTION_UNLOAD_MODULE);<span class="hljs-comment">// 是不是要unload的dll</span><br>  dll_info-&gt;record_bytes = required;<br>  dll_info-&gt;offset_to_functions = required;<br>  dll_info-&gt;num_functions = <span class="hljs-number">0</span>;<br>  data.dll.<span class="hljs-built_in">copy</span>(dll_info-&gt;dll_name, data.dll.<span class="hljs-built_in">size</span>());<br>  dll_info-&gt;dll_name[data.dll.<span class="hljs-built_in">size</span>()] = <span class="hljs-string">L&#x27;\0&#x27;</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::SetupInterceptionInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> InterceptionData&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">void</span>** buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">size_t</span>* buffer_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                DllPatchInfo* dll_info)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(buffer_bytes);<br>  <span class="hljs-built_in">DCHECK</span>(buffer);<br>  <span class="hljs-built_in">DCHECK</span>(*buffer);<br><br>  <span class="hljs-comment">// 都要卸载了，还patch个毛，检查一下有没有这种矛盾的情况</span><br>  <span class="hljs-keyword">if</span> ((dll_info-&gt;unload_module) &amp;&amp; (data.function != kUnloadDLLDummyFunction)) &#123;<br>    <span class="hljs-comment">// Can&#x27;t specify a dll for both patch and unload.</span><br>    <span class="hljs-built_in">NOTREACHED</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 常规操作，把InterceptorData的信息全部倒出来，给FunctionInfo</span><br>  FunctionInfo* function = <span class="hljs-built_in">reinterpret_cast</span>&lt;FunctionInfo*&gt;(*buffer);<br><br>  <span class="hljs-type">size_t</span> name_bytes = data.function.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-type">size_t</span> interceptor_bytes = data.interceptor.<span class="hljs-built_in">size</span>();<br><br>  <span class="hljs-comment">// the strings at the end of the structure are zero terminated</span><br>  <span class="hljs-type">size_t</span> required =<br>      <span class="hljs-built_in">offsetof</span>(FunctionInfo, function) + name_bytes + interceptor_bytes + <span class="hljs-number">2</span>;<br>  required = <span class="hljs-built_in">RoundUpToMultiple</span>(required, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>));<br>  <span class="hljs-keyword">if</span> (*buffer_bytes &lt; required)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// update the caller&#x27;s values</span><br>  *buffer_bytes -= required;<br>  *buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(*buffer) + required;<br><br>  function-&gt;record_bytes = required;<br>  function-&gt;type = data.type;<br>  function-&gt;id = data.id;<br>  <span class="hljs-comment">// FunctionInfo实际上有interceptor_address</span><br>  function-&gt;interceptor_address = data.interceptor_address;<br>  <span class="hljs-type">char</span>* names = function-&gt;function;<br><br>  data.function.<span class="hljs-built_in">copy</span>(names, name_bytes);<br>  names += name_bytes;<br>  *names++ = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>  <span class="hljs-comment">// interceptor follows the function_name</span><br>  <span class="hljs-comment">// 所以对于第一种Add方法，这个interceptor_bytes应该就是0</span><br>  data.interceptor.<span class="hljs-built_in">copy</span>(names, interceptor_bytes);<br>  names += interceptor_bytes;<br>  *names++ = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>  <span class="hljs-comment">// update the dll table</span><br>  <span class="hljs-comment">// 这两个结构才是最为重要的，有他们才能正确定位尾随的FunctionInfo</span><br>  dll_info-&gt;num_functions++;<br>  dll_info-&gt;record_bytes += required;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此后，buffer拷贝给child:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">InterceptionManager::CopyDataToChild</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* local_buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">size_t</span> buffer_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">void</span>** remote_buffer)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(remote_buffer);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == buffer_bytes) &#123;<br>    *remote_buffer = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>  &#125;<br><br>  <span class="hljs-comment">// 借助TargetProcess拿到target进程的句柄</span><br>  HANDLE child = child_-&gt;<span class="hljs-built_in">Process</span>();<br><br>  <span class="hljs-comment">// Allocate memory on the target process without specifying the address</span><br>  <span class="hljs-comment">// 经典的素质二连：VirtualAllocEx + WriteProcessMemory</span><br>  <span class="hljs-type">void</span>* remote_data = ::<span class="hljs-built_in">VirtualAllocEx</span>(child, <span class="hljs-literal">nullptr</span>, buffer_bytes, MEM_COMMIT,<br>                                       PAGE_READWRITE);<br>  <span class="hljs-keyword">if</span> (!remote_data)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_NO_SPACE;<br><br>  SIZE_T bytes_written;<br>  <span class="hljs-type">bool</span> success = ::<span class="hljs-built_in">WriteProcessMemory</span>(child, remote_data, local_buffer,<br>                                      buffer_bytes, &amp;bytes_written);<br>  <span class="hljs-keyword">if</span> (!success || bytes_written != buffer_bytes) &#123;<br>    ::<span class="hljs-built_in">VirtualFreeEx</span>(child, remote_data, <span class="hljs-number">0</span>, MEM_RELEASE);<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_COPY_DATA_TO_CHILD;<br>  &#125;<br><br>  <span class="hljs-comment">//注意remote_buffer参数是个二级指针，如此通过OUT型参数返回了分配地址</span><br>  *remote_buffer = remote_data;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>此后<code>g_interceptions</code>值也传递（<code>TransferVariable</code>）过去，target就可以用它来索引这块<code>remote_buffer</code>。</p><p>分析至此，剩余三个疑点：</p><ol type="1"><li>某个Interception是由target自己执行还是由broker执行，判断的具体条件是什么？</li><li>broker的fire函数仅仅只是把target自己要执行的Interceptions传递了过去，但具体是怎么使用的？broker端执行的Interceptions又是怎样使用的？</li><li><code>PatchNtdll</code>究竟是什么鬼？</li></ol><p>第一个问题实际上很简单，我们展开看看判断函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Only return true if the child should be able to perform this interception.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::IsInterceptionPerformedByChild</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> InterceptionData&amp; data)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-comment">// 心智健全？</span><br>  <span class="hljs-keyword">if</span> (INTERCEPTION_INVALID == data.type)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 系统调用类型的Interception不能由target自己执行，要broker去执行</span><br>  <span class="hljs-keyword">if</span> (INTERCEPTION_SERVICE_CALL == data.type)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 心智健全？</span><br>  <span class="hljs-keyword">if</span> (data.type &gt;= INTERCEPTION_LAST)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// ntdll相关的Interception，都只能由broker执行</span><br>  <span class="hljs-function">base::string16 <span class="hljs-title">ntdll</span><span class="hljs-params">(kNtdllName)</span></span>;<br>  <span class="hljs-keyword">if</span> (ntdll == data.dll)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// ntdll has to be intercepted from the parent</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个问题涉及到了target进程使用的Agent对端，很快就会看到。</p><p>第三个我们展开<code>PatchNtdll</code>看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">InterceptionManager::PatchNtdll</span><span class="hljs-params">(<span class="hljs-type">bool</span> hot_patch_needed)</span> </span>&#123;<br>  <span class="hljs-comment">// Maybe there is nothing to do</span><br>  <span class="hljs-comment">// 如果不需要热补丁且interception空空如也，就什么都不用做</span><br>  <span class="hljs-keyword">if</span> (!hot_patch_needed &amp;&amp; interceptions_.<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br><br>  <span class="hljs-comment">// 如果需要热补丁</span><br>  <span class="hljs-keyword">if</span> (hot_patch_needed) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(SANDBOX_EXPORTS)</span><br><span class="hljs-comment">// Make sure the functions are not excluded by the linker.</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/include:TargetNtMapViewOfSection64&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/include:TargetNtUnmapViewOfSection64&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/include:_TargetNtMapViewOfSection@44&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/include:_TargetNtUnmapViewOfSection@12&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// defined(SANDBOX_EXPORTS)</span></span><br>    <span class="hljs-comment">// 这个宏有点意思，第二个参数的两个InterceptorId是内部使用的前两个成员</span><br>    <span class="hljs-built_in">ADD_NT_INTERCEPTION</span>(NtMapViewOfSection, MAP_VIEW_OF_SECTION_ID, <span class="hljs-number">44</span>);<br>    <span class="hljs-built_in">ADD_NT_INTERCEPTION</span>(NtUnmapViewOfSection, UNMAP_VIEW_OF_SECTION_ID, <span class="hljs-number">12</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Reserve a full 64k memory range in the child process.</span><br>  <span class="hljs-comment">// 在target进程中储备一个64k大小的内存</span><br>  HANDLE child = child_-&gt;<span class="hljs-built_in">Process</span>();<br>  BYTE* thunk_base = <span class="hljs-built_in">reinterpret_cast</span>&lt;BYTE*&gt;(::<span class="hljs-built_in">VirtualAllocEx</span>(<br>      child, <span class="hljs-literal">nullptr</span>, kAllocGranularity, MEM_RESERVE, PAGE_NOACCESS));<br><br>  <span class="hljs-comment">// Find an aligned, random location within the reserved range.</span><br>  <span class="hljs-comment">// 每一个interceptions都占用一个ThunkData，ThunkData实际上是个char[64]包装</span><br>  <span class="hljs-comment">// DllInterceptionData是ThunkData flexible数组的头部</span><br>  <span class="hljs-type">size_t</span> thunk_bytes =<br>      interceptions_.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(ThunkData) + <span class="hljs-built_in">sizeof</span>(DllInterceptionData);<br>  <span class="hljs-comment">// 在64k内存中找到一个随机的偏移起始，当然偏移必须要合适，即64k-offset的尺寸比thunk_bytes大</span><br>  <span class="hljs-type">size_t</span> thunk_offset = internal::<span class="hljs-built_in">GetGranularAlignedRandomOffset</span>(thunk_bytes);<br><br>  <span class="hljs-comment">// Split the base and offset along page boundaries.</span><br>  thunk_base += thunk_offset &amp; ~(kPageSize - <span class="hljs-number">1</span>);<br>  thunk_offset &amp;= kPageSize - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// Make an aligned, padded allocation, and move the pointer to our chunk.</span><br>  <span class="hljs-type">size_t</span> thunk_bytes_padded = (thunk_bytes + kPageSize - <span class="hljs-number">1</span>) &amp; ~(kPageSize - <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 分配padded部分内存空间</span><br>  thunk_base = <span class="hljs-built_in">reinterpret_cast</span>&lt;BYTE*&gt;(<br>      ::<span class="hljs-built_in">VirtualAllocEx</span>(child, thunk_base, thunk_bytes_padded, MEM_COMMIT,<br>                       PAGE_EXECUTE_READWRITE));<br>  <span class="hljs-built_in">CHECK</span>(thunk_base);  <span class="hljs-comment">// If this fails we&#x27;d crash anyway on an invalid access.</span><br>  <span class="hljs-comment">// 找到存储DllInterceptionData的起始位置</span><br>  DllInterceptionData* thunks =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;DllInterceptionData*&gt;(thunk_base + thunk_offset);<br><br>  DllInterceptionData dll_data;<br>  dll_data.data_bytes = thunk_bytes;<br>  dll_data.num_thunks = <span class="hljs-number">0</span>;<br>  dll_data.used_bytes = <span class="hljs-built_in">offsetof</span>(DllInterceptionData, thunks);<br><br>  <span class="hljs-comment">// Reset all helpers for a new child.</span><br>  <span class="hljs-comment">// 清空g_originals全局函数指针数组</span><br>  <span class="hljs-built_in">memset</span>(g_originals, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(g_originals));<br><br>  <span class="hljs-comment">// this should write all the individual thunks to the child&#x27;s memory</span><br>  <span class="hljs-comment">// 对target进程的内存空间写入数据，这个函数看起来很关键</span><br>  ResultCode rc = <span class="hljs-built_in">PatchClientFunctions</span>(thunks, thunk_bytes, &amp;dll_data);<br><br>  <span class="hljs-keyword">if</span> (rc != SBOX_ALL_OK)<br>    <span class="hljs-keyword">return</span> rc;<br><br>  <span class="hljs-comment">// and now write the first part of the table to the child&#x27;s memory</span><br>  <span class="hljs-comment">// 这里向target进程的内存空间写入了DllInterceptionData头部数据</span><br>  <span class="hljs-comment">// 看起来PatchClientFunctions写的是ThunkData[]，并更新了dll_data的成员</span><br>  SIZE_T written;<br>  <span class="hljs-type">bool</span> ok =<br>      !!::<span class="hljs-built_in">WriteProcessMemory</span>(child, thunks, &amp;dll_data,<br>                             <span class="hljs-built_in">offsetof</span>(DllInterceptionData, thunks), &amp;written);<br><br>  <span class="hljs-keyword">if</span> (!ok || (<span class="hljs-built_in">offsetof</span>(DllInterceptionData, thunks) != written))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_WRITE_INTERCEPTION_THUNK;<br><br>  <span class="hljs-comment">// Attempt to protect all the thunks, but ignore failure</span><br>  <span class="hljs-comment">// 对target进程这段空间设置为只读，不允许更改</span><br>  DWORD old_protection;<br>  ::<span class="hljs-built_in">VirtualProtectEx</span>(child, thunks, thunk_bytes, PAGE_EXECUTE_READ,<br>                     &amp;old_protection);<br><br>  <span class="hljs-comment">// 这里传过去了g_originals全局变量，显然这货肯定在PatchClientFunctions中调整了值</span><br>  ResultCode ret =<br>      child_-&gt;<span class="hljs-built_in">TransferVariable</span>(<span class="hljs-string">&quot;g_originals&quot;</span>, g_originals, <span class="hljs-built_in">sizeof</span>(g_originals));<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>看看<code>ADD_NT_INTERCEPTION</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD_NT_INTERCEPTION(service, id, num_params)        \</span><br><span class="hljs-meta">  AddToPatchedFunctions(kNtdllName, #service,               \</span><br><span class="hljs-meta">                        sandbox::INTERCEPTION_SERVICE_CALL, \</span><br><span class="hljs-meta">                        MAKE_SERVICE_NAME(service, num_params), id)</span><br><br><span class="hljs-comment">// This macro simply calls interception_manager.AddToPatchedFunctions with</span><br><span class="hljs-comment">// the given service to intercept (INTERCEPTION_SERVICE_CALL), and assumes that</span><br><span class="hljs-comment">// the interceptor is called &quot;TargetXXX&quot;, where XXX is the name of the service.</span><br><span class="hljs-comment">// Note that num_params is the number of bytes to pop out of the stack for</span><br><span class="hljs-comment">// the exported interceptor, following the calling convention of a service call</span><br><span class="hljs-comment">// (WINAPI = with the &quot;C&quot; underscore).</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SANDBOX_EXPORTS</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_SERVICE_NAME(service, params) <span class="hljs-string">&quot;Target&quot;</span> #service <span class="hljs-string">&quot;64&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_SERVICE_NAME(service, params) <span class="hljs-string">&quot;_Target&quot;</span> #service <span class="hljs-string">&quot;@&quot;</span> #params</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>其实就是拦截ntdll中的某个系统调用，拦截的函数x64上叫TargetXXX64，x86叫_TargetXXX@YYY。</p><p>XXX是系统调用名称，YYY是拦截器在栈上所用的字节数。有个问题在于，这个拦截函数是在哪儿定义的呢？</p><p>再看关键Call：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">InterceptionManager::PatchClientFunctions</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    DllInterceptionData* thunks,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">size_t</span> thunk_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">    DllInterceptionData* dll_data)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(thunks);<br>  <span class="hljs-built_in">DCHECK</span>(dll_data);<br><br>  <span class="hljs-comment">// 拿到ntdll基址</span><br>  HMODULE ntdll_base = ::<span class="hljs-built_in">GetModuleHandle</span>(kNtdllName);<br>  <span class="hljs-keyword">if</span> (!ntdll_base)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_NO_HANDLE;<br><br>  <span class="hljs-type">char</span>* interceptor_base = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(SANDBOX_EXPORTS)</span><br>  interceptor_base = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(child_-&gt;<span class="hljs-built_in">MainModule</span>());<br>  <span class="hljs-function">base::ScopedNativeLibrary <span class="hljs-title">local_interceptor</span><span class="hljs-params">(::LoadLibrary(child_-&gt;Name()))</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// defined(SANDBOX_EXPORTS)</span></span><br><br>  <span class="hljs-comment">// 这个ServiceResolverThunk是个什么东西？</span><br>  std::unique_ptr&lt;ServiceResolverThunk&gt; thunk;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64)</span><br>  thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ServiceResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  base::win::OSInfo* os_info = base::win::OSInfo::<span class="hljs-built_in">GetInstance</span>();<br>  <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">wow64_status</span>() == base::win::OSInfo::WOW64_ENABLED) &#123;<br>    <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">version</span>() &gt;= base::win::VERSION_WIN10)<br>      thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Wow64W10ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">version</span>() &gt;= base::win::VERSION_WIN8)<br>      thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Wow64W8ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>    <span class="hljs-keyword">else</span><br>      thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Wow64ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">version</span>() &gt;= base::win::VERSION_WIN8) &#123;<br>    thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Win8ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ServiceResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> interception : interceptions_) &#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> base::string16 <span class="hljs-title">ntdll</span><span class="hljs-params">(kNtdllName)</span></span>;<br>    <span class="hljs-comment">// 必须的是ntdll的系统调用类型拦截器</span><br>    <span class="hljs-keyword">if</span> (interception.dll != ntdll)<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br>    <span class="hljs-keyword">if</span> (INTERCEPTION_SERVICE_CALL != interception.type)<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(SANDBOX_EXPORTS)</span><br>    <span class="hljs-comment">// We may be trying to patch by function name.</span><br>    <span class="hljs-keyword">if</span> (!interception.interceptor_address) &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* address;<br>      NTSTATUS ret = thunk-&gt;<span class="hljs-built_in">ResolveInterceptor</span>(<br>          local_interceptor.<span class="hljs-built_in">get</span>(), interception.interceptor.<span class="hljs-built_in">c_str</span>(),<br>          <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>**&gt;(&amp;address));<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret)) &#123;<br>        ::<span class="hljs-built_in">SetLastError</span>(<span class="hljs-built_in">GetLastErrorFromNtStatus</span>(ret));<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_RESOLVE_INTERCEPTION_THUNK;<br>      &#125;<br><br>      <span class="hljs-comment">// Translate the local address to an address on the child.</span><br>      interception.interceptor_address =<br>          interceptor_base +<br>          (address - <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(local_interceptor.<span class="hljs-built_in">get</span>()));<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// defined(SANDBOX_EXPORTS)</span></span><br>    NTSTATUS ret = thunk-&gt;<span class="hljs-built_in">Setup</span>(<br>        ntdll_base, interceptor_base, interception.function.<span class="hljs-built_in">c_str</span>(),<br>        interception.interceptor.<span class="hljs-built_in">c_str</span>(), interception.interceptor_address,<br>        &amp;thunks-&gt;thunks[dll_data-&gt;num_thunks],<span class="hljs-comment">// 这里把thunk发在了thunks中，thunks实际上是child的内存空间</span><br>        thunk_bytes - dll_data-&gt;used_bytes, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret)) &#123;<br>      ::<span class="hljs-built_in">SetLastError</span>(<span class="hljs-built_in">GetLastErrorFromNtStatus</span>(ret));<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_SETUP_INTERCEPTION_THUNK;<br>    &#125;<br><br>    <span class="hljs-comment">// 看起来都是围绕着ServiceResolverThunk对象的操作，暂时不关心他具体做了什么</span><br>    <span class="hljs-comment">// 但这里可以看到g_originals的ntdll service call的id索引到了正确的thunks</span><br>    <span class="hljs-comment">// 实际上就是Interceptor id中第一个类别：internal</span><br>    <span class="hljs-built_in">DCHECK</span>(!g_originals[interception.id]);<br>    g_originals[interception.id] = &amp;thunks-&gt;thunks[dll_data-&gt;num_thunks];<br><br>    dll_data-&gt;num_thunks++;<br>    dll_data-&gt;used_bytes += <span class="hljs-built_in">sizeof</span>(ThunkData);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>PatchNtdll</code>看得云里雾里，看起来<code>InterceptionManager</code>确实是个名副其实的管理者，负责的工作有限，我们到此还没有看到完整的功能拼图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Dummy single thunk:</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThunkData</span> &#123;<br>  <span class="hljs-type">char</span> data[kMaxThunkDataBytes];<br>&#125;;<br><br><span class="hljs-comment">// In-memory representation of the interceptions for a given dll:</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DllInterceptionData</span> &#123;<br>  <span class="hljs-type">size_t</span> data_bytes;<br>  <span class="hljs-type">size_t</span> used_bytes;<br>  <span class="hljs-type">void</span>* base;<br>  <span class="hljs-type">int</span> num_thunks;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64)</span><br>  <span class="hljs-type">int</span> dummy;  <span class="hljs-comment">// Improve alignment.</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  ThunkData thunks[<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="interceptionagent"><code>InterceptionAgent</code></h2><p>暂时不理<code>ServiceResolverThunk</code>，去看看target进程的收端Agent：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// of setting up the desired interceptions or indicating what module needs to</span><br><span class="hljs-comment">// be unloaded.</span><br><span class="hljs-comment">// target进程上部署具体的拦截器，broker的manager把interceptions发了过来</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// The exposed API consists of three methods: GetInterceptionAgent to retrieve</span><br><span class="hljs-comment">// the single class instance, OnDllLoad and OnDllUnload to process a dll being</span><br><span class="hljs-comment">// loaded and unloaded respectively.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This class assumes that it will get called for every dll being loaded,</span><br><span class="hljs-comment">// starting with kernel32, so the singleton will be instantiated from within the</span><br><span class="hljs-comment">// loader lock.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptionAgent</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Returns the single InterceptionAgent object for this process.</span><br>  <span class="hljs-comment">// InterceptionAgent是单例模式</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> InterceptionAgent* <span class="hljs-title">GetInterceptionAgent</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// This method should be invoked whenever a new dll is loaded to perform the</span><br>  <span class="hljs-comment">// required patches. If the return value is false, this dll should not be</span><br>  <span class="hljs-comment">// allowed to load.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// full_path is the (optional) full name of the module being loaded and name</span><br>  <span class="hljs-comment">// is the internal module name. If full_path is provided, it will be used</span><br>  <span class="hljs-comment">// before the internal name to determine if we care about this dll.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OnDllLoad</span><span class="hljs-params">(<span class="hljs-type">const</span> UNICODE_STRING* full_path, <span class="hljs-type">const</span> UNICODE_STRING* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">void</span>* base_address)</span></span>;<br><br>  <span class="hljs-comment">// Performs cleanup when a dll is unloaded.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnDllUnload</span><span class="hljs-params">(<span class="hljs-type">void</span>* base_address)</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  ~<span class="hljs-built_in">InterceptionAgent</span>() &#123;&#125;<span class="hljs-comment">// 限定到static成员使用</span><br><br>  <span class="hljs-comment">// Performs initialization of the singleton.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Init</span><span class="hljs-params">(SharedMemory* shared_memory)</span></span>;<br><br>  <span class="hljs-comment">// Returns true if we are interested on this dll. dll_info is an entry of the</span><br>  <span class="hljs-comment">// list of intercepted dlls.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DllMatch</span><span class="hljs-params">(<span class="hljs-type">const</span> UNICODE_STRING* full_path, <span class="hljs-type">const</span> UNICODE_STRING* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> DllPatchInfo* dll_info)</span></span>;<br><br>  <span class="hljs-comment">// Performs the patching of the dll loaded at base_address.</span><br>  <span class="hljs-comment">// The patches to perform are described on dll_info, and thunks is the thunk</span><br>  <span class="hljs-comment">// storage for the whole dll.</span><br>  <span class="hljs-comment">// Returns true on success.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PatchDll</span><span class="hljs-params">(<span class="hljs-type">const</span> DllPatchInfo* dll_info, DllInterceptionData* thunks)</span></span>;<br><br>  <span class="hljs-comment">// 这里又出现了一个ResolverThunk</span><br>  <span class="hljs-comment">// Returns a resolver for a given interception type.</span><br>  <span class="hljs-function">ResolverThunk* <span class="hljs-title">GetResolver</span><span class="hljs-params">(InterceptionType type)</span></span>;<br><br>  <span class="hljs-comment">// 这个是SharedMemory结构</span><br>  <span class="hljs-comment">// 里面描述了有哪些dll，每个dll的哪些函数被hook了</span><br>  <span class="hljs-comment">// Shared memory containing the list of functions to intercept.</span><br>  SharedMemory* interceptions_;<br><br>  <span class="hljs-comment">// Array of thunk data buffers for the intercepted dlls. This object singleton</span><br>  <span class="hljs-comment">// is allocated with a placement new with enough space to hold the complete</span><br>  <span class="hljs-comment">// array of pointers, not just the first element.</span><br>  <span class="hljs-comment">// 这个是DllInterceptionData flexible数组结构，每个dll对应一个成员，这里面承载的是thunk数据</span><br>  DllInterceptionData* dlls_[<span class="hljs-number">1</span>];<br><br>  <span class="hljs-built_in">DISALLOW_IMPLICIT_CONSTRUCTORS</span>(InterceptionAgent);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="getinterceptionagent"><code>GetInterceptionAgent</code></h3><p>先看看单例模式的静态Get方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Memory buffer mapped from the parent, with the list of interceptions.</span><br><span class="hljs-comment">// 这个已经认识了，存储数据的内存空间由broker开辟，g_interceptions会指向那段空间</span><br>SANDBOX_INTERCEPT SharedMemory* g_interceptions = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function">InterceptionAgent* <span class="hljs-title">InterceptionAgent::GetInterceptionAgent</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">static</span> InterceptionAgent* s_singleton = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (!s_singleton) &#123;<br>    <span class="hljs-keyword">if</span> (!g_interceptions)<span class="hljs-comment">// broker得把信息发过来先</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// 注意这里并不是直接new InterceptionAgent对象，而是附加了array_bytes尺寸</span><br>    <span class="hljs-comment">// 附加的尺寸实际上就是flexible成员dlls_这个DllInterceptionData指针数组的尺寸</span><br>    <span class="hljs-comment">// 每有一个dll，就分配一个DllInterceptionData指针出来</span><br>    <span class="hljs-type">size_t</span> array_bytes = g_interceptions-&gt;num_intercepted_dlls * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*);<br>    s_singleton = <span class="hljs-built_in">reinterpret_cast</span>&lt;InterceptionAgent*&gt;(<br>        <span class="hljs-built_in">new</span> (NT_ALLOC) <span class="hljs-type">char</span>[array_bytes + <span class="hljs-built_in">sizeof</span>(InterceptionAgent)]);<br><br>    <span class="hljs-comment">// 实际上是个“零化”函数，全局g_interceptions会在broker中设置，然后调整interceptions_成员</span><br>    <span class="hljs-comment">// 指向这片内存空间，此外，所有的dlls_[i]（每个对应一个DllInterceptionData结构）先指向null</span><br>    <span class="hljs-type">bool</span> success = s_singleton-&gt;<span class="hljs-built_in">Init</span>(g_interceptions);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>      <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(s_singleton, NT_ALLOC)</span></span>;<br>      s_singleton = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s_singleton;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ondllload"><code>OnDllLoad</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionAgent::OnDllLoad</span><span class="hljs-params">(<span class="hljs-type">const</span> UNICODE_STRING* full_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">const</span> UNICODE_STRING* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">void</span>* base_address)</span> </span>&#123;<br>  <span class="hljs-comment">// 解包，拿到DllPatchInfo结构</span><br>  DllPatchInfo* dll_info = interceptions_-&gt;dll_list;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 当dll加载时，先看看想要加载的这个dll是否在拦截列表里</span><br>  <span class="hljs-keyword">for</span> (; i &lt; interceptions_-&gt;num_intercepted_dlls; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">DllMatch</span>(full_path, name, dll_info))<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 定位下一个DllPatchInfo</span><br>    dll_info = <span class="hljs-built_in">reinterpret_cast</span>&lt;DllPatchInfo*&gt;(<br>        <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(dll_info) + dll_info-&gt;record_bytes);<br>  &#125;<br><br>  <span class="hljs-comment">// Return now if the dll is not in our list of interest.</span><br>  <span class="hljs-comment">// 如果不在，说明拦截器对它没兴趣，那么直接load就行了</span><br>  <span class="hljs-keyword">if</span> (i == interceptions_-&gt;num_intercepted_dlls)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// The dll must be unloaded.</span><br>  <span class="hljs-comment">// 到此说明拦截器有这个dll，如果它unload_module的true，那么就表示不允许load</span><br>  <span class="hljs-keyword">if</span> (dll_info-&gt;unload_module)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// Purify causes this condition to trigger.</span><br>  <span class="hljs-comment">// 看看是否已经部署了Dll的DllInterceptionData，也就是拦截器已实装。如果已经实装了，就let it go</span><br>  <span class="hljs-keyword">if</span> (dlls_[i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// 还没有的话就要new出来这个dlls_[i]</span><br>  <span class="hljs-comment">// 每个拦截的函数都有一个ThunkData，为这个拦截dll分配出DllInterceptionData</span><br>  <span class="hljs-comment">// 在dll加载的base_address处分配，这个base_address是参数，究竟把这些thunk data写到了哪里呢？</span><br>  <span class="hljs-type">size_t</span> buffer_bytes = <span class="hljs-built_in">offsetof</span>(DllInterceptionData, thunks) +<br>                        dll_info-&gt;num_functions * <span class="hljs-built_in">sizeof</span>(ThunkData);<br>  dlls_[i] = <span class="hljs-built_in">reinterpret_cast</span>&lt;DllInterceptionData*&gt;(<br>      <span class="hljs-built_in">new</span> (NT_PAGE, base_address) <span class="hljs-type">char</span>[buffer_bytes]);<br><br>  <span class="hljs-built_in">DCHECK_NT</span>(dlls_[i]);<br>  <span class="hljs-comment">// 这种情况居然返回true？我很好奇如何fall through</span><br>  <span class="hljs-keyword">if</span> (!dlls_[i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// 这个时候还仅仅只是一片初始化的空间，ThunkData未填充，num_thunks待更新</span><br>  dlls_[i]-&gt;data_bytes = buffer_bytes;<br>  dlls_[i]-&gt;num_thunks = <span class="hljs-number">0</span>;<br>  dlls_[i]-&gt;base = base_address;<br>  dlls_[i]-&gt;used_bytes = <span class="hljs-built_in">offsetof</span>(DllInterceptionData, thunks);<br><br>  <span class="hljs-comment">// 这个PatchDll看起来很关键，从传入的两个参数就能看出来，应该是真正的thunk实装</span><br>  <span class="hljs-built_in">VERIFY</span>(<span class="hljs-built_in">PatchDll</span>(dll_info, dlls_[i]));<br><br>  <span class="hljs-comment">// dlls_[i]指向的这段内存标记为RE，防止Write</span><br>  ULONG old_protect;<br>  SIZE_T real_size = buffer_bytes;<br>  <span class="hljs-type">void</span>* to_protect = dlls_[i];<br>  <span class="hljs-built_in">VERIFY_SUCCESS</span>(g_nt.<span class="hljs-built_in">ProtectVirtualMemory</span>(NtCurrentProcess, &amp;to_protect,<br>                                           &amp;real_size, PAGE_EXECUTE_READ,<br>                                           &amp;old_protect));<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键的<code>PatchDll</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TODO(rvargas): We have to deal with prebinded dlls. I see two options: change</span><br><span class="hljs-comment">// the timestamp of the patched dll, or modify the info on the prebinded dll.</span><br><span class="hljs-comment">// the first approach messes matching of debug symbols, the second one is more</span><br><span class="hljs-comment">// complicated.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionAgent::PatchDll</span><span class="hljs-params">(<span class="hljs-type">const</span> DllPatchInfo* dll_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 DllInterceptionData* thunks)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_NT</span>(thunks);<br>  <span class="hljs-built_in">DCHECK_NT</span>(dll_info);<br><br>  <span class="hljs-comment">// 定位到DllPatchInfo中的第一个FunctionInfo</span><br>  <span class="hljs-type">const</span> FunctionInfo* function = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> FunctionInfo*&gt;(<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(dll_info) + dll_info-&gt;offset_to_functions);<br><br>  <span class="hljs-comment">// 对每个需要interception的函数进行处理</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dll_info-&gt;num_functions; i++) &#123;<br>    <span class="hljs-comment">// 尺寸校验</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsWithinRange</span>(dll_info, dll_info-&gt;record_bytes, function-&gt;function)) &#123;<br>      <span class="hljs-built_in">NOTREACHED_NT</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里用到了resolver，function-&gt;type指定了这是哪一类别的interception，所以就找到具体的resolver</span><br>    <span class="hljs-comment">// 怎么看resolver都是个父类指针指向子类对象，而猜测每一种type的interception都会有一个resolver</span><br>    ResolverThunk* resolver = <span class="hljs-built_in">GetResolver</span>(function-&gt;type);<br>    <span class="hljs-keyword">if</span> (!resolver)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// interceptor的名称紧随function的名称其后</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor =<br>        function-&gt;function + g_nt.<span class="hljs-built_in">strlen</span>(function-&gt;function) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsWithinRange</span>(function, function-&gt;record_bytes, interceptor) ||<br>        !<span class="hljs-built_in">IsWithinRange</span>(dll_info, dll_info-&gt;record_bytes, interceptor)) &#123;<br>      <span class="hljs-built_in">NOTREACHED_NT</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-comment">// resolver的Setup方法看起来很关键，thunk data和DllPatchInfo的关联就在此处</span><br>    NTSTATUS ret = resolver-&gt;<span class="hljs-built_in">Setup</span>(<br>        thunks-&gt;base, interceptions_-&gt;interceptor_base, function-&gt;function,<br>        interceptor, function-&gt;interceptor_address, &amp;thunks-&gt;thunks[i],<br>        <span class="hljs-built_in">sizeof</span>(ThunkData), <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret)) &#123;<br>      <span class="hljs-built_in">NOTREACHED_NT</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">DCHECK_NT</span>(!g_originals[function-&gt;id]);<br>    <span class="hljs-comment">// 这里调整了g_originals的数组成员，根据被拦截函数的id，索引指针指向正确的thunk data</span><br>    <span class="hljs-comment">// 看起来DllPatchInfo中的FunctionInfo和DllInterceptionData中的ThunkData一一对应</span><br>    <span class="hljs-comment">// FunctionInfo[i]-&gt;ThunkData[i]</span><br>    g_originals[function-&gt;id] = &amp;thunks-&gt;thunks[i];<br><br>    <span class="hljs-comment">// 更新DllInterceptionData的数据成员</span><br>    thunks-&gt;num_thunks++;<br>    thunks-&gt;used_bytes += <span class="hljs-built_in">sizeof</span>(ThunkData);<br><br>    <span class="hljs-comment">// 但FunctionInfo毕竟是不定长的，不能用FunctionInfo[i]，所以要通过record_bytes来step</span><br>    function = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> FunctionInfo*&gt;(<br>        <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(function) + function-&gt;record_bytes);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体resolver是如何利用的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This method is called from within the loader lock</span><br><span class="hljs-function">ResolverThunk* <span class="hljs-title">InterceptionAgent::GetResolver</span><span class="hljs-params">(InterceptionType type)</span> </span>&#123;<br>  <span class="hljs-comment">// 这几个都是ResolverThunk的派生类，根据名称可以发现和type息息相关</span><br>  <span class="hljs-comment">// 看起来此前的推断是正确的</span><br>  <span class="hljs-type">static</span> EatResolverThunk* eat_resolver = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-type">static</span> SidestepResolverThunk* sidestep_resolver = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-type">static</span> SmartSidestepResolverThunk* smart_sidestep_resolver = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-comment">// static成员，在第一次进入时new出单例</span><br>  <span class="hljs-keyword">if</span> (!eat_resolver)<br>    eat_resolver = <span class="hljs-built_in">new</span> (NT_ALLOC) EatResolverThunk;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(_WIN64)</span><br>  <span class="hljs-comment">// Sidestep is not supported for x64.</span><br>  <span class="hljs-comment">// sidestep和smart_sidestep不能在x64上使用</span><br>  <span class="hljs-keyword">if</span> (!sidestep_resolver)<br>    sidestep_resolver = <span class="hljs-built_in">new</span> (NT_ALLOC) SidestepResolverThunk;<br><br>  <span class="hljs-keyword">if</span> (!smart_sidestep_resolver)<br>    smart_sidestep_resolver = <span class="hljs-built_in">new</span> (NT_ALLOC) SmartSidestepResolverThunk;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">// 根据type返回对应type的resolver</span><br>  <span class="hljs-comment">// 注意到实际上只有3种类型，少了service call和unload module</span><br>  <span class="hljs-comment">// unload module可以理解，毕竟不涉及到function的interception，但service call为什么用不到呢？</span><br>  <span class="hljs-comment">// 根据此前对两种interception的了解，service call应该都是由broker来执行的，target并不会用到</span><br>  <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> INTERCEPTION_EAT:<br>      <span class="hljs-keyword">return</span> eat_resolver;<br>    <span class="hljs-keyword">case</span> INTERCEPTION_SIDESTEP:<br>      <span class="hljs-keyword">return</span> sidestep_resolver;<br>    <span class="hljs-keyword">case</span> INTERCEPTION_SMART_SIDESTEP:<br>      <span class="hljs-keyword">return</span> smart_sidestep_resolver;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-built_in">NOTREACHED_NT</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个最为关键的就是<code>Resolver</code>的<code>Setup</code>方法了，是他把<code>ThunkData</code>和<code>FunctionInfo</code>关联了起来，实装了补丁，那么具体是如何操纵的呢？我们下一篇抽离<code>Resolver</code>相关内容单独分析。</p><h3 id="ondllunload"><code>OnDllUnload</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InterceptionAgent::OnDllUnload</span><span class="hljs-params">(<span class="hljs-type">void</span>* base_address)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; interceptions_-&gt;num_intercepted_dlls; i++) &#123;<br>    <span class="hljs-comment">// 这种逻辑处理方式，如果有两个感兴趣的dll在load的时候，base_address一致怎么办？</span><br>    <span class="hljs-comment">// 这样就可能在unload时找错了目标。</span><br>    <span class="hljs-comment">// 但仔细想想，如果base_address是dll加载基址的话，不同dll也不可能具有相同的base_address</span><br>    <span class="hljs-comment">// 所以这个base_address的意义就很重要了</span><br>    <span class="hljs-keyword">if</span> (dlls_[i] &amp;&amp; dlls_[i]-&gt;base == base_address) &#123;<br>      <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(dlls_[i], NT_PAGE)</span></span>;<br>      dlls_[i] = <span class="hljs-literal">nullptr</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就相当简单了，此前安装的dll如果部署了interception，那就需要delete掉在<code>base_address</code>分配的内存空间。这部分内存空间此前用来承载thunkdata。</p><p>到此，<code>Interception</code>相关的Manager和Agent就分析完了，显然缺少了<code>Resolver</code>的介入，我们对整个流程还是不甚清楚，下一节我们分析<code>Resolver</code>，直捣黄龙。</p>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-HandleCloser-analysis</title>
    <link href="/2018/05/21/chromium-sandbox-HandleCloser-analysis/"/>
    <url>/2018/05/21/chromium-sandbox-HandleCloser-analysis/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第九篇，主要分析了windows平台下，Chromiumsandbox中broker制造并传输target需要关闭的句柄的实现机制。阅读本篇前，请先阅读前四篇。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-handlecloser-analysis">chromium-sandbox-HandleCloser-analysis</h1><p>在分析了<code>PolicyBase</code>的三大组件后，转去分析了一波不太相关的<code>SharedMemIPC</code>机制。实际上<code>PolicyBase</code>内部还有很多东西我们没有拆解，比如AppContainer、<code>HandleClose</code>、Mitigations等等。今天来分析一个比较简单的<code>HandleCloser</code>类。该类模块维护了一个句柄类型到名称的映射，用于在target进程中关闭句柄。而联系此前在<code>PolicyBase</code>中所观察到的对<code>handle_closer_</code>成员的使用以及句柄列表的传输，这个模块的功用也就呼之欲出了。</p><h2 id="policybase-related"><code>PolicyBase</code> related</h2><p>从<code>PolicyBase</code>的操纵开始分析，在<code>BrokerServicesBase::SpawnTarget</code>中创建<code>TargetProcess</code>并将target挂到<code>PolicyBase</code>对象时，调用了<code>PolicyBase::AddTarget</code>，而它的内部进行了这样几个操作：</p><ol type="1"><li>low-level-policy的收工（这个low-level-policy是个狭义的policy，和<code>PolicyBase</code>的这个policy不是一个层面的意思，我们之后会说到，windows子系统行为鉴权的三大构成：policy+dispatcher+interception）</li><li>mitigation对target进程的应用（当前还是挂起态）</li><li>部署Interceptions</li><li>部署<code>HandleCloser</code></li><li>创建<code>SharedMemIPC</code>的Server端，实际上创建的是IPCserver和<code>Dispatcher</code>，用于处理target进程的IPC请求。</li><li>对target进程的全局变量<code>g_shared_delayed_integrity_level</code>和<code>g_shared_delayed_mitigations</code>赋值</li></ol><p>这里关于第五点和第六点，我们都已经清楚了它的实现机理与意义，前三个我们暂时不关心，看看第四点对<code>HandleCloser</code>的部署：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PolicyBase::SetupHandleCloser</span><span class="hljs-params">(TargetProcess* target)</span> </span>&#123;<br>  <span class="hljs-comment">// 调用了handle_closer_的InitializeTargetHandles方法</span><br>  <span class="hljs-comment">// handle_closer_是PolicyBase内部的HandleCloser对象</span><br>  <span class="hljs-keyword">return</span> handle_closer_.<span class="hljs-built_in">InitializeTargetHandles</span>(target);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="handlecloser"><code>HandleCloser</code></h2><p>在展开<code>HandleCloser</code>类头定义前，先看看该类成员类型<code>HandleMap</code>的定义。<code>HandleMap</code>是这样的一种类型：<code>typedef std::map&lt;const base::string16, std::set&lt;base::string16&gt;&gt; HandleMap;</code></p><p>从<code>const string16</code>(也就是<code>const std::wstring</code>)到<code>set&lt;base::string16&gt;</code>的一个map。</p><p>除了<code>HandleMap</code>以外，先不关心其他的辅助结构，看看类头：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Adds handles to close after lockdown.</span><br><span class="hljs-comment">// 在target进程被LowerToken()降权时，关闭加入的所有句柄</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleCloser</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">HandleCloser</span>();<br>  ~<span class="hljs-built_in">HandleCloser</span>();<br><br>  <span class="hljs-comment">// Adds a handle that will be closed in the target process after lockdown.</span><br>  <span class="hljs-comment">// A nullptr value for handle_name indicates all handles of the specified</span><br>  <span class="hljs-comment">// type. An empty string for handle_name indicates the handle is unnamed.</span><br>  <span class="hljs-comment">// 可以看到这个接口需要被提供句柄类型和名称</span><br>  <span class="hljs-comment">// 如果name是nullptr，那就表示所有的该类型句柄都要加入</span><br>  <span class="hljs-comment">// 如果name是空串，就表示该句柄是匿名的</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">AddHandle</span><span class="hljs-params">(<span class="hljs-type">const</span> base::char16* handle_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">const</span> base::char16* handle_name)</span></span>;<br><br>  <span class="hljs-comment">// Serializes and copies the closer table into the target process.</span><br>  <span class="hljs-comment">// 看起来是序列化待关闭句柄表，copy给target进程</span><br>  <span class="hljs-comment">// 这个函数就是在PolicyBase::SetupHandleCloser中调用的</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InitializeTargetHandles</span><span class="hljs-params">(TargetProcess* target)</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Calculates the memory needed to copy the serialized handles list (rounded</span><br>  <span class="hljs-comment">// to the nearest machine-word size).</span><br>  <span class="hljs-comment">// copy序列化句柄列表时，用于计算buffer尺寸</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetBufferSize</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Serializes the handle list into the target process.</span><br>  <span class="hljs-comment">// 序列化句柄列表到target进程</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetupHandleList</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer, <span class="hljs-type">size_t</span> buffer_bytes)</span></span>;<br><br>  HandleMap handles_to_close_;<span class="hljs-comment">//这个HandleMap就是维护句柄类型到名称的成员</span><br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(HandleCloser);<br>&#125;;<br></code></pre></td></tr></table></figure><p>此外，有个全局的<code>g_handle_closer_info</code>指针指向<code>HandleCloserInfo</code>结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Global parameters and a pointer to the list of entries.</span><br><span class="hljs-comment">// 看起来是个全局量，内部维护了一个到handle列表的指针</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HandleCloserInfo</span> &#123;<br>  <span class="hljs-type">size_t</span> record_bytes;  <span class="hljs-comment">// Rounded to sizeof(size_t) bytes.</span><br>  <span class="hljs-type">size_t</span> num_handle_types;<span class="hljs-comment">//有多少种类型</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">HandleListEntry</span> handle_entries[<span class="hljs-number">1</span>];<span class="hljs-comment">//应该是flexible</span><br>&#125;;<br><br><span class="hljs-comment">// Type and set of corresponding handle names to close.</span><br><span class="hljs-comment">// 某种类型句柄的所有handle</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HandleListEntry</span> &#123;<br>  <span class="hljs-type">size_t</span> record_bytes;     <span class="hljs-comment">// Rounded to sizeof(size_t) bytes.</span><br>  <span class="hljs-type">size_t</span> offset_to_names;  <span class="hljs-comment">// Nul terminated strings of name_count names.</span><br>  <span class="hljs-type">size_t</span> name_count;<span class="hljs-comment">// 有多少个name</span><br>  base::char16 handle_type[<span class="hljs-number">1</span>];<span class="hljs-comment">// 这个应该不是flexible，表示type类型</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的设计很像<code>SharedMemIPC</code>中buffer的设计，它也分为三级结构：</p><ol type="1"><li><code>HandleCloserInfo</code>的<code>num_handle_types</code>表明了有多少个<code>HandleListEntry</code>结构</li><li>每个<code>HandleListEntry</code>包含了一个<code>offset_to_names</code>成员，指向了存储该type的句柄所有名称的位置</li><li>指向的真实数据就是一堆句柄的名称了，它们应该是紧凑的附加在<code>HandleListEntry</code>数组的正后方的。</li></ol><p>当然，这里仅仅是大胆的猜测，是否真的如此，还得继续看代码逻辑处理。</p><p>###<code>InitializeTargetHandles</code></p><p>由<code>PolicyBase::SetupHandleCloser</code>跟入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HandleCloser::InitializeTargetHandles</span><span class="hljs-params">(TargetProcess* target)</span> </span>&#123;<br>  <span class="hljs-comment">// Do nothing on an empty list (global pointer already initialized to</span><br>  <span class="hljs-comment">// nullptr).</span><br>  <span class="hljs-comment">// 如果没什么需要target关闭的，返回就好了</span><br>  <span class="hljs-keyword">if</span> (handles_to_close_.<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-type">size_t</span> bytes_needed = <span class="hljs-built_in">GetBufferSize</span>();<span class="hljs-comment">//先不管他怎么算出来的</span><br>  <span class="hljs-comment">// new出一片空间，划分成size_t大小的块，local_buffer指向首块</span><br>  <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">size_t</span>[]&gt; <span class="hljs-title">local_buffer</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">new</span> <span class="hljs-type">size_t</span>[bytes_needed / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">size_t</span>)])</span></span>;<br><br>  <span class="hljs-comment">// 切成size_t数组的缓冲区丢给SetupHandleList，内部应该就是对buffer结构的部署</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetupHandleList</span>(local_buffer.<span class="hljs-built_in">get</span>(), bytes_needed))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 拿到target进程的进程句柄</span><br>  HANDLE child = target-&gt;<span class="hljs-built_in">Process</span>();<br><br>  <span class="hljs-comment">// Windows跨进程写入数据的常见套路VirtualAllocEx-&gt;WriteProcessMemory</span><br>  <span class="hljs-comment">// 然而第二个参数使用的是nullptr，这就表示broker在这里并不是把数据写入到某个固定的内存空间</span><br>  <span class="hljs-comment">// Allocate memory in the target process without specifying the address</span><br>  <span class="hljs-type">void</span>* remote_data = ::<span class="hljs-built_in">VirtualAllocEx</span>(child, <span class="hljs-literal">nullptr</span>, bytes_needed, MEM_COMMIT,<br>                                       PAGE_READWRITE);<br>  <span class="hljs-keyword">if</span> (!remote_data)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// Copy the handle buffer over.</span><br>  SIZE_T bytes_written;<br>  <span class="hljs-type">bool</span> result = ::<span class="hljs-built_in">WriteProcessMemory</span>(child, remote_data, local_buffer.<span class="hljs-built_in">get</span>(),<br>                                     bytes_needed, &amp;bytes_written);<br>  <span class="hljs-keyword">if</span> (!result || bytes_written != bytes_needed) &#123;<br>    ::<span class="hljs-built_in">VirtualFreeEx</span>(child, remote_data, <span class="hljs-number">0</span>, MEM_RELEASE);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 为了让target自己能够找到这段内存空间，broker把一个指向这段内存起始的remote_data也传了过去</span><br>  <span class="hljs-comment">// 依然是通过老方法TransferVariable，对target自己的全局变量g_handles_to_close赋值</span><br>  <span class="hljs-comment">// 这里也可以看到，内存空间已经布局成了HandleCloserInfo，暂时和我们的猜想一致</span><br>  g_handles_to_close = <span class="hljs-built_in">reinterpret_cast</span>&lt;HandleCloserInfo*&gt;(remote_data);<br>  ResultCode rc = target-&gt;<span class="hljs-built_in">TransferVariable</span>(<br>      <span class="hljs-string">&quot;g_handles_to_close&quot;</span>, &amp;g_handles_to_close, <span class="hljs-built_in">sizeof</span>(g_handles_to_close));<br><br>  <span class="hljs-keyword">return</span> (SBOX_ALL_OK == rc);<br>&#125;<br></code></pre></td></tr></table></figure><p>展开<code>GetBufferSize</code>看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">HandleCloser::GetBufferSize</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 先算出HandleCloserInfo第一层数据的尺寸</span><br>  <span class="hljs-type">size_t</span> bytes_total = <span class="hljs-built_in">offsetof</span>(HandleCloserInfo, handle_entries);<br><br>  <span class="hljs-comment">// 迭代每种type的handles，</span><br>  <span class="hljs-keyword">for</span> (HandleMap::iterator i = handles_to_close_.<span class="hljs-built_in">begin</span>();<br>       i != handles_to_close_.<span class="hljs-built_in">end</span>(); ++i) &#123;<br>    <span class="hljs-comment">// bytes_entry表示HandleListEntry二层结构的尺寸加上handle_type本身这个字符串的尺寸</span><br>    <span class="hljs-type">size_t</span> bytes_entry = <span class="hljs-built_in">offsetof</span>(HandleListEntry, handle_type) +<br>                         (i-&gt;first.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(base::char16);<br>    <span class="hljs-comment">// 迭代该类型handles的set，里面存的都是名称</span><br>    <span class="hljs-keyword">for</span> (HandleMap::mapped_type::iterator j = i-&gt;second.<span class="hljs-built_in">begin</span>();<br>         j != i-&gt;second.<span class="hljs-built_in">end</span>(); ++j) &#123;<br>      <span class="hljs-comment">// 这里又对bytes_entry累加了所有名称的长度</span><br>      bytes_entry += ((*j).<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(base::char16);<br>    &#125;<br><br>    <span class="hljs-comment">// Round up to the nearest multiple of word size.</span><br>    <span class="hljs-comment">// 因为字符串的单位不规则，为了解构时方便索引下一个HandleListEntry，做了个对齐操作</span><br>    bytes_entry = <span class="hljs-built_in">RoundUpToWordSize</span>(bytes_entry);<br>    <span class="hljs-comment">// 加到总的尺寸上</span><br>    bytes_total += bytes_entry;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> bytes_total;<br>&#125;<br></code></pre></td></tr></table></figure><p>好吧，看到这个<code>GetBuffer</code>感觉和此前的猜想有些出入，至少<code>HandleListEntry</code>的<code>handle_type</code>是flexible的，但它的长度是不定的，而紧随在一个<code>HandleListEntry</code>之后的并不是下一个<code>HandleListEntry</code>，应该是该种类型handles的名称字符串集合，<code>HandleListEntry</code>的<code>offset_to_names</code>指向了第一个name起始。</p><p>为了确认这一布局，我们在<code>SetupHandleList</code>中一探究竟：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HandleCloser::SetupHandleList</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer, <span class="hljs-type">size_t</span> buffer_bytes)</span> </span>&#123;<br>  <span class="hljs-comment">// buffer_bytes就是GetBuffer算出来的尺寸，buffer就是new出来的空间</span><br>  ::<span class="hljs-built_in">ZeroMemory</span>(buffer, buffer_bytes);<br>  HandleCloserInfo* handle_info = <span class="hljs-built_in">reinterpret_cast</span>&lt;HandleCloserInfo*&gt;(buffer);<br>  <span class="hljs-comment">// 总的字节数，有多少种句柄</span><br>  handle_info-&gt;record_bytes = buffer_bytes;<br>  handle_info-&gt;num_handle_types = handles_to_close_.<span class="hljs-built_in">size</span>();<br><br>  <span class="hljs-comment">// output指向第一个HandleListEntry起始位置</span><br>  <span class="hljs-comment">// end指向整个buffer的末尾</span><br>  base::char16* output =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;base::char16*&gt;(&amp;handle_info-&gt;handle_entries[<span class="hljs-number">0</span>]);<br>  base::char16* end = <span class="hljs-built_in">reinterpret_cast</span>&lt;base::char16*&gt;(<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(buffer) + buffer_bytes);<br>  <span class="hljs-comment">// 这里面包含了各种不定长的HandleListEntry对nameset的嵌套</span><br>  <span class="hljs-comment">// 还是迭代每种类型</span><br>  <span class="hljs-keyword">for</span> (HandleMap::iterator i = handles_to_close_.<span class="hljs-built_in">begin</span>();<br>       i != handles_to_close_.<span class="hljs-built_in">end</span>(); ++i) &#123;<br>    <span class="hljs-comment">// 这说明算出来的buffer有问题</span><br>    <span class="hljs-keyword">if</span> (output &gt;= end)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 找到本次迭代的HandleListEntry</span><br>    <span class="hljs-comment">// 尽管HandleListEntry在HandleClientInfo中定义成了flexible array，但因为不定长的原因</span><br>    <span class="hljs-comment">// 不能直接使用HandleListEntry[index]来索引</span><br>    HandleListEntry* list_entry = <span class="hljs-built_in">reinterpret_cast</span>&lt;HandleListEntry*&gt;(output);<br>    <span class="hljs-comment">//调整output到handle_type，起始处是个type name</span><br>    output = &amp;list_entry-&gt;handle_type[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-comment">// Copy the typename and set the offset and count.</span><br>    i-&gt;first.<span class="hljs-built_in">copy</span>(output, i-&gt;first.<span class="hljs-built_in">size</span>());<br>    *(output += i-&gt;first.<span class="hljs-built_in">size</span>()) = <span class="hljs-string">L&#x27;\0&#x27;</span>;<br>    output++;<br>    <span class="hljs-comment">// skip typename后，就是一串name了，偏移也就可以算出来了</span><br>    list_entry-&gt;offset_to_names =<br>        <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(output) - <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(list_entry);<br>    list_entry-&gt;name_count = i-&gt;second.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// Copy the handle names.</span><br>    <span class="hljs-comment">// 拷贝所有的handle name到buffer中，output相应做位置调整</span><br>    <span class="hljs-keyword">for</span> (HandleMap::mapped_type::iterator j = i-&gt;second.<span class="hljs-built_in">begin</span>();<br>         j != i-&gt;second.<span class="hljs-built_in">end</span>(); ++j) &#123;<br>      output = std::<span class="hljs-built_in">copy</span>((*j).<span class="hljs-built_in">begin</span>(), (*j).<span class="hljs-built_in">end</span>(), output) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Round up to the nearest multiple of sizeof(size_t).</span><br>    <span class="hljs-comment">// 向上取整，按size_t对齐，这个和GetBuffer的对齐方法必须要一致，否则这里的迭代会有问题</span><br>    output = <span class="hljs-built_in">RoundUpToWordSize</span>(output);<br>    list_entry-&gt;record_bytes =<br>        <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(output) - <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(list_entry);<br>    <span class="hljs-comment">//处理下一个type</span><br>  &#125;<br><br>  <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(output), <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(end));<br>  <span class="hljs-keyword">return</span> output &lt;= end;<br>&#125;<br></code></pre></td></tr></table></figure><p>看了这个布局函数，也就彻底明白了<code>HandleCloserInfo</code>的嵌套结构。所以，<code>HandleCloserInfo</code>和<code>SharedMemIPC</code>的设计不同，前者只有两级结构，二级结构的flexible数组是不定长的，而后者则是三级结构，二级结构flexible数组定长。</p><p>此外，我们在<code>InitializeTargetHandles</code>中看到，这些数组都被拷贝给了target进程中，由<code>g_handles_to_close</code>全局变量来定位，且不管target自己是怎么关闭这些handle的（还能怎么关，不过是同种方式解包然后<code>CloseHandle</code>），至少我们知道了在调用<code>InitializeTargetHandles</code>之前，<code>handles_to_close_</code>成员就应该已经填充好了需要关闭的句柄（这就和target可继承句柄列表的设置很像，先填充成员，再<code>CreateProcess</code>）。</p><p>那么添加句柄的接口是谁呢？是还未分析的<code>AddHandle</code>。操纵<code>AddHandle</code>的又是谁呢？现在还不知道。</p><h3 id="addhandle"><code>AddHandle</code></h3><p>先看看<code>AddHandle</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">HandleCloser::AddHandle</span><span class="hljs-params">(<span class="hljs-type">const</span> base::char16* handle_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">const</span> base::char16* handle_name)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!handle_type)<span class="hljs-comment">// 这个必须有</span><br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br>  base::string16 resolved_name;<br>  <span class="hljs-keyword">if</span> (handle_name) &#123;<span class="hljs-comment">// 这个可以有</span><br>    resolved_name = handle_name;<br>    <span class="hljs-keyword">if</span> (handle_type == base::<span class="hljs-built_in">string16</span>(<span class="hljs-string">L&quot;Key&quot;</span>))<span class="hljs-comment">// 如果handle是Key类型，那么名称要修剪一下,ResolveRegistryName其实是一个Windows注册表相关操作简单的封装</span><br>      <span class="hljs-comment">// 这里就不详细研究名称是什么了，想要了解可以用调试器下断点分析</span><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ResolveRegistryName</span>(resolved_name, &amp;resolved_name))<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>  &#125;<br><br>  <span class="hljs-comment">// 先在handles_to_close_找一下是否有该类型的句柄，map中type为键</span><br>  HandleMap::iterator names = handles_to_close_.<span class="hljs-built_in">find</span>(handle_type);<br>  <span class="hljs-keyword">if</span> (names == handles_to_close_.<span class="hljs-built_in">end</span>()) &#123;  <span class="hljs-comment">// We have no entries for this type.</span><br>    <span class="hljs-comment">// 如果没有的话，就插入handle_type, HandleMap::mapped_type()这样的一个entry</span><br>    std::pair&lt;HandleMap::iterator, <span class="hljs-type">bool</span>&gt; result = handles_to_close_.<span class="hljs-built_in">insert</span>(<br>        HandleMap::<span class="hljs-built_in">value_type</span>(handle_type, HandleMap::<span class="hljs-built_in">mapped_type</span>()));<br>    names = result.first;<span class="hljs-comment">// names索引插入的entry</span><br>    <span class="hljs-keyword">if</span> (handle_name)<br>      names-&gt;second.<span class="hljs-built_in">insert</span>(resolved_name);<span class="hljs-comment">// 如果有名字，那就在该type对应的空set中插入该名字</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!handle_name) &#123;  <span class="hljs-comment">// Now we need to close all handles of this type.</span><br>    <span class="hljs-comment">// 如果handle_name是nullptr，会清掉当前该type对应set的所有名字</span><br>    <span class="hljs-comment">// 原来是clear，看前面注释还以为是把所有该类型句柄都加进来。。。想想也不太可能</span><br>    names-&gt;second.<span class="hljs-built_in">clear</span>();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!names-&gt;second.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">// Add another name for this type.</span><br>    <span class="hljs-comment">// 如果当前type对应的set不为空，则插入另一个名字</span><br>    names-&gt;second.<span class="hljs-built_in">insert</span>(resolved_name);<br>  &#125;  <span class="hljs-comment">// If we&#x27;re already closing all handles of type then we&#x27;re done.</span><br><span class="hljs-comment">// 如果此时已经全都清掉了，那再来的就不管了。</span><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>逻辑很紧凑，也可以看出它的工作机理和外部的操纵息息相关，外部如果出现第一次插入某个匿名的不存在其他该type的句柄，然后后续又插入一个该type的命名句柄，并不会顺利插入。</p><p>感觉这个函数挖了坑，说不定以后会有错误的使用者出现。</p></blockquote><p>再来找找操纵者，除了test测试代码，仅在这里找到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::AddKernelObjectToClose</span><span class="hljs-params">(<span class="hljs-type">const</span> base::char16* handle_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                                              <span class="hljs-type">const</span> base::char16* handle_name)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> handle_closer_.<span class="hljs-built_in">AddHandle</span>(handle_type, handle_name);<br>&#125;<br></code></pre></td></tr></table></figure><p>再次查找<code>AddKernelObjectToClose</code>的caller，除了test，只有<code>PolicyBase::SetDisconnectCsrss</code>中有身影：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetDisconnectCsrss</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// Does not work on 32-bit, and the ASAN runtime falls over with the</span><br><span class="hljs-comment">// CreateThread EAT patch used when this is enabled.</span><br><span class="hljs-comment">// See https://crbug.com/783296#c27.</span><br><span class="hljs-comment">// 未开启ASAN的win10 x64所用，看起来和某个bug有关，以后有空看看</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64) &amp;&amp; !defined(ADDRESS_SANITIZER)</span><br>  <span class="hljs-keyword">if</span> (base::win::<span class="hljs-built_in">GetVersion</span>() &gt;= base::win::VERSION_WIN10) &#123;<br>    is_csrss_connected_ = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">AddKernelObjectToClose</span>(<span class="hljs-string">L&quot;ALPC Port&quot;</span>, <span class="hljs-literal">nullptr</span>);<span class="hljs-comment">//但这里是把ALPC Port都clear了</span><br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// !defined(_WIN64)</span></span><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是个clear操作，显然是为了让win10 x64的target可以使用ALPCPort句柄。sandbox找不到其他的调用处，应该是启动器外部通过<code>PolicyBase</code>调用了<code>AddKernelObjectToClose</code>。</p><p>毕竟<code>PolicyBase</code>是传进来的，外部通过<code>BrokerServicesBase::CreatePolicy</code>创建policy，然后对policy一顿操作，然后<code>BrokerServicesBase::SpawnTarget</code>中传入了policy。</p><h2 id="handlecloseragent"><code>HandleCloserAgent</code></h2><p>Broker这边的流程都已了解了，下面我们找找target自身是如何关闭这些句柄的。在handle_closer_agent.h中找到了target用到的封装类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Target process code to close the handle list copied over from the broker.</span><br><span class="hljs-comment">// 这个是target进程的代码，它关闭broker传过来的句柄列表</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleCloserAgent</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">HandleCloserAgent</span>();<br>  ~<span class="hljs-built_in">HandleCloserAgent</span>();<br><br>  <span class="hljs-comment">// Reads the serialized list from the broker and creates the lookup map.</span><br>  <span class="hljs-comment">// Updates is_csrss_connected based on type of handles closed.</span><br>  <span class="hljs-comment">// 从broker读取序列化列表，创建一个lookup map</span><br>  <span class="hljs-comment">// 根据关闭的句柄类型，更新is_csrss_connected</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitializeHandlesToClose</span><span class="hljs-params">(<span class="hljs-type">bool</span>* is_csrss_connected)</span></span>;<br><br>  <span class="hljs-comment">// Closes any handles matching those in the lookup map.</span><br>  <span class="hljs-comment">// 关闭lookup map中匹配的句柄</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CloseHandles</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// True if we have handles waiting to be closed.</span><br>  <span class="hljs-comment">// 这是个static方法，用于判断当前是否在等待句柄被关闭</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">NeedsHandlesClosed</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Attempt to stuff a closed handle with a dummy Event.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AttemptToStuffHandleSlot</span><span class="hljs-params">(HANDLE closed_handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">const</span> base::string16&amp; type)</span></span>;<br><br>  HandleMap handles_to_close_;<br>  base::win::ScopedHandle dummy_handle_;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(HandleCloserAgent);<br>&#125;;<br></code></pre></td></tr></table></figure><h3id="initializehandlestoclose"><code>InitializeHandlesToClose</code></h3><p>这个函数应该就是从传过来的g_handles_to_close读操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Reads g_handles_to_close and creates the lookup map.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleCloserAgent::InitializeHandlesToClose</span><span class="hljs-params">(<span class="hljs-type">bool</span>* is_csrss_connected)</span> </span>&#123;<br>  <span class="hljs-built_in">CHECK</span>(g_handles_to_close);<br>  <span class="hljs-comment">//target进也定义了一个g_handles_to_close指针，但实际上是由broker进程来写入</span><br><br>  <span class="hljs-comment">// Default to connected state</span><br>  <span class="hljs-comment">// 默认情况是连接到运行时子系统的</span><br>  *is_csrss_connected = <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// Grab the header.</span><br>  <span class="hljs-comment">// 开始了，对HandleCloserInfo开始parse</span><br>  HandleListEntry* entry = g_handles_to_close-&gt;handle_entries;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; g_handles_to_close-&gt;num_handle_types; ++i) &#123;<br>    <span class="hljs-comment">// Set the type name.</span><br>    base::char16* input = entry-&gt;handle_type;<br>    <span class="hljs-comment">// 如果关闭的句柄有ALPC Port类型，就会断开与csrss的连接（csrss就是通过这个ALPC端口连接的）</span><br>    <span class="hljs-comment">// 还记得前面探索AddTarget时发现的win10 x64特殊处理吗？</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">wcscmp</span>(input, <span class="hljs-string">L&quot;ALPC Port&quot;</span>)) &#123;<br>      *is_csrss_connected = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//handle_names是句柄名的set</span><br>    HandleMap::mapped_type&amp; handle_names = handles_to_close_[input];<br>    input = <span class="hljs-built_in">reinterpret_cast</span>&lt;base::char16*&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(entry) +<br>                                            entry-&gt;offset_to_names);<br>    <span class="hljs-comment">// Grab all the handle names.</span><br>    <span class="hljs-comment">// 这就导入到成员handles_to_close_中了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; entry-&gt;name_count; ++j) &#123;<br>      std::pair&lt;HandleMap::mapped_type::iterator, <span class="hljs-type">bool</span>&gt; name =<br>          handle_names.<span class="hljs-built_in">insert</span>(input);<br>      <span class="hljs-built_in">CHECK</span>(name.second);<br>      input += name.first-&gt;<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Move on to the next entry.</span><br>    <span class="hljs-comment">// 继续下一个</span><br>    entry = <span class="hljs-built_in">reinterpret_cast</span>&lt;HandleListEntry*&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(entry) +<br>                                               entry-&gt;record_bytes);<br><br>    <span class="hljs-built_in">DCHECK</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;base::char16*&gt;(entry) &gt;= input);<br>    <span class="hljs-built_in">DCHECK</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;base::char16*&gt;(entry) - input &lt;<br>           <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">ptrdiff_t</span>&gt;(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>) / <span class="hljs-built_in">sizeof</span>(base::char16)));<br>  &#125;<br><br>  <span class="hljs-comment">// Clean up the memory we copied over.</span><br>  <span class="hljs-comment">// 拷贝到handles_to_close_完毕，可以清了g_handles_to_close</span><br>  ::<span class="hljs-built_in">VirtualFree</span>(g_handles_to_close, <span class="hljs-number">0</span>, MEM_RELEASE);<br>  g_handles_to_close = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="closehandles"><code>CloseHandles</code></h3><p>导入操作已经知晓了，此时<code>handles_to_close_</code>已装载。下一个最为重要的就是close操作了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HandleCloserAgent::CloseHandles</span><span class="hljs-params">()</span> </span>&#123;<br>  DWORD handle_count = UINT_MAX;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> kInvalidHandleThreshold = <span class="hljs-number">100</span>;<br>  <span class="hljs-comment">// 句柄都是4的倍数，可以参考wrk的句柄表设计，PID的设计也复用了句柄表设计，所以都是4的倍数</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kHandleOffset = <span class="hljs-number">4</span>;  <span class="hljs-comment">// Handles are always a multiple of 4.</span><br><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">GetProcessHandleCount</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), &amp;handle_count))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// Set up buffers for the type info and the name.</span><br>  <span class="hljs-function">std::vector&lt;BYTE&gt; <span class="hljs-title">type_info_buffer</span><span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(OBJECT_TYPE_INFORMATION) +</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-number">32</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">wchar_t</span>))</span></span>;<br>  OBJECT_TYPE_INFORMATION* type_info =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;OBJECT_TYPE_INFORMATION*&gt;(&amp;(type_info_buffer[<span class="hljs-number">0</span>]));<br>  base::string16 handle_name;<br>  HANDLE handle = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-type">int</span> invalid_count = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Keep incrementing until we hit the number of handles reported by</span><br>  <span class="hljs-comment">// GetProcessHandleCount(). If we hit a very long sequence of invalid</span><br>  <span class="hljs-comment">// handles we assume that we&#x27;ve run past the end of the table.</span><br>  <span class="hljs-comment">// 以句柄号从下限值到上限值迭代，通过NtQueryObject来判断某个句柄值是否有效，然后再匹配</span><br>  <span class="hljs-keyword">while</span> (handle_count &amp;&amp; invalid_count &lt; kInvalidHandleThreshold) &#123;<br>    <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">size_t</span>&amp;&gt;(handle) += kHandleOffset;<br>    NTSTATUS rc;<br><br>    <span class="hljs-comment">// Get the type name, reusing the buffer.</span><br>    <span class="hljs-comment">// 又见二次调用的操作，只不过做了二层封装</span><br>    ULONG size = <span class="hljs-built_in">static_cast</span>&lt;ULONG&gt;(type_info_buffer.<span class="hljs-built_in">size</span>());<br>    rc = <span class="hljs-built_in">QueryObjectTypeInformation</span>(handle, type_info, &amp;size);<span class="hljs-comment">//封装了NtQueryObject的一些操作</span><br>    <span class="hljs-keyword">while</span> (rc == STATUS_INFO_LENGTH_MISMATCH || rc == STATUS_BUFFER_OVERFLOW) &#123;<br>      type_info_buffer.<span class="hljs-built_in">resize</span>(size + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>));<br>      type_info =<br>          <span class="hljs-built_in">reinterpret_cast</span>&lt;OBJECT_TYPE_INFORMATION*&gt;(&amp;(type_info_buffer[<span class="hljs-number">0</span>]));<br>      rc = <span class="hljs-built_in">QueryObjectTypeInformation</span>(handle, type_info, &amp;size);<br>      <span class="hljs-comment">// Leave padding for the nul terminator.</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NT_SUCCESS</span>(rc) &amp;&amp; size == type_info_buffer.<span class="hljs-built_in">size</span>())<br>        rc = STATUS_INFO_LENGTH_MISMATCH;<br>    &#125;<br>    <span class="hljs-comment">// 如果这个句柄号是有效的，那么就说明确实有这个句柄，没有的话就不浪费感情lookup匹配了</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(rc) || !type_info-&gt;Name.Buffer) &#123;<br>      ++invalid_count;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    --handle_count;<br>    type_info-&gt;Name.Buffer[type_info-&gt;Name.Length / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>)] = <span class="hljs-string">L&#x27;\0&#x27;</span>;<br>    <span class="hljs-comment">// 这段是查找传过来的handles_to_close_，看看是否需要关闭该句柄</span><br>    <span class="hljs-comment">// 如果需要关闭，那就CloseHandle</span><br>    <span class="hljs-comment">// Check if we&#x27;re looking for this type of handle.</span><br>    HandleMap::iterator result = handles_to_close_.<span class="hljs-built_in">find</span>(type_info-&gt;Name.Buffer);<br>    <span class="hljs-keyword">if</span> (result != handles_to_close_.<span class="hljs-built_in">end</span>()) &#123;<br>      HandleMap::mapped_type&amp; names = result-&gt;second;<br>      <span class="hljs-comment">// Empty set means close all handles of this type; otherwise check name.</span><br>      <span class="hljs-keyword">if</span> (!names.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// Move on to the next handle if this name doesn&#x27;t match.</span><br>        <span class="hljs-comment">// 这个GetHandleName在handle_closer.cc中实现，实际上依然是NtQueryObject的封装</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetHandleName</span>(handle, &amp;handle_name) || !names.<span class="hljs-built_in">count</span>(handle_name))<br>          <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">SetHandleInformation</span>(handle, HANDLE_FLAG_PROTECT_FROM_CLOSE, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">CloseHandle</span>(handle))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-comment">// Attempt to stuff this handle with a new dummy Event.</span><br>      <span class="hljs-comment">// 尝试填满Handle槽？不懂什么意思，传入了handle和type</span><br>      <span class="hljs-built_in">AttemptToStuffHandleSlot</span>(handle, result-&gt;first);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// Returns the object manager&#x27;s name associated with a handle</span><br><span class="hljs-comment">// 通过handle反查name，实际上用NtQueryObject这个万用API可以做到，查询的class为</span><br><span class="hljs-comment">// ObjectNameInformation</span><br><span class="hljs-comment">// NtQueryObject很强大，根据传入的OBJECT_INFORMATION_CLASS值可以查询不同的信息</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetHandleName</span><span class="hljs-params">(HANDLE handle, base::string16* handle_name)</span> </span>&#123;<br>  <span class="hljs-type">static</span> NtQueryObject QueryObject = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (!QueryObject)<br>    <span class="hljs-built_in">ResolveNTFunctionPtr</span>(<span class="hljs-string">&quot;NtQueryObject&quot;</span>, &amp;QueryObject);<br><br>  ULONG size = MAX_PATH;<br>  std::unique_ptr&lt;UNICODE_STRING, base::FreeDeleter&gt; name;<br>  NTSTATUS result;<br><br>  <span class="hljs-keyword">do</span> &#123;<br>    name.<span class="hljs-built_in">reset</span>(<span class="hljs-built_in">static_cast</span>&lt;UNICODE_STRING*&gt;(<span class="hljs-built_in">malloc</span>(size)));<br>    <span class="hljs-built_in">DCHECK</span>(name.<span class="hljs-built_in">get</span>());<br>    result =<br>        <span class="hljs-built_in">QueryObject</span>(handle, ObjectNameInformation, name.<span class="hljs-built_in">get</span>(), size, &amp;size);<br>  &#125; <span class="hljs-keyword">while</span> (result == STATUS_INFO_LENGTH_MISMATCH ||<br>           result == STATUS_BUFFER_OVERFLOW);<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NT_SUCCESS</span>(result) &amp;&amp; name-&gt;Buffer &amp;&amp; name-&gt;Length)<br>    handle_name-&gt;<span class="hljs-built_in">assign</span>(name-&gt;Buffer, name-&gt;Length / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>));<br>  <span class="hljs-keyword">else</span><br>    handle_name-&gt;<span class="hljs-built_in">clear</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">NT_SUCCESS</span>(result);<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个<code>QueryObjectTypeInformation</code>也类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Returns type infomation for an NT object. This routine is expected to be</span><br><span class="hljs-comment">// called for invalid handles so it catches STATUS_INVALID_HANDLE exceptions</span><br><span class="hljs-comment">// that can be generated when handle tracing is enabled.</span><br><span class="hljs-comment">// 返回的是handle对应的type而非name</span><br><span class="hljs-function">NTSTATUS <span class="hljs-title">QueryObjectTypeInformation</span><span class="hljs-params">(HANDLE handle, <span class="hljs-type">void</span>* buffer, ULONG* size)</span> </span>&#123;<br>  <span class="hljs-type">static</span> NtQueryObject QueryObject = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// 还是用NtQueryObject</span><br>  <span class="hljs-keyword">if</span> (!QueryObject)<br>    <span class="hljs-built_in">ResolveNTFunctionPtr</span>(<span class="hljs-string">&quot;NtQueryObject&quot;</span>, &amp;QueryObject);<br><br>  NTSTATUS status = STATUS_UNSUCCESSFUL;<br>  __try &#123;<br>    <span class="hljs-comment">// 这一次用的class是ObjectTypeInformation</span><br>    status = <span class="hljs-built_in">QueryObject</span>(handle, ObjectTypeInformation, buffer, *size, size);<br>  &#125; __except (<span class="hljs-built_in">GetExceptionCode</span>() == STATUS_INVALID_HANDLE<br>                  ? EXCEPTION_EXECUTE_HANDLER<br>                  : EXCEPTION_CONTINUE_SEARCH) &#123;<br>    status = STATUS_INVALID_HANDLE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CloseHandles</code>最后调用了<code>AttemptToStuffHandleSlot</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Attempts to stuff |closed_handle| with a duplicated handle for a dummy Event</span><br><span class="hljs-comment">// with no access. This should allow the handle to be closed, to avoid</span><br><span class="hljs-comment">// generating EXCEPTION_INVALID_HANDLE on shutdown, but nothing else. For now</span><br><span class="hljs-comment">// the only supported |type| is Event or File.</span><br><span class="hljs-comment">// 关闭句柄时防止产生EXCEPTION_INVALID_HANDLE，仅仅支持Event或File类型句柄</span><br><span class="hljs-comment">// 这东西用途我还不理解，看起来是对于Event和File句柄做的额外操作，复制一个再CloseHandle</span><br><span class="hljs-comment">// 不懂有什么用</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HandleCloserAgent::AttemptToStuffHandleSlot</span><span class="hljs-params">(HANDLE closed_handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">const</span> base::string16&amp; type)</span> </span>&#123;<br>  <span class="hljs-comment">// Only attempt to stuff Files and Events at the moment.</span><br>  <span class="hljs-keyword">if</span> (type != <span class="hljs-string">L&quot;Event&quot;</span> &amp;&amp; type != <span class="hljs-string">L&quot;File&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!dummy_handle_.<span class="hljs-built_in">IsValid</span>())<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// This should never happen, as g_dummy is created before closing to_stuff.</span><br>  <span class="hljs-built_in">DCHECK</span>(dummy_handle_.<span class="hljs-built_in">Get</span>() != closed_handle);<br><br>  std::vector&lt;HANDLE&gt; to_close;<br>  HANDLE dup_dummy = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-type">size_t</span> count = <span class="hljs-number">16</span>;<br><br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), dummy_handle_.<span class="hljs-built_in">Get</span>(),<br>                           ::<span class="hljs-built_in">GetCurrentProcess</span>(), &amp;dup_dummy, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>))<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (dup_dummy != closed_handle)<br>      to_close.<span class="hljs-built_in">push_back</span>(dup_dummy);<br>  &#125; <span class="hljs-keyword">while</span> (count-- &amp;&amp; <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(dup_dummy) &lt;<br>                          <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(closed_handle));<br><br>  <span class="hljs-keyword">for</span> (HANDLE h : to_close)<br>    ::<span class="hljs-built_in">CloseHandle</span>(h);<br><br>  <span class="hljs-comment">// TODO(wfh): Investigate why stuffing handles sometimes fails.</span><br>  <span class="hljs-comment">// http://crbug.com/649904</span><br>  <span class="hljs-keyword">return</span> dup_dummy == closed_handle;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要是不懂dummy_handle_成员的意义，不知道为什么要频繁尝试复制，且再次Close掉。这里面应该涉及到了某种技术，而这个函数只是抛开基础架设的一个应用。</p><p>如果以后我对它有了正确的理解，再来补充吧，留个坑。</p><p>下面感兴趣的就是target进程如何操纵。</p><h2 id="targetservicesbase-related"><code>TargetServicesBase</code>related</h2><p><code>TargetServicesBase</code>是给target进程提供的服务面。在<code>TargetServicesBase::LowerToken</code>中找到了这样一个操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Failure here is a breach of security so the process is terminated.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TargetServicesBase::LowerToken</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (ERROR_SUCCESS !=<br>      <span class="hljs-built_in">SetProcessIntegrityLevel</span>(g_shared_delayed_integrity_level))<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_INTEGRITY);<br>  process_state_.<span class="hljs-built_in">SetRevertedToSelf</span>();<br>  <span class="hljs-comment">// If the client code as called RegOpenKey, advapi32.dll has cached some</span><br>  <span class="hljs-comment">// handles. The following code gets rid of them.</span><br>  <span class="hljs-comment">// 最不起眼的其实是最关键的call，不过本次我们就不理它了</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">RevertToSelf</span>())<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_DROPTOKEN);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">FlushCachedRegHandles</span>())<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_FLUSHANDLES);<br>  <span class="hljs-keyword">if</span> (ERROR_SUCCESS != ::<span class="hljs-built_in">RegDisablePredefinedCache</span>())<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_CACHEDISABLE);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WarmupWindowsLocales</span>())<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_WARMUP);<br>  <span class="hljs-type">bool</span> is_csrss_connected = <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">// 就是它，关闭了句柄，并根据ALPC port是否被关闭来设置csrss的连接状态</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CloseOpenHandles</span>(&amp;is_csrss_connected))<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_CLOSEHANDLES);<br>  process_state_.<span class="hljs-built_in">SetCsrssConnected</span>(is_csrss_connected);<br>  <span class="hljs-comment">// Enabling mitigations must happen last otherwise handle closing breaks</span><br>  <span class="hljs-keyword">if</span> (g_shared_delayed_mitigations &amp;&amp;<br>      !<span class="hljs-built_in">ApplyProcessMitigationsToCurrentProcess</span>(g_shared_delayed_mitigations))<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_MITIGATION);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还可以看到<code>g_shared_delayed_integrity_level</code>和<code>g_shared_delayed_mitigations</code>的使用。</p><p>展开<code>CloseOpenHandles</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Checks if we have handle entries pending and runs the closer.</span><br><span class="hljs-comment">// Updates is_csrss_connected based on which handle types are closed.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CloseOpenHandles</span><span class="hljs-params">(<span class="hljs-type">bool</span>* is_csrss_connected)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (HandleCloserAgent::<span class="hljs-built_in">NeedsHandlesClosed</span>()) &#123;<span class="hljs-comment">//其实就是!!g_handles_to_close，转bool值判断</span><br>    <span class="hljs-comment">// 此时broker已经写好了g_handles_to_close，开始吧</span><br>    HandleCloserAgent handle_closer;<br>    <span class="hljs-comment">// 第一步，InitializeHandlesToClose</span><br>    handle_closer.<span class="hljs-built_in">InitializeHandlesToClose</span>(is_csrss_connected);<br>    <span class="hljs-keyword">if</span> (!*is_csrss_connected) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CsrssDisconnectCleanup</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 第二步，CloseHandles</span><br>    <span class="hljs-keyword">if</span> (!handle_closer.<span class="hljs-built_in">CloseHandles</span>())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，关于<code>HandleCloser</code>和<code>HandleCloserAgent</code>的分析就结束了，相对简单的一部分。</p>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-SharedMemIPC-analysis</title>
    <link href="/2018/05/20/chromium-sandbox-SharedMemIPC/"/>
    <url>/2018/05/20/chromium-sandbox-SharedMemIPC/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第八篇，主要分析了windows平台下，Chromiumsandbox IPC通信中使用的共享内存IPC机制，其中分析了IPCbuffer的设计以及C/S两端的使用流程。阅读本篇前，请先阅读第七篇。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sharedmemipc-analysis">chromium-SharedMemIPC-analysis</h1><p><code>CrossCall</code>的server和client只组成了IPC通信的一部分，尽管整体的通信模型已经有了了解，但代码拼图还未完成，上一节留下的疑问是Server端的<code>Dispatcher</code>是如何驱动的，又有谁来驱动。经一番搜索，在<code>SharedMemIPC</code>相关的代码中找到了答案。</p><p><code>SharedMemIPC</code>是一个基于共享内存的IPC机制，它是IPC的一种具体实现的封装。也可以通过其他机制来实现IPC，比如命名管道等。</p><h2 id="server">Server</h2><p>且看sharedmem_ipc_server.h对server的描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// IPC transport implementation that uses shared memory.</span><br><span class="hljs-comment">// This is the server side</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The server side has knowledge about the layout of the shared memory</span><br><span class="hljs-comment">// and the state transitions. Both are explained in sharedmem_ipc_client.h</span><br><span class="hljs-comment">// server对共享内存的布局是知情的。</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// As opposed to SharedMemIPClient, the Server object should be one for the</span><br><span class="hljs-comment">// entire lifetime of the target process. The server is in charge of creating</span><br><span class="hljs-comment">// the events (ping, pong) both for the client and for the target that are used</span><br><span class="hljs-comment">// to signal the IPC and also in charge of setting the initial state of the</span><br><span class="hljs-comment">// channels.</span><br><span class="hljs-comment">// 与Client不同的是，对整个target进程生命周期来说，server object只能有一个</span><br><span class="hljs-comment">// 它负责为client和用于signal IPC的target创建事件，也负责设置channel（信道）的初始化状态</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// When an IPC is ready, the server relies on being called by on the</span><br><span class="hljs-comment">// ThreadPingEventReady callback. The IPC server then retrieves the buffer,</span><br><span class="hljs-comment">// marshals it into a CrossCallParam object and calls the Dispatcher, who is in</span><br><span class="hljs-comment">// charge of fulfilling the IPC request.</span><br><span class="hljs-comment">// IPC到来时，server在ThreadPingEventReady回调函数上回复。</span><br><span class="hljs-comment">// IPC server解包buffer，置入CrossCallParam对象并调用Dispatcher来处理IPC请求。</span><br></code></pre></td></tr></table></figure><p>Server处理的后半段机制已经在CrossCall的server端看到了。感兴趣的是这个<code>ThreadPingEventReady</code>。</p><h3 id="sharedmemipcserver"><code>SharedMemIPCServer</code></h3><p>先看一下类定义头：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// the shared memory implementation of the IPC server. There should be one</span><br><span class="hljs-comment">// of these objects per target (IPC client) process</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedMemIPCServer</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Creates the IPC server.</span><br>  <span class="hljs-comment">// target_process: handle to the target process. It must be suspended. It is</span><br>  <span class="hljs-comment">// unfortunate to receive a raw handle (and store it inside this object) as</span><br>  <span class="hljs-comment">// that dilutes ownership of the process, but in practice a SharedMemIPCServer</span><br>  <span class="hljs-comment">// is owned by TargetProcess, which calls this method, and owns the handle, so</span><br>  <span class="hljs-comment">// everything is safe. If that changes, we should break this dependency and</span><br>  <span class="hljs-comment">// duplicate the handle instead.</span><br>  <span class="hljs-comment">// target_process_id: process id of the target process.</span><br>  <span class="hljs-comment">// thread_provider: a thread provider object.</span><br>  <span class="hljs-comment">// dispatcher: an object that can service IPC calls.</span><br>  <span class="hljs-comment">// 构造器很关键，数据结构的关联就在此处理，描述中得知一个关键的线索是SharedMemIPCServer由TargetProcess所持有</span><br>  <span class="hljs-built_in">SharedMemIPCServer</span>(HANDLE target_process,<span class="hljs-comment">//关联target进程句柄和id</span><br>                     DWORD target_process_id,<br>                     ThreadProvider* thread_provider,<span class="hljs-comment">//关联线程池</span><br>                     Dispatcher* dispatcher);<span class="hljs-comment">//关联分发器</span><br><br>  ~<span class="hljs-built_in">SharedMemIPCServer</span>();<br><br>  <span class="hljs-comment">// Initializes the server structures, shared memory structures and</span><br>  <span class="hljs-comment">// creates the kernels events used to signal the IPC.</span><br>  <span class="hljs-comment">// 看来还是有日常操作Init，用于初始化共享内存的尺寸、信道分割</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">void</span>* shared_mem, <span class="hljs-type">uint32_t</span> shared_size, <span class="hljs-type">uint32_t</span> channel_size)</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Allow tests to be marked DISABLED_. Note that FLAKY_ and FAILS_ prefixes</span><br>  <span class="hljs-comment">// do not work with sandbox tests.</span><br>  <span class="hljs-built_in">FRIEND_TEST_ALL_PREFIXES</span>(IPCTest, SharedMemServerTests);<br>  <span class="hljs-comment">// When an event fires (IPC request). A thread from the ThreadProvider</span><br>  <span class="hljs-comment">// will call this function. The context parameter should be the same as</span><br>  <span class="hljs-comment">// provided when ThreadProvider::RegisterWait was called.</span><br>  <span class="hljs-comment">// IPC请求到来时，ThreadProvider产生的thread会先调用这个static函数</span><br>  <span class="hljs-comment">// context就是ThreadProvider::RegisterWait调用时用到的context</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __stdcall <span class="hljs-title">ThreadPingEventReady</span><span class="hljs-params">(<span class="hljs-type">void</span>* context, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)</span></span>;<br><br>  <span class="hljs-comment">// Makes the client and server events. This function is called once</span><br>  <span class="hljs-comment">// per channel.</span><br>  <span class="hljs-comment">// C/S之间的来回event make方法，因为是共享内存的IPC，所以填充的一方signal ping事件，</span><br>  <span class="hljs-comment">// 表示收端可以处理了，而收端处理完signal pong事件，表示填充完结果请发端get</span><br>  <span class="hljs-comment">// ping-pong的名称很有灵性啊</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MakeEvents</span><span class="hljs-params">(base::win::ScopedHandle* server_ping,</span></span><br><span class="hljs-params"><span class="hljs-function">                  base::win::ScopedHandle* server_pong,</span></span><br><span class="hljs-params"><span class="hljs-function">                  HANDLE* client_ping,</span></span><br><span class="hljs-params"><span class="hljs-function">                  HANDLE* client_pong)</span></span>;<br><br>  <span class="hljs-comment">// A copy this structure is maintained per channel.</span><br>  <span class="hljs-comment">// Note that a lot of the fields are just the same of what we have in the IPC</span><br>  <span class="hljs-comment">// object itself. It is better to have the copies since we can dispatch in the</span><br>  <span class="hljs-comment">// static method without worrying about converting back to a member function</span><br>  <span class="hljs-comment">// call or about threading issues.</span><br>  <span class="hljs-comment">// 定义了一个内部结构体，提取了一些IPC对象本体的成员，用于在static方法中dispatch</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServerControl</span> &#123;<br>    <span class="hljs-built_in">ServerControl</span>();<br>    ~<span class="hljs-built_in">ServerControl</span>();<br><br>    <span class="hljs-comment">// This channel server ping event.</span><br>    base::win::ScopedHandle ping_event;<br>    <span class="hljs-comment">// This channel server pong event.</span><br>    base::win::ScopedHandle pong_event;<br>    <span class="hljs-comment">// The size of this channel.</span><br>    <span class="hljs-type">uint32_t</span> channel_size;<br>    <span class="hljs-comment">// The pointer to the actual channel data.</span><br>    <span class="hljs-type">char</span>* channel_buffer;<br>    <span class="hljs-comment">// The pointer to the base of the shared memory.</span><br>    <span class="hljs-type">char</span>* shared_base;<br>    <span class="hljs-comment">// A pointer to this channel&#x27;s client-side control structure this structure</span><br>    <span class="hljs-comment">// lives in the shared memory.</span><br>    ChannelControl* channel;<br>    <span class="hljs-comment">// the IPC dispatcher associated with this channel.</span><br>    Dispatcher* dispatcher;<br>    <span class="hljs-comment">// The target process information associated with this channel.</span><br>    ClientInfo target_info;<br>  &#125;;<br><br>  <span class="hljs-comment">// Looks for the appropriate handler for this IPC and invokes it.</span><br>  <span class="hljs-comment">// 这个是对IPC handler的查找与调用static方法</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">InvokeCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ServerControl* service_context,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">void</span>* ipc_buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                             CrossCallReturn* call_result)</span></span>;<br><br>  <span class="hljs-comment">// Points to the shared memory channel control which lives at</span><br>  <span class="hljs-comment">// the start of the shared section.</span><br>  IPCControl* client_control_;<span class="hljs-comment">//共享内存的起始结构，控制了channel的分割</span><br><br>  <span class="hljs-comment">// Keeps track of the server side objects that are used to answer an IPC.</span><br>  <span class="hljs-comment">// 这里把ServerControl对象的指针做成链，在响应IPC时会用到</span><br>  std::list&lt;std::unique_ptr&lt;ServerControl&gt;&gt; server_contexts_;<br><br>  <span class="hljs-comment">// The thread provider provides the threads that call back into this object</span><br>  <span class="hljs-comment">// when the IPC events fire.</span><br>  <span class="hljs-comment">// 当IPC事件到来时，thread_provider_就是那个负责发起线程来调用callback的线程池</span><br>  ThreadProvider* thread_provider_;<br><br>  <span class="hljs-comment">// The IPC object is associated with a target process.</span><br>  <span class="hljs-comment">// IPC对象关联的target进程句柄</span><br>  HANDLE target_process_;<br><br>  <span class="hljs-comment">// The target process id associated with the IPC object.</span><br>  <span class="hljs-comment">// IPC对象关联的target进程id</span><br>  DWORD target_process_id_;<br><br>  <span class="hljs-comment">// The dispatcher handles &#x27;ready&#x27; IPC calls.</span><br>  <span class="hljs-comment">// Dispatcher就是IPC call的分发器，分发到具体的callback</span><br>  Dispatcher* call_dispatcher_;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(SharedMemIPCServer);<br>&#125;;<br></code></pre></td></tr></table></figure><p>构造器/析构器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 显然thread_provider和dispatcher都不归该对象管理，SharedMemIPCServer只是他们的操纵者</span><br>SharedMemIPCServer::<span class="hljs-built_in">SharedMemIPCServer</span>(HANDLE target_process,<br>                                       DWORD target_process_id,<br>                                       ThreadProvider* thread_provider,<br>                                       Dispatcher* dispatcher)<br>    : <span class="hljs-built_in">client_control_</span>(<span class="hljs-literal">nullptr</span>),<br>      <span class="hljs-built_in">thread_provider_</span>(thread_provider),<br>      <span class="hljs-built_in">target_process_</span>(target_process),<br>      <span class="hljs-built_in">target_process_id_</span>(target_process_id),<br>      <span class="hljs-built_in">call_dispatcher_</span>(dispatcher) &#123;<br>  <span class="hljs-comment">// We create a initially owned mutex. If the server dies unexpectedly,</span><br>  <span class="hljs-comment">// the thread that owns it will fail to release the lock and windows will</span><br>  <span class="hljs-comment">// report to the target (when it tries to acquire it) that the wait was</span><br>  <span class="hljs-comment">// abandoned. Note: We purposely leak the local handle because we want it to</span><br>  <span class="hljs-comment">// be closed by Windows itself so it is properly marked as abandoned if the</span><br>  <span class="hljs-comment">// server dies.</span><br>  <span class="hljs-keyword">if</span> (!g_alive_mutex) &#123;<br>    HANDLE mutex = ::<span class="hljs-built_in">CreateMutexW</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-comment">// 教科书般的竞态处理</span><br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">InterlockedCompareExchangePointer</span>(&amp;g_alive_mutex, mutex, <span class="hljs-literal">nullptr</span>)) &#123;<br>      <span class="hljs-comment">// We lost the race to create the mutex.</span><br>      ::<span class="hljs-built_in">CloseHandle</span>(mutex);<br>    &#125;<br>  &#125;<br>&#125;<br><br>SharedMemIPCServer::~<span class="hljs-built_in">SharedMemIPCServer</span>() &#123;<br>  <span class="hljs-comment">// Free the wait handles associated with the thread pool.</span><br>  <span class="hljs-comment">// 暂时先不关心thread_provider的实现机制，了解他的角色功用就行了</span><br>  <span class="hljs-keyword">if</span> (!thread_provider_-&gt;<span class="hljs-built_in">UnRegisterWaits</span>(<span class="hljs-keyword">this</span>)) &#123;<br>    <span class="hljs-comment">// Better to leak than to crash.</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  server_contexts_.<span class="hljs-built_in">clear</span>();<br><br>  <span class="hljs-keyword">if</span> (client_control_)<br>    ::<span class="hljs-built_in">UnmapViewOfFile</span>(client_control_);<span class="hljs-comment">// 明显共享内存是client控制的，它是IPCControl起始的结构</span><br>&#125;<br></code></pre></td></tr></table></figure><p>明显析构和构造对不上，这是chrome的固有套路，构造要接Init:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SharedMemIPCServer::Init</span><span class="hljs-params">(<span class="hljs-type">void</span>* shared_mem,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">uint32_t</span> shared_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">uint32_t</span> channel_size)</span> </span>&#123;<br>  <span class="hljs-comment">// The shared memory needs to be at least as big as a channel.</span><br>  <span class="hljs-comment">// 共享内存大小至少得容纳一个channel</span><br>  <span class="hljs-keyword">if</span> (shared_size &lt; channel_size) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// The channel size should be aligned.</span><br>  <span class="hljs-comment">// 信道尺寸必须得是按32字节对齐</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != (channel_size % <span class="hljs-number">32</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Calculate how many channels we can fit in the shared memory.</span><br>  <span class="hljs-comment">// 计算出共享内存可以容纳多少个信道（每个信道一次跑一个IPC调用）</span><br>  <span class="hljs-comment">// 这里的计算方式与IPCControl结构有关，channels是IPCControl的最后一个flexible ChannelControl数组成员</span><br>  <span class="hljs-comment">// 扣除IPCControl的其他成员，剩余的尺寸都是承载ChannelControl的</span><br>  <span class="hljs-comment">// 关于IPCControl和ChannelControl，它们的结构在下面分析。</span><br>  <span class="hljs-comment">// 简单来说就是IPCControl控制了有多少个ChannelControl，而每个ChannelControl又控制了真实的channel buffer的偏移位置</span><br>  <span class="hljs-comment">// 这和crosscall的设计很像</span><br>  shared_size -= <span class="hljs-built_in">offsetof</span>(IPCControl, channels);<br>  <span class="hljs-type">size_t</span> channel_count = shared_size / (<span class="hljs-built_in">sizeof</span>(ChannelControl) + channel_size);<br><br>  <span class="hljs-comment">// If we cannot fit even one channel we bail out.</span><br>  <span class="hljs-comment">// 一个信道都放不下，are you kidding me?</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == channel_count) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">//算出第一个真实信道的起始位置</span><br>  <span class="hljs-comment">// Calculate the start of the first channel.</span><br>  <span class="hljs-type">size_t</span> base_start =<br>      (<span class="hljs-built_in">sizeof</span>(ChannelControl) * channel_count) + <span class="hljs-built_in">offsetof</span>(IPCControl, channels);<br><br>  <span class="hljs-comment">// 调整client_control_这个IPCControl指针指向了共享内存头部</span><br>  client_control_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;IPCControl*&gt;(shared_mem);<br>  client_control_-&gt;channels_count = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// This is the initialization that we do per-channel. Basically:</span><br>  <span class="hljs-comment">// 1) make two events (ping &amp; pong)</span><br>  <span class="hljs-comment">// 2) create handles to the events for the client and the server.</span><br>  <span class="hljs-comment">// 3) initialize the channel (client_context) with the state.</span><br>  <span class="hljs-comment">// 4) initialize the server side of the channel (service_context).</span><br>  <span class="hljs-comment">// 5) call the thread provider RegisterWait to register the ping events.</span><br>  <span class="hljs-comment">// 每个channel都要做两个事件(ping &amp; pong)</span><br>  <span class="hljs-comment">// client对事件句柄的保存在client_context中，也就是shared_mem</span><br>  <span class="hljs-comment">// server对事件句柄的保存在new出来的ServerControl中，每个ServerControl都丢入server_contexts_</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> ix = <span class="hljs-number">0</span>; ix != channel_count; ++ix) &#123;<br>    ChannelControl* client_context = &amp;client_control_-&gt;channels[ix];<br>    ServerControl* service_context = <span class="hljs-keyword">new</span> ServerControl;<br>    server_contexts_.<span class="hljs-built_in">push_back</span>(base::<span class="hljs-built_in">WrapUnique</span>(service_context));<span class="hljs-comment">//丢入的是智能指针</span><br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">MakeEvents</span>(&amp;service_context-&gt;ping_event, &amp;service_context-&gt;pong_event,<br>                    &amp;client_context-&gt;ping_event, &amp;client_context-&gt;pong_event)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    client_context-&gt;channel_base = base_start;<br>    client_context-&gt;state = kFreeChannel;<span class="hljs-comment">//ChannelState这个enum记录了channel的几个state</span><br><br>    <span class="hljs-comment">// Note that some of these values are available as members of this object</span><br>    <span class="hljs-comment">// but we put them again into the service_context because we will be called</span><br>    <span class="hljs-comment">// on a static method (ThreadPingEventReady). In particular, target_process_</span><br>    <span class="hljs-comment">// is a raw handle that is not owned by this object (it&#x27;s owned by the</span><br>    <span class="hljs-comment">// owner of this object), and we are storing it in multiple places.</span><br>    <span class="hljs-comment">// 都放在service_context中是为了方便在静态方法ThreadPingEventReady调用</span><br>    service_context-&gt;shared_base = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(shared_mem);<br>    service_context-&gt;channel_size = channel_size;<br>    service_context-&gt;channel = client_context;<br>    service_context-&gt;channel_buffer =<br>        service_context-&gt;shared_base + client_context-&gt;channel_base;<br>    service_context-&gt;dispatcher = call_dispatcher_;<br>    service_context-&gt;target_info.process = target_process_;<br>    service_context-&gt;target_info.process_id = target_process_id_;<br>    <span class="hljs-comment">// Advance to the next channel.</span><br>    base_start += channel_size;<br>    <span class="hljs-comment">// Register the ping event with the threadpool.</span><br>    <span class="hljs-comment">// 这里通过thread_provider的接口将ping事件与ThreadPingEventReady绑定，service_context作为</span><br>    <span class="hljs-comment">// ping事件signaled时，调用ThreadPingEventReady所携带的参数</span><br>    thread_provider_-&gt;<span class="hljs-built_in">RegisterWait</span>(<span class="hljs-keyword">this</span>, service_context-&gt;ping_event.<span class="hljs-built_in">Get</span>(),<br>                                   ThreadPingEventReady, service_context);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), g_alive_mutex, target_process_,<br>                         &amp;client_control_-&gt;server_alive,<br>                         SYNCHRONIZE | EVENT_MODIFY_STATE, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// This last setting indicates to the client all is setup.</span><br>  <span class="hljs-comment">// 到此，所有的channel都实装了</span><br>  client_control_-&gt;channels_count = channel_count;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再看ThreadPingEventReady:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This function gets called by a thread from the thread pool when a</span><br><span class="hljs-comment">// ping event fires. The context is the same as passed in the RegisterWait()</span><br><span class="hljs-comment">// call above.</span><br><span class="hljs-comment">// 客户端会把thread_provider_-&gt;RegisterWait绑定的service_context-&gt;ping_event置信</span><br><span class="hljs-comment">// 然后windows会回调ThreadPingEventReady，context实际上就是service_context这个ServerControl对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> __stdcall <span class="hljs-title">SharedMemIPCServer::ThreadPingEventReady</span><span class="hljs-params">(<span class="hljs-type">void</span>* context,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!context) &#123;<br>    <span class="hljs-built_in">DCHECK</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  ServerControl* service_context = <span class="hljs-built_in">reinterpret_cast</span>&lt;ServerControl*&gt;(context);<span class="hljs-comment">//接驾</span><br>  <span class="hljs-comment">// Since the event fired, the channel *must* be busy. Change to kAckChannel</span><br>  <span class="hljs-comment">// while we service it.</span><br>  <span class="hljs-comment">// 对state的修改必须是原子操作，如果当前是kBusyChannel（这个应该由client设置）</span><br>  <span class="hljs-comment">// 就设置成kAckChannel</span><br>  LONG last_state = ::<span class="hljs-built_in">InterlockedCompareExchange</span>(<br>      &amp;service_context-&gt;channel-&gt;state, kAckChannel, kBusyChannel);<br>  <span class="hljs-comment">// 如果此前的状态不是kBusyChannel，说明调用异常</span><br>  <span class="hljs-keyword">if</span> (kBusyChannel != last_state) &#123;<br>    <span class="hljs-built_in">DCHECK</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Prepare the result structure. At this point we will return some result</span><br>  <span class="hljs-comment">// even if the IPC is invalid, malformed or has no handler.</span><br>  <span class="hljs-comment">// CrossCallReturn是在这构造的。</span><br>  CrossCallReturn call_result = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-comment">// 追根溯源，实际上是sharedMem中的一个channel，每个IPC调用用到的是共享内存分割成的</span><br>  <span class="hljs-comment">// 众多信道中的一个，channel_buffer就是该channel的buffer起始</span><br>  <span class="hljs-type">void</span>* buffer = service_context-&gt;channel_buffer;<br><br>  <span class="hljs-comment">// 这个就是关键call，结果存在了局部的CrossCallReturn对象中</span><br>  <span class="hljs-built_in">InvokeCallback</span>(service_context, buffer, &amp;call_result);<br><br>  <span class="hljs-comment">// Copy the answer back into the channel and signal the pong event. This</span><br>  <span class="hljs-comment">// should wake up the client so it can finish the ipc cycle.</span><br>  <span class="hljs-comment">// 把answer CrossCallReturn对象拷贝回与client共享的buffer</span><br>  <span class="hljs-comment">// (call_params是个ActualCallParams，内部包含一个CrossCallReturn结构)</span><br>  <span class="hljs-comment">// 然后将pong event置signaled</span><br>  <span class="hljs-comment">// 切换channel的state状态到kAckChannel（这里又设置了一次，可能InvokeCallback中改了该值）</span><br>  CrossCallParams* call_params = <span class="hljs-built_in">reinterpret_cast</span>&lt;CrossCallParams*&gt;(buffer);<br>  <span class="hljs-built_in">memcpy</span>(call_params-&gt;<span class="hljs-built_in">GetCallReturn</span>(), &amp;call_result, <span class="hljs-built_in">sizeof</span>(call_result));<br>  ::<span class="hljs-built_in">InterlockedExchange</span>(&amp;service_context-&gt;channel-&gt;state, kAckChannel);<br>  ::<span class="hljs-built_in">SetEvent</span>(service_context-&gt;pong_event.<span class="hljs-built_in">Get</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>InvokeCallback就是分发了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SharedMemIPCServer::InvokeCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ServerControl* service_context,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* ipc_buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        CrossCallReturn* call_result)</span> </span>&#123;<br>  <span class="hljs-comment">// Set the default error code;</span><br>  <span class="hljs-built_in">SetCallError</span>(SBOX_ERROR_INVALID_IPC, call_result); <span class="hljs-comment">// 设置的是call_result的call_outcome</span><br>  <span class="hljs-type">uint32_t</span> output_size = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// Parse, verify and copy the message. The handler operates on a copy</span><br>  <span class="hljs-comment">// of the message so the client cannot play dirty tricks by changing the</span><br>  <span class="hljs-comment">// data in the channel while the IPC is being processed.</span><br>  <span class="hljs-comment">// server用一个CrossCallParamsEx来承载channel buffer中的数据</span><br>  <span class="hljs-comment">// output_size会返回channel buffer中真实有效的数据尺寸（传输的内容一般没有填满channel buffer）</span><br>  <span class="hljs-function">std::unique_ptr&lt;CrossCallParamsEx&gt; <span class="hljs-title">params</span><span class="hljs-params">(CrossCallParamsEx::CreateFromBuffer(</span></span><br><span class="hljs-params"><span class="hljs-function">      ipc_buffer, service_context-&gt;channel_size, &amp;output_size))</span></span>;<br>  <span class="hljs-keyword">if</span> (!params.<span class="hljs-built_in">get</span>())<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 获取信道中IPC调用的tag</span><br>  <span class="hljs-type">uint32_t</span> tag = params-&gt;<span class="hljs-built_in">GetTag</span>();<br>  <span class="hljs-built_in">static_assert</span>(<span class="hljs-number">0</span> == INVALID_TYPE, <span class="hljs-string">&quot;incorrect type enum&quot;</span>);<br>  <span class="hljs-comment">// 构造一个IPCParams</span><br>  IPCParams ipc_params = &#123;<span class="hljs-number">0</span>&#125;;<br>  ipc_params.ipc_tag = tag;<br><br>  <span class="hljs-type">void</span>* args[kMaxIpcParams];<span class="hljs-comment">// 最多有9个参数，通过GetArgs获取全部参数，一会儿展开这个函数</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetArgs</span>(params.<span class="hljs-built_in">get</span>(), &amp;ipc_params, args))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 构造IPCInfo，它是callback家族函数的第一个参数</span><br>  IPCInfo ipc_info = &#123;<span class="hljs-number">0</span>&#125;;<br>  ipc_info.ipc_tag = tag;<span class="hljs-comment">// IPC调用的tag</span><br>  ipc_info.client_info = &amp;service_context-&gt;target_info;<span class="hljs-comment">// 传入的target pid和handle</span><br>  Dispatcher* dispatcher = service_context-&gt;dispatcher;<span class="hljs-comment">// 传入的dispatcher</span><br>  <span class="hljs-built_in">DCHECK</span>(dispatcher);<br>  <span class="hljs-type">bool</span> error = <span class="hljs-literal">true</span>;<br>  Dispatcher* handler = <span class="hljs-literal">nullptr</span>;<br><br>  Dispatcher::CallbackGeneric callback_generic;<br>  <span class="hljs-comment">// 总算是找到上一节的答案了，在这里调用了OnMessageReady来匹配handler</span><br>  handler = dispatcher-&gt;<span class="hljs-built_in">OnMessageReady</span>(&amp;ipc_params, &amp;callback_generic);<br>  <span class="hljs-comment">// 如果这个dispatcher可以处理的话，那就用返回的callback_generic来处理IPC调用</span><br>  <span class="hljs-keyword">if</span> (handler) &#123;<br>    <span class="hljs-comment">// 又是呆萌的不定参数匹配</span><br>    <span class="hljs-keyword">switch</span> (params-&gt;<span class="hljs-built_in">GetParamsCount</span>()) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: &#123;<br>        <span class="hljs-comment">// Ask the IPC dispatcher if it can service this IPC.</span><br>        <span class="hljs-comment">// 无参数的IPC调用，转成Callback0来处理，下面同理</span><br>        <span class="hljs-comment">// 换句话说，CallbackGeneric类型只是个幌子，真正的callback参数肯定是对得上的。</span><br>        Dispatcher::Callback0 callback =<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Dispatcher::Callback0&gt;(callback_generic);<br>        <span class="hljs-comment">// 进行调用</span><br>        <span class="hljs-keyword">if</span> (!(handler-&gt;*callback)(&amp;ipc_info))<br>          <span class="hljs-keyword">break</span>;<br>        error = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;<br>        Dispatcher::Callback1 callback =<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Dispatcher::Callback1&gt;(callback_generic);<br>        <span class="hljs-keyword">if</span> (!(handler-&gt;*callback)(&amp;ipc_info, args[<span class="hljs-number">0</span>]))<br>          <span class="hljs-keyword">break</span>;<br>        error = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: &#123;<br>        Dispatcher::Callback2 callback =<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Dispatcher::Callback2&gt;(callback_generic);<br>        <span class="hljs-keyword">if</span> (!(handler-&gt;*callback)(&amp;ipc_info, args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>]))<br>          <span class="hljs-keyword">break</span>;<br>        error = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: &#123;<br>        Dispatcher::Callback3 callback =<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Dispatcher::Callback3&gt;(callback_generic);<br>        <span class="hljs-keyword">if</span> (!(handler-&gt;*callback)(&amp;ipc_info, args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>]))<br>          <span class="hljs-keyword">break</span>;<br>        error = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: &#123;<br>        Dispatcher::Callback4 callback =<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Dispatcher::Callback4&gt;(callback_generic);<br>        <span class="hljs-keyword">if</span> (!(handler-&gt;*callback)(&amp;ipc_info, args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>],<br>                                  args[<span class="hljs-number">3</span>]))<br>          <span class="hljs-keyword">break</span>;<br>        error = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: &#123;<br>        Dispatcher::Callback5 callback =<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Dispatcher::Callback5&gt;(callback_generic);<br>        <span class="hljs-keyword">if</span> (!(handler-&gt;*callback)(&amp;ipc_info, args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>], args[<span class="hljs-number">3</span>],<br>                                  args[<span class="hljs-number">4</span>]))<br>          <span class="hljs-keyword">break</span>;<br>        error = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: &#123;<br>        Dispatcher::Callback6 callback =<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Dispatcher::Callback6&gt;(callback_generic);<br>        <span class="hljs-keyword">if</span> (!(handler-&gt;*callback)(&amp;ipc_info, args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>], args[<span class="hljs-number">3</span>],<br>                                  args[<span class="hljs-number">4</span>], args[<span class="hljs-number">5</span>]))<br>          <span class="hljs-keyword">break</span>;<br>        error = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: &#123;<br>        Dispatcher::Callback7 callback =<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Dispatcher::Callback7&gt;(callback_generic);<br>        <span class="hljs-keyword">if</span> (!(handler-&gt;*callback)(&amp;ipc_info, args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>], args[<span class="hljs-number">3</span>],<br>                                  args[<span class="hljs-number">4</span>], args[<span class="hljs-number">5</span>], args[<span class="hljs-number">6</span>]))<br>          <span class="hljs-keyword">break</span>;<br>        error = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: &#123;<br>        Dispatcher::Callback8 callback =<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Dispatcher::Callback8&gt;(callback_generic);<br>        <span class="hljs-keyword">if</span> (!(handler-&gt;*callback)(&amp;ipc_info, args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>], args[<span class="hljs-number">3</span>],<br>                                  args[<span class="hljs-number">4</span>], args[<span class="hljs-number">5</span>], args[<span class="hljs-number">6</span>], args[<span class="hljs-number">7</span>]))<br>          <span class="hljs-keyword">break</span>;<br>        error = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: &#123;<br>        Dispatcher::Callback9 callback =<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Dispatcher::Callback9&gt;(callback_generic);<br>        <span class="hljs-keyword">if</span> (!(handler-&gt;*callback)(&amp;ipc_info, args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>], args[<span class="hljs-number">3</span>],<br>                                  args[<span class="hljs-number">4</span>], args[<span class="hljs-number">5</span>], args[<span class="hljs-number">6</span>], args[<span class="hljs-number">7</span>], args[<span class="hljs-number">8</span>]))<br>          <span class="hljs-keyword">break</span>;<br>        error = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">default</span>: &#123;<br>        <span class="hljs-built_in">NOTREACHED</span>();<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 调用发生了错误的话，就要设置SBOX_ERROR_FAILED_IPC错误</span><br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    <span class="hljs-keyword">if</span> (handler)<br>      <span class="hljs-built_in">SetCallError</span>(SBOX_ERROR_FAILED_IPC, call_result);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 调用成功，这时callback已经填充了ipc_info.return_info这个CrossCallReturn对象了</span><br>    <span class="hljs-built_in">memcpy</span>(call_result, &amp;ipc_info.return_info, <span class="hljs-built_in">sizeof</span>(*call_result));<br>    <span class="hljs-built_in">SetCallSuccess</span>(call_result);<br>    <span class="hljs-keyword">if</span> (params-&gt;<span class="hljs-built_in">IsInOut</span>()) &#123;<br>      <span class="hljs-comment">// Maybe the params got changed by the broker. We need to upadte the</span><br>      <span class="hljs-comment">// memory section.</span><br>      <span class="hljs-comment">// 如果有InOut型参数，那么还得把CrossCallParamsEx对象copy回channel buffer</span><br>      <span class="hljs-comment">// 这是因为static CrossCallParamsEx::CreateFromBuffer内部对CrossCallParamsEx的make</span><br>      <span class="hljs-comment">// 并不是直接对channel buffer进行了类型转换，而是copy了channel buffer到新new出来的空间中</span><br>      <span class="hljs-comment">// 如果你不记得了，请回去看crosscall一篇</span><br>      <span class="hljs-built_in">memcpy</span>(ipc_buffer, params.<span class="hljs-built_in">get</span>(), output_size);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 该放放，好习惯</span><br>  <span class="hljs-built_in">ReleaseArgs</span>(&amp;ipc_params, args);<br><br>  <span class="hljs-keyword">return</span> !error;<br>&#125;<br></code></pre></td></tr></table></figure><p>先看看<code>GetArgs</code>和<code>ReleaseArgs</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// IPCParams是用于在OnMessageReady中判断该种类型IPC是否是本dispatcher可以处理的参考</span><br><span class="hljs-comment">// dispatcher会预置很多IPCParams，而到来的IPC调用就用它的IPCParams来lookup</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Releases memory allocated for IPC arguments, if needed.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReleaseArgs</span><span class="hljs-params">(<span class="hljs-type">const</span> IPCParams* ipc_params, <span class="hljs-type">void</span>* args[kMaxIpcParams])</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; kMaxIpcParams; i++) &#123;<br>    <span class="hljs-keyword">switch</span> (ipc_params-&gt;args[i]) &#123;<br>      <span class="hljs-comment">// 其实只有两种要delete资源，一种是字符串，一种是INOUTPTR</span><br>      <span class="hljs-keyword">case</span> WCHAR_TYPE: &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;base::string16*&gt;(args[i]);<br>        args[i] = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> INOUTPTR_TYPE: &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;CountedBuffer*&gt;(args[i]);<br>        args[i] = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Fills up the list of arguments (args and ipc_params) for an IPC call.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetArgs</span><span class="hljs-params">(CrossCallParamsEx* params,</span></span><br><span class="hljs-params"><span class="hljs-function">             IPCParams* ipc_params,</span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-type">void</span>* args[kMaxIpcParams])</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (kMaxIpcParams &lt; params-&gt;<span class="hljs-built_in">GetParamsCount</span>())<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; params-&gt;<span class="hljs-built_in">GetParamsCount</span>(); i++) &#123;<br>    <span class="hljs-type">uint32_t</span> size;<br>    ArgType type;<br>    <span class="hljs-comment">// 循环调用GetRawParameter</span><br>    args[i] = params-&gt;<span class="hljs-built_in">GetRawParameter</span>(i, &amp;size, &amp;type);<br>    <span class="hljs-keyword">if</span> (args[i]) &#123;<br>      ipc_params-&gt;args[i] = type;<br>      <span class="hljs-comment">// 根据type，进行args[i]的填充</span><br>      <span class="hljs-keyword">switch</span> (type) &#123;<br>        <span class="hljs-keyword">case</span> WCHAR_TYPE: &#123;<br>          <span class="hljs-function">std::unique_ptr&lt;base::string16&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-keyword">new</span> base::string16)</span></span>;<span class="hljs-comment">//这种情况要new 字符串</span><br>          <span class="hljs-keyword">if</span> (!params-&gt;<span class="hljs-built_in">GetParameterStr</span>(i, data.<span class="hljs-built_in">get</span>())) &#123;<br>            args[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">ReleaseArgs</span>(ipc_params, args);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          &#125;<br>          args[i] = data.<span class="hljs-built_in">release</span>();<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> UINT32_TYPE: &#123;<br>          <span class="hljs-type">uint32_t</span> data;<br>          <span class="hljs-keyword">if</span> (!params-&gt;<span class="hljs-built_in">GetParameter32</span>(i, &amp;data)) &#123;<br>            <span class="hljs-built_in">ReleaseArgs</span>(ipc_params, args);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          &#125;<br>          <span class="hljs-function">IPCInt <span class="hljs-title">ipc_int</span><span class="hljs-params">(data)</span></span>;<br>          args[i] = ipc_int.<span class="hljs-built_in">AsVoidPtr</span>();<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> VOIDPTR_TYPE: &#123;<br>          <span class="hljs-type">void</span>* data;<br>          <span class="hljs-keyword">if</span> (!params-&gt;<span class="hljs-built_in">GetParameterVoidPtr</span>(i, &amp;data)) &#123;<br>            <span class="hljs-built_in">ReleaseArgs</span>(ipc_params, args);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          &#125;<br>          args[i] = data;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> INOUTPTR_TYPE: &#123;<br>          <span class="hljs-keyword">if</span> (!args[i]) &#123;<br>            <span class="hljs-built_in">ReleaseArgs</span>(ipc_params, args);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          &#125;<br>          CountedBuffer* buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CountedBuffer</span>(args[i], size);<span class="hljs-comment">// 这种情况是要new CountedBuffer的</span><br>          args[i] = buffer;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span>:<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后看看<code>MakeEvents</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SharedMemIPCServer::MakeEvents</span><span class="hljs-params">(base::win::ScopedHandle* server_ping,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    base::win::ScopedHandle* server_pong,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    HANDLE* client_ping,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    HANDLE* client_pong)</span> </span>&#123;<br>  <span class="hljs-comment">// Note that the IPC client has no right to delete the events. That would</span><br>  <span class="hljs-comment">// cause problems. The server *owns* the events.</span><br>  <span class="hljs-comment">// event的拥有者是Server端，client无权删除</span><br>  <span class="hljs-type">const</span> DWORD kDesiredAccess = SYNCHRONIZE | EVENT_MODIFY_STATE;<br><br>  <span class="hljs-comment">// The events are auto reset, and start not signaled.</span><br>  <span class="hljs-comment">// 实际上就是简单的CreateEventW封装，因为client和server各持有一个handle，所以要DuplicateHandle</span><br>  <span class="hljs-comment">// 给了target进程也就是client端的event句柄</span><br>  server_ping-&gt;<span class="hljs-built_in">Set</span>(::<span class="hljs-built_in">CreateEventW</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), server_ping-&gt;<span class="hljs-built_in">Get</span>(),<br>                         target_process_, client_ping, kDesiredAccess, <span class="hljs-literal">false</span>,<br>                         <span class="hljs-number">0</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  server_pong-&gt;<span class="hljs-built_in">Set</span>(::<span class="hljs-built_in">CreateEventW</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), server_pong-&gt;<span class="hljs-built_in">Get</span>(),<br>                         target_process_, client_pong, kDesiredAccess, <span class="hljs-literal">false</span>,<br>                         <span class="hljs-number">0</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，server的流程大体清楚了，一个疑点就是<code>client_control_</code>这个成员，根据析构的处理，这理应是个<code>MapViewOfFile</code>，但server端却不见它创建的踪影，而是直接使用，看起来共享内存的创建由client控制。</p><h2 id="client">Client</h2><p>目前已经搞清楚了这部分的设计，是时候看看客户端实现了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// IPC transport implementation that uses shared memory.</span><br><span class="hljs-comment">// This is the client side</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The shared memory is divided on blocks called channels, and potentially</span><br><span class="hljs-comment">// it can perform as many concurrent IPC calls as channels. The IPC over</span><br><span class="hljs-comment">// each channel is strictly synchronous for the client.</span><br><span class="hljs-comment">// 共享内存划分成多个channel，这就可以并发处理IPC调用</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// Each channel as a channel control section associated with. Each control</span><br><span class="hljs-comment">// section has two kernel events (known as ping and pong) and a integer</span><br><span class="hljs-comment">// variable that maintains a state</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// this is the state diagram of a channel:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//                   locked                in service</span><br><span class="hljs-comment">//     kFreeChannel----------&gt;BusyChannel--------------&gt;kAckChannel</span><br><span class="hljs-comment">//          ^                                                 |</span><br><span class="hljs-comment">//          |_________________________________________________|</span><br><span class="hljs-comment">//                             answer ready</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The protocol is as follows:</span><br><span class="hljs-comment">//   1) client finds a free channel: state = kFreeChannel</span><br><span class="hljs-comment">//   2) does an atomic compare-and-swap, now state = BusyChannel</span><br><span class="hljs-comment">//   3) client writes the data into the channel buffer</span><br><span class="hljs-comment">//   4) client signals the ping event and waits (blocks) on the pong event</span><br><span class="hljs-comment">//   5) eventually the server signals the pong event</span><br><span class="hljs-comment">//   6) the client awakes and reads the answer from the same channel</span><br><span class="hljs-comment">//   7) the client updates its InOut parameters with the new data from the</span><br><span class="hljs-comment">//      shared memory section.</span><br><span class="hljs-comment">//   8) the client atomically sets the state = kFreeChannel</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  In the shared memory the layout is as follows:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    [ channel count    ]</span><br><span class="hljs-comment">//    [ channel control 0]</span><br><span class="hljs-comment">//    [ channel control 1]</span><br><span class="hljs-comment">//    [ channel control N]</span><br><span class="hljs-comment">//    [ channel buffer 0 ] 1024 bytes</span><br><span class="hljs-comment">//    [ channel buffer 1 ] 1024 bytes</span><br><span class="hljs-comment">//    [ channel buffer N ] 1024 bytes</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// By default each channel buffer is 1024 bytes</span><br></code></pre></td></tr></table></figure><p>client端所做的事，上面起始阐释的已经很清楚了，总结一下就是：</p><ol type="1"><li>client想要发IPC调用时，先要在共享内存中找到一个free态的channel，并置为busy态</li><li>client把数据写入到channelbuffer中，置信ping事件并在pong事件等待，以此做与server端的同步</li><li>server收到ping置信后，会进行我们前面剖析的流程，最终填好channelbuffer并置信pong事件，channel置为ack态</li><li>client设置channel状态为free态</li></ol><h3 id="共享内存布局">共享内存布局</h3><p>另一方面，共享内存的结构其实之前已经隐隐约约说过了，它是个flexible的层级结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// shared memory起始，一层结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IPCControl</span> &#123;<br>  <span class="hljs-comment">// total number of channels available, some might be busy at a given time</span><br>  <span class="hljs-type">size_t</span> channels_count;<br>  <span class="hljs-comment">// handle to a shared mutex to detect when the server is dead</span><br>  HANDLE server_alive;<br>  <span class="hljs-comment">// array of channel control structures</span><br>  ChannelControl channels[<span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-comment">// 二层结构，一层的channels_count决定了它的数量，附着在一层数据正后方</span><br><span class="hljs-comment">// the channel control structure</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ChannelControl</span> &#123;<br>  <span class="hljs-comment">// points to be beginning of the channel buffer, where data goes</span><br>  <span class="hljs-type">size_t</span> channel_base;<br>  <span class="hljs-comment">// maintains the state from the ChannelState enumeration</span><br>  <span class="hljs-keyword">volatile</span> LONG state;<br>  <span class="hljs-comment">// the ping event is signaled by the client when the IPC data is ready on</span><br>  <span class="hljs-comment">// the buffer</span><br>  HANDLE ping_event;<br>  <span class="hljs-comment">// the client waits on the pong event for the IPC answer back</span><br>  HANDLE pong_event;<br>  <span class="hljs-comment">// the IPC unique identifier</span><br>  <span class="hljs-type">uint32_t</span> ipc_tag;<br>&#125;;<br><br><span class="hljs-comment">// 三层结构就是真实的channel buffer了，每个channel buffer大小被sandbox硬编码成了1024</span><br><span class="hljs-comment">// 每有一个ChannelControl，就有一个channel buffer，它的偏移由二层结构的channel_base索引</span><br></code></pre></td></tr></table></figure><h3 id="sharedmemipcclient"><code>SharedMemIPCClient</code></h3><p>头定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// the actual shared memory IPC implementation class. This object is designed</span><br><span class="hljs-comment">// to be lightweight so it can be constructed on-site (at the calling place)</span><br><span class="hljs-comment">// wherever an IPC call is needed.</span><br><span class="hljs-comment">// 设计成了一个轻量对象，可以在IPC调用发起时，在发端简单的构造出来</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedMemIPCClient</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Creates the IPC client.</span><br>  <span class="hljs-comment">// as parameter it takes the base address of the shared memory</span><br>  <span class="hljs-comment">// 显式声明，对于这种单简单类型参数的构造器都要设置explicit，防止编译器自作聪明的隐式转换</span><br>  <span class="hljs-comment">// 可以看出来shared_mem也并不是Client控制的</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SharedMemIPCClient</span><span class="hljs-params">(<span class="hljs-type">void</span>* shared_mem)</span></span>;<br><br>  <span class="hljs-comment">// locks a free channel and returns the channel buffer memory base. This call</span><br>  <span class="hljs-comment">// blocks until there is a free channel</span><br>  <span class="hljs-comment">// 占坑，找个free态channel，如果没有的话会阻塞</span><br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">GetBuffer</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// releases the lock on the channel, for other to use. call this if you have</span><br>  <span class="hljs-comment">// called GetBuffer and you want to abort but have not called yet DoCall()</span><br>  <span class="hljs-comment">// 释放channel的锁，使用情景在你通过GetBuffer获得了channel但却在调用DoCall()前想要终止</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FreeBuffer</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span></span>;<br><br>  <span class="hljs-comment">// Performs the actual IPC call.</span><br>  <span class="hljs-comment">// params: The blob of packed input parameters.</span><br>  <span class="hljs-comment">// answer: upon IPC completion, it contains the server answer to the IPC.</span><br>  <span class="hljs-comment">// If the return value is not SBOX_ERROR_CHANNEL_ERROR, the caller has to free</span><br>  <span class="hljs-comment">// the channel.</span><br>  <span class="hljs-comment">// returns ALL_OK if the IPC mechanism successfully delivered. You still need</span><br>  <span class="hljs-comment">// to check on the answer structure to see the actual IPC result.</span><br>  <span class="hljs-comment">// 这个DoCall就是关键的IPC调用了，这个接口实际上在crosscall中就已经看过了，当时比较奇怪的是</span><br>  <span class="hljs-comment">// CrossCallParams内部已经有CrossCallReturn了，为什么还要额外传一个answer</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">DoCall</span><span class="hljs-params">(CrossCallParams* params, CrossCallReturn* answer)</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Returns the index of the first free channel. It sets &#x27;severe_failure&#x27;</span><br>  <span class="hljs-comment">// to true if there is an unrecoverable error that does not allow to</span><br>  <span class="hljs-comment">// find a channel.</span><br>  <span class="hljs-comment">// 这货一看就是给GetBuffer用的内部helper函数</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">LockFreeChannel</span><span class="hljs-params">(<span class="hljs-type">bool</span>* severe_failure)</span></span>;<br>  <span class="hljs-comment">// Return the channel index given the address of the buffer.</span><br>  <span class="hljs-comment">// 由buffer的address反推channel的索引</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ChannelIndexFromBuffer</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* buffer)</span></span>;<br>  IPCControl* control_;<span class="hljs-comment">// client端也是这个结构，指向共享内存起始</span><br>  <span class="hljs-comment">// point to the first channel base</span><br>  <span class="hljs-type">char</span>* first_base_;<span class="hljs-comment">// 三级channel结构的起始地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>构造器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The constructor simply casts the shared memory to the internal</span><br><span class="hljs-comment">// structures. This is a cheap step that is why this IPC object can</span><br><span class="hljs-comment">// and should be constructed per call.</span><br><span class="hljs-comment">// 共享内存也不是client维护的，而是外部传过来的。</span><br>SharedMemIPCClient::<span class="hljs-built_in">SharedMemIPCClient</span>(<span class="hljs-type">void</span>* shared_mem)<br>    : <span class="hljs-built_in">control_</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;IPCControl*&gt;(shared_mem)) &#123;<br>  first_base_ =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(shared_mem) + control_-&gt;channels[<span class="hljs-number">0</span>].channel_base;<br>  <span class="hljs-comment">// There must be at least one channel.</span><br>  <span class="hljs-built_in">DCHECK</span>(<span class="hljs-number">0</span> != control_-&gt;channels_count);<br>&#125;<br></code></pre></td></tr></table></figure><p>直观的两个private函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Locking a channel is a simple as looping over all the channels</span><br><span class="hljs-comment">// looking for one that is has state = kFreeChannel and atomically</span><br><span class="hljs-comment">// swapping it to kBusyChannel.</span><br><span class="hljs-comment">// If there is no free channel, then we must back off so some other</span><br><span class="hljs-comment">// thread makes progress and frees a channel. To back off we sleep.</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">SharedMemIPCClient::LockFreeChannel</span><span class="hljs-params">(<span class="hljs-type">bool</span>* severe_failure)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == control_-&gt;channels_count) &#123;<br>    *severe_failure = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">//对channel做遍历，找第一个kFreeChannel态的channel，如果找到就置为busy态</span><br>  ChannelControl* channel = control_-&gt;channels;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> ix = <span class="hljs-number">0</span>; ix != control_-&gt;channels_count; ++ix) &#123;<br>      <span class="hljs-keyword">if</span> (kFreeChannel == ::<span class="hljs-built_in">InterlockedCompareExchange</span>(<br>                              &amp;channel[ix].state, kBusyChannel, kFreeChannel)) &#123;<br>        *severe_failure = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> ix;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// We did not find any available channel, maybe the server is dead.</span><br>    <span class="hljs-comment">// 如果当前没有空闲channel的话，先判断一下server是否还在，挂了就直接failure吧，也没有IPC的必要了</span><br>    <span class="hljs-comment">// 否则就一直轮询</span><br>    DWORD wait =<br>        ::<span class="hljs-built_in">WaitForSingleObject</span>(control_-&gt;server_alive, kIPCWaitTimeOut2);<br>    <span class="hljs-keyword">if</span> (WAIT_TIMEOUT != wait) &#123;<br>      <span class="hljs-comment">// The server is dead and we outlive it enough to get in trouble.</span><br>      *severe_failure = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">// Find out which channel we are from the pointer returned by GetBuffer.</span><br><span class="hljs-comment">// 简单的四则运算，基操，勿6</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">SharedMemIPCClient::ChannelIndexFromBuffer</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* buffer)</span> </span>&#123;<br>  <span class="hljs-type">ptrdiff_t</span> d = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(buffer) - first_base_;<br>  <span class="hljs-type">size_t</span> num = d / kIPCChannelSize;<br>  <span class="hljs-built_in">DCHECK_LT</span>(num, control_-&gt;channels_count);<br>  <span class="hljs-keyword">return</span> (num);<br>&#125;<br></code></pre></td></tr></table></figure><p>再看对buffer的处理，应该是用于test的封装：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Get the base of the data buffer of the channel; this is where the input</span><br><span class="hljs-comment">// parameters get serialized. Since they get serialized directly into the</span><br><span class="hljs-comment">// channel we avoid one copy.</span><br><span class="hljs-comment">// 获取一个free态channel</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">SharedMemIPCClient::GetBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">bool</span> failure = <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">size_t</span> ix = <span class="hljs-built_in">LockFreeChannel</span>(&amp;failure);<br>  <span class="hljs-comment">// 这种表示server已经挂了</span><br>  <span class="hljs-keyword">if</span> (failure)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// 基本四则运算</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(control_) +<br>         control_-&gt;channels[ix].channel_base;<br>&#125;<br><br><span class="hljs-comment">// If we need to cancel an IPC before issuing DoCall</span><br><span class="hljs-comment">// our client should call FreeBuffer with the same pointer</span><br><span class="hljs-comment">// returned by GetBuffer.</span><br><span class="hljs-comment">// 这里的free不是释放channel buffer，而是把channel置为free态，表示可用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SharedMemIPCClient::FreeBuffer</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span> </span>&#123;<br>  <span class="hljs-type">size_t</span> num = <span class="hljs-built_in">ChannelIndexFromBuffer</span>(buffer);<br>  ChannelControl* channel = control_-&gt;channels;<br>  LONG result = ::<span class="hljs-built_in">InterlockedExchange</span>(&amp;channel[num].state, kFreeChannel);<br>  <span class="hljs-built_in">DCHECK_NE</span>(kFreeChannel, <span class="hljs-built_in">static_cast</span>&lt;ChannelState&gt;(result));<br>&#125;<br></code></pre></td></tr></table></figure><p>再看与server联系紧密的<code>DoCall</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Do the IPC. At this point the channel should have already been</span><br><span class="hljs-comment">// filled with the serialized input parameters.</span><br><span class="hljs-comment">// We follow the pattern explained in the header file.</span><br><span class="hljs-comment">// params和answer都是外部传入的，我们毕竟只是个驱动器，承载什么消息是驱动者决定的</span><br><span class="hljs-function">ResultCode <span class="hljs-title">SharedMemIPCClient::DoCall</span><span class="hljs-params">(CrossCallParams* params,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      CrossCallReturn* answer)</span> </span>&#123;<br>  <span class="hljs-comment">// server要健在</span><br>  <span class="hljs-keyword">if</span> (!control_-&gt;server_alive)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CHANNEL_ERROR;<br><br>  <span class="hljs-comment">// channel的buffer就是params对象本身（params-&gt;GetBuffer返回this）</span><br>  <span class="hljs-comment">// channel buffer承载了crosscall_client中看到的输入结构</span><br>  <span class="hljs-comment">// 外部在调用该函数时，应该已经把params放入了shareMem的某个channel中，这里素质二连算出num，主要是为了直接操纵channel[num]来把参数导入</span><br>  <span class="hljs-type">size_t</span> num = <span class="hljs-built_in">ChannelIndexFromBuffer</span>(params-&gt;<span class="hljs-built_in">GetBuffer</span>());<br>  ChannelControl* channel = control_-&gt;channels;<br>  <span class="hljs-comment">// Note that the IPC tag goes outside the buffer as well inside</span><br>  <span class="hljs-comment">// the buffer. This should enable the server to prioritize based on</span><br>  <span class="hljs-comment">// IPC tags without having to de-serialize the entire message.</span><br>  channel[num].ipc_tag = params-&gt;<span class="hljs-built_in">GetTag</span>();<br><br>  <span class="hljs-comment">// Wait for the server to service this IPC call. After kIPCWaitTimeOut1</span><br>  <span class="hljs-comment">// we check if the server_alive mutex was abandoned which will indicate</span><br>  <span class="hljs-comment">// that the server has died.</span><br><br>  <span class="hljs-comment">// While the atomic signaling and waiting is not a requirement, it</span><br>  <span class="hljs-comment">// is nice because we save a trip to kernel.</span><br>  <span class="hljs-comment">// 填充好channelcontrol的参数后，就可以直接signaled ping通知server了</span><br>  <span class="hljs-comment">// 然后在pong上等待，等待时间kIPCWaitTimeOut1</span><br>  DWORD wait =<br>      ::<span class="hljs-built_in">SignalObjectAndWait</span>(channel[num].ping_event, channel[num].pong_event,<br>                            kIPCWaitTimeOut1, <span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">if</span> (WAIT_TIMEOUT == wait) &#123;<br>    <span class="hljs-comment">// The server is taking too long. Enter a loop were we check if the</span><br>    <span class="hljs-comment">// server_alive mutex has been abandoned which would signal a server crash</span><br>    <span class="hljs-comment">// or else we keep waiting for a response.</span><br>    <span class="hljs-comment">// 如果超时了，那么得探测一下server是否还存活，是否只是因为繁忙而暂时没处理IPC</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      wait = ::<span class="hljs-built_in">WaitForSingleObject</span>(control_-&gt;server_alive, <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">if</span> (WAIT_TIMEOUT == wait) &#123;<br>        <span class="hljs-comment">// Server seems still alive. We already signaled so here we just wait.</span><br>        wait = ::<span class="hljs-built_in">WaitForSingleObject</span>(channel[num].pong_event, kIPCWaitTimeOut1);<br>        <span class="hljs-keyword">if</span> (WAIT_OBJECT_0 == wait) &#123;<br>          <span class="hljs-comment">// The server took a long time but responded.</span><br>          <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WAIT_TIMEOUT == wait) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> SBOX_ERROR_CHANNEL_ERROR;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// The server has crashed and windows has signaled the mutex as</span><br>        <span class="hljs-comment">// abandoned.</span><br>        <span class="hljs-comment">// server崩溃了，玩个J8</span><br>        ::<span class="hljs-built_in">InterlockedExchange</span>(&amp;channel[num].state, kAbandonedChannel);<br>        control_-&gt;server_alive = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_CHANNEL_ERROR;<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WAIT_OBJECT_0 != wait) &#123;<br>    <span class="hljs-comment">// Probably the server crashed before the kIPCWaitTimeOut1 occurred.</span><br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CHANNEL_ERROR;<br>  &#125;<br><br>  <span class="hljs-comment">// 按常规操作，WAIT_OBJECT_0这个返回值就对了，channel buffer实际上就是params对象</span><br>  <span class="hljs-comment">// server处理后params已经被重置了，其中params的CrossCallReturn对象被填充好，</span><br>  <span class="hljs-comment">// 如果有INOUT型参数的话，那么params本身的输入参数也被修改了。</span><br>  <span class="hljs-comment">// Client端把params的CrossCallReturn对象抽离出来，拷贝到了传入的answer参数</span><br>  <span class="hljs-comment">// 到这儿也就明白了为什么此前参数中既然已有了CrossCallParams还要再传一个CrossCallReturn</span><br>  <span class="hljs-comment">// 原来只是为了纯粹的剥离params，二者实际上是同一个东西，DoCall返回后answer还有用</span><br>  <span class="hljs-comment">// The server has returned an answer, copy it and free the channel.</span><br>  <span class="hljs-built_in">memcpy</span>(answer, params-&gt;<span class="hljs-built_in">GetCallReturn</span>(), <span class="hljs-built_in">sizeof</span>(CrossCallReturn));<br><br>  <span class="hljs-comment">// Return the IPC state It can indicate that while the IPC has</span><br>  <span class="hljs-comment">// completed some error in the Broker has caused to not return valid</span><br>  <span class="hljs-comment">// results.</span><br>  <span class="hljs-keyword">return</span> answer-&gt;call_outcome;<span class="hljs-comment">// 这个是本次IPC调用的成功或失败的状态码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>到此，也就明白了<code>SharedMemIPC</code>一种基于共享内存的操纵器，现在的问题就在于client和server两端<code>SharedMemIPC</code>的操纵者是如何操纵的。</p><p>由于当前我们还没有见过target进程完整的时间线，所以client的操纵暂时不关心。我们找找server的时间线。</p><p>最终在<code>BrokerServicesBase::SpawnTarget =&gt; PolicyBase::AddTarget =&gt; TargetProcess::Init</code>中找到了蛛丝马迹：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Construct the IPC server and the IPC dispatcher. When the target does</span><br><span class="hljs-comment">// an IPC it will eventually call the dispatcher.</span><br><span class="hljs-comment">// TargetProcess对象会挂到broker创建出来的PolicyBase对象中管理</span><br><span class="hljs-comment">// 一定要搞清楚TargetProcess是broker的，不是target的，它是broker中用于表示target进程的结构</span><br><span class="hljs-comment">// 上层传入的是：</span><br><span class="hljs-comment">// ret = target-&gt;Init(dispatcher_.get(), policy_, kIPCMemSize, kPolMemSize, &amp;win_error);</span><br><span class="hljs-comment">// dispatcher_就是用于在OnMessageReady中匹配参数的那货</span><br><span class="hljs-comment">// policy_是low-level-policy的buffer，这个暂时不关心</span><br><span class="hljs-comment">// kIPCMemSize是SharedMemIPC所用buffer的尺寸，这里设置成了2页</span><br><span class="hljs-comment">// kPolMemSize是low-level-policy的buffer尺寸，设置成了14页，这个暂时不关心</span><br><span class="hljs-function">ResultCode <span class="hljs-title">TargetProcess::Init</span><span class="hljs-params">(Dispatcher* ipc_dispatcher,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">void</span>* policy,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">uint32_t</span> shared_IPC_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">uint32_t</span> shared_policy_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                               DWORD* win_error)</span> </span>&#123;<br>  <span class="hljs-comment">// We need to map the shared memory on the target. This is necessary for</span><br>  <span class="hljs-comment">// any IPC that needs to take place, even if the target has not yet hit</span><br>  <span class="hljs-comment">// the main( ) function or even has initialized the CRT. So here we set</span><br>  <span class="hljs-comment">// the handle to the shared section. The target on the first IPC must do</span><br>  <span class="hljs-comment">// the rest, which boils down to calling MapViewofFile()</span><br><br>  <span class="hljs-comment">// We use this single memory pool for IPC and for policy.</span><br>  DWORD shared_mem_size =<br>      <span class="hljs-built_in">static_cast</span>&lt;DWORD&gt;(shared_IPC_size + shared_policy_size);<br>  <span class="hljs-comment">// 总算找到你了，这里是把SharedMemIPC和low-level-policy的共享内存一并创建出来</span><br>  shared_section_.<span class="hljs-built_in">Set</span>(::<span class="hljs-built_in">CreateFileMappingW</span>(INVALID_HANDLE_VALUE, <span class="hljs-literal">nullptr</span>,<br>                                           PAGE_READWRITE | SEC_COMMIT, <span class="hljs-number">0</span>,<br>                                           shared_mem_size, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-keyword">if</span> (!shared_section_.<span class="hljs-built_in">IsValid</span>()) &#123;<br>    *win_error = ::<span class="hljs-built_in">GetLastError</span>();<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CREATE_FILE_MAPPING;<br>  &#125;<br><br>  <span class="hljs-comment">// 设置共享内存的权限：读写查询</span><br>  DWORD access = FILE_MAP_READ | FILE_MAP_WRITE | SECTION_QUERY;<br>  HANDLE target_shared_section;<br>  <span class="hljs-comment">// 把broker进程的共享内存句柄复制给target进程</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), shared_section_.<span class="hljs-built_in">Get</span>(),<br>                         sandbox_process_info_.<span class="hljs-built_in">process_handle</span>(),<br>                         &amp;target_shared_section, access, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)) &#123;<br>    *win_error = ::<span class="hljs-built_in">GetLastError</span>();<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_DUPLICATE_SHARED_SECTION;<br>  &#125;<br><br>  <span class="hljs-comment">// 文件映射，CreateFileMapping+MapViewOfFile共享内存素质二连</span><br>  <span class="hljs-type">void</span>* shared_memory = ::<span class="hljs-built_in">MapViewOfFile</span>(<br>      shared_section_.<span class="hljs-built_in">Get</span>(), FILE_MAP_WRITE | FILE_MAP_READ, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (!shared_memory) &#123;<br>    *win_error = ::<span class="hljs-built_in">GetLastError</span>();<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_MAP_VIEW_OF_SHARED_SECTION;<br>  &#125;<br><br>  <span class="hljs-comment">// 这个暂时不关心，把low-level-policy通过共享内存的方式拷贝给target</span><br>  <span class="hljs-built_in">CopyPolicyToTarget</span>(policy, shared_policy_size,<br>                     <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(shared_memory) + shared_IPC_size);<br><br>  ResultCode ret;<br>  <span class="hljs-comment">// Set the global variables in the target. These are not used on the broker.</span><br>  <span class="hljs-comment">// target_shared_section是为target进程复制出来的句柄，通过TransferVariable的方式把它的值</span><br>  <span class="hljs-comment">// 赋值给了target进程中的一个全局变量g_shared_section</span><br>  <span class="hljs-comment">// 这个TransferVariable在分析TargetProcess时就看过了</span><br>  <span class="hljs-comment">// 实际上就是LoadLibrary+GetProcAddress+WriteProcessMemory素质3连</span><br>  g_shared_section = target_shared_section;<br>  ret = <span class="hljs-built_in">TransferVariable</span>(<span class="hljs-string">&quot;g_shared_section&quot;</span>, &amp;g_shared_section,<br>                         <span class="hljs-built_in">sizeof</span>(g_shared_section));<br>  <span class="hljs-comment">// broker本身不用这货</span><br>  g_shared_section = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (SBOX_ALL_OK != ret) &#123;<br>    *win_error = ::<span class="hljs-built_in">GetLastError</span>();<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>  <span class="hljs-comment">// 如法炮制，把shared_IPC_size也赋值给target进程的g_shared_IPC_size全局变量</span><br>  g_shared_IPC_size = shared_IPC_size;<br>  ret = <span class="hljs-built_in">TransferVariable</span>(<span class="hljs-string">&quot;g_shared_IPC_size&quot;</span>, &amp;g_shared_IPC_size,<br>                         <span class="hljs-built_in">sizeof</span>(g_shared_IPC_size));<br>  g_shared_IPC_size = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (SBOX_ALL_OK != ret) &#123;<br>    *win_error = ::<span class="hljs-built_in">GetLastError</span>();<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>  <span class="hljs-comment">// 同上</span><br>  g_shared_policy_size = shared_policy_size;<br>  ret = <span class="hljs-built_in">TransferVariable</span>(<span class="hljs-string">&quot;g_shared_policy_size&quot;</span>, &amp;g_shared_policy_size,<br>                         <span class="hljs-built_in">sizeof</span>(g_shared_policy_size));<br>  g_shared_policy_size = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (SBOX_ALL_OK != ret) &#123;<br>    *win_error = ::<span class="hljs-built_in">GetLastError</span>();<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br><br>  <span class="hljs-comment">// buffer已经准备好了，这里就new出了SharedMemIPCServer</span><br>  <span class="hljs-comment">// 智能指针ipc_server_由TargetProcess对象管理</span><br>  ipc_server_.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SharedMemIPCServer</span>(<br>      sandbox_process_info_.<span class="hljs-built_in">process_handle</span>(),<br>      sandbox_process_info_.<span class="hljs-built_in">process_id</span>(), thread_pool_, ipc_dispatcher));<br><br>  <span class="hljs-keyword">if</span> (!ipc_server_-&gt;<span class="hljs-built_in">Init</span>(shared_memory, shared_IPC_size, kIPCChannelSize))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_NO_SPACE;<br><br>  <span class="hljs-comment">// After this point we cannot use this handle anymore.</span><br>  ::<span class="hljs-built_in">CloseHandle</span>(sandbox_process_info_.<span class="hljs-built_in">TakeThreadHandle</span>());<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>看到这里可以发现，server匹配用的<code>Dispatcher</code>对象不是<code>TargetProcess</code>控制的，而是一早就创建好了的，<code>TargetProcess</code>内部创建了<code>SharedMemIPC</code>机制的共享内存并new出了<code>SharedMemIPCServer</code>对象。</p><p>向上翻，可以发现<code>Dispatcher</code>是<code>PolicyBase</code>对象控制的成员，这也是合理的，因为共享内存IPC交互是进程之间的事，理应进程对象来管理，但匹配处理的事宜就应该由Policy来管理，所以<code>Dispatcher</code>对象作为<code>PolicyBase</code>的一员也就合情合理了。</p><p>我们找找<code>Dispatcher</code>在哪里创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PolicyBase::<span class="hljs-built_in">PolicyBase</span>()<br>    : <span class="hljs-built_in">ref_count</span>(<span class="hljs-number">1</span>),<br>      <span class="hljs-built_in">lockdown_level_</span>(USER_LOCKDOWN),<br>      <span class="hljs-built_in">initial_level_</span>(USER_LOCKDOWN),<br>      <span class="hljs-built_in">job_level_</span>(JOB_LOCKDOWN),<br>      <span class="hljs-built_in">ui_exceptions_</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">memory_limit_</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">use_alternate_desktop_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">use_alternate_winstation_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">file_system_init_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">relaxed_interceptions_</span>(<span class="hljs-literal">true</span>),<br>      <span class="hljs-built_in">stdout_handle_</span>(INVALID_HANDLE_VALUE),<br>      <span class="hljs-built_in">stderr_handle_</span>(INVALID_HANDLE_VALUE),<br>      <span class="hljs-built_in">integrity_level_</span>(INTEGRITY_LEVEL_LAST),<br>      <span class="hljs-built_in">delayed_integrity_level_</span>(INTEGRITY_LEVEL_LAST),<br>      <span class="hljs-built_in">mitigations_</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">delayed_mitigations_</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">is_csrss_connected_</span>(<span class="hljs-literal">true</span>),<br>      <span class="hljs-built_in">policy_maker_</span>(<span class="hljs-literal">nullptr</span>),<br>      <span class="hljs-built_in">policy_</span>(<span class="hljs-literal">nullptr</span>),<br>      <span class="hljs-built_in">lowbox_sid_</span>(<span class="hljs-literal">nullptr</span>),<br>      <span class="hljs-built_in">lockdown_default_dacl_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">enable_opm_redirection_</span>(<span class="hljs-literal">false</span>) &#123;<br>  ::<span class="hljs-built_in">InitializeCriticalSection</span>(&amp;lock_);<br>  <span class="hljs-comment">// 还记得之前在分析Dispatcher类的时候，发现Dispatcher只是个抽象基类的结论吗？</span><br>  <span class="hljs-comment">// 没错，Dispatcher本身没有实际意义，只是个框架，在使用时，PolicyBase使用了具有实际意义的</span><br>  <span class="hljs-comment">// TopLevelDispatcher，那么它究竟是什么？</span><br>  dispatcher_.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TopLevelDispatcher</span>(<span class="hljs-keyword">this</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们好奇的展开<code>TopLevelDispatcher</code>看看，注意它传入了<code>PolicyBase</code>对象本身。</p><h3 id="topleveldispatcher"><code>TopLevelDispatcher</code></h3><p>想要理解一个类的构造，先得了解它的类头定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Top level dispatcher which hands requests to the appropriate service</span><br><span class="hljs-comment">// dispatchers.</span><br><span class="hljs-comment">// 看起来是个顶层的dispatcher，维护了多个子系统dispatcher，用于按类别分发IPC请求</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TopLevelDispatcher</span> : <span class="hljs-keyword">public</span> Dispatcher &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// |policy| must outlive this class.</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TopLevelDispatcher</span><span class="hljs-params">(PolicyBase* policy)</span></span>;<br>  ~<span class="hljs-built_in">TopLevelDispatcher</span>() <span class="hljs-keyword">override</span>;<br><br>  <span class="hljs-function">Dispatcher* <span class="hljs-title">OnMessageReady</span><span class="hljs-params">(IPCParams* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                             CallbackGeneric* callback)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-comment">// 还记得Dispatcher类的该函数吗，它当初的注释是这样的：</span><br>  <span class="hljs-comment">// Called when a target proces is created, to setup the interceptions related</span><br>  <span class="hljs-comment">// with the given service (IPC).</span><br>  <span class="hljs-comment">// Interception看起来是施加给IPC请求的一个拦截，但它如何奏效，得在分析Interception的机制后才会明白</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetupService</span><span class="hljs-params">(InterceptionManager* manager, <span class="hljs-type">int</span> service)</span> <span class="hljs-keyword">override</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Test IPC provider.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Ping</span><span class="hljs-params">(IPCInfo* ipc, <span class="hljs-type">void</span>* cookie)</span></span>;<br><br>  <span class="hljs-comment">// Returns a dispatcher from ipc_targets_.</span><br>  <span class="hljs-comment">// 想必是OnMessageReady内部会根据IPCParams携带的ipc_tag来找到具体的下层Dispatcher</span><br>  <span class="hljs-function">Dispatcher* <span class="hljs-title">GetDispatcher</span><span class="hljs-params">(<span class="hljs-type">int</span> ipc_tag)</span></span>;<br><br>  PolicyBase* policy_;<span class="hljs-comment">//关联的PolicyBase对象，这个我们已经看到了在构造器中会传入</span><br>  <span class="hljs-comment">// 各种下层Dispatcher，每个子系统对应一个Dispatcher</span><br>  std::unique_ptr&lt;Dispatcher&gt; filesystem_dispatcher_;<br>  std::unique_ptr&lt;Dispatcher&gt; named_pipe_dispatcher_;<br>  std::unique_ptr&lt;Dispatcher&gt; thread_process_dispatcher_;<br>  std::unique_ptr&lt;Dispatcher&gt; sync_dispatcher_;<br>  std::unique_ptr&lt;Dispatcher&gt; registry_dispatcher_;<br>  std::unique_ptr&lt;Dispatcher&gt; handle_dispatcher_;<br>  std::unique_ptr&lt;Dispatcher&gt; process_mitigations_win32k_dispatcher_;<br>  Dispatcher* ipc_targets_[IPC_LAST_TAG];<span class="hljs-comment">// 下层分发器指针数组,IPC_LAST_TAG是ipc tag的数量</span><br>  <span class="hljs-comment">// 每个IPC请求都对应到一个具体的下层子系统Dispatcher，可以重复</span><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(TopLevelDispatcher);<br>&#125;;<br></code></pre></td></tr></table></figure><p>IPC的tag实际上在ipc_tags.h给出了定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> &#123;<br>  IPC_UNUSED_TAG = <span class="hljs-number">0</span>,<br>  IPC_PING1_TAG,  <span class="hljs-comment">// Takes a cookie in parameters and returns the cookie</span><br>                  <span class="hljs-comment">// multiplied by 2 and the tick_count. Used for testing only.</span><br>  IPC_PING2_TAG,  <span class="hljs-comment">// Takes an in/out cookie in parameters and modify the cookie</span><br>                  <span class="hljs-comment">// to be multiplied by 3. Used for testing only.</span><br>  IPC_NTCREATEFILE_TAG,<br>  IPC_NTOPENFILE_TAG,<br>  IPC_NTQUERYATTRIBUTESFILE_TAG,<br>  IPC_NTQUERYFULLATTRIBUTESFILE_TAG,<br>  IPC_NTSETINFO_RENAME_TAG,<br>  IPC_CREATENAMEDPIPEW_TAG,<br>  IPC_NTOPENTHREAD_TAG,<br>  IPC_NTOPENPROCESS_TAG,<br>  IPC_NTOPENPROCESSTOKEN_TAG,<br>  IPC_NTOPENPROCESSTOKENEX_TAG,<br>  IPC_CREATEPROCESSW_TAG,<br>  IPC_CREATEEVENT_TAG,<br>  IPC_OPENEVENT_TAG,<br>  IPC_NTCREATEKEY_TAG,<br>  IPC_NTOPENKEY_TAG,<br>  IPC_GDI_GDIDLLINITIALIZE_TAG,<br>  IPC_GDI_GETSTOCKOBJECT_TAG,<br>  IPC_USER_REGISTERCLASSW_TAG,<br>  IPC_CREATETHREAD_TAG,<br>  IPC_USER_ENUMDISPLAYMONITORS_TAG,<br>  IPC_USER_ENUMDISPLAYDEVICES_TAG,<br>  IPC_USER_GETMONITORINFO_TAG,<br>  IPC_GDI_CREATEOPMPROTECTEDOUTPUTS_TAG,<br>  IPC_GDI_GETCERTIFICATE_TAG,<br>  IPC_GDI_GETCERTIFICATESIZE_TAG,<br>  IPC_GDI_DESTROYOPMPROTECTEDOUTPUT_TAG,<br>  IPC_GDI_CONFIGUREOPMPROTECTEDOUTPUT_TAG,<br>  IPC_GDI_GETOPMINFORMATION_TAG,<br>  IPC_GDI_GETOPMRANDOMNUMBER_TAG,<br>  IPC_GDI_GETSUGGESTEDOPMPROTECTEDOUTPUTARRAYSIZE_TAG,<br>  IPC_GDI_SETOPMSIGNINGKEYANDSEQUENCENUMBERS_TAG,<br>  IPC_LAST_TAG<br>&#125;;<br></code></pre></td></tr></table></figure><p>那么看看构造器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TopLevelDispatcher::<span class="hljs-built_in">TopLevelDispatcher</span>(PolicyBase* policy) : <span class="hljs-built_in">policy_</span>(policy) &#123;<br>  <span class="hljs-comment">// Initialize the IPC dispatcher array.</span><br>  <span class="hljs-built_in">memset</span>(ipc_targets_, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(ipc_targets_));<br>  Dispatcher* dispatcher;<br><br>  <span class="hljs-comment">// new出多个子系统的Dispatcher，指派对应的那些IPC请求</span><br>  dispatcher = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FilesystemDispatcher</span>(policy_);<br>  ipc_targets_[IPC_NTCREATEFILE_TAG] = dispatcher;<br>  ipc_targets_[IPC_NTOPENFILE_TAG] = dispatcher;<br>  ipc_targets_[IPC_NTSETINFO_RENAME_TAG] = dispatcher;<br>  ipc_targets_[IPC_NTQUERYATTRIBUTESFILE_TAG] = dispatcher;<br>  ipc_targets_[IPC_NTQUERYFULLATTRIBUTESFILE_TAG] = dispatcher;<br>  filesystem_dispatcher_.<span class="hljs-built_in">reset</span>(dispatcher);<br><br>  dispatcher = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NamedPipeDispatcher</span>(policy_);<br>  ipc_targets_[IPC_CREATENAMEDPIPEW_TAG] = dispatcher;<br>  named_pipe_dispatcher_.<span class="hljs-built_in">reset</span>(dispatcher);<br><br>  dispatcher = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ThreadProcessDispatcher</span>(policy_);<br>  ipc_targets_[IPC_NTOPENTHREAD_TAG] = dispatcher;<br>  ipc_targets_[IPC_NTOPENPROCESS_TAG] = dispatcher;<br>  ipc_targets_[IPC_CREATEPROCESSW_TAG] = dispatcher;<br>  ipc_targets_[IPC_NTOPENPROCESSTOKEN_TAG] = dispatcher;<br>  ipc_targets_[IPC_NTOPENPROCESSTOKENEX_TAG] = dispatcher;<br>  ipc_targets_[IPC_CREATETHREAD_TAG] = dispatcher;<br>  thread_process_dispatcher_.<span class="hljs-built_in">reset</span>(dispatcher);<br><br>  dispatcher = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SyncDispatcher</span>(policy_);<br>  ipc_targets_[IPC_CREATEEVENT_TAG] = dispatcher;<br>  ipc_targets_[IPC_OPENEVENT_TAG] = dispatcher;<br>  sync_dispatcher_.<span class="hljs-built_in">reset</span>(dispatcher);<br><br>  dispatcher = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegistryDispatcher</span>(policy_);<br>  ipc_targets_[IPC_NTCREATEKEY_TAG] = dispatcher;<br>  ipc_targets_[IPC_NTOPENKEY_TAG] = dispatcher;<br>  registry_dispatcher_.<span class="hljs-built_in">reset</span>(dispatcher);<br><br>  dispatcher = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ProcessMitigationsWin32KDispatcher</span>(policy_);<br>  ipc_targets_[IPC_GDI_GDIDLLINITIALIZE_TAG] = dispatcher;<br>  ipc_targets_[IPC_GDI_GETSTOCKOBJECT_TAG] = dispatcher;<br>  ipc_targets_[IPC_USER_REGISTERCLASSW_TAG] = dispatcher;<br>  ipc_targets_[IPC_USER_ENUMDISPLAYMONITORS_TAG] = dispatcher;<br>  ipc_targets_[IPC_USER_ENUMDISPLAYDEVICES_TAG] = dispatcher;<br>  ipc_targets_[IPC_USER_GETMONITORINFO_TAG] = dispatcher;<br>  ipc_targets_[IPC_GDI_CREATEOPMPROTECTEDOUTPUTS_TAG] = dispatcher;<br>  ipc_targets_[IPC_GDI_GETCERTIFICATE_TAG] = dispatcher;<br>  ipc_targets_[IPC_GDI_GETCERTIFICATESIZE_TAG] = dispatcher;<br>  ipc_targets_[IPC_GDI_DESTROYOPMPROTECTEDOUTPUT_TAG] = dispatcher;<br>  ipc_targets_[IPC_GDI_CONFIGUREOPMPROTECTEDOUTPUT_TAG] = dispatcher;<br>  ipc_targets_[IPC_GDI_GETOPMINFORMATION_TAG] = dispatcher;<br>  ipc_targets_[IPC_GDI_GETOPMRANDOMNUMBER_TAG] = dispatcher;<br>  ipc_targets_[IPC_GDI_GETSUGGESTEDOPMPROTECTEDOUTPUTARRAYSIZE_TAG] =<br>      dispatcher;<br>  ipc_targets_[IPC_GDI_SETOPMSIGNINGKEYANDSEQUENCENUMBERS_TAG] = dispatcher;<br>  process_mitigations_win32k_dispatcher_.<span class="hljs-built_in">reset</span>(dispatcher);<br>&#125;<br></code></pre></td></tr></table></figure><p>构造器做了IPC请求的分类，而在<code>OnMessageReady</code>中则只是对分发的包装：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// When an IPC is ready in any of the targets we get called. We manage an array</span><br><span class="hljs-comment">// of IPC dispatchers which are keyed on the IPC tag so we normally delegate</span><br><span class="hljs-comment">// to the appropriate dispatcher unless we can handle the IPC call ourselves.</span><br><span class="hljs-function">Dispatcher* <span class="hljs-title">TopLevelDispatcher::OnMessageReady</span><span class="hljs-params">(IPCParams* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                               CallbackGeneric* callback)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(callback);<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> IPCParams ping1 = &#123;IPC_PING1_TAG, &#123;UINT32_TYPE&#125;&#125;;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> IPCParams ping2 = &#123;IPC_PING2_TAG, &#123;INOUTPTR_TYPE&#125;&#125;;<br><br>  <span class="hljs-keyword">if</span> (ping1.<span class="hljs-built_in">Matches</span>(ipc) || ping2.<span class="hljs-built_in">Matches</span>(ipc)) &#123;<br>    *callback = <span class="hljs-built_in">reinterpret_cast</span>&lt;CallbackGeneric&gt;(<br>        <span class="hljs-built_in">static_cast</span>&lt;Callback1&gt;(&amp;TopLevelDispatcher::Ping));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 父类指针指向子类对象</span><br>  Dispatcher* dispatcher = <span class="hljs-built_in">GetDispatcher</span>(ipc-&gt;ipc_tag);<br>  <span class="hljs-keyword">if</span> (!dispatcher) &#123;<br>    <span class="hljs-built_in">NOTREACHED</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-comment">// 调用真正的子系统Dispatcher派生类来处理</span><br>  <span class="hljs-keyword">return</span> dispatcher-&gt;<span class="hljs-built_in">OnMessageReady</span>(ipc, callback);<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，我们还剩下两个疑点：</p><ol type="1"><li><code>SetupService</code>具体作用是什么，如何与Interception联系并工作的？</li><li>这些具体的子系统Dispatcher派生类是如何工作的？</li></ol><p>关于第一点，日后在分析Interception时自然知晓。而第二点则在日后分析完Interception+Dispatcher+Policy三大组成基础设施后，逐一分析每个子系统的部署。</p><h2 id="管中窥豹">管中窥豹</h2><p>当然，sandbox有很多单元测试代码，透过lpc_unittest.cc中对IPC的测试代码可以窥探一二。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Creates a server thread that answers the IPC so slow that is guaranteed to</span><br><span class="hljs-comment">// trigger the time-out code path in the client. A second thread is created</span><br><span class="hljs-comment">// to hold locked the server_alive mutex: this signals the client that the</span><br><span class="hljs-comment">// server is not dead and it retries the wait.</span><br><span class="hljs-built_in">TEST</span>(IPCTest, ClientSlowServer) &#123;<br>  <span class="hljs-type">size_t</span> base_start = <span class="hljs-number">0</span>;<br>  IPCControl* client_control =<br>      <span class="hljs-built_in">MakeChannels</span>(kIPCChannelSize, <span class="hljs-number">4096</span> * <span class="hljs-number">2</span>, &amp;base_start);<span class="hljs-comment">// 实际上并没有共享，只是new了一片空间</span><br>  <span class="hljs-built_in">FixChannels</span>(client_control, base_start, kIPCChannelSize, FIX_PONG_NOT_READY);<br>  client_control-&gt;server_alive = ::<span class="hljs-built_in">CreateMutex</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nullptr</span>);<br><br>  <span class="hljs-type">char</span>* mem = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(client_control);<br>  <span class="hljs-function">SharedMemIPCClient <span class="hljs-title">client</span><span class="hljs-params">(mem)</span></span>;<span class="hljs-comment">// 局部做出一个SharedMemIPCClient对象</span><br><br>  ServerEvents events = &#123;<span class="hljs-number">0</span>&#125;;<br>  events.ping = client_control-&gt;channels[<span class="hljs-number">0</span>].ping_event;<br>  events.pong = client_control-&gt;channels[<span class="hljs-number">0</span>].pong_event;<br>  events.state = &amp;client_control-&gt;channels[<span class="hljs-number">0</span>].state;<br><br>  <span class="hljs-comment">// 因为没有共享内存，不是真正的进程间通信，所以只是用同一进程中线程间通信来测试功能代码</span><br>  <span class="hljs-comment">// 这个是回复IPC调用的线程</span><br>  HANDLE t1 =<br>      ::<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, SlowResponseServer, &amp;events, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">ASSERT_TRUE</span>(t1);<br>  ::<span class="hljs-built_in">CloseHandle</span>(t1);<br><br>  ServerEvents events2 = &#123;<span class="hljs-number">0</span>&#125;;<br>  events2.pong = events.pong;<br>  events2.mutex = client_control-&gt;server_alive;<br><br>  <span class="hljs-comment">// 这个是控制client_control-&gt;server_alive锁的线程</span><br>  HANDLE t2 =<br>      ::<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, MainServerThread, &amp;events2, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">ASSERT_TRUE</span>(t2);<br>  ::<span class="hljs-built_in">CloseHandle</span>(t2);<br><br>  ::<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">// 这里获取了channel，并填充了CrossCallParamsMock，它是个测试用的CrossCallParams子类</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    class CrossCallParamsMock : public CrossCallParams &#123;</span><br><span class="hljs-comment">     public:</span><br><span class="hljs-comment">      CrossCallParamsMock(uint32_t tag, uint32_t params_count)</span><br><span class="hljs-comment">          : CrossCallParams(tag, params_count) &#123;&#125;</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-type">void</span>* buff0 = client.<span class="hljs-built_in">GetBuffer</span>();<br>  <span class="hljs-type">uint32_t</span> tag = <span class="hljs-number">4321</span>;<br>  CrossCallReturn answer;<br>  CrossCallParamsMock* params1 = <span class="hljs-built_in">new</span> (buff0) <span class="hljs-built_in">CrossCallParamsMock</span>(tag, <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">FakeOkAnswerInChannel</span>(buff0);<br><br>  <span class="hljs-comment">// 调用了DoCall，印证了channel buffer已经填充完毕的想法</span><br>  ResultCode result = client.<span class="hljs-built_in">DoCall</span>(params1, &amp;answer);/<br>  <span class="hljs-keyword">if</span> (SBOX_ERROR_CHANNEL_ERROR != result)<br>    client.<span class="hljs-built_in">FreeBuffer</span>(buff0);<br><br>  <span class="hljs-comment">// 判断一下这些值是否正确</span><br>  <span class="hljs-built_in">EXPECT_TRUE</span>(SBOX_ALL_OK == result);<br>  <span class="hljs-built_in">EXPECT_EQ</span>(tag, client_control-&gt;channels[<span class="hljs-number">0</span>].ipc_tag);<br>  <span class="hljs-built_in">EXPECT_EQ</span>(kFreeChannel, client_control-&gt;channels[<span class="hljs-number">0</span>].state);<br><br>  <span class="hljs-built_in">CloseChannelEvents</span>(client_control);<br>  ::<span class="hljs-built_in">CloseHandle</span>(client_control-&gt;server_alive);<br>  <span class="hljs-keyword">delete</span>[] <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(client_control);<br>&#125;<br></code></pre></td></tr></table></figure><p>展开<code>MakeChannels</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Helper function to make the fake shared memory with some</span><br><span class="hljs-comment">// basic elements initialized.</span><br><span class="hljs-function">IPCControl* <span class="hljs-title">MakeChannels</span><span class="hljs-params">(<span class="hljs-type">size_t</span> channel_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">size_t</span> total_shared_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">size_t</span>* base_start)</span> </span>&#123;<br>  <span class="hljs-comment">// Allocate memory</span><br>  <span class="hljs-type">char</span>* mem = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[total_shared_size];<span class="hljs-comment">// new一片内存空间，部署好IPCControl</span><br>  <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, total_shared_size);<br>  <span class="hljs-comment">// Calculate how many channels we can fit in the shared memory.</span><br>  total_shared_size -= <span class="hljs-built_in">offsetof</span>(IPCControl, channels);<br>  <span class="hljs-type">size_t</span> channel_count =<br>      total_shared_size / (<span class="hljs-built_in">sizeof</span>(ChannelControl) + channel_size);<br>  <span class="hljs-comment">// Calculate the start of the first channel.</span><br>  *base_start =<br>      (<span class="hljs-built_in">sizeof</span>(ChannelControl) * channel_count) + <span class="hljs-built_in">offsetof</span>(IPCControl, channels);<br>  <span class="hljs-comment">// Setup client structure.</span><br>  IPCControl* client_control = <span class="hljs-built_in">reinterpret_cast</span>&lt;IPCControl*&gt;(mem);<br>  client_control-&gt;channels_count = channel_count;<br>  <span class="hljs-keyword">return</span> client_control;<br>&#125;<br><br><span class="hljs-comment">// 创建ping/pong事件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FixChannels</span><span class="hljs-params">(IPCControl* client_control,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span> base_start,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span> channel_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                 TestFixMode mode)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> ix = <span class="hljs-number">0</span>; ix != client_control-&gt;channels_count; ++ix) &#123;<br>    ChannelControl&amp; channel = client_control-&gt;channels[ix];<br>    channel.channel_base = base_start;<br>    channel.state = kFreeChannel;<br>    <span class="hljs-keyword">if</span> (mode != FIX_NO_EVENTS) &#123;<br>      <span class="hljs-type">bool</span> signaled = (FIX_PONG_READY == mode) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>      channel.ping_event = ::<span class="hljs-built_in">CreateEventW</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nullptr</span>);<br>      channel.pong_event = ::<span class="hljs-built_in">CreateEventW</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, signaled, <span class="hljs-literal">nullptr</span>);<br>    &#125;<br>    base_start += channel_size;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再看一下两个线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is the server thread that very slowly answers an IPC and exits. Note</span><br><span class="hljs-comment">// that the pong event needs to be signaled twice.</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">SlowResponseServer</span><span class="hljs-params">(PVOID param)</span> </span>&#123;<br>  ServerEvents* events = <span class="hljs-built_in">reinterpret_cast</span>&lt;ServerEvents*&gt;(param);<br>  DWORD wait_result = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 在ping上等待</span><br>  wait_result = ::<span class="hljs-built_in">WaitForSingleObject</span>(events-&gt;ping, INFINITE);<br>  <span class="hljs-comment">// sleep好久。。。</span><br>  ::<span class="hljs-built_in">Sleep</span>(kIPCWaitTimeOut1 + kIPCWaitTimeOut2 + <span class="hljs-number">200</span>);<br>  <span class="hljs-comment">// 没有处理参数，只是简单的设置信道为Ack</span><br>  ::<span class="hljs-built_in">InterlockedExchange</span>(events-&gt;state, kAckChannel);<br>  <span class="hljs-comment">// 置信pong event</span><br>  ::<span class="hljs-built_in">SetEvent</span>(events-&gt;pong);<br>  <span class="hljs-keyword">return</span> wait_result;<br>&#125;<br><br><span class="hljs-comment">// This thread&#x27;s job is to keep the mutex locked.</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">MainServerThread</span><span class="hljs-params">(PVOID param)</span> </span>&#123;<br>  ServerEvents* events = <span class="hljs-built_in">reinterpret_cast</span>&lt;ServerEvents*&gt;(param);<br>  DWORD wait_result = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 等待events的mutex，只要这个mutex还拿不到就表示server还在</span><br>  wait_result = ::<span class="hljs-built_in">WaitForSingleObject</span>(events-&gt;mutex, INFINITE);<br>  <span class="hljs-built_in">Sleep</span>(kIPCWaitTimeOut1 * <span class="hljs-number">20</span>);<br>  <span class="hljs-keyword">return</span> wait_result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-crosscall-analysis</title>
    <link href="/2018/05/19/chromium-sandbox-Crosscall-analysis/"/>
    <url>/2018/05/19/chromium-sandbox-Crosscall-analysis/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第七篇，主要分析了windows平台下，Chromiumsandbox IPC通信中参数返回值的封装以及IPC ChannelBuffer的结构设计。本篇相对独立，可以直接阅读。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-crosscall-analysis">chromium-sandbox-crosscall-analysis</h1><h2 id="common-gargets">Common gargets</h2><p>CrossCall是沙盒IPC实现的灵魂。想要了解CrossCall代码，势必先了解它的设计。从crosscall_params.h的注释头可以获取大量的有用信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This header is part of CrossCall: the sandbox inter-process communication.</span><br><span class="hljs-comment">// This header defines the basic types used both in the client IPC and in the</span><br><span class="hljs-comment">// server IPC code. CrossCallParams and ActualCallParams model the input</span><br><span class="hljs-comment">// parameters of an IPC call and CrossCallReturn models the output params and</span><br><span class="hljs-comment">// the return value.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// An IPC call is defined by its &#x27;tag&#x27; which is a (uint32_t) unique identifier</span><br><span class="hljs-comment">// that is used to route the IPC call to the proper server. Every tag implies</span><br><span class="hljs-comment">// a complete call signature including the order and type of each parameter.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Like most IPC systems. CrossCall is designed to take as inputs &#x27;simple&#x27;</span><br><span class="hljs-comment">// types such as integers and strings. Classes, generic arrays or pointers to</span><br><span class="hljs-comment">// them are not supported.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Another limitation of CrossCall is that the return value and output</span><br><span class="hljs-comment">// parameters can only be uint32_t integers. Returning complex structures or</span><br><span class="hljs-comment">// strings is not supported.</span><br></code></pre></td></tr></table></figure><p>简单梳理一下：</p><ol type="1"><li>client和server端通过IPC通信，其中<code>CrossCallParams</code>和<code>ActualCallParams</code>封装了client端发起IPC调用的输入型参数，而<code>CrossCallReturn</code>封装了输出型参数和返回值。</li><li>每种IPC调用都以它的tag区分，tag是个<code>uint32_t</code>类型值，不同的值对应不同的IPC调用。tag用以将IPC调用转发给正确的server处理，每种tag类型暗示了一套完整的调用签名，这包括参数的类型和顺序。</li><li>CrossCall的输入参数只能使用整型、字符串等简单类型。类、数组或指针是不行的。</li><li>CrossCall的另一个限制在于返回值和输出参数只能是<code>uint32_t</code>类型，不能返回复杂的结构体或字符串。</li></ol><blockquote><p>其实<code>uint32_t</code>已经绰绰有余了，x86平台指针也是32位的，可以做类型转换。</p></blockquote><h3 id="infrastructure">Infrastructure</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// max number of extended return parameters. See CrossCallReturn</span><br><span class="hljs-comment">// 输出型参数最多只能有8个，不清楚是否包括返回值，等到看CrossCallReturn时再说</span><br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kExtendedReturnCount = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">// Union of multiple types to be used as extended results</span><br><span class="hljs-comment">// in the CrossCallReturn.</span><br><span class="hljs-comment">// 前面已经看到了，返回值和输出型参数只能是uint32_t</span><br><span class="hljs-comment">// 实际上这种说法不严谨，编码意义上的本质在于只能使用32位的值。</span><br><span class="hljs-comment">// 32位的值可以表示一个任意类型x86指针，可以表示句柄等等。</span><br><span class="hljs-comment">// 下面的union就整理了CrossCallReturn可能会用到的几种类型</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">MultiType</span> &#123;<br>  <span class="hljs-type">uint32_t</span> unsigned_int;<br>  <span class="hljs-type">void</span>* pointer;<br>  HANDLE handle;<br>  ULONG_PTR ulong_ptr;<br>&#125;;<br><br><span class="hljs-comment">// Maximum number of IPC parameters currently supported.</span><br><span class="hljs-comment">// To increase this value, we have to:</span><br><span class="hljs-comment">//  - Add another Callback typedef to Dispatcher.</span><br><span class="hljs-comment">//  - Add another case to the switch on SharedMemIPCServer::InvokeCallback.</span><br><span class="hljs-comment">//  - Add another case to the switch in GetActualAndMaxBufferSize</span><br><span class="hljs-comment">// 这个应该是IPC参数的最大数量</span><br><span class="hljs-comment">// 看起来如果扩展参数数量会相当麻烦：</span><br><span class="hljs-comment">//- Dispatcher的Callback需要增加</span><br><span class="hljs-comment">//- SharedMemIPCServer::InvokeCallback的switch需要加个case</span><br><span class="hljs-comment">//- GetActualAndMaxBufferSize的switch需要加个case</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kMaxIpcParams = <span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure><p>再看IPC buffer的info封装：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Contains the information about a parameter in the ipc buffer.</span><br><span class="hljs-comment">// IPC通信无论如何折腾，最本质的client用buffer承载数据，将其发给server</span><br><span class="hljs-comment">// ParamInfo则抽象了buffer中的某个参数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ParamInfo</span> &#123;<br>  ArgType type_;<span class="hljs-comment">// 看下面</span><br>  <span class="hljs-type">uint32_t</span> offset_;<span class="hljs-comment">// 真实数据偏移</span><br>  <span class="hljs-type">uint32_t</span> size_;<span class="hljs-comment">// 真实数据尺寸</span><br>&#125;;<br><span class="hljs-comment">// 这种offset+size的组合通常来说都是真实数据游离于ParamInfo结构之外</span><br><span class="hljs-comment">// 而真实数据append到ParamInfo后面的某个地址处，offset和size用于定位真实数据的起始</span><br><br><span class="hljs-comment">// Defines the supported C++ types encoding to numeric id. Like a simplified</span><br><span class="hljs-comment">// RTTI. Note that true C++ RTTI will not work because the types are not</span><br><span class="hljs-comment">// polymorphic anyway.</span><br><span class="hljs-comment">// 这个就表示参数（上面提到的真实数据）是哪一种C++类型，用枚举来表示</span><br><span class="hljs-comment">// 这就很像一个简化的RTTI（runtime type identify），当然了这些类型没有多态所以RTTI是没戏的。</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ArgType</span> &#123;<br>  INVALID_TYPE = <span class="hljs-number">0</span>,<br>  WCHAR_TYPE,<br>  UINT32_TYPE,<br>  UNISTR_TYPE,<br>  VOIDPTR_TYPE,<br>  INPTR_TYPE,<br>  INOUTPTR_TYPE,<br>  LAST_TYPE<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="crosscallreturn"><code>CrossCallReturn</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Models the return value and the return parameters of an IPC call</span><br><span class="hljs-comment">// currently limited to one status code and eight generic return values</span><br><span class="hljs-comment">// which cannot be pointers to other data. For x64 ports this structure</span><br><span class="hljs-comment">// might have to use other integer types.</span><br><span class="hljs-comment">// 封装了IPC调用的输出型参数和返回值</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CrossCallReturn</span> &#123;<br>  <span class="hljs-comment">// the IPC tag. It should match the original IPC tag.</span><br>  <span class="hljs-type">uint32_t</span> tag;<span class="hljs-comment">// 每种IPC调用独有的tag</span><br>  <span class="hljs-comment">// The result of the IPC operation itself.</span><br>  ResultCode call_outcome;<span class="hljs-comment">// 保存IPC操作本身的状态码结果</span><br>  <span class="hljs-comment">// the result of the IPC call as executed in the server. The interpretation</span><br>  <span class="hljs-comment">// of this value depends on the specific service.</span><br>  <span class="hljs-comment">// 这个就是server上处理IPC call的结果状态值，具体意义取决于特定的服务</span><br>  <span class="hljs-keyword">union</span> &#123;<br>    NTSTATUS nt_status;<br>    DWORD win32_result;<br>  &#125;;<br>  <span class="hljs-comment">// Number of extended return values.</span><br>  <span class="hljs-type">uint32_t</span> extended_count;<span class="hljs-comment">// 应该是输出型参数的个数，暂不清楚是否包含返回值</span><br>  <span class="hljs-comment">// for calls that should return a windows handle. It is found here.</span><br>  HANDLE handle;<span class="hljs-comment">// 如果有需要返回windows句柄的，可以存在这里</span><br>  <span class="hljs-comment">// The array of extended values.</span><br>  <span class="hljs-comment">// extended values数组，每一种都是MultiType这个union</span><br>  MultiType extended[kExtendedReturnCount];<span class="hljs-comment">//kExtendedReturnCount是8</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>CrossCallReturn</code>看起来的确封装了输出参数和返回值，在client发起IPC调用时，应该是直接或者间接通过某种结构嵌套传到server，而server在把结果和输出参数填充好，client再读出来。</p><h3 id="crosscallparams"><code>CrossCallParams</code></h3><p>再看看输入型参数的封装结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CrossCallParams base class that models the input params all packed in a</span><br><span class="hljs-comment">// single compact memory blob. The representation can vary but in general a</span><br><span class="hljs-comment">// given child of this class is meant to represent all input parameters</span><br><span class="hljs-comment">// necessary to make a IPC call.</span><br><span class="hljs-comment">// 把输入型参数紧凑的捏成一团，用于发起IPC调用</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// This class cannot have virtual members because its assumed the IPC</span><br><span class="hljs-comment">// parameters start from the &#x27;this&#x27; pointer to the end, which is defined by</span><br><span class="hljs-comment">// one of the subclasses</span><br><span class="hljs-comment">// 该类无法拥有虚成员函数，因为设计上会假定从this指针起始到结尾（并不是对象内存空间尾）这部分内存空间</span><br><span class="hljs-comment">// 要作为IPC参数的buffer，这由它的子类定义</span><br><span class="hljs-comment">//（含有虚函数的对象会有虚表，虚表在this处即对象头部位置）</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// Objects of this class cannot be constructed directly. Only derived</span><br><span class="hljs-comment">// classes have the proper knowledge to construct it.</span><br><span class="hljs-comment">// 限于这种复杂的使用方式，该类不能简单的直接构造，而是必须通过子类以特殊方式构造。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossCallParams</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Returns the tag (ipc unique id) associated with this IPC.</span><br>  <span class="hljs-comment">// 获取该IPC调用的tag，实际上存储在tag_成员</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetTag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> tag_; &#125;<br><br>  <span class="hljs-comment">// Returns the beggining of the buffer where the IPC params can be stored.</span><br>  <span class="hljs-comment">// prior to an IPC call</span><br>  <span class="hljs-comment">// 这里就看出类头注释的意义了，该对象实体的整个内存空间都是IPC参数存储的buffer</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetBuffer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br><br>  <span class="hljs-comment">// Returns how many parameter this IPC call should have.</span><br>  <span class="hljs-comment">// 返回该IPC call有多少个参数</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetParamsCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> params_count_; &#125;<br><br>  <span class="hljs-comment">// Returns a pointer to the CrossCallReturn structure.</span><br>  <span class="hljs-comment">// 返回CrossCallReturn结构指针，这里可以看出该对象内部封装了一个用于承载返回值和</span><br>  <span class="hljs-comment">// 输出型参数的结构</span><br>  <span class="hljs-function">CrossCallReturn* <span class="hljs-title">GetCallReturn</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;call_return; &#125;<br><br>  <span class="hljs-comment">// Returns true if this call contains InOut parameters.</span><br>  <span class="hljs-comment">// 是否有InOut型即输入输出型参数</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> == is_in_out_); &#125;<br><br>  <span class="hljs-comment">// Tells the CrossCall object if it contains InOut parameters.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetIsInOut</span><span class="hljs-params">(<span class="hljs-type">bool</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (value)<br>      is_in_out_ = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>      is_in_out_ = <span class="hljs-number">0</span>;<br>  &#125;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// constructs the IPC call params. Called only from the derived classes</span><br>  <span class="hljs-comment">// 构造器是protected，表明该对象的实例化需要借助派生类。</span><br>  <span class="hljs-built_in">CrossCallParams</span>(<span class="hljs-type">uint32_t</span> tag, <span class="hljs-type">uint32_t</span> params_count)<br>      : <span class="hljs-built_in">tag_</span>(tag), <span class="hljs-built_in">is_in_out_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">params_count_</span>(params_count) &#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">uint32_t</span> tag_;<br>  <span class="hljs-type">uint32_t</span> is_in_out_;<br>  CrossCallReturn call_return;<br>  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> params_count_;<br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(CrossCallParams);<br>&#125;;<br></code></pre></td></tr></table></figure><p>能够嗅到一点设计上熟悉的味道，下一步就是找到它的派生类，看看整个buffer到底是什么，<code>CrossCallParams</code>内存空间后又贴了哪些数据。</p><h3 id="actualcallparams"><code>ActualCallParams</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ActualCallParams models an specific IPC call parameters with respect to the</span><br><span class="hljs-comment">// storage allocation that the packed parameters should need.</span><br><span class="hljs-comment">// NUMBER_PARAMS: the number of parameters, valid from 1 to N</span><br><span class="hljs-comment">// BLOCK_SIZE: the total storage that the NUMBER_PARAMS parameters can take,</span><br><span class="hljs-comment">// typically the block size is defined by the channel size of the underlying</span><br><span class="hljs-comment">// ipc mechanism.</span><br><span class="hljs-comment">// In practice this class is used to levergage C++ capacity to properly</span><br><span class="hljs-comment">// calculate sizes and displacements given the possibility of the packed params</span><br><span class="hljs-comment">// blob to be complex.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// As is, this class assumes that the layout of the blob is as follows. Assume</span><br><span class="hljs-comment">// that NUMBER_PARAMS = 2 and a 32-bit build:</span><br><span class="hljs-comment">// 这就是关键之处了，刻画了2个参数情形下的buffer布局</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// [ tag                4 bytes]</span><br><span class="hljs-comment">// [ IsOnOut            4 bytes]// 这个应该是IsInOut吧。。.</span><br><span class="hljs-comment">// [ call return       52 bytes]</span><br><span class="hljs-comment">// [ params count       4 bytes]// 上面这些就是父类CrossCallParam的64B内存空间</span><br><span class="hljs-comment">// [ parameter 0 type   4 bytes]// 三元组就是struct ParamInfo，2表示有3个</span><br><span class="hljs-comment">// [ parameter 0 offset 4 bytes] ---delta to ---\</span><br><span class="hljs-comment">// [ parameter 0 size   4 bytes]                |</span><br><span class="hljs-comment">// [ parameter 1 type   4 bytes]                |</span><br><span class="hljs-comment">// [ parameter 1 offset 4 bytes] ---------------|--\</span><br><span class="hljs-comment">// [ parameter 1 size   4 bytes]                |  |</span><br><span class="hljs-comment">// [ parameter 2 type   4 bytes]                |  |</span><br><span class="hljs-comment">// [ parameter 2 offset 4 bytes] ----------------------\</span><br><span class="hljs-comment">// [ parameter 2 size   4 bytes]                |  |   |</span><br><span class="hljs-comment">// |---------------------------|                |  |   |</span><br><span class="hljs-comment">// | value 0     (x bytes)     | &lt;--------------/  |   |// 这部分对应真实数据</span><br><span class="hljs-comment">// | value 1     (y bytes)     | &lt;-----------------/   |</span><br><span class="hljs-comment">// |                           |                       |</span><br><span class="hljs-comment">// | end of buffer             | &lt;---------------------/// 最后一个offset表示结尾</span><br><span class="hljs-comment">// |---------------------------|</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Note that the actual number of params is NUMBER_PARAMS + 1</span><br><span class="hljs-comment">// so that the size of each actual param can be computed from the difference</span><br><span class="hljs-comment">// between one parameter and the next down. The offset of the last param</span><br><span class="hljs-comment">// points to the end of the buffer and the type and size are undefined.</span><br><span class="hljs-comment">// 描述了最后一个ParamInfo的说明</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 类模板，常数型，用以在定义ActualCallParams&lt;xxx,xxx&gt;类时指定参数个数与buffer尺寸</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">size_t</span> NUMBER_PARAMS, <span class="hljs-type">size_t</span> BLOCK_SIZE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ActualCallParams</span> : <span class="hljs-keyword">public</span> CrossCallParams &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// constructor. Pass the ipc unique tag as input</span><br>  <span class="hljs-comment">// 以传入的tag和模板常量NUMBER_PARAMS调用父类构造器</span><br>  <span class="hljs-comment">// 像这种单基本型参数的构造器都要声明explicit，防止编译器自作聪明的在某些情况把uint32_t自动转化成ActualCallParams&lt;xxx,xxx&gt;对象</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ActualCallParams</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> tag)</span></span><br><span class="hljs-function">      : CrossCallParams(tag, NUMBER_PARAMS) &#123;</span><br>    <span class="hljs-comment">// 第一个ParamInfo的offset是已知的</span><br>    <span class="hljs-comment">// parameters_数组存储真实参数，它的首地址减去param_info_数组地址就是param_info_[0]的offset</span><br>    param_info_[<span class="hljs-number">0</span>].offset_ =<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(parameters_ - <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-keyword">this</span>));<br>  &#125;<br><br>  <span class="hljs-comment">// Testing-only constructor. Allows setting the |number_params| to a</span><br>  <span class="hljs-comment">// wrong value.</span><br>  <span class="hljs-comment">// 测试用的构造器，这里没有用模板常量而是使用了传入的参数个数</span><br>  <span class="hljs-built_in">ActualCallParams</span>(<span class="hljs-type">uint32_t</span> tag, <span class="hljs-type">uint32_t</span> number_params)<br>      : <span class="hljs-built_in">CrossCallParams</span>(tag, number_params) &#123;<br>    param_info_[<span class="hljs-number">0</span>].offset_ =<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(parameters_ - <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-keyword">this</span>));<br>  &#125;<br><br>  <span class="hljs-comment">// Testing-only method. Allows setting the apparent size to a wrong value.</span><br>  <span class="hljs-comment">// returns the previous size.</span><br>  <span class="hljs-comment">// 测试用，修改一个param_info_[someone]的offset</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">OverrideSize</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> new_size)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> previous_size = param_info_[NUMBER_PARAMS].offset_;<br>    param_info_[NUMBER_PARAMS].offset_ = new_size;<br>    <span class="hljs-keyword">return</span> previous_size;<br>  &#125;<br><br>  <span class="hljs-comment">// Copies each paramter into the internal buffer. For each you must supply:</span><br>  <span class="hljs-comment">// index: 0 for the first param, 1 for the next an so on</span><br>  <span class="hljs-comment">// 把参数拷贝到正确的buffer位置，index表示第几个参数</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CopyParamIn</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">const</span> <span class="hljs-type">void</span>* parameter_address,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">uint32_t</span> size,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">bool</span> is_in_out,</span></span><br><span class="hljs-params"><span class="hljs-function">                   ArgType type)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= NUMBER_PARAMS) &#123;<span class="hljs-comment">// sanity check</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (UINT32_MAX == size) &#123;<br>      <span class="hljs-comment">// Memory error while getting the size.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (size &amp;&amp; !parameter_address) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((size &gt; <span class="hljs-built_in">sizeof</span>(*<span class="hljs-keyword">this</span>)) ||<br>        (param_info_[index].offset_ &gt; (<span class="hljs-built_in">sizeof</span>(*<span class="hljs-keyword">this</span>) - size))) &#123;<br>      <span class="hljs-comment">// It does not fit, abort copy.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-comment">// 安检通过，找到坑位</span><br>    <span class="hljs-type">char</span>* dest = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-keyword">this</span>) + param_info_[index].offset_;<br><br>    <span class="hljs-comment">// We might be touching user memory, this has to be done from inside a try</span><br>    <span class="hljs-comment">// except.</span><br>    <span class="hljs-comment">// copy参数过去</span><br>    __try &#123;<br>      <span class="hljs-built_in">memcpy</span>(dest, parameter_address, size);<br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Set the flag to tell the broker to update the buffer once the call is</span><br>    <span class="hljs-comment">// made.</span><br>    <span class="hljs-comment">// 如果这个参数是输入输出型参数，enable is_in_out_</span><br>    <span class="hljs-keyword">if</span> (is_in_out)<br>      <span class="hljs-built_in">SetIsInOut</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 常规offset计算与type,size填充</span><br>    param_info_[index + <span class="hljs-number">1</span>].offset_ = <span class="hljs-built_in">Align</span>(param_info_[index].offset_ + size);<br>    param_info_[index].size_ = size;<br>    param_info_[index].type_ = type;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns a pointer to a parameter in the memory section.</span><br>  <span class="hljs-comment">// get特定参数，返回的是buffer中真实参数的指针</span><br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">GetParamPtr</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-keyword">this</span>) + param_info_[index].offset_;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns the total size of the buffer. Only valid once all the paramters</span><br>  <span class="hljs-comment">// have been copied in with CopyParamIn.</span><br>  <span class="hljs-comment">// 只有当所有参数都通过CopyParamIn拷贝过来后，这个函数返回的才是正确的值。</span><br>  <span class="hljs-comment">// 所以如果我并不copy NUMBER_PARAMS个参数的话，是否会引入某些漏洞？</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> param_info_[NUMBER_PARAMS].offset_; &#125;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// tag为0的构造，这货是protected，对外隐藏</span><br>  <span class="hljs-built_in">ActualCallParams</span>() : <span class="hljs-built_in">CrossCallParams</span>(<span class="hljs-number">0</span>, NUMBER_PARAMS) &#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  ParamInfo param_info_[NUMBER_PARAMS + <span class="hljs-number">1</span>];<span class="hljs-comment">//这个+1说明最后一个边界块不占用参数个数</span><br>  <span class="hljs-type">char</span> parameters_[BLOCK_SIZE - <span class="hljs-built_in">sizeof</span>(CrossCallParams) -<br>                   <span class="hljs-built_in">sizeof</span>(ParamInfo) * (NUMBER_PARAMS + <span class="hljs-number">1</span>)];<br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(ActualCallParams);<span class="hljs-comment">//用不到就禁了，以绝后患</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>到此，IPC调用传输所用的IN/OUT参数、返回值是如何被安排在buffer上，已经非常清楚了。下面就是对Client和Server两端驱动者的分析。</p><h2 id="client">Client</h2><p>老规矩先看看crosscall_client.h头注释的说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This header defines the CrossCall(..) family of templated functions</span><br><span class="hljs-comment">// Their purpose is to simulate the syntax of regular call but to generate</span><br><span class="hljs-comment">// and IPC from the client-side.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The basic pattern is to</span><br><span class="hljs-comment">//   1) use template argument deduction to compute the size of each</span><br><span class="hljs-comment">//      parameter and the appropriate copy method</span><br><span class="hljs-comment">//   2) pack the parameters in the appropriate ActualCallParams&lt; &gt; object</span><br><span class="hljs-comment">//   3) call the IPC interface IPCProvider::DoCall( )</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The general interface of CrossCall is:</span><br><span class="hljs-comment">//  ResultCode CrossCall(IPCProvider&amp; ipc_provider,</span><br><span class="hljs-comment">//                       uint32_t tag,</span><br><span class="hljs-comment">//                       const Par1&amp; p1, const Par2&amp; p2,...pn</span><br><span class="hljs-comment">//                       CrossCallReturn* answer)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  where:</span><br><span class="hljs-comment">//    ipc_provider: is a specific implementation of the ipc transport see</span><br><span class="hljs-comment">//                  sharedmem_ipc_server.h for an example.</span><br><span class="hljs-comment">//    tag : is the unique id for this IPC call. Is used to route the call to</span><br><span class="hljs-comment">//          the appropriate service.</span><br><span class="hljs-comment">//    p1, p2,.. pn : The input parameters of the IPC. Use only simple types</span><br><span class="hljs-comment">//                   and wide strings (can add support for others).</span><br><span class="hljs-comment">//    answer : If the IPC was successful. The server-side answer is here. The</span><br><span class="hljs-comment">//             interpretation of the answer is private to client and server.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The return value is ALL_OK if the IPC was delivered to the server, other</span><br><span class="hljs-comment">// return codes indicate that the IPC transport failed to deliver it.</span><br></code></pre></td></tr></table></figure><p>归纳一下大概就是：</p><ol type="1"><li>定义了一套<code>CrossCall</code>函数模板，每一个函数模板都对应不同个数的参数。</li><li><code>CrossCall</code>的使用方式:<ol type="1"><li>利用模板参数来推断每个参数尺寸的计算以及合适的copy方法</li><li>把参数打包到<code>ActualCallParams&lt; &gt;</code>对象</li><li>发起IPC调用<code>IPCProvider::DoCall()</code></li></ol></li></ol><h3 id="crosscall"><code>CrossCall</code></h3><p>可以说是安排的明明白白，那么我们先看一下<code>CrossCall</code>全家桶。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CrossCall template with one input parameter</span><br><span class="hljs-comment">// 一个参数的CrossCall模板</span><br><span class="hljs-comment">// 模板参数IPCProvider实际上才是IPC机制真正的操纵者，至于它是什么，sandbox用的是哪个Provider，以后再说</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IPCProvider, <span class="hljs-keyword">typename</span> Par1&gt;<br><span class="hljs-function">ResultCode <span class="hljs-title">CrossCall</span><span class="hljs-params">(IPCProvider&amp; ipc_provider,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">uint32_t</span> tag,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par1&amp; p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                     CrossCallReturn* answer)</span> </span>&#123;<br>  <span class="hljs-comment">// 这两个宏有点复杂，一会儿展开</span><br>  <span class="hljs-comment">// 相当于</span><br>  <span class="hljs-comment">// ActualCallParams&lt;1,1024&gt;* call_params = new (ipc_provider.GetBuffer())ActualCallParams&lt;1,1024&gt;(tag);</span><br>  <span class="hljs-comment">// ActualCallParams&lt;&gt;对象是buffer上的抽象，负责具体的参数布局</span><br>  <span class="hljs-comment">// 但buffer内存空间的来源是ipc_provider提供的</span><br>  <span class="hljs-built_in">XCALL_GEN_PARAMS_OBJ</span>(<span class="hljs-number">1</span>, call_params);<br>  <span class="hljs-comment">// 相当于</span><br>  <span class="hljs-comment">// CopyHelper&lt;Par1&gt; ch1(p1); </span><br>  <span class="hljs-comment">// call_params-&gt;CopyParamIn(0,ch1.GetStart(),ch1.GetSize(),ch1.IsInOut(),ch1.GetType())</span><br>  <span class="hljs-comment">// 至于CopyHelper是什么，一会儿再分析，功能上推测是个控制参数拷贝的类模板</span><br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">1</span>, call_params);<br><br>  <span class="hljs-comment">// 实际上还是借用了ipc_provider的DoCall，call_params是个ActualCallParam没问题</span><br>  <span class="hljs-comment">// ActualCallParam已经包含了一个CrossCallReturn，这里又传入了一个CrossCallReturn</span><br>  <span class="hljs-comment">// 是传参的answer，call_params在new的时候并没有对内部的CrossCallReturn做什么</span><br>  <span class="hljs-comment">// 所以answer和call_params中的CrossCallReturn的关系现在还不明朗</span><br>  ResultCode result = ipc_provider.<span class="hljs-built_in">DoCall</span>(call_params, answer);<br><br>  <span class="hljs-keyword">if</span> (SBOX_ERROR_CHANNEL_ERROR != result) &#123;<br>    <span class="hljs-comment">// if(!ch1.Update(call_params-&gt;GetParamPtr(num - 1)))</span><br>    <span class="hljs-comment">// &#123;ipc_provider.FreeBuffer(ipc_provider.GetBuffer());&#125;</span><br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">1</span>, call_params);<br>    <span class="hljs-comment">// ipc_provider.FreeBuffer(ipc_provider.GetBuffer());</span><br>    <span class="hljs-built_in">XCALL_GEN_FREE_CHANNEL</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这几个宏的展开：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> XCALL_GEN_PARAMS_OBJ(num, params)                      \</span><br><span class="hljs-meta">  typedef ActualCallParams<span class="hljs-string">&lt;num, kIPCChannelSize&gt;</span> ActualParams; \</span><br><span class="hljs-meta">  void* raw_mem = ipc_provider.GetBuffer();                    \</span><br><span class="hljs-meta">  <span class="hljs-keyword">if</span> (!raw_mem)                                                \</span><br><span class="hljs-meta">    return SBOX_ERROR_NO_SPACE;                                \</span><br><span class="hljs-meta">  ActualParams* params = new (raw_mem) ActualParams(tag);</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XCALL_GEN_COPY_PARAM(num, params)                                  \</span><br><span class="hljs-meta">  static_assert(kMaxIpcParams &gt;= num, <span class="hljs-string">&quot;too many parameters&quot;</span>);              \</span><br><span class="hljs-meta">  CopyHelper<span class="hljs-string">&lt;Par##num&gt;</span> ch##num(p##num);                                    \</span><br><span class="hljs-meta">  <span class="hljs-keyword">if</span> (!params-&gt;CopyParamIn(num - 1, ch##num.GetStart(), ch##num.GetSize(), \</span><br><span class="hljs-meta">                           ch##num.IsInOut(), ch##num.GetType()))          \</span><br><span class="hljs-meta">    return SBOX_ERROR_NO_SPACE;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XCALL_GEN_UPDATE_PARAM(num, params)            \</span><br><span class="hljs-meta">  <span class="hljs-keyword">if</span> (!ch##num.Update(params-&gt;GetParamPtr(num - 1))) &#123; \</span><br><span class="hljs-meta">    ipc_provider.FreeBuffer(raw_mem);                  \</span><br><span class="hljs-meta">    return SBOX_ERROR_BAD_PARAMS;                      \</span><br><span class="hljs-meta">  &#125;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XCALL_GEN_FREE_CHANNEL() ipc_provider.FreeBuffer(raw_mem);</span><br></code></pre></td></tr></table></figure><p>到此，一个参数的<code>CrossCall</code>类模板就清楚了，那么按照<code>static_assert(kMaxIpcParams &gt;= num, "too many parameters");</code>的指示，应该还有2个参数到9个参数的版本。</p><p>但观察了一下crosscall_client.h的定义，只发现了2到7个参数的模板，我也不清楚为何定义和最大值常量有出入。</p><p>展开看看7个参数的版本吧，实际上只是简单的叠加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CrossCall template with seven input parameters.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IPCProvider,<br>          <span class="hljs-keyword">typename</span> Par1,<br>          <span class="hljs-keyword">typename</span> Par2,<br>          <span class="hljs-keyword">typename</span> Par3,<br>          <span class="hljs-keyword">typename</span> Par4,<br>          <span class="hljs-keyword">typename</span> Par5,<br>          <span class="hljs-keyword">typename</span> Par6,<br>          <span class="hljs-keyword">typename</span> Par7&gt;<br><span class="hljs-function">ResultCode <span class="hljs-title">CrossCall</span><span class="hljs-params">(IPCProvider&amp; ipc_provider,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">uint32_t</span> tag,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par1&amp; p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par2&amp; p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par3&amp; p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par4&amp; p4,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par5&amp; p5,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par6&amp; p6,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par7&amp; p7,</span></span><br><span class="hljs-params"><span class="hljs-function">                     CrossCallReturn* answer)</span> </span>&#123;<br>  <span class="hljs-built_in">XCALL_GEN_PARAMS_OBJ</span>(<span class="hljs-number">7</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">1</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">2</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">3</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">4</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">5</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">6</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">7</span>, call_params);<br><br>  ResultCode result = ipc_provider.<span class="hljs-built_in">DoCall</span>(call_params, answer);<br><br>  <span class="hljs-keyword">if</span> (SBOX_ERROR_CHANNEL_ERROR != result) &#123;<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">1</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">2</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">3</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">4</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">5</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">6</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">7</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_FREE_CHANNEL</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="copyhelper"><code>CopyHelper</code></h3><p>一个类模板，用以推断合适的copy函数来把输入参数拷贝到buffer。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The copy helper uses templates to deduce the appropriate copy function to</span><br><span class="hljs-comment">// copy the input parameters in the buffer that is going to be send across the</span><br><span class="hljs-comment">// IPC. These template facility can be made more sophisticated as need arises.</span><br><br><span class="hljs-comment">// The default copy helper. It catches the general case where no other</span><br><span class="hljs-comment">// specialized template matches better. We set the type to UINT32_TYPE, so this</span><br><span class="hljs-comment">// only works with objects whose size is 32 bits.</span><br><span class="hljs-comment">// 这个是default模板，除了下面对明确类型的模板类定义以外，其他的都匹配到这里</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyHelper</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CopyHelper</span>(<span class="hljs-type">const</span> T&amp; t) : <span class="hljs-built_in">t_</span>(t) &#123;&#125;<br><br>  <span class="hljs-comment">// Returns the pointer to the start of the input.</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetStart</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;t_; &#125;<br><br>  <span class="hljs-comment">// Update the stored value with the value in the buffer. This is not</span><br>  <span class="hljs-comment">// supported for this type.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span> </span>&#123;<br>    <span class="hljs-comment">// Not supported;</span><br>    <span class="hljs-comment">// 这个显然对未知类型很危险，不能瞎j8赋值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns the size of the input in bytes.</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(T); &#125;<br><br>  <span class="hljs-comment">// Returns true if the current type is used as an In or InOut parameter.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><br>  <span class="hljs-comment">// Returns this object&#x27;s type.</span><br>  <span class="hljs-comment">// 这里的处理强制了UINT32_TYPE</span><br>  <span class="hljs-function">ArgType <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(T) == <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>), <span class="hljs-string">&quot;specialization needed&quot;</span>);<br>    <span class="hljs-keyword">return</span> UINT32_TYPE;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">const</span> T&amp; t_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>再看几个具体的包装（实际上就是对<code>ArgType</code>的每种类型都包装一个），这些才是有实际实用意义的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This copy helper template specialization if for the void pointer</span><br><span class="hljs-comment">// case both 32 and 64 bit.</span><br><span class="hljs-comment">// 这个是T为void*的情景，实际上没做什么实际内容</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyHelper</span>&lt;<span class="hljs-type">void</span>*&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CopyHelper</span>(<span class="hljs-type">void</span>* t) : <span class="hljs-built_in">t_</span>(t) &#123;&#125;<br><br>  <span class="hljs-comment">// Returns the pointer to the start of the input.</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetStart</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;t_; &#125;<br><br>  <span class="hljs-comment">// Update the stored value with the value in the buffer. This is not</span><br>  <span class="hljs-comment">// supported for this type.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span> </span>&#123;<br>    <span class="hljs-comment">// Not supported;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns the size of the input in bytes.</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(t_); &#125;<br><br>  <span class="hljs-comment">// Returns true if the current type is used as an In or InOut parameter.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><br>  <span class="hljs-comment">// Returns this object&#x27;s type.</span><br>  <span class="hljs-function">ArgType <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> VOIDPTR_TYPE; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* t_;<br>&#125;;<br><br><span class="hljs-comment">// This copy helper template specialization catches the cases where the</span><br><span class="hljs-comment">// parameter is a pointer to a string.</span><br><span class="hljs-comment">// 这个是const宽字符指针，实际上是字符串</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyHelper</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CopyHelper</span>(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* t) : <span class="hljs-built_in">t_</span>(t) &#123;&#125;<br><br>  <span class="hljs-comment">// Returns the pointer to the start of the string.</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetStart</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> t_; &#125;<br><br>  <span class="hljs-comment">// Update the stored value with the value in the buffer. This is not</span><br>  <span class="hljs-comment">// supported for this type.</span><br>  <span class="hljs-comment">// 都const了，改个毛线</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span> </span>&#123;<br>    <span class="hljs-comment">// Not supported;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns the size of the string in bytes. We define a nullptr string to</span><br>  <span class="hljs-comment">// be of zero length.</span><br>  <span class="hljs-comment">// 获取尺寸，这里并不是类型的尺寸，而是宽字符串的整体大小</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    __try &#123;<br>      <span class="hljs-keyword">return</span> (!t_) ? <span class="hljs-number">0</span><br>                   : <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-built_in">StringLength</span>(t_) * <span class="hljs-built_in">sizeof</span>(t_[<span class="hljs-number">0</span>]));<br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>      <span class="hljs-keyword">return</span> UINT32_MAX;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns true if the current type is used as an In or InOut parameter.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><br>  <span class="hljs-function">ArgType <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> WCHAR_TYPE; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// We provide our not very optimized version of wcslen(), since we don&#x27;t</span><br>  <span class="hljs-comment">// want to risk having the linker use the version in the CRT since the CRT</span><br>  <span class="hljs-comment">// might not be present when we do an early IPC call.</span><br>  <span class="hljs-comment">// 起始就是简单的count，\0结束，包含了\0</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> __cdecl <span class="hljs-title">StringLength</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* wcs)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* eos = wcs;<br>    <span class="hljs-keyword">while</span> (*eos++)<br>      ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(eos - wcs - <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* t_;<br>&#125;;<br><br><span class="hljs-comment">// Specialization for non-const strings. We just reuse the implementation of the</span><br><span class="hljs-comment">// const string specialization.</span><br><span class="hljs-comment">// 这个是non-const字符串</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyHelper</span>&lt;<span class="hljs-type">wchar_t</span>*&gt; : <span class="hljs-keyword">public</span> CopyHelper&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">typedef</span> CopyHelper&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt; Base;<span class="hljs-comment">//定义这货是怕编译器混淆，用了自生成类模板类吗？</span><br>  <span class="hljs-built_in">CopyHelper</span>(<span class="hljs-type">wchar_t</span>* t) : <span class="hljs-built_in">Base</span>(t) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetStart</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">GetStart</span>(); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">Update</span>(buffer); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">GetSize</span>(); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">IsInOut</span>(); &#125;<br><br>  <span class="hljs-function">ArgType <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">GetType</span>(); &#125;<br>&#125;;<br><br><span class="hljs-comment">// Specialization for wchar_t arrays strings. We just reuse the implementation</span><br><span class="hljs-comment">// of the const string specialization.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">size_t</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyHelper</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>[n]&gt; : <span class="hljs-keyword">public</span> CopyHelper&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> array[n];<br>  <span class="hljs-keyword">typedef</span> CopyHelper&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt; Base;<br>  <span class="hljs-built_in">CopyHelper</span>(array t) : <span class="hljs-built_in">Base</span>(t) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetStart</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">GetStart</span>(); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">Update</span>(buffer); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">GetSize</span>(); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">IsInOut</span>(); &#125;<br><br>  <span class="hljs-function">ArgType <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">GetType</span>(); &#125;<br>&#125;;<br><br><span class="hljs-comment">// This copy helper template specialization catches the cases where the</span><br><span class="hljs-comment">// parameter is a an input/output buffer.</span><br><span class="hljs-comment">// 输入输出型参数比较特殊，用InOutCountedBuffer结构，这个结构一会儿再分析</span><br><span class="hljs-comment">// 对应ArgType为INOUTPTR_TYPE</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyHelper</span>&lt;InOutCountedBuffer&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CopyHelper</span>(<span class="hljs-type">const</span> InOutCountedBuffer t) : <span class="hljs-built_in">t_</span>(t) &#123;&#125;<br><br>  <span class="hljs-comment">// Returns the pointer to the start of the string.</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetStart</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> t_.<span class="hljs-built_in">Buffer</span>(); &#125;<br><br>  <span class="hljs-comment">// Updates the buffer with the value from the new buffer in parameter.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span> </span>&#123;<br>    <span class="hljs-comment">// We are touching user memory, this has to be done from inside a try</span><br>    <span class="hljs-comment">// except.</span><br>    __try &#123;<br>      <span class="hljs-built_in">memcpy</span>(t_.<span class="hljs-built_in">Buffer</span>(), buffer, t_.<span class="hljs-built_in">Size</span>());<br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns the size of the string in bytes. We define a nullptr string to</span><br>  <span class="hljs-comment">// be of zero length.</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> t_.<span class="hljs-built_in">Size</span>(); &#125;<br><br>  <span class="hljs-comment">// Returns true if the current type is used as an In or InOut parameter.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><br>  <span class="hljs-function">ArgType <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> INOUTPTR_TYPE; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">const</span> InOutCountedBuffer t_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>展开<code>InOutCountedBuffer</code>，实际上是一个对指针的包装类，描述了指针和指向buffer的尺寸：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Generic encapsulation class containing a pointer to a buffer and the</span><br><span class="hljs-comment">// size of the buffer. It is used by the IPC to be able to pass in/out</span><br><span class="hljs-comment">// parameters.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InOutCountedBuffer</span> : <span class="hljs-keyword">public</span> CountedBuffer &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">InOutCountedBuffer</span>(<span class="hljs-type">void</span>* buffer, <span class="hljs-type">uint32_t</span> size)<br>      : <span class="hljs-built_in">CountedBuffer</span>(buffer, size) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// Encapsulates a pointer to a buffer and the size of the buffer.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CountedBuffer</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CountedBuffer</span>(<span class="hljs-type">void</span>* buffer, <span class="hljs-type">uint32_t</span> size) : <span class="hljs-built_in">size_</span>(size), <span class="hljs-built_in">buffer_</span>(buffer) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">Size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size_; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">Buffer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> buffer_; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">uint32_t</span> size_;<br>  <span class="hljs-type">void</span>* buffer_;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="server">Server</h2><p>再看看server的描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is the IPC server interface for CrossCall: The  IPC for the Sandbox</span><br><span class="hljs-comment">// On the server, CrossCall needs two things:</span><br><span class="hljs-comment">// 1) threads: Or better said, someone to provide them, that is what the</span><br><span class="hljs-comment">//             ThreadProvider interface is defined for. These thread(s) are</span><br><span class="hljs-comment">//             the ones that will actually execute the  IPC data retrieval.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 2) a dispatcher: This interface represents the way to route and process</span><br><span class="hljs-comment">//                  an  IPC call given the  IPC tag.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The other class included here CrossCallParamsEx is the server side version</span><br><span class="hljs-comment">// of the CrossCallParams class of /sandbox/crosscall_params.h The difference</span><br><span class="hljs-comment">// is that the sever version is paranoid about the correctness of the IPC</span><br><span class="hljs-comment">// message and will do all sorts of verifications.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A general diagram of the interaction is as follows:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//                                 ------------</span><br><span class="hljs-comment">//                                 |          |</span><br><span class="hljs-comment">//  ThreadProvider &lt;--(1)Register--|  IPC     |</span><br><span class="hljs-comment">//      |                          | Implemen |</span><br><span class="hljs-comment">//      |                          | -tation  |</span><br><span class="hljs-comment">//     (2)                         |          |  OnMessage</span><br><span class="hljs-comment">//     IPC fired --callback ------&gt;|          |--(3)---&gt; Dispatcher</span><br><span class="hljs-comment">//                                 |          |</span><br><span class="hljs-comment">//                                 ------------</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  The  IPC implementation sits as a middleman between the handling of the</span><br><span class="hljs-comment">//  specifics of scheduling a thread to service the  IPC and the multiple</span><br><span class="hljs-comment">//  entities that can potentially serve each particular IPC.</span><br></code></pre></td></tr></table></figure><p>大致梳理一下：</p><ol type="1"><li>IPC的server端需要完成两件事：<ol type="1"><li>需要一个provide IPC调用的线程池，provider每次收到IPCcall就assign到一个thread来处理</li><li>一个分发器：基于IPC tag来引导、处理每一种IPC call</li></ol></li><li>图示已经描摹出了整个状态机，看起来Server借助了两个外部组件：”线程池供给者ThreadProvider“+"消息处理器Dispatcher"</li></ol><p>说白了就是每来一个消息就用一个线程来处理，实现并发性，而消息根据tag在Dispatcher的OnMessage中分门别类，找到它自己的回调处理Handler。</p><h3 id="threadprovider">ThreadProvider</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ThreadProvider models a thread factory. The idea is to decouple thread</span><br><span class="hljs-comment">// creation and lifetime from the inner guts of the IPC. The contract is</span><br><span class="hljs-comment">// simple:</span><br><span class="hljs-comment">//   - the IPC implementation calls RegisterWait with a waitable object that</span><br><span class="hljs-comment">//     becomes signaled when an IPC arrives and needs to be serviced.</span><br><span class="hljs-comment">//   - when the waitable object becomes signaled, the thread provider conjures</span><br><span class="hljs-comment">//     a thread that calls the callback (CrossCallIPCCallback) function</span><br><span class="hljs-comment">//   - the callback function tries its best not to block and return quickly</span><br><span class="hljs-comment">//     and should not assume that the next callback will use the same thread</span><br><span class="hljs-comment">//   - when the callback returns the ThreadProvider owns again the thread</span><br><span class="hljs-comment">//     and can destroy it or keep it around.</span><br><span class="hljs-comment">// simple已经描述的很清楚了，IPC实现体会利用RegisterWait来注册一个可等待对象，一旦IPC</span><br><span class="hljs-comment">// 请求到来，那么该对象signaled，ThreadProvider这个线程工厂会生成一个线程来调用CrossCallIPCCallback</span><br><span class="hljs-comment">// CrossCallIPCCallback很快回来，ThreadProvider再次控制该线程，可以销毁也可以保持</span><br><span class="hljs-comment">// 前后两次执行callback的不一定是同一个线程</span><br><span class="hljs-comment">// 那么CrossCallIPCCallback是个什么样的callback呢？实际上是个函数指针类型定义：</span><br><br><span class="hljs-comment">// This function signature is required as the callback when an  IPC call fires.</span><br><span class="hljs-comment">// context: a user-defined pointer that was set using  ThreadProvider</span><br><span class="hljs-comment">// reason: 0 if the callback was fired because of a timeout.</span><br><span class="hljs-comment">//         1 if the callback was fired because of an event.</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(__stdcall* CrossCallIPCCallback)</span><span class="hljs-params">(<span class="hljs-type">void</span>* context,</span></span><br><span class="hljs-params"><span class="hljs-function">                                              <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> reason)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadProvider</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Registers a waitable object with the thread provider.</span><br>  <span class="hljs-comment">// client: A number to associate with all the RegisterWait calls, typically</span><br>  <span class="hljs-comment">//         this is the address of the caller object. This parameter cannot</span><br>  <span class="hljs-comment">//         be zero.</span><br>  <span class="hljs-comment">// waitable_object : a kernel object that can be waited on</span><br>  <span class="hljs-comment">// callback: a function pointer which is the function that will be called</span><br>  <span class="hljs-comment">//           when the waitable object fires</span><br>  <span class="hljs-comment">// context: a user-provider pointer that is passed back to the callback</span><br>  <span class="hljs-comment">//          when its called</span><br>  <span class="hljs-comment">// client作为标志把waitable_object与callback绑定，当waitable_object signaled（IPC arrive），调用callback</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">RegisterWait</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* client,</span></span><br><span class="hljs-params"><span class="hljs-function">                            HANDLE waitable_object,</span></span><br><span class="hljs-params"><span class="hljs-function">                            CrossCallIPCCallback callback,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">void</span>* context)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Removes all the registrations done with the same cookie parameter.</span><br>  <span class="hljs-comment">// This frees internal thread pool resources.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">UnRegisterWaits</span><span class="hljs-params">(<span class="hljs-type">void</span>* cookie)</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ThreadProvider</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但这只是个抽象基类，实际上windows应该是靠<code>Win2kThreadPool</code>这个内存池类来操作的。而线程池本身是个非常复杂的东西，本身也不属于sandbox的范畴，日后有空的时候再分析一下。</p><h3 id="crosscallparamsex"><code>CrossCallParamsEx</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Models the server-side of the original input parameters.</span><br><span class="hljs-comment">// Provides IPC buffer validation and it is capable of reading the parameters</span><br><span class="hljs-comment">// out of the IPC buffer.</span><br><span class="hljs-comment">// CrossCallParams的另一个子类，用在server</span><br><span class="hljs-comment">// 模拟server端原始输入参数的处理，提供了IPC buffer的检查并copy到另一个对象结构</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossCallParamsEx</span> : <span class="hljs-keyword">public</span> CrossCallParams &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Factory constructor. Pass an IPCbuffer (and buffer size) that contains a</span><br>  <span class="hljs-comment">// pending IPCcall. This constructor will:</span><br>  <span class="hljs-comment">// 1) validate the IPC buffer. returns nullptr is the IPCbuffer is malformed.</span><br>  <span class="hljs-comment">// 2) make a copy of the IPCbuffer (parameter capture)</span><br>  <span class="hljs-comment">// 颇为关键的static工厂方法，验证IPC buffer并拷贝参数</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> CrossCallParamsEx* <span class="hljs-title">CreateFromBuffer</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer_base,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">uint32_t</span> buffer_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">uint32_t</span>* output_size)</span></span>;<br><br>  <span class="hljs-comment">// Provides IPCinput parameter raw access:</span><br>  <span class="hljs-comment">// index : the parameter to read; 0 is the first parameter</span><br>  <span class="hljs-comment">// returns nullptr if the parameter is non-existent. If it exists it also</span><br>  <span class="hljs-comment">// returns the size in *size</span><br>  <span class="hljs-comment">// IPCinput参数的各种形态原生访问方法</span><br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">GetRawParameter</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index, <span class="hljs-type">uint32_t</span>* size, ArgType* type)</span></span>;<br><br>  <span class="hljs-comment">// Gets a parameter that is four bytes in size.</span><br>  <span class="hljs-comment">// Returns false if the parameter does not exist or is not 32 bits wide.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetParameter32</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index, <span class="hljs-type">uint32_t</span>* param)</span></span>;<br><br>  <span class="hljs-comment">// Gets a parameter that is void pointer in size.</span><br>  <span class="hljs-comment">// Returns false if the parameter does not exist or is not void pointer sized.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetParameterVoidPtr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index, <span class="hljs-type">void</span>** param)</span></span>;<br><br>  <span class="hljs-comment">// Gets a parameter that is a string. Returns false if the parameter does not</span><br>  <span class="hljs-comment">// exist.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetParameterStr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index, base::string16* string)</span></span>;<br><br>  <span class="hljs-comment">// Gets a parameter that is an in/out buffer. Returns false is the parameter</span><br>  <span class="hljs-comment">// does not exist or if the size of the actual parameter is not equal to the</span><br>  <span class="hljs-comment">// expected size.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetParameterPtr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index, <span class="hljs-type">uint32_t</span> expected_size, <span class="hljs-type">void</span>** pointer)</span></span>;<br><br>  <span class="hljs-comment">// Frees the memory associated with the IPC parameters.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* raw_memory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Only the factory method CreateFromBuffer can construct these objects.</span><br>  <span class="hljs-built_in">CrossCallParamsEx</span>();<span class="hljs-comment">//CrossCallParamsEx对象必须从static工厂方法中make</span><br><br>  ParamInfo param_info_[<span class="hljs-number">1</span>];<span class="hljs-comment">//ParamInfo是通用的(type,offset,size)三元组，熟悉的味道</span><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(CrossCallParamsEx);<span class="hljs-comment">//用不到就禁了，防呆</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这个类就是解包client IPC请求的，工厂方法相当关键：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This function uses a SEH try block so cannot use C++ objects that</span><br><span class="hljs-comment">// have destructors or else you get Compiler Error C2712. So no DCHECKs</span><br><span class="hljs-comment">// inside this function.</span><br><span class="hljs-function">CrossCallParamsEx* <span class="hljs-title">CrossCallParamsEx::CreateFromBuffer</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer_base,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                       <span class="hljs-type">uint32_t</span> buffer_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                       <span class="hljs-type">uint32_t</span>* output_size)</span> </span>&#123;<br>  <span class="hljs-comment">// IMPORTANT: Everything inside buffer_base and derived from it such</span><br>  <span class="hljs-comment">// as param_count and declared_size is untrusted.</span><br>  <span class="hljs-comment">// 心智检查</span><br>  <span class="hljs-keyword">if</span> (!buffer_base)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (buffer_size &lt; <span class="hljs-built_in">sizeof</span>(CrossCallParams))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (buffer_size &gt; kMaxBufferSize)<span class="hljs-comment">//就是1024，IPC Channel实现体目前的硬编码最大尺寸</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-type">char</span>* backing_mem = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-type">uint32_t</span> param_count = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">uint32_t</span> declared_size;<br>  <span class="hljs-type">uint32_t</span> min_declared_size;<br>  CrossCallParamsEx* copied_params = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-comment">// Touching the untrusted buffer is done under a SEH try block. This</span><br>  <span class="hljs-comment">// will catch memory access violations so we don&#x27;t crash.</span><br>  __try &#123;<br>    CrossCallParams* call_params =<br>        <span class="hljs-built_in">reinterpret_cast</span>&lt;CrossCallParams*&gt;(buffer_base);<br>    <span class="hljs-comment">//传入的应该是client的ActualCallParams，call_params父类指针指向子类对象</span><br><br>    <span class="hljs-comment">// 过安检，CrossCallParams+((param_count + 1) * sizeof(ParamInfo))是除了真实参数数据以外至少需要的空间</span><br>    <span class="hljs-comment">// Check against the minimum size given the number of stated params</span><br>    <span class="hljs-comment">// if too small we bail out.</span><br>    param_count = call_params-&gt;<span class="hljs-built_in">GetParamsCount</span>();<br>    min_declared_size =<br>        <span class="hljs-built_in">sizeof</span>(CrossCallParams) + ((param_count + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(ParamInfo));<br><br>    <span class="hljs-comment">// Initial check for the buffer being big enough to determine the actual</span><br>    <span class="hljs-comment">// buffer size.</span><br>    <span class="hljs-comment">// 如果buffer_size比min_declared_size还小，说明这段数据是有问题的，显然不能继续解析了</span><br>    <span class="hljs-keyword">if</span> (buffer_size &lt; min_declared_size)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// Retrieve the declared size which if it fails returns 0.</span><br>    <span class="hljs-comment">// 不管参数个数有几个，参数总尺寸是可以计算的</span><br>    <span class="hljs-comment">// 参数总尺寸的计算其实就是ParamInfo[]的parser，一会儿展开看</span><br>    declared_size = <span class="hljs-built_in">GetActualBufferSize</span>(param_count, buffer_base);<br><br>    <span class="hljs-comment">// 判断一下buffer_size，buffer_size理应&gt;=declared_size而declared_size理应&gt;=min_declared_size</span><br>    <span class="hljs-comment">// 这个函数很简单</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsSizeWithinRange</span>(buffer_size, min_declared_size, declared_size))<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// 这里就进行解包了，移花接木给copied_params，CrossCallParamsEx对象是在这里new的</span><br>    <span class="hljs-comment">// Now we copy the actual amount of the message.</span><br>    *output_size = declared_size;<br>    backing_mem = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[declared_size];<br>    <span class="hljs-comment">// 依然是这种间接new操作，因为buffer尺寸是已知的，但CrossCallParamsEx并没有包含所有的</span><br>    <span class="hljs-comment">// buffer数据（真实数据由ParamInfo定位，附加在类的正后方），所以要用间接的方式把这段</span><br>    <span class="hljs-comment">// 内存空间看成CrossCallParamsEx + 额外的真实参数数据</span><br>    copied_params = <span class="hljs-built_in">reinterpret_cast</span>&lt;CrossCallParamsEx*&gt;(backing_mem);<br>    <span class="hljs-comment">// 这个memcpy实际上非常讲究，把ActualCallParams + 额外真实参数数据直接copy到了另外</span><br>    <span class="hljs-comment">// 一个对象CrossCallParamsEx+额外真实参数数据</span><br>    <span class="hljs-comment">// 这意味着CrossCallParamsEx和ActualCallParams有着相同的内存布局，事实上也确实如此</span><br>    <span class="hljs-comment">// 都是CrossCallParams基类+ParamInfo[] flexible数据的结构</span><br>    <span class="hljs-comment">// 在server和client各封装这样一个成员变量布局相同的类，主要是因为布局理应相同，但</span><br>    <span class="hljs-comment">// 要用到的接口函数是互逆的</span><br>    <span class="hljs-built_in">memcpy</span>(backing_mem, call_params, declared_size);<br><br>    <span class="hljs-comment">// Avoid compiler optimizations across this point. Any value stored in</span><br>    <span class="hljs-comment">// memory should be stored for real, and values previously read from memory</span><br>    <span class="hljs-comment">// should be actually read.</span><br>    <span class="hljs-comment">// 内存屏障，防止此处的编译优化，所有内存的值必须用存储的真实值，此前从memory中读出的高速缓存不能在寄存器中直接复用</span><br>    base::subtle::<span class="hljs-built_in">MemoryBarrier</span>();<br><br>    <span class="hljs-comment">// 内存屏障是为这一句准备的我懂，但我不明白为啥要重算</span><br>    <span class="hljs-comment">// 有大神了解的话还请解惑</span><br>    min_declared_size =<br>        <span class="hljs-built_in">sizeof</span>(CrossCallParams) + ((param_count + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(ParamInfo));<br><br>    <span class="hljs-comment">// Check that the copied buffer is still valid.</span><br>    <span class="hljs-comment">// 可以看出server对input param的检查近乎严苛</span><br>    <span class="hljs-comment">// 还要检查copy过去后buffer是否符合预期</span><br>    <span class="hljs-keyword">if</span> (copied_params-&gt;<span class="hljs-built_in">GetParamsCount</span>() != param_count ||<br>        <span class="hljs-built_in">GetActualBufferSize</span>(param_count, backing_mem) != declared_size ||<br>        !<span class="hljs-built_in">IsSizeWithinRange</span>(buffer_size, min_declared_size, declared_size)) &#123;<br>      <span class="hljs-keyword">delete</span>[] backing_mem;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>  &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>    <span class="hljs-comment">// In case of a windows exception we know it occurred while touching the</span><br>    <span class="hljs-comment">// untrusted buffer so we bail out as is.</span><br>    <span class="hljs-keyword">delete</span>[] backing_mem;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125; <span class="hljs-comment">// 内存的访问很可能因畸形或恶意构造IPCInput出现access violations，这里套上了try块，windows对应SEH</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* last_byte = &amp;backing_mem[declared_size];<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* first_byte = &amp;backing_mem[min_declared_size];<br><br>  <span class="hljs-comment">// last_byte和first_byte之间就是真实参数数据区间了</span><br>  <span class="hljs-comment">// Verify here that all and each parameters make sense. This is done in the</span><br>  <span class="hljs-comment">// local copy.</span><br>  <span class="hljs-comment">// 检查每个parameter都有意义，可以说是相当的严格</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> ix = <span class="hljs-number">0</span>; ix != param_count; ++ix) &#123;<br>    <span class="hljs-type">uint32_t</span> size = <span class="hljs-number">0</span>;<br>    ArgType type;<br>    <span class="hljs-type">char</span>* address = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<br>        <span class="hljs-comment">//一会儿展开看这货</span><br>        copied_params-&gt;<span class="hljs-built_in">GetRawParameter</span>(ix, &amp;size, &amp;type));<br>    <span class="hljs-keyword">if</span> ((!address) ||                                     <span class="hljs-comment">// No null params.</span><br>        (INVALID_TYPE &gt;= type) || (LAST_TYPE &lt;= type) ||  <span class="hljs-comment">// Unknown type.</span><br>        (address &lt; backing_mem) ||         <span class="hljs-comment">// Start cannot point before buffer.</span><br>        (address &lt; first_byte) ||          <span class="hljs-comment">// Start cannot point too low.</span><br>        (address &gt; last_byte) ||           <span class="hljs-comment">// Start cannot point past buffer.</span><br>        ((address + size) &lt; address) ||    <span class="hljs-comment">// Invalid size.</span><br>        ((address + size) &gt; last_byte)) &#123;  <span class="hljs-comment">// End cannot point past buffer.</span><br>      <span class="hljs-comment">// Malformed.</span><br>      <span class="hljs-keyword">delete</span>[] backing_mem;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// The parameter buffer looks good.</span><br>  <span class="hljs-keyword">return</span> copied_params;<br>&#125;<br></code></pre></td></tr></table></figure><p>工厂只是做了移花接木的操作。</p><p>看看几个关键的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Returns the actual size for the parameters in an IPC buffer. Returns</span><br><span class="hljs-comment">// zero if the |param_count| is zero or too big.</span><br><span class="hljs-comment">// 又见呆逼操作，不定参数个数的匹配处理在这里完成，不管是几个参数，返回的就是参数总尺寸</span><br><span class="hljs-comment">// 这里又变成1-9个了，怕是client端少写了两个，然后一直用不到？</span><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetActualBufferSize</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> param_count, <span class="hljs-type">void</span>* buffer_base)</span> </span>&#123;<br>  <span class="hljs-comment">// The template types are used to calculate the maximum expected size.</span><br>  <span class="hljs-comment">// kMaxBufferSize是硬编码的sandbox::kIPCChannelSize，也就是1024</span><br>  <span class="hljs-comment">// 把9种模板类都做一下typedef</span><br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">1</span>, kMaxBufferSize&gt; ActualCP1;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">2</span>, kMaxBufferSize&gt; ActualCP2;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">3</span>, kMaxBufferSize&gt; ActualCP3;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">4</span>, kMaxBufferSize&gt; ActualCP4;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">5</span>, kMaxBufferSize&gt; ActualCP5;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">6</span>, kMaxBufferSize&gt; ActualCP6;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">7</span>, kMaxBufferSize&gt; ActualCP7;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">8</span>, kMaxBufferSize&gt; ActualCP8;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">9</span>, kMaxBufferSize&gt; ActualCP9;<br><br>  <span class="hljs-comment">// Retrieve the actual size and the maximum size of the params buffer.</span><br>  <span class="hljs-comment">// 根据参数个数，可以判断出是哪一个模板类</span><br>  <span class="hljs-keyword">switch</span> (param_count) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP1*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP2*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP3*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP4*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP5*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP6*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP7*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP8*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP9*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>GetSize</code>实际上就是client端<code>ActualCallParams&lt;&gt;</code>的接口，我们再次看一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> param_info_[NUMBER_PARAMS].offset_; &#125;<br><span class="hljs-comment">// 所以想要计算尺寸，只需要获取最后一个ParamInfo的offset即可，这个就是最后一个end struct</span><br></code></pre></td></tr></table></figure><p>再看简单的值范围检查：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Verifies that the declared sizes of an IPC buffer are within range.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsSizeWithinRange</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> buffer_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">uint32_t</span> min_declared_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">uint32_t</span> declared_size)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> ((buffer_size &lt; min_declared_size) ||<br>      (<span class="hljs-built_in">sizeof</span>(CrossCallParamsEx) &gt; min_declared_size)) &#123;<br>    <span class="hljs-comment">// Minimal computed size bigger than existing buffer or param_count</span><br>    <span class="hljs-comment">// integer overflow.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ((declared_size &gt; buffer_size) || (declared_size &lt; min_declared_size)) &#123;<br>    <span class="hljs-comment">// Declared size is bigger than buffer or smaller than computed size</span><br>    <span class="hljs-comment">// or param_count is equal to 0 or bigger than 9.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后一个关键的<code>GetRawParameter</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Accessors to the parameters in the raw buffer.</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">CrossCallParamsEx::GetRawParameter</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         <span class="hljs-type">uint32_t</span>* size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         ArgType* type)</span> </span>&#123;<br>  <span class="hljs-comment">// 不能越界</span><br>  <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-built_in">GetParamsCount</span>())<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// The size is always computed from the parameter minus the next</span><br>  <span class="hljs-comment">// parameter, this works because the message has an extra parameter slot</span><br>  <span class="hljs-comment">// 拿到该参数的尺寸和类型</span><br>  *size = param_info_[index].size_;<br>  *type = param_info_[index].type_;<br><br>  <span class="hljs-comment">// 返回该参数的真实数据所在的位置</span><br>  <span class="hljs-keyword">return</span> param_info_[index].offset_ + <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>也是非常简单的函数。</p><h3 id="diapatcher"><code>Diapatcher</code></h3><p><code>CrossCallParamsEx</code>不过是个承载buffer的容器，真正的驱动者另有其人。在crosscall_server.h中可以找到<code>Dispatcher</code>类，根据头的注释可以知道它时IPC消息的操纵者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Models an entity that can process an IPC message or it can route to another</span><br><span class="hljs-comment">// one that could handle it. When an IPC arrives the IPC implementation will:</span><br><span class="hljs-comment">// 1) call OnMessageReady() with the tag of the pending IPC. If the dispatcher</span><br><span class="hljs-comment">//    returns nullptr it means that it cannot handle this IPC but if it returns</span><br><span class="hljs-comment">//    non-null, it must be the pointer to a dispatcher that can handle it.</span><br><span class="hljs-comment">// 2) When the  IPC finally obtains a valid Dispatcher the IPC</span><br><span class="hljs-comment">//    implementation creates a CrossCallParamsEx from the raw IPC buffer.</span><br><span class="hljs-comment">// 3) It calls the returned callback, with the IPC info and arguments.</span><br><span class="hljs-comment">// 所以IPC请求给到IPC实现体时，会先使用tag调用Dispatcher::OnMessageReady()。</span><br><span class="hljs-comment">// Dispatcher维护了一组callback，如果该IPC与其中某一个匹配的话，就表示该Dispatcher</span><br><span class="hljs-comment">// 可以处理该IPC调用</span><br><span class="hljs-comment">// 找到以后，IPC实现体会创建一个CrossCallParamsEx，从buffer拷贝数据</span><br><span class="hljs-comment">// 然后，以IPC info和args调用对应的callback</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dispatcher</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Called from the  IPC implementation to handle a specific IPC message.</span><br>  <span class="hljs-comment">// 又是这种笨拙的函数指针定义，根据参数个数的多少，定义callback多种形态</span><br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*CallbackGeneric)</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback0)</span><span class="hljs-params">(IPCInfo* ipc)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback1)</span><span class="hljs-params">(IPCInfo* ipc, <span class="hljs-type">void</span>* p1)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback2)</span><span class="hljs-params">(IPCInfo* ipc, <span class="hljs-type">void</span>* p1, <span class="hljs-type">void</span>* p2)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback3)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback4)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p4)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback5)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p4,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p5)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback6)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p4,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p5,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p6)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback7)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p4,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p5,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p6,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p7)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback8)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p4,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p5,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p6,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p7,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p8)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback9)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p4,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p5,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p6,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p7,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p8,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p9)</span></span>;<br><br>  <span class="hljs-comment">// Called from the  IPC implementation when an  IPC message is ready override</span><br>  <span class="hljs-comment">// on a derived class to handle a set of  IPC messages. Return nullptr if your</span><br>  <span class="hljs-comment">// subclass does not handle the message or return the pointer to the subclass</span><br>  <span class="hljs-comment">// that can handle it.</span><br>  <span class="hljs-comment">// IPC消息到来时，IPC实现体先调用这个MessageReady事件响应，看看是否有能力handle</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Dispatcher* <span class="hljs-title">OnMessageReady</span><span class="hljs-params">(IPCParams* ipc, CallbackGeneric* callback)</span></span>;<br><br>  <span class="hljs-comment">// Called when a target proces is created, to setup the interceptions related</span><br>  <span class="hljs-comment">// with the given service (IPC).</span><br>  <span class="hljs-comment">// 当target进程创建时，部署与给定服务（IPC）相关的interceptions</span><br>  <span class="hljs-comment">// 这个暂时不关心，涉及到它的上层组件Interception机制</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">SetupService</span><span class="hljs-params">(InterceptionManager* manager, <span class="hljs-type">int</span> service)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-built_in">Dispatcher</span>();<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Dispatcher</span>();<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// Structure that defines an IPC Call with all the parameters and the handler.</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IPCCall</span> &#123;<br>    IPCParams params;<br>    CallbackGeneric callback;<br>  &#125;;<br><br>  <span class="hljs-comment">// List of IPC Calls supported by the class.</span><br>  <span class="hljs-comment">// 一个Dispatcher所支持的IPC调用列表，这个结构在内部定义使用</span><br>  <span class="hljs-comment">// 封装了IPCParams和CallbackGeneric</span><br>  std::vector&lt;IPCCall&gt; ipc_calls_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>看看这几个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Represents the client process that initiated the IPC which boils down to the</span><br><span class="hljs-comment">// process handle and the job object handle that contains the client process.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ClientInfo</span> &#123;<br>  HANDLE process;<br>  DWORD process_id;<br>&#125;;<br><br><span class="hljs-comment">// All IPC-related information to be passed to the IPC handler.</span><br><span class="hljs-comment">// 一组callback的第一个参数，分组了tag，进程相关信息以及一个CrossCallReturn</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IPCInfo</span> &#123;<br>  <span class="hljs-type">int</span> ipc_tag;<br>  <span class="hljs-type">const</span> ClientInfo* client_info;<br>  CrossCallReturn return_info;<br>&#125;;<br><br><span class="hljs-comment">// This structure identifies IPC signatures.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IPCParams</span> &#123;<br>  <span class="hljs-type">int</span> ipc_tag;<br>  ArgType args[kMaxIpcParams];<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Matches</span><span class="hljs-params">(IPCParams* other)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">memcmp</span>(<span class="hljs-keyword">this</span>, other, <span class="hljs-built_in">sizeof</span>(*other));<span class="hljs-comment">//这个IPCParams的对比有点粗暴</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>看一下<code>OnMessageReady</code>的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Dispatcher* <span class="hljs-title">Dispatcher::OnMessageReady</span><span class="hljs-params">(IPCParams* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       CallbackGeneric* callback)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(callback);<br>  std::vector&lt;IPCCall&gt;::iterator it = ipc_calls_.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">for</span> (; it != ipc_calls_.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    <span class="hljs-comment">//IPCCall的第一个成员是IPCParams，所以可以直接调用IPCParams的Matches</span><br>    <span class="hljs-keyword">if</span> (it-&gt;params.<span class="hljs-built_in">Matches</span>(ipc)) &#123;<br>      *callback = it-&gt;callback;<span class="hljs-comment">//如果可以处理该ipc，就填充callback，这种callback是个CallbackGeneric类型</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，<code>Dispatcher</code>也只是个基类。<code>ipc_calls_</code>应该是派生的子类中某个setup方法中填充的，而父类的构造和析构都是空函数。除此之外，基类定义的不过是一组typedef，原材料都已准备好了，但依然找不到使用者。</p><p>显然<code>Dispatcher</code>也不过是架在<code>CrossCallParamsEx</code>之上的adapter。那么<code>Dispatcher</code>又是由谁来操纵呢？我们下回继续求索。</p>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-AlternateDesktop-analysis</title>
    <link href="/2018/05/19/chromium-sandbox-AlternateDesktop-analysis/"/>
    <url>/2018/05/19/chromium-sandbox-AlternateDesktop-analysis/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第六篇，主要分析了windows平台下，Chromium对alternatedesktop的创建与使用。阅读本篇前，最好阅读前四篇（本篇相对独立）。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-alternatedesktop-analysis">chromium-sandbox-AlternateDesktop-analysis</h1><p>policy三大组件最后一个——AlternateDesktop，也是最为简单的一个。关于target进程为什么要设置alternatedesktop，在前面其他篇章中已经不止一次的说过了。</p><p>依然是围绕policy和target对alternatedesktop的行为，对代码进行展开。</p><h2 id="spawntarget-related"><code>SpawnTarget</code> related</h2><p>除了job和token，alternate desktop也是在这里捏出来的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">base::string16 desktop = policy_base-&gt;<span class="hljs-built_in">GetAlternateDesktop</span>();<br> <span class="hljs-keyword">if</span> (!desktop.<span class="hljs-built_in">empty</span>()) &#123;<br>   startup_info.<span class="hljs-built_in">startup_info</span>()-&gt;lpDesktop =<br>       <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">wchar_t</span>*&gt;(desktop.<span class="hljs-built_in">c_str</span>());<br> &#125;<br></code></pre></td></tr></table></figure><p>通过policy的<code>GetAlternateDesktop</code>接口拿到宽字符形式的desktop，将其指派到startup_info的对应成员。</p><p>与job和token的Make方法不同，这里的名称是Get：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">base::string16 <span class="hljs-title">PolicyBase::GetAlternateDesktop</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-comment">// No alternate desktop or winstation. Return an empty string.</span><br>  <span class="hljs-comment">// 如果policy在SpawnTarget前就已经指明了既不使用alternate desktop也不</span><br>  <span class="hljs-comment">// 使用alternate winstation，就返回空串</span><br>  <span class="hljs-keyword">if</span> (!use_alternate_desktop_ &amp;&amp; !use_alternate_winstation_) &#123;<br>    <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 如果要使用的是alternate winstation</span><br>  <span class="hljs-keyword">if</span> (use_alternate_winstation_) &#123;<br>    <span class="hljs-comment">// The desktop and winstation should have been created by now.</span><br>    <span class="hljs-comment">// If we hit this scenario, it means that the user ignored the failure</span><br>    <span class="hljs-comment">// during SetAlternateDesktop, so we ignore it here too.</span><br>    <span class="hljs-comment">// 理论上走到这里之前，desktop和winstation都已经创建完毕了</span><br>    <span class="hljs-comment">// 所以如果走到这里的话，就意味着用户已经忽略了失败</span><br>    <span class="hljs-keyword">if</span> (!alternate_desktop_handle_ || !alternate_winstation_handle_) &#123;<br>      <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>();<br>    &#125;<br>    <span class="hljs-comment">// 利用winstation和desktop的handle来调用关键Call</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetFullDesktopName</span>(alternate_winstation_handle_,<br>                              alternate_desktop_handle_);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 这就意味着不适用winstation，只用desktop，但还需要对</span><br>    <span class="hljs-comment">// alternate_desktop_local_winstation_handle_检查一下</span><br>    <span class="hljs-comment">// 如果其无效则表示设置上出现了差错</span><br>    <span class="hljs-keyword">if</span> (!alternate_desktop_local_winstation_handle_) &#123;<br>      <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>();<br>    &#125;<br>    <span class="hljs-comment">// 关键Call，此时winstation句柄是null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetFullDesktopName</span>(<span class="hljs-literal">nullptr</span>,<br>                              alternate_desktop_local_winstation_handle_);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>展开关键Call看一看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">base::string16 <span class="hljs-title">GetFullDesktopName</span><span class="hljs-params">(HWINSTA winsta, HDESK desktop)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!desktop) &#123;<span class="hljs-comment">// desktop是不可能没有的，这辈子不可能没有的</span><br>    <span class="hljs-built_in">NOTREACHED</span>();<br>    <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>();<br>  &#125;<br><br>  base::string16 name;<br>  <span class="hljs-comment">// 如果使用winsta，则返回winsta做参数调用返回的name</span><br>  <span class="hljs-keyword">if</span> (winsta) &#123;<br>    name = <span class="hljs-built_in">GetWindowObjectName</span>(winsta);<br>    name += <span class="hljs-string">L&#x27;\\&#x27;</span>;<span class="hljs-comment">//后面跟了个反斜杠</span><br>  &#125;<br><br>  name += <span class="hljs-built_in">GetWindowObjectName</span>(desktop);<span class="hljs-comment">//使用desktop做参数</span><br>  <span class="hljs-keyword">return</span> name;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续call in：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">base::string16 <span class="hljs-title">GetWindowObjectName</span><span class="hljs-params">(HANDLE handle)</span> </span>&#123;<br>  <span class="hljs-comment">// Get the size of the name.</span><br>  <span class="hljs-comment">// 又是经典的二次调用，首次调用获取对象名称的尺寸</span><br>  DWORD size = <span class="hljs-number">0</span>;<br>  ::<span class="hljs-built_in">GetUserObjectInformation</span>(handle, UOI_NAME, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, &amp;size);<br><br>  <span class="hljs-keyword">if</span> (!size) &#123;<br>    <span class="hljs-built_in">NOTREACHED</span>();<br>    <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// Create the buffer that will hold the name.</span><br>  <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">wchar_t</span>[]&gt; <span class="hljs-title">name_buffer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">wchar_t</span>[size])</span></span>;<br><br>  <span class="hljs-comment">// 二次调用获取对象名称</span><br>  <span class="hljs-comment">// Query the name of the object.</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">GetUserObjectInformation</span>(handle, UOI_NAME, name_buffer.<span class="hljs-built_in">get</span>(), size,<br>                                  &amp;size)) &#123;<br>    <span class="hljs-built_in">NOTREACHED</span>();<br>    <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>(name_buffer.<span class="hljs-built_in">get</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里，再通过前面的注释提示，就明白了alternatedesktop在<code>SpawnTarget</code>之前就已经做出来了，这也难怪job和token是Make，而alternatedesktop却是Get。</p><h2 id="setalternatedesktop-related"><code>SetAlternateDesktop</code>related</h2><p>从AlternateDesktop的Create方法层层回溯，最终找到policy的<code>SetAlternateDesktop</code>方法。</p><p>sandbox本身没有new出policy对象来做这样一件事，这是使用sandbox的驱动者的事，但是sandbox有一些单元测试脚本，给出了调用的示范，其实此前在token中也看过了，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">TEST</span>(IntegrityLevelTest, TestLowILReal) &#123;<br>  <span class="hljs-function">TestRunner <span class="hljs-title">runner</span><span class="hljs-params">(JOB_LOCKDOWN, USER_INTERACTIVE, USER_INTERACTIVE)</span></span>;<br><br>  runner.<span class="hljs-built_in">SetTimeout</span>(INFINITE);<br><br>  runner.<span class="hljs-built_in">GetPolicy</span>()-&gt;<span class="hljs-built_in">SetAlternateDesktop</span>(<span class="hljs-literal">true</span>);<span class="hljs-comment">//true表示使用winstation</span><br>  runner.<span class="hljs-built_in">GetPolicy</span>()-&gt;<span class="hljs-built_in">SetIntegrityLevel</span>(INTEGRITY_LEVEL_LOW);<br><br>  <span class="hljs-built_in">EXPECT_EQ</span>(SBOX_TEST_SUCCEEDED, runner.<span class="hljs-built_in">RunTest</span>(<span class="hljs-string">L&quot;CheckIntegrityLevel&quot;</span>));<br><br>  runner.<span class="hljs-built_in">SetTestState</span>(BEFORE_REVERT);<br>  <span class="hljs-built_in">EXPECT_EQ</span>(SBOX_TEST_SUCCEEDED, runner.<span class="hljs-built_in">RunTest</span>(<span class="hljs-string">L&quot;CheckIntegrityLevel&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>于是，我们跟进<code>SetAlternateDesktop</code>看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetAlternateDesktop</span><span class="hljs-params">(<span class="hljs-type">bool</span> alternate_winstation)</span> </span>&#123;<br>  use_alternate_desktop_ = <span class="hljs-literal">true</span>;<span class="hljs-comment">//这个肯定得true啊，还信誓旦旦搞个成员变量</span><br>  use_alternate_winstation_ = alternate_winstation;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateAlternateDesktop</span>(alternate_winstation);<br>&#125;<br></code></pre></td></tr></table></figure><p>步入<code>CreateAlternateDesktop</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::CreateAlternateDesktop</span><span class="hljs-params">(<span class="hljs-type">bool</span> alternate_winstation)</span> </span>&#123;<br>  <span class="hljs-comment">// 需要winstation的分支</span><br>  <span class="hljs-keyword">if</span> (alternate_winstation) &#123;<br>    <span class="hljs-comment">// Check if it&#x27;s already created.</span><br>    <span class="hljs-comment">// 防止二次create</span><br>    <span class="hljs-keyword">if</span> (alternate_winstation_handle_ &amp;&amp; alternate_desktop_handle_)<br>      <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br><br>    <span class="hljs-built_in">DCHECK</span>(!alternate_winstation_handle_);<br>    <span class="hljs-comment">// Create the window station.</span><br>    <span class="hljs-comment">// 创建winstation的关键Call，传入的句柄作为OUT型参数</span><br>    ResultCode result = <span class="hljs-built_in">CreateAltWindowStation</span>(&amp;alternate_winstation_handle_);<br>    <span class="hljs-keyword">if</span> (SBOX_ALL_OK != result)<br>      <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-comment">// Verify that everything is fine.</span><br>    <span class="hljs-keyword">if</span> (!alternate_winstation_handle_ ||<br>        <span class="hljs-built_in">GetWindowObjectName</span>(alternate_winstation_handle_).<span class="hljs-built_in">empty</span>())<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_CREATE_DESKTOP;<br><br>    <span class="hljs-comment">// Create the destkop.</span><br>    <span class="hljs-comment">// 创建desktop的关键Call</span><br>    result = <span class="hljs-built_in">CreateAltDesktop</span>(alternate_winstation_handle_,<br>                              &amp;alternate_desktop_handle_);<br>    <span class="hljs-keyword">if</span> (SBOX_ALL_OK != result)<br>      <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-comment">// Verify that everything is fine.</span><br>    <span class="hljs-keyword">if</span> (!alternate_desktop_handle_ ||<br>        <span class="hljs-built_in">GetWindowObjectName</span>(alternate_desktop_handle_).<span class="hljs-built_in">empty</span>())<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_CREATE_DESKTOP;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Check if it already exists.</span><br>    <span class="hljs-comment">// 这个成员作为无winstation（意味着使用local winstation）的desktop句柄</span><br>    <span class="hljs-keyword">if</span> (alternate_desktop_local_winstation_handle_)<br>      <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br><br>    <span class="hljs-comment">// Create the destkop.</span><br>    <span class="hljs-comment">// 第一个参数是nullptr</span><br>    ResultCode result =<br>        <span class="hljs-built_in">CreateAltDesktop</span>(<span class="hljs-literal">nullptr</span>, &amp;alternate_desktop_local_winstation_handle_);<br>    <span class="hljs-keyword">if</span> (SBOX_ALL_OK != result)<br>      <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-comment">// Verify that everything is fine.</span><br>    <span class="hljs-keyword">if</span> (!alternate_desktop_local_winstation_handle_ ||<br>        <span class="hljs-built_in">GetWindowObjectName</span>(alternate_desktop_local_winstation_handle_).<span class="hljs-built_in">empty</span>())<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_CREATE_DESKTOP;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，就明白了这三个句柄成员的用途与联系了。</p><p>进入两个关键的Create中看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">CreateAltDesktop</span><span class="hljs-params">(HWINSTA winsta, HDESK* desktop)</span> </span>&#123;<br>  base::string16 desktop_name = <span class="hljs-string">L&quot;sbox_alternate_desktop_&quot;</span>;<br><br>  <span class="hljs-comment">// 没有create winstation就接local_winstation_</span><br>  <span class="hljs-keyword">if</span> (!winsta) &#123;<br>    desktop_name += <span class="hljs-string">L&quot;local_winstation_&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Append the current PID to the desktop name.</span><br>  <span class="hljs-comment">// 把当前进程的PID追加到desktop_name上</span><br>  <span class="hljs-type">wchar_t</span> buffer[<span class="hljs-number">16</span>];<br>  _snwprintf_s(buffer, <span class="hljs-built_in">sizeof</span>(buffer) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>), <span class="hljs-string">L&quot;0x%X&quot;</span>,<br>               ::<span class="hljs-built_in">GetCurrentProcessId</span>());<br>  desktop_name += buffer;<br><br>  <span class="hljs-comment">// 以当前线程ID获取当前的Desktop</span><br>  HDESK current_desktop = <span class="hljs-built_in">GetThreadDesktop</span>(<span class="hljs-built_in">GetCurrentThreadId</span>());<br><br>  <span class="hljs-keyword">if</span> (!current_desktop)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_GET_DESKTOP;<br><br>  <span class="hljs-comment">// Get the security attributes from the current desktop, we will use this as</span><br>  <span class="hljs-comment">// the base security attributes for the new desktop.</span><br>  <span class="hljs-comment">// 从当前desktop获取安全属性，用来给新的desktop当模板</span><br>  SECURITY_ATTRIBUTES attributes = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetSecurityAttributes</span>(current_desktop, &amp;attributes))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_QUERY_DESKTOP_SECURITY;<br><br>  <span class="hljs-comment">// Back up the current window station, in case we need to switch it.</span><br>  <span class="hljs-comment">// 获取当前的winstation</span><br>  HWINSTA current_winsta = ::<span class="hljs-built_in">GetProcessWindowStation</span>();<br><br>  <span class="hljs-comment">// 如果此前创建了winstation，就需要先切换到这个winstation上再创建desktop</span><br>  <span class="hljs-keyword">if</span> (winsta) &#123;<br>    <span class="hljs-comment">// We need to switch to the alternate window station before creating the</span><br>    <span class="hljs-comment">// desktop.</span><br>    <span class="hljs-comment">// 这个Windows API负责切换进程的winstation</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">SetProcessWindowStation</span>(winsta)) &#123;<br>      ::<span class="hljs-built_in">LocalFree</span>(attributes.lpSecurityDescriptor);<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_CREATE_DESKTOP;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Create the destkop.</span><br>  <span class="hljs-comment">// 此时就可以创建desktop了，名称已经填充好，标志也很明确</span><br>  <span class="hljs-comment">// 具体意义参考MSDN，和对象安全访问有关</span><br>  *desktop = ::<span class="hljs-built_in">CreateDesktop</span>(desktop_name.<span class="hljs-built_in">c_str</span>(), <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,<br>                             DESKTOP_CREATEWINDOW | DESKTOP_READOBJECTS |<br>                                 READ_CONTROL | WRITE_DAC | WRITE_OWNER,<br>                             &amp;attributes);<br>  ::<span class="hljs-built_in">LocalFree</span>(attributes.lpSecurityDescriptor);<br><br>  <span class="hljs-keyword">if</span> (winsta) &#123;<br>    <span class="hljs-comment">// Revert to the right window station.</span><br>    <span class="hljs-comment">// 切回来</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">SetProcessWindowStation</span>(current_winsta)) &#123;<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_FAILED_TO_SWITCH_BACK_WINSTATION;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (*desktop) &#123;<br>    <span class="hljs-comment">// Replace the DACL on the new Desktop with a reduced privilege version.</span><br>    <span class="hljs-comment">// We can soft fail on this for now, as it&#x27;s just an extra mitigation.</span><br>    <span class="hljs-comment">// 替换新desktop的DACL，做了降权处理</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> ACCESS_MASK kDesktopDenyMask =<br>        WRITE_DAC | WRITE_OWNER | DELETE | DESKTOP_CREATEMENU |<br>        DESKTOP_CREATEWINDOW | DESKTOP_HOOKCONTROL | DESKTOP_JOURNALPLAYBACK |<br>        DESKTOP_JOURNALRECORD | DESKTOP_SWITCHDESKTOP;<br>    <span class="hljs-comment">// 涉及到对象DACL的意义以及存储结构</span><br>    <span class="hljs-comment">// 可以自行参考《Windows Internals》的描述，阅读Acl.cc相关的代码</span><br>    <span class="hljs-comment">// 理解SID和DACL之间判定方法、顺序影响等</span><br>    <span class="hljs-built_in">AddKnownSidToObject</span>(*desktop, SE_WINDOW_OBJECT, <span class="hljs-built_in">Sid</span>(WinRestrictedCodeSid),<br>                        DENY_ACCESS, kDesktopDenyMask);<br>    <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_CREATE_DESKTOP;<br>&#125;<br></code></pre></td></tr></table></figure><p>winstation的创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">CreateAltWindowStation</span><span class="hljs-params">(HWINSTA* winsta)</span> </span>&#123;<br>  <span class="hljs-comment">// Get the security attributes from the current window station; we will</span><br>  <span class="hljs-comment">// use this as the base security attributes for the new window station.</span><br>  <span class="hljs-comment">// 老套路，先用当前的winstation的安全属性做模板</span><br>  HWINSTA current_winsta = ::<span class="hljs-built_in">GetProcessWindowStation</span>();<br>  <span class="hljs-keyword">if</span> (!current_winsta)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_GET_WINSTATION;<br><br>  SECURITY_ATTRIBUTES attributes = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-comment">// 不过是GetSecurityInfo WinAPI的封装</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetSecurityAttributes</span>(current_winsta, &amp;attributes))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_QUERY_WINSTATION_SECURITY;<br><br>  <span class="hljs-comment">// Create the window station using nullptr for the name to ask the os to</span><br>  <span class="hljs-comment">// generate it.</span><br>  <span class="hljs-comment">// 不指定名称，由OS生成，创建出一个winstation</span><br>  *winsta = ::<span class="hljs-built_in">CreateWindowStationW</span>(<br>      <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, GENERIC_READ | WINSTA_CREATEDESKTOP, &amp;attributes);<br>  <span class="hljs-keyword">if</span> (!*winsta &amp;&amp; ::<span class="hljs-built_in">GetLastError</span>() == ERROR_ACCESS_DENIED) &#123;<br>    *winsta = ::<span class="hljs-built_in">CreateWindowStationW</span>(<br>        <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, WINSTA_READATTRIBUTES | WINSTA_CREATEDESKTOP, &amp;attributes);<br>  &#125;<br>  <span class="hljs-built_in">LocalFree</span>(attributes.lpSecurityDescriptor);<br><br>  <span class="hljs-keyword">if</span> (*winsta)<br>    <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br><br>  <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_CREATE_WINSTATION;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-Tokens-analysis</title>
    <link href="/2018/05/19/chromium-sandbox-Tokens-analysis/"/>
    <url>/2018/05/19/chromium-sandbox-Tokens-analysis/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第六篇，主要分析了windows平台下，Chromium对Token的封装与使用。阅读本篇前，最好阅读前四篇（本篇相对独立）。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-tokens-analysis">chromium-sandbox-Tokens-analysis</h1><p>上一节分析了Job，本节分析policy三大组件之Token。Token实际上是Windows环境下的一种安全信令，它可以作为判定资源是否可以访问的凭证。Chrome的sandbox使用了token，以此来限制target进程的访问权限。</p><p>这一节我们从已知的几个疑惑点入手，层层深入。</p><p>由于Token牵扯到了Windows系统安全鉴权方面的知识，所以建议对token不了解的读者优先阅读《WindowsInternals》第六章。在搞清楚下面的问题之后，你就可以看这部分代码了。</p><ol type="1"><li>token的结构是什么样的、拥有者是谁、用来干什么？personationtoken是谁的，用来干什么？restricted token又是什么？</li><li>IntegrityLevel是什么，用来区分什么，SID相同时，低Level进程可以访问高Level对象吗？</li><li>privilege和account right是什么，有什么区别？</li><li>SID(Security Identifier)代表什么？</li><li>SD(SecurityDescriptor)是什么，DACL又是什么，进程用token访问对象时，如何利用SD裁决请求的？</li></ol><h2 id="brokerservicesbase-related"><code>BrokerServicesBase</code>related</h2><p>三个token最初是在<code>BrokerServicesBase::SpawnTarget</code>中make出来的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">base::win::ScopedHandle initial_token;<br>base::win::ScopedHandle lockdown_token;<br>base::win::ScopedHandle lowbox_token;<br>ResultCode result = SBOX_ALL_OK;<br><br>result =<br>  policy_base-&gt;<span class="hljs-built_in">MakeTokens</span>(&amp;initial_token, &amp;lockdown_token, &amp;lowbox_token);<br></code></pre></td></tr></table></figure><p>步入到<code>MakeToken</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::MakeTokens</span><span class="hljs-params">(base::win::ScopedHandle* initial,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  base::win::ScopedHandle* lockdown,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  base::win::ScopedHandle* lowbox)</span> </span>&#123;<br>  <span class="hljs-comment">// Create the &#x27;naked&#x27; token. This will be the permanent token associated</span><br>  <span class="hljs-comment">// with the process and therefore with any thread that is not impersonating.</span><br>  <span class="hljs-comment">// 这是个很关键的API，在进程token基础上，做出一个受限信令，使用的是默认DACL</span><br>  <span class="hljs-comment">// restricted token是Windows的一个重要概念</span><br>  DWORD result =<br>      <span class="hljs-built_in">CreateRestrictedToken</span>(lockdown_level_, integrity_level_, PRIMARY,<br>                            lockdown_default_dacl_, lockdown);<br>  <span class="hljs-keyword">if</span> (ERROR_SUCCESS != result)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>  <span class="hljs-comment">// If we&#x27;re launching on the alternate desktop we need to make sure the</span><br>  <span class="hljs-comment">// integrity label on the object is no higher than the sandboxed process&#x27;s</span><br>  <span class="hljs-comment">// integrity level. So, we lower the label on the desktop process if it&#x27;s</span><br>  <span class="hljs-comment">// not already low enough for our process.</span><br>  <span class="hljs-comment">// 这一部分是对alternative desktop IL的调整，它不应该高于target的IL，所以如果</span><br>  <span class="hljs-comment">// IL不够低，就要削成一样低</span><br>  <span class="hljs-keyword">if</span> (use_alternate_desktop_ &amp;&amp; integrity_level_ != INTEGRITY_LEVEL_LAST) &#123;<br>    <span class="hljs-comment">// Integrity label enum is reversed (higher level is a lower value).</span><br>    <span class="hljs-built_in">static_assert</span>(INTEGRITY_LEVEL_SYSTEM &lt; INTEGRITY_LEVEL_UNTRUSTED,<br>                  <span class="hljs-string">&quot;Integrity level ordering reversed.&quot;</span>);<br>    HDESK desktop_handle = <span class="hljs-literal">nullptr</span>;<br>    IntegrityLevel desktop_integrity_level_label;<br>    <span class="hljs-keyword">if</span> (use_alternate_winstation_) &#123;<br>      desktop_handle = alternate_desktop_handle_;<br>      desktop_integrity_level_label = alternate_desktop_integrity_level_label_;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      desktop_handle = alternate_desktop_local_winstation_handle_;<br>      desktop_integrity_level_label =<br>          alternate_desktop_local_winstation_integrity_level_label_;<br>    &#125;<br>    <span class="hljs-comment">// If the desktop_handle hasn&#x27;t been created for any reason, skip this.</span><br>    <span class="hljs-keyword">if</span> (desktop_handle &amp;&amp; desktop_integrity_level_label &lt; integrity_level_) &#123;<br>      result =<br>          <span class="hljs-built_in">SetObjectIntegrityLabel</span>(desktop_handle, SE_WINDOW_OBJECT, <span class="hljs-string">L&quot;&quot;</span>,<br>                                  <span class="hljs-built_in">GetIntegrityLevelString</span>(integrity_level_));<br>      <span class="hljs-keyword">if</span> (ERROR_SUCCESS != result)<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>      <span class="hljs-keyword">if</span> (use_alternate_winstation_) &#123;<br>        alternate_desktop_integrity_level_label_ = integrity_level_;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        alternate_desktop_local_winstation_integrity_level_label_ =<br>            integrity_level_;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// lowbox和另外两个不太一样，它的设定依赖于lowbox object</span><br>  <span class="hljs-comment">// 它是Win8以上才能用的技术，我目前亯܌将target交给了policy来管理(`AddTarget`)。</span><br><br>展开看看`AddTarget`:<br><br>​```<span class="hljs-function">cpp</span><br><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::AddTarget</span><span class="hljs-params">(TargetProcess* target)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (policy_)<br>    policy_maker_-&gt;<span class="hljs-built_in">Done</span>();<br><br>  <span class="hljs-comment">// mitigation实装</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ApplyProcessMitigationsToSuspendedProcess</span>(target-&gt;<span class="hljs-built_in">Process</span>(),<br>                                                 mitigations_)) &#123;<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_APPLY_ASLR_MITIGATIONS;<br>  &#125;<br><br>  <span class="hljs-comment">// 对target设置所有的Interceptions，Interception是一种对target进程的Hook机制</span><br>  <span class="hljs-comment">// 内容非常丰富，以后会分析</span><br>  ResultCode ret = <span class="hljs-built_in">SetupAllInterceptions</span>(target);<br><br>  <span class="hljs-keyword">if</span> (ret != SBOX_ALL_OK)<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// broker为target进程开辟一块空间，存储传过去的handles</span><br>  <span class="hljs-comment">// 还要把g_handles_to_close值传过去</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetupHandleCloser</span>(target))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_SETUP_HANDLE_CLOSER;<br><br>  DWORD win_error = ERROR_SUCCESS;<br>  <span class="hljs-comment">// Initialize the sandbox infrastructure for the target.</span><br>  <span class="hljs-comment">// TODO(wfh) do something with win_error code here.</span><br>  <span class="hljs-comment">// 这里面别有洞天，现在知道传过去的都是什么鬼了</span><br>  ret = target-&gt;<span class="hljs-built_in">Init</span>(dispatcher_.<span class="hljs-built_in">get</span>(), policy_, kIPCMemSize, kPolMemSize,<br>                     &amp;win_error);<br><br>  <span class="hljs-keyword">if</span> (ret != SBOX_ALL_OK)<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// 通过broker把delayed_integrity_level_传给target</span><br>  <span class="hljs-comment">// 这货在SpawnTarget前就由传入的policy参数对象设置好了</span><br>  <span class="hljs-comment">// 在TargetServicesBase::LowerToken中用于降权</span><br>  g_shared_delayed_integrity_level = delayed_integrity_level_;<br>  ret = target-&gt;<span class="hljs-built_in">TransferVariable</span>(<span class="hljs-string">&quot;g_shared_delayed_integrity_level&quot;</span>,<br>                                 &amp;g_shared_delayed_integrity_level,<br>                                 <span class="hljs-built_in">sizeof</span>(g_shared_delayed_integrity_level));<br>  g_shared_delayed_integrity_level = INTEGRITY_LEVEL_LAST;<br>  <span class="hljs-keyword">if</span> (SBOX_ALL_OK != ret)<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// 传入g_shared_delayed_mitigations</span><br>  <span class="hljs-comment">// Add in delayed mitigations and pseudo-mitigations enforced at startup.</span><br>  g_shared_delayed_mitigations =<br>      delayed_mitigations_ | <span class="hljs-built_in">FilterPostStartupProcessMitigations</span>(mitigations_);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CanSetProcessMitigationsPostStartup</span>(g_shared_delayed_mitigations))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br>  ret = target-&gt;<span class="hljs-built_in">TransferVariable</span>(<span class="hljs-string">&quot;g_shared_delayed_mitigations&quot;</span>,<br>                                 &amp;g_shared_delayed_mitigations,<br>                                 <span class="hljs-built_in">sizeof</span>(g_shared_delayed_mitigations));<br>  g_shared_delayed_mitigations = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (SBOX_ALL_OK != ret)<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-function">AutoLock <span class="hljs-title">lock</span><span class="hljs-params">(&amp;lock_)</span></span>;<br>  targets_.<span class="hljs-built_in">push_back</span>(target);<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在再看<code>TargetProcess::Init</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Construct the IPC server and the IPC dispatcher. When the target does</span><br><span class="hljs-comment">// an IPC it will eventually call the dispatcher.</span><br><span class="hljs-function">ResultCode <span class="hljs-title">TargetProcess::Init</span><span class="hljs-params">(Dispatcher* ipc_dispatcher,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">void</span>* policy,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">uint32_t</span> shared_IPC_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">uint32_t</span> shared_policy_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                               DWORD* win_error)</span> </span>&#123;<br>  <span class="hljs-comment">// We need to map the shared memory on the target. This is necessary for</span><br>  <span class="hljs-comment">// any IPC that needs to take place, even if the target has not yet hit</span><br>  <span class="hljs-comment">// the main( ) function or even has initialized the CRT. So here we set</span><br>  <span class="hljs-comment">// the handle to the shared section. The target on the first IPC must do</span><br>  <span class="hljs-comment">// the rest, which boils down to calling MapViewofFile()</span><br><br>  <span class="hljs-comment">// We use this single memory pool for IPC and for policy.</span><br>  <span class="hljs-comment">// 使用了shared_mem的IPC通信方式，以后会详细分析这些内容</span><br>  DWORD shared_mem_size =<br>      <span class="hljs-built_in">static_cast</span>&lt;DWORD&gt;(shared_IPC_size + shared_policy_size);<br>  shared_section_.<span class="hljs-built_in">Set</span>(::<span class="hljs-built_in">CreateFileMappingW</span>(INVALID_HANDLE_VALUE, <span class="hljs-literal">nullptr</span>,<br>                                           PAGE_READWRITE | SEC_COMMIT, <span class="hljs-number">0</span>,<br>                                           shared_mem_size, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-keyword">if</span> (!shared_section_.<span class="hljs-built_in">IsValid</span>()) &#123;<br>    *win_error = ::<span class="hljs-built_in">GetLastError</span>();<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CREATE_FILE_MAPPING;<br>  &#125;<br><br>  DWORD access = FILE_MAP_READ | FILE_MAP_WRITE | SECTION_QUERY;<br>  HANDLE target_shared_section;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), shared_section_.<span class="hljs-built_in">Get</span>(),<br>                         sandbox_process_info_.<span class="hljs-built_in">process_handle</span>(),<br>                         &amp;target_sharedࠤ؍是很清楚它的作用<br>  <span class="hljs-keyword">if</span> (lowbox_sid_) &#123;<br>    <span class="hljs-keyword">if</span> (!lowbox_directory_.<span class="hljs-built_in">IsValid</span>()) &#123;<br>      result =<br>          <span class="hljs-built_in">CreateLowBoxObjectDirectory</span>(lowbox_sid_, <span class="hljs-literal">true</span>, &amp;lowbox_directory_);<br>      <span class="hljs-built_in">DCHECK</span>(result == ERROR_SUCCESS);<br>    &#125;<br><br>    <span class="hljs-comment">// The order of handles isn&#x27;t important in the CreateLowBoxToken call.</span><br>    <span class="hljs-comment">// The kernel will maintain a reference to the object directory handle.</span><br>    HANDLE saved_handles[<span class="hljs-number">1</span>] = &#123;lowbox_directory_.<span class="hljs-built_in">Get</span>()&#125;;<br>    DWORD saved_handles_count = lowbox_directory_.<span class="hljs-built_in">IsValid</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><br>    Sid <span class="hljs-built_in">package_sid</span>(lowbox_sid_);<br>    SecurityCapabilities <span class="hljs-built_in">caps</span>(package_sid);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateLowBoxToken</span>(lockdown-&gt;<span class="hljs-built_in">Get</span>(), PRIMARY, &amp;caps, saved_handles,<br>                          saved_handles_count, lowbox) != ERROR_SUCCESS) &#123;<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Create the &#x27;better&#x27; token. We use this token as the one that the main</span><br>  <span class="hljs-comment">// thread uses when booting up the process. It should contain most of</span><br>  <span class="hljs-comment">// what we need (before reaching main( ))</span><br>  <span class="hljs-comment">// initial token的创建使用的是和lockdown同样的接口，但它是IMPERSONATION而lockdown是PRIMARY</span><br>  result =<br>      <span class="hljs-built_in">CreateRestrictedToken</span>(initial_level_, integrity_level_, IMPERSONATION,<br>                            lockdown_default_dacl_, initial);<br>  <span class="hljs-keyword">if</span> (ERROR_SUCCESS != result)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="restrictedtoken"><code>RestrictedToken</code></h2><p>想要看懂<code>CreateRestrictedToken</code>，首先得搞清楚<code>RestrictedToken</code>类存在的意义。所以在步入<code>CreateRestrictedToken</code>之前，先拆解一下该类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Handles the creation of a restricted token using the effective token or</span><br><span class="hljs-comment">// any token handle.</span><br><span class="hljs-comment">// 在一个有效的token句柄之上，创建出一个权限更为严格的token</span><br><span class="hljs-comment">// 在Windows中这种token叫受限令牌</span><br><span class="hljs-comment">// 可能从特权集中删除一些特权；该令牌SID可以被标记成Deny-only；该令牌SID可以被标记为</span><br><span class="hljs-comment">// restricted</span><br><span class="hljs-comment">// Sample usage:</span><br><span class="hljs-comment">//    RestrictedToken restricted_token;</span><br><span class="hljs-comment">//    DWORD err_code = restricted_token.Init(nullptr);  // Use the current</span><br><span class="hljs-comment">//                                                   // effective token</span><br><span class="hljs-comment">//    if (ERROR_SUCCESS != err_code) &#123;</span><br><span class="hljs-comment">//      // handle error.</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    restricted_token.AddRestrictingSid(ATL::Sids::Users().GetPSID());</span><br><span class="hljs-comment">//    base::win::ScopedHandle token_handle;</span><br><span class="hljs-comment">//    err_code = restricted_token.GetRestrictedToken(&amp;token_handle);</span><br><span class="hljs-comment">//    if (ERROR_SUCCESS != err_code) &#123;</span><br><span class="hljs-comment">//      // handle error.</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//    [...]</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedToken</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Init() has to be called before calling any other method in the class.</span><br>  <span class="hljs-built_in">RestrictedToken</span>();<br>  ~<span class="hljs-built_in">RestrictedToken</span>();<br><br>  <span class="hljs-comment">// Initializes the RestrictedToken object with effective_token.</span><br>  <span class="hljs-comment">// If effective_token is nullptr, it initializes the RestrictedToken object</span><br>  <span class="hljs-comment">// with the effective token of the current process.</span><br>  <span class="hljs-comment">// 构造器接Init素质二连，如果effective_token是nullptr，就使用当前进程的token</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">Init</span><span class="hljs-params">(HANDLE effective_token)</span></span>;<br><br>  <span class="hljs-comment">// Creates a restricted token.</span><br>  <span class="hljs-comment">// If the function succeeds, the return value is ERROR_SUCCESS. If the</span><br>  <span class="hljs-comment">// function fails, the return value is the win32 error code corresponding to</span><br>  <span class="hljs-comment">// the error.</span><br>  <span class="hljs-comment">// 这个就是在应用了所有的规则之后，创建出来的restricted token，在最后一步使用</span><br>  <span class="hljs-comment">// token显然是个OUT型参数</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">GetRestrictedToken</span><span class="hljs-params">(base::win::ScopedHandle* token)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Creates a restricted token and uses this new token to create a new token</span><br>  <span class="hljs-comment">// for impersonation. Returns this impersonation token.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// If the function succeeds, the return value is ERROR_SUCCESS. If the</span><br>  <span class="hljs-comment">// function fails, the return value is the win32 error code corresponding to</span><br>  <span class="hljs-comment">// the error.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The sample usage is the same as the GetRestrictedToken function.</span><br>  <span class="hljs-comment">// 与上面类似，只是生成的是个impersonation token</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">GetRestrictedTokenForImpersonation</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      base::win::ScopedHandle* token)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Lists all sids in the token and mark them as Deny Only except for those</span><br>  <span class="hljs-comment">// present in the exceptions parameter. If there is no exception needed,</span><br>  <span class="hljs-comment">// the caller can pass an empty list or nullptr for the exceptions</span><br>  <span class="hljs-comment">// parameter.</span><br>  <span class="hljs-comment">// 除了exceptions参数中指定的白名单Sid列表，token中的所有sid都被设置为Deny Only</span><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-comment">// If the function succeeds, the return value is ERROR_SUCCESS. If the</span><br>  <span class="hljs-comment">// function fails, the return value is the win32 error code corresponding to</span><br>  <span class="hljs-comment">// the error.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Sample usage:</span><br>  <span class="hljs-comment">//    std::vector&lt;Sid&gt; sid_exceptions;</span><br>  <span class="hljs-comment">//    sid_exceptions.push_back(ATL::Sids::Users().GetPSID());</span><br>  <span class="hljs-comment">//    sid_exceptions.push_back(ATL::Sids::World().GetPSID());</span><br>  <span class="hljs-comment">//    restricted_token.AddAllSidsForDenyOnly(&amp;sid_exceptions);</span><br>  <span class="hljs-comment">// Note: A Sid marked for Deny Only in a token cannot be used to grant</span><br>  <span class="hljs-comment">// access to any resource. It can only be used to deny access.</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">AddAllSidsForDenyOnly</span><span class="hljs-params">(std::vector&lt;Sid&gt;* exceptions)</span></span>;<br><br>  <span class="hljs-comment">// Adds a user or group SID for Deny Only in the restricted token.</span><br>  <span class="hljs-comment">// Parameter: sid is the SID to add in the Deny Only list.</span><br>  <span class="hljs-comment">// The return value is always ERROR_SUCCESS.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Sample Usage:</span><br>  <span class="hljs-comment">//    restricted_token.AddSidForDenyOnly(ATL::Sids::Admins().GetPSID());</span><br>  <span class="hljs-comment">// 某个SID设为Deny Only</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">AddSidForDenyOnly</span><span class="hljs-params">(<span class="hljs-type">const</span> Sid&amp; sid)</span></span>;<br><br>  <span class="hljs-comment">// Adds the user sid of the token for Deny Only in the restricted token.</span><br>  <span class="hljs-comment">// If the function succeeds, the return value is ERROR_SUCCESS. If the</span><br>  <span class="hljs-comment">// function fails, the return value is the win32 error code corresponding to</span><br>  <span class="hljs-comment">// the error.</span><br>  <span class="hljs-comment">// 这个是user SID的版本</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">AddUserSidForDenyOnly</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Lists all privileges in the token and add them to the list of privileges</span><br>  <span class="hljs-comment">// to remove except for those present in the exceptions parameter. If</span><br>  <span class="hljs-comment">// there is no exception needed, the caller can pass an empty list or nullptr</span><br>  <span class="hljs-comment">// for the exceptions parameter.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// If the function succeeds, the return value is ERROR_SUCCESS. If the</span><br>  <span class="hljs-comment">// function fails, the return value is the win32 error code corresponding to</span><br>  <span class="hljs-comment">// the error.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Sample usage:</span><br>  <span class="hljs-comment">//    std::vector&lt;base::string16&gt; privilege_exceptions;</span><br>  <span class="hljs-comment">//    privilege_exceptions.push_back(SE_CHANGE_NOTIFY_NAME);</span><br>  <span class="hljs-comment">//    restricted_token.DeleteAllPrivileges(&amp;privilege_exceptions);</span><br>  <span class="hljs-comment">// 删除所有特权，除了白名单的那些privilege</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">DeleteAllPrivileges</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;base::string16&gt;* exceptions)</span></span>;<br><br>  <span class="hljs-comment">// Adds a privilege to the list of privileges to remove in the restricted</span><br>  <span class="hljs-comment">// token.</span><br>  <span class="hljs-comment">// Parameter: privilege is the privilege name to remove. This is the string</span><br>  <span class="hljs-comment">// representing the privilege. (e.g. &quot;SeChangeNotifyPrivilege&quot;).</span><br>  <span class="hljs-comment">// If the function succeeds, the return value is ERROR_SUCCESS. If the</span><br>  <span class="hljs-comment">// function fails, the return value is the win32 error code corresponding to</span><br>  <span class="hljs-comment">// the error.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Sample usage:</span><br>  <span class="hljs-comment">//    restricted_token.DeletePrivilege(SE_LOAD_DRIVER_NAME);</span><br>  <span class="hljs-comment">// 删除某个特权</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">DeletePrivilege</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* privilege)</span></span>;<br><br>  <span class="hljs-comment">// Adds a SID to the list of restricting sids in the restricted token.</span><br>  <span class="hljs-comment">// Parameter: sid is the sid to add to the list restricting sids.</span><br>  <span class="hljs-comment">// The return value is always ERROR_SUCCESS.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Sample usage:</span><br>  <span class="hljs-comment">//    restricted_token.AddRestrictingSid(ATL::Sids::Users().GetPSID());</span><br>  <span class="hljs-comment">// Note: The list of restricting is used to force Windows to perform all</span><br>  <span class="hljs-comment">// access checks twice. The first time using your user SID and your groups,</span><br>  <span class="hljs-comment">// and the second time using your list of restricting sids. The access has</span><br>  <span class="hljs-comment">// to be granted in both places to get access to the resource requested.</span><br>  <span class="hljs-comment">// Restricting SID强制windows对所有检查进行两次。</span><br>  <span class="hljs-comment">// 第一次使用你的用户和组SID，第二次使用restricting SID列表的SID。</span><br>  <span class="hljs-comment">// 两次必须都被授予可访问，才能通过请求</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">AddRestrictingSid</span><span class="hljs-params">(<span class="hljs-type">const</span> Sid&amp; sid)</span></span>;<br><br>  <span class="hljs-comment">// Adds the logon sid of the token in the list of restricting sids for the</span><br>  <span class="hljs-comment">// restricted token.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// If the function succeeds, the return value is ERROR_SUCCESS. If the</span><br>  <span class="hljs-comment">// function fails, the return value is the win32 error code corresponding to</span><br>  <span class="hljs-comment">// the error.</span><br>  <span class="hljs-comment">// Logon SID是个特殊的SID，是登录会话进行时系统随机生成的（SID最后一节）</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">AddRestrictingSidLogonSession</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Adds the owner sid of the token in the list of restricting sids for the</span><br>  <span class="hljs-comment">// restricted token.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// If the function succeeds, the return value is ERROR_SUCCESS. If the</span><br>  <span class="hljs-comment">// function fails, the return value is the win32 error code corresponding to</span><br>  <span class="hljs-comment">// the error.</span><br>  <span class="hljs-comment">// 把所有者SID也加到restricting SID列表</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">AddRestrictingSidCurrentUser</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Adds all group sids and the user sid to the restricting sids list.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// If the function succeeds, the return value is ERROR_SUCCESS. If the</span><br>  <span class="hljs-comment">// function fails, the return value is the win32 error code corresponding to</span><br>  <span class="hljs-comment">// the error.</span><br>  <span class="hljs-comment">// token的所有用户/组 SID都加入到restricting sid列表</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">AddRestrictingSidAllSids</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Sets the token integrity level. This is only valid on Vista. The integrity</span><br>  <span class="hljs-comment">// level cannot be higher than your current integrity level.</span><br>  <span class="hljs-comment">// IL是用于隔离同一所有者不同权限资源的机制，实际上windows上最终也会折射成一个SID</span><br>  <span class="hljs-comment">// 只是SID的不同节值表示不同含义，并以此区分开</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">SetIntegrityLevel</span><span class="hljs-params">(IntegrityLevel integrity_level)</span></span>;<br><br>  <span class="hljs-comment">// Set a flag which indicates the created token should have a locked down</span><br>  <span class="hljs-comment">// default DACL when created.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetLockdownDefaultDacl</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// The list of restricting sids in the restricted token.</span><br>  std::vector&lt;Sid&gt; sids_to_restrict_;<br>  <span class="hljs-comment">// The list of privileges to remove in the restricted token.</span><br>  std::vector&lt;LUID&gt; privileges_to_disable_;<br>  <span class="hljs-comment">// The list of sids to mark as Deny Only in the restricted token.</span><br>  std::vector&lt;Sid&gt; sids_for_deny_only_;<br>  <span class="hljs-comment">// The token to restrict. Can only be set in a constructor.</span><br>  base::win::ScopedHandle effective_token_;<br>  <span class="hljs-comment">// The token integrity level. Only valid on Vista.</span><br>  IntegrityLevel integrity_level_;<br>  <span class="hljs-comment">// Tells if the object is initialized or not (if Init() has been called)</span><br>  <span class="hljs-type">bool</span> init_;<br>  <span class="hljs-comment">// Lockdown the default DACL when creating new tokens.</span><br>  <span class="hljs-type">bool</span> lockdown_default_dacl_;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(RestrictedToken);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="构造器init"><code>构造器+Init</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RestrictedToken::<span class="hljs-built_in">RestrictedToken</span>()<br>    : <span class="hljs-built_in">integrity_level_</span>(INTEGRITY_LEVEL_LAST),<br>      <span class="hljs-built_in">init_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">lockdown_default_dacl_</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br><br>RestrictedToken::~<span class="hljs-built_in">RestrictedToken</span>() &#123;&#125;<br><br><span class="hljs-function">DWORD <span class="hljs-title">RestrictedToken::Init</span><span class="hljs-params">(<span class="hljs-type">const</span> HANDLE effective_token)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (init_)<br>    <span class="hljs-keyword">return</span> ERROR_ALREADY_INITIALIZED;<br><br>  HANDLE temp_token;<br>  <span class="hljs-keyword">if</span> (effective_token) &#123;<br>    <span class="hljs-comment">// We duplicate the handle to be able to use it even if the original handle</span><br>    <span class="hljs-comment">// is closed.</span><br>    <span class="hljs-comment">// 使用受限令牌的WinAPI定式，复制句柄-&gt;打开进程令牌</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), effective_token,<br>                           ::<span class="hljs-built_in">GetCurrentProcess</span>(), &amp;temp_token, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>,<br>                           DUPLICATE_SAME_ACCESS)) &#123;<br>      <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">OpenProcessToken</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), TOKEN_ALL_ACCESS,<br>                            &amp;temp_token)) &#123;<br>      <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 到这里，effective_token_成员就是当前或某个进程的句柄了（取决于传入参数是不是空）</span><br>  effective_token_.<span class="hljs-built_in">Set</span>(temp_token);<br><br>  init_ = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sid-related"><code>SID related</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">RestrictedToken::AddAllSidsForDenyOnly</span><span class="hljs-params">(std::vector&lt;Sid&gt;* exceptions)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(init_);<span class="hljs-comment">//确保干这事的时候已经初始化过了</span><br>  <span class="hljs-keyword">if</span> (!init_)<br>    <span class="hljs-keyword">return</span> ERROR_NO_TOKEN;<br><br>  DWORD error;<br>  <span class="hljs-comment">// Windows API GetTokenInformation的封装</span><br>  <span class="hljs-comment">// TokenGroups这个枚举值表示所有组SID</span><br>  std::unique_ptr&lt;BYTE[]&gt; buffer =<br>      <span class="hljs-built_in">GetTokenInfo</span>(effective_token_, TokenGroups, &amp;error);<br><br>  <span class="hljs-keyword">if</span> (!buffer)<br>    <span class="hljs-keyword">return</span> error;<br><br>  <span class="hljs-comment">//通过获取的group SID，构筑deny only group SID列表</span><br>  TOKEN_GROUPS* token_groups = <span class="hljs-built_in">reinterpret_cast</span>&lt;TOKEN_GROUPS*&gt;(buffer.<span class="hljs-built_in">get</span>());<br><br>  <span class="hljs-comment">// Build the list of the deny only group SIDs</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; token_groups-&gt;GroupCount; ++i) &#123;<br>    <span class="hljs-keyword">if</span> ((token_groups-&gt;Groups[i].Attributes &amp; SE_GROUP_INTEGRITY) == <span class="hljs-number">0</span> &amp;&amp;<br>        (token_groups-&gt;Groups[i].Attributes &amp; SE_GROUP_LOGON_ID) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-type">bool</span> should_ignore = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">if</span> (exceptions) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; exceptions-&gt;<span class="hljs-built_in">size</span>(); ++j) &#123;<br>          <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">EqualSid</span>((*exceptions)[j].<span class="hljs-built_in">GetPSID</span>(),<br>                         token_groups-&gt;Groups[i].Sid)) &#123;<br>            should_ignore = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!should_ignore) &#123;<br>        <span class="hljs-comment">// 装入group SID</span><br>        sids_for_deny_only_.<span class="hljs-built_in">push_back</span>(<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;SID*&gt;(token_groups-&gt;Groups[i].Sid));<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br><span class="hljs-comment">// 所以上面这货是装所有组SID的</span><br><span class="hljs-comment">// user sid只可能有一个，但组SID则可能有多个（用户在多个组）</span><br><br><span class="hljs-comment">// 载入特定SID</span><br><span class="hljs-comment">// 注意没有白名单的拦截</span><br><span class="hljs-function">DWORD <span class="hljs-title">RestrictedToken::AddSidForDenyOnly</span><span class="hljs-params">(<span class="hljs-type">const</span> Sid&amp; sid)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(init_);<br>  <span class="hljs-keyword">if</span> (!init_)<br>    <span class="hljs-keyword">return</span> ERROR_NO_TOKEN;<br><br>  sids_for_deny_only_.<span class="hljs-built_in">push_back</span>(sid);<br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br><br><span class="hljs-function">DWORD <span class="hljs-title">RestrictedToken::AddUserSidForDenyOnly</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(init_);<br>  <span class="hljs-keyword">if</span> (!init_)<br>    <span class="hljs-keyword">return</span> ERROR_NO_TOKEN;<br><br>  DWORD size = <span class="hljs-built_in">sizeof</span>(TOKEN_USER) + SECURITY_MAX_SID_SIZE;<br>  <span class="hljs-function">std::unique_ptr&lt;BYTE[]&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BYTE[size])</span></span>;<br>  TOKEN_USER* token_user = <span class="hljs-built_in">reinterpret_cast</span>&lt;TOKEN_USER*&gt;(buffer.<span class="hljs-built_in">get</span>());<br><br>  <span class="hljs-comment">// TokenUser枚举量则表示获取User SID。这次没封装。</span><br>  <span class="hljs-comment">// 因为SID仅有一个，所以知道buffer的合适大小，调用一次就行</span><br>  <span class="hljs-type">bool</span> result = ::<span class="hljs-built_in">GetTokenInformation</span>(effective_token_.<span class="hljs-built_in">Get</span>(), TokenUser,<br>                                      token_user, size, &amp;size);<br><br>  <span class="hljs-keyword">if</span> (!result)<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br><br>  Sid user = <span class="hljs-built_in">reinterpret_cast</span>&lt;SID*&gt;(token_user-&gt;User.Sid);<br>  sids_for_deny_only_.<span class="hljs-built_in">push_back</span>(user);<br><br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>有意思的是获取组SID封装了一个外部函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Calls GetTokenInformation with the desired |info_class| and returns a buffer</span><br><span class="hljs-comment">// with the result.</span><br><span class="hljs-function">std::unique_ptr&lt;BYTE[]&gt; <span class="hljs-title">GetTokenInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> base::win::ScopedHandle&amp; token,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     TOKEN_INFORMATION_CLASS info_class,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     DWORD* error)</span> </span>&#123;<br>  <span class="hljs-comment">// Get the required buffer size.</span><br>  <span class="hljs-comment">// 因为组SID是不定长的，无法预先知道长度，GetTokenInformation这个API允许通过传入null的方式来获取长度，然后再二次调用</span><br>  <span class="hljs-comment">// 很多Windows API都有这个特性，好比炉石的暗影步刷一个范克里夫</span><br>  DWORD size = <span class="hljs-number">0</span>;<br>  ::<span class="hljs-built_in">GetTokenInformation</span>(token.<span class="hljs-built_in">Get</span>(), info_class, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, &amp;size);<br>  <span class="hljs-keyword">if</span> (!size) &#123;<br>    *error = ::<span class="hljs-built_in">GetLastError</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-function">std::unique_ptr&lt;BYTE[]&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BYTE[size])</span></span>;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">GetTokenInformation</span>(token.<span class="hljs-built_in">Get</span>(), info_class, buffer.<span class="hljs-built_in">get</span>(), size,<br>                             &amp;size)) &#123;<br>    *error = ::<span class="hljs-built_in">GetLastError</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  *error = ERROR_SUCCESS;<br>  <span class="hljs-keyword">return</span> buffer;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="privilege-related">privilege related</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">RestrictedToken::DeleteAllPrivileges</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> std::vector&lt;base::string16&gt;* exceptions)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(init_);<br>  <span class="hljs-keyword">if</span> (!init_)<br>    <span class="hljs-keyword">return</span> ERROR_NO_TOKEN;<br><br>  DWORD error;<br>  <span class="hljs-comment">// Privilege是token组成的一部分，通过TokenPrivileges枚举来获取</span><br>  <span class="hljs-comment">// 不定个privilege同样也是未知长度buffer</span><br>  std::unique_ptr&lt;BYTE[]&gt; buffer =<br>      <span class="hljs-built_in">GetTokenInfo</span>(effective_token_, TokenPrivileges, &amp;error);<br><br>  <span class="hljs-keyword">if</span> (!buffer)<br>    <span class="hljs-keyword">return</span> error;<br><br>  TOKEN_PRIVILEGES* token_privileges =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;TOKEN_PRIVILEGES*&gt;(buffer.<span class="hljs-built_in">get</span>());<br><br>  <span class="hljs-comment">// Build the list of privileges to disable</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; token_privileges-&gt;PrivilegeCount; ++i) &#123;<br>    <span class="hljs-type">bool</span> should_ignore = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (exceptions) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; exceptions-&gt;<span class="hljs-built_in">size</span>(); ++j) &#123;<br>        <span class="hljs-comment">// 特权在windows中以LUID值存在，这里通过比较LUID来判断是不是在白名单中</span><br>        LUID luid = &#123;<span class="hljs-number">0</span>&#125;;<br>        ::<span class="hljs-built_in">LookupPrivilegeValue</span>(<span class="hljs-literal">nullptr</span>, (*exceptions)[j].<span class="hljs-built_in">c_str</span>(), &amp;luid);<br>        <span class="hljs-keyword">if</span> (token_privileges-&gt;Privileges[i].Luid.HighPart == luid.HighPart &amp;&amp;<br>            token_privileges-&gt;Privileges[i].Luid.LowPart == luid.LowPart) &#123;<br>          should_ignore = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!should_ignore) &#123;<br>      <span class="hljs-comment">// 装入</span><br>      privileges_to_disable_.<span class="hljs-built_in">push_back</span>(token_privileges-&gt;Privileges[i].Luid);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br><br><span class="hljs-comment">// 删除某条具体的特权，这个就很easy了，注意没有白名单的拦截</span><br><span class="hljs-function">DWORD <span class="hljs-title">RestrictedToken::DeletePrivilege</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* privilege)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(init_);<br>  <span class="hljs-keyword">if</span> (!init_)<br>    <span class="hljs-keyword">return</span> ERROR_NO_TOKEN;<br><br>  LUID luid = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LookupPrivilegeValue</span>(<span class="hljs-literal">nullptr</span>, privilege, &amp;luid))<br>    privileges_to_disable_.<span class="hljs-built_in">push_back</span>(luid);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br><br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="restricting-sid-list-related">Restricting SID list related</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 载入特定sid，没啥好说的</span><br><span class="hljs-function">DWORD <span class="hljs-title">RestrictedToken::AddRestrictingSid</span><span class="hljs-params">(<span class="hljs-type">const</span> Sid&amp; sid)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(init_);<br>  <span class="hljs-keyword">if</span> (!init_)<br>    <span class="hljs-keyword">return</span> ERROR_NO_TOKEN;<br><br>  sids_to_restrict_.<span class="hljs-built_in">push_back</span>(sid);  <span class="hljs-comment">// No attributes</span><br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br><br><span class="hljs-function">DWORD <span class="hljs-title">RestrictedToken::AddRestrictingSidLogonSession</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(init_);<br>  <span class="hljs-keyword">if</span> (!init_)<br>    <span class="hljs-keyword">return</span> ERROR_NO_TOKEN;<br><br>  <span class="hljs-comment">// 先找所有的group SID</span><br>  DWORD error;<br>  std::unique_ptr&lt;BYTE[]&gt; buffer =<br>      <span class="hljs-built_in">GetTokenInfo</span>(effective_token_, TokenGroups, &amp;error);<br><br>  <span class="hljs-keyword">if</span> (!buffer)<br>    <span class="hljs-keyword">return</span> error;<br><br>  TOKEN_GROUPS* token_groups = <span class="hljs-built_in">reinterpret_cast</span>&lt;TOKEN_GROUPS*&gt;(buffer.<span class="hljs-built_in">get</span>());<br><br>  SID* logon_sid = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// 在group SID中找那个SE_GROUP_LOGON_ID属性的SID，这个就是logon SID</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; token_groups-&gt;GroupCount; ++i) &#123;<br>    <span class="hljs-keyword">if</span> ((token_groups-&gt;Groups[i].Attributes &amp; SE_GROUP_LOGON_ID) != <span class="hljs-number">0</span>) &#123;<br>      logon_sid = <span class="hljs-built_in">static_cast</span>&lt;SID*&gt;(token_groups-&gt;Groups[i].Sid);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (logon_sid)<br>    sids_to_restrict_.<span class="hljs-built_in">push_back</span>(logon_sid);<br><br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br><br><span class="hljs-comment">// 这个和上面的DenyOnly设定类似</span><br><span class="hljs-function">DWORD <span class="hljs-title">RestrictedToken::AddRestrictingSidCurrentUser</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(init_);<br>  <span class="hljs-keyword">if</span> (!init_)<br>    <span class="hljs-keyword">return</span> ERROR_NO_TOKEN;<br><br>  DWORD size = <span class="hljs-built_in">sizeof</span>(TOKEN_USER) + SECURITY_MAX_SID_SIZE;<br>  <span class="hljs-function">std::unique_ptr&lt;BYTE[]&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BYTE[size])</span></span>;<br>  TOKEN_USER* token_user = <span class="hljs-built_in">reinterpret_cast</span>&lt;TOKEN_USER*&gt;(buffer.<span class="hljs-built_in">get</span>());<br><br>  <span class="hljs-type">bool</span> result = ::<span class="hljs-built_in">GetTokenInformation</span>(effective_token_.<span class="hljs-built_in">Get</span>(), TokenUser,<br>                                      token_user, size, &amp;size);<br><br>  <span class="hljs-keyword">if</span> (!result)<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br><br>  Sid user = <span class="hljs-built_in">reinterpret_cast</span>&lt;SID*&gt;(token_user-&gt;User.Sid);<br>  sids_to_restrict_.<span class="hljs-built_in">push_back</span>(user);<br><br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br><br><span class="hljs-comment">// 这个也和Deny only的类似，对所有group SID都加入到restricting SID list</span><br><span class="hljs-function">DWORD <span class="hljs-title">RestrictedToken::AddRestrictingSidAllSids</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(init_);<br>  <span class="hljs-keyword">if</span> (!init_)<br>    <span class="hljs-keyword">return</span> ERROR_NO_TOKEN;<br><br>  <span class="hljs-comment">// Add the current user to the list.</span><br>  DWORD error = <span class="hljs-built_in">AddRestrictingSidCurrentUser</span>();<br>  <span class="hljs-keyword">if</span> (ERROR_SUCCESS != error)<br>    <span class="hljs-keyword">return</span> error;<br><br>  std::unique_ptr&lt;BYTE[]&gt; buffer =<br>      <span class="hljs-built_in">GetTokenInfo</span>(effective_token_, TokenGroups, &amp;error);<br><br>  <span class="hljs-keyword">if</span> (!buffer)<br>    <span class="hljs-keyword">return</span> error;<br><br>  TOKEN_GROUPS* token_groups = <span class="hljs-built_in">reinterpret_cast</span>&lt;TOKEN_GROUPS*&gt;(buffer.<span class="hljs-built_in">get</span>());<br><br>  <span class="hljs-comment">// Build the list of restricting sids from all groups.</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; token_groups-&gt;GroupCount; ++i) &#123;<br>    <span class="hljs-keyword">if</span> ((token_groups-&gt;Groups[i].Attributes &amp; SE_GROUP_INTEGRITY) == <span class="hljs-number">0</span>)<br>      <span class="hljs-built_in">AddRestrictingSid</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;SID*&gt;(token_groups-&gt;Groups[i].Sid));<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>关于SID的意义，以及chrome对它的封装类Sid，就不展开了，实际上只是把各种类型各种渠道的SID使用不同的static接口汇集在了一起，最终都变成了一个Sid对象。具体请自己阅读Sid.h/Sid.cc。</p></blockquote><h3 id="integrity-level-related">Integrity Level related</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">RestrictedToken::SetIntegrityLevel</span><span class="hljs-params">(IntegrityLevel integrity_level)</span> </span>&#123;<br>  <span class="hljs-comment">// 仅仅只是个成员set，实际上IL到Token SID的转换，我们在前面已经见过了。</span><br>  integrity_level_ = integrity_level;<br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getrestrictedtoken-related">GetRestrictedToken related</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">RestrictedToken::GetRestrictedToken</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    base::win::ScopedHandle* token)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(init_);<br>  <span class="hljs-keyword">if</span> (!init_)<br>    <span class="hljs-keyword">return</span> ERROR_NO_TOKEN;<br><br>  <span class="hljs-comment">// 调用Get的时机，对三个代表的容器应该都已经设置好了</span><br>  <span class="hljs-type">size_t</span> deny_size = sids_for_deny_only_.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-type">size_t</span> restrict_size = sids_to_restrict_.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-type">size_t</span> privileges_size = privileges_to_disable_.<span class="hljs-built_in">size</span>();<br><br>  <span class="hljs-comment">// SID_AND_ATTRIBUTES和LUID_AND_ATTRIBUTES是token存SID和privilege的结构体</span><br>  SID_AND_ATTRIBUTES* deny_only_array = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (deny_size) &#123;<br>    deny_only_array = <span class="hljs-keyword">new</span> SID_AND_ATTRIBUTES[deny_size];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sids_for_deny_only_.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>      deny_only_array[i].Attributes = SE_GROUP_USE_FOR_DENY_ONLY;<span class="hljs-comment">//这个是key</span><br>      deny_only_array[i].Sid = sids_for_deny_only_[i].<span class="hljs-built_in">GetPSID</span>();<br>    &#125;<br>  &#125;<br><br>  SID_AND_ATTRIBUTES* sids_to_restrict_array = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (restrict_size) &#123;<br>    sids_to_restrict_array = <span class="hljs-keyword">new</span> SID_AND_ATTRIBUTES[restrict_size];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; restrict_size; ++i) &#123;<br>      sids_to_restrict_array[i].Attributes = <span class="hljs-number">0</span>;<span class="hljs-comment">//同理</span><br>      sids_to_restrict_array[i].Sid = sids_to_restrict_[i].<span class="hljs-built_in">GetPSID</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 特权的结构和SID不一样</span><br>  LUID_AND_ATTRIBUTES* privileges_to_disable_array = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (privileges_size) &#123;<br>    privileges_to_disable_array = <span class="hljs-keyword">new</span> LUID_AND_ATTRIBUTES[privileges_size];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; privileges_size; ++i) &#123;<br>      privileges_to_disable_array[i].Attributes = <span class="hljs-number">0</span>;<br>      privileges_to_disable_array[i].Luid = privileges_to_disable_[i];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-type">bool</span> result = <span class="hljs-literal">true</span>;<br>  HANDLE new_token_handle = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// The SANDBOX_INERT flag did nothing in XP and it was just a way to tell</span><br>  <span class="hljs-comment">// if a token has ben restricted given the limiations of IsTokenRestricted()</span><br>  <span class="hljs-comment">// but it appears that in Windows 7 it hints the AppLocker subsystem to</span><br>  <span class="hljs-comment">// leave us alone.</span><br>  <span class="hljs-comment">// Windows API真身在此</span><br>  <span class="hljs-keyword">if</span> (deny_size || restrict_size || privileges_size) &#123;<br>    result = ::<span class="hljs-built_in">CreateRestrictedToken</span>(<br>        effective_token_.<span class="hljs-built_in">Get</span>(), SANDBOX_INERT, <span class="hljs-built_in">static_cast</span>&lt;DWORD&gt;(deny_size),<br>        deny_only_array, <span class="hljs-built_in">static_cast</span>&lt;DWORD&gt;(privileges_size),<br>        privileges_to_disable_array, <span class="hljs-built_in">static_cast</span>&lt;DWORD&gt;(restrict_size),<br>        sids_to_restrict_array, &amp;new_token_handle);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Duplicate the token even if it&#x27;s not modified at this point</span><br>    <span class="hljs-comment">// because any subsequent changes to this token would also affect the</span><br>    <span class="hljs-comment">// current process.</span><br>    result = ::<span class="hljs-built_in">DuplicateTokenEx</span>(effective_token_.<span class="hljs-built_in">Get</span>(), TOKEN_ALL_ACCESS,<br>                                <span class="hljs-literal">nullptr</span>, SecurityIdentification, TokenPrimary,<br>                                &amp;new_token_handle);<br>  &#125;<br>  <span class="hljs-keyword">auto</span> last_error = ::<span class="hljs-built_in">GetLastError</span>();<br><br>  <span class="hljs-comment">// 清理资源</span><br>  <span class="hljs-keyword">if</span> (deny_only_array)<br>    <span class="hljs-keyword">delete</span>[] deny_only_array;<br><br>  <span class="hljs-keyword">if</span> (sids_to_restrict_array)<br>    <span class="hljs-keyword">delete</span>[] sids_to_restrict_array;<br><br>  <span class="hljs-keyword">if</span> (privileges_to_disable_array)<br>    <span class="hljs-keyword">delete</span>[] privileges_to_disable_array;<br><br>  <span class="hljs-keyword">if</span> (!result)<br>    <span class="hljs-keyword">return</span> last_error;<br><br>  base::<span class="hljs-function">win::ScopedHandle <span class="hljs-title">new_token</span><span class="hljs-params">(new_token_handle)</span></span>;<br><br>  <span class="hljs-keyword">if</span> (lockdown_default_dacl_) &#123;<br>    <span class="hljs-comment">// Don&#x27;t add Restricted sid and also remove logon sid access.</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">RevokeLogonSidFromDefaultDacl</span>(new_token.<span class="hljs-built_in">Get</span>()))<br>      <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Modify the default dacl on the token to contain Restricted.</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">AddSidToDefaultDacl</span>(new_token.<span class="hljs-built_in">Get</span>(), WinRestrictedCodeSid,<br>                             GRANT_ACCESS, GENERIC_ALL)) &#123;<br>      <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Add user to default dacl.</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">AddUserSidToDefaultDacl</span>(new_token.<span class="hljs-built_in">Get</span>(), GENERIC_ALL))<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br><br>  <span class="hljs-comment">// 对IntegrityLevel的处理在这儿，实际上这个已经看过了，就是到SID的转换</span><br>  <span class="hljs-comment">// 然后通过SetTokenInformation API来设置属性为SE_GROUP_INTEGRITY的SID</span><br>  <span class="hljs-comment">// 换句话说，IL也不过是SID的一个子集，而SID是token的子集</span><br>  DWORD error = <span class="hljs-built_in">SetTokenIntegrityLevel</span>(new_token.<span class="hljs-built_in">Get</span>(), integrity_level_);<br>  <span class="hljs-keyword">if</span> (ERROR_SUCCESS != error)<br>    <span class="hljs-keyword">return</span> error;<br><br>  HANDLE token_handle;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), new_token.<span class="hljs-built_in">Get</span>(),<br>                         ::<span class="hljs-built_in">GetCurrentProcess</span>(), &amp;token_handle, TOKEN_ALL_ACCESS,<br>                         <span class="hljs-literal">false</span>,  <span class="hljs-comment">// Don&#x27;t inherit.</span><br>                         <span class="hljs-number">0</span>)) &#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br>  &#125;<br><br>  token-&gt;<span class="hljs-built_in">Set</span>(token_handle);<br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br><br><span class="hljs-function">DWORD <span class="hljs-title">RestrictedToken::GetRestrictedTokenForImpersonation</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    base::win::ScopedHandle* token)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(init_);<br>  <span class="hljs-keyword">if</span> (!init_)<br>    <span class="hljs-keyword">return</span> ERROR_NO_TOKEN;<br><br>  base::win::ScopedHandle restricted_token;<br>  DWORD err_code = <span class="hljs-built_in">GetRestrictedToken</span>(&amp;restricted_token);<br>  <span class="hljs-keyword">if</span> (ERROR_SUCCESS != err_code)<br>    <span class="hljs-keyword">return</span> err_code;<br><br>  HANDLE impersonation_token_handle;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateToken</span>(restricted_token.<span class="hljs-built_in">Get</span>(), SecurityImpersonation,<br>                        &amp;impersonation_token_handle)) &#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br>  &#125;<br>  base::<span class="hljs-function">win::ScopedHandle <span class="hljs-title">impersonation_token</span><span class="hljs-params">(impersonation_token_handle)</span></span>;<br><br>  HANDLE token_handle;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">DuplicateHandle</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), impersonation_token.<span class="hljs-built_in">Get</span>(),<br>                         ::<span class="hljs-built_in">GetCurrentProcess</span>(), &amp;token_handle, TOKEN_ALL_ACCESS,<br>                         <span class="hljs-literal">false</span>,  <span class="hljs-comment">// Don&#x27;t inherit.</span><br>                         <span class="hljs-number">0</span>)) &#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br>  &#125;<br><br>  token-&gt;<span class="hljs-built_in">Set</span>(token_handle);<br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="createrestrictedtoken"><code>CreateRestrictedToken</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Creates a restricted token based on the effective token of the current</span><br><span class="hljs-comment">// process. The parameter security_level determines how much the token is</span><br><span class="hljs-comment">// restricted. The token_type determines if the token will be used as a primary</span><br><span class="hljs-comment">// token or impersonation token. The integrity level of the token is set to</span><br><span class="hljs-comment">// |integrity level| on Vista only.</span><br><span class="hljs-comment">// |token| is the output value containing the handle of the newly created</span><br><span class="hljs-comment">// restricted token.</span><br><span class="hljs-comment">// |lockdown_default_dacl| indicates the token&#x27;s default DACL should be locked</span><br><span class="hljs-comment">// down to restrict what other process can open kernel resources created while</span><br><span class="hljs-comment">// running under the token.</span><br><span class="hljs-comment">// If the function succeeds, the return value is ERROR_SUCCESS. If the</span><br><span class="hljs-comment">// function fails, the return value is the win32 error code corresponding to</span><br><span class="hljs-comment">// the error.</span><br><span class="hljs-comment">// 根据注释多少能明白一些，传入的这些参数都是PolicyBase对象在调用前就设置好了的成员变量</span><br><span class="hljs-function">DWORD <span class="hljs-title">CreateRestrictedToken</span><span class="hljs-params">(TokenLevel security_level,</span></span><br><span class="hljs-params"><span class="hljs-function">                            IntegrityLevel integrity_level,</span></span><br><span class="hljs-params"><span class="hljs-function">                            TokenType token_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">bool</span> lockdown_default_dacl,</span></span><br><span class="hljs-params"><span class="hljs-function">                            base::win::ScopedHandle* token)</span> </span>&#123;<br>  RestrictedToken restricted_token;<span class="hljs-comment">// 构造接Init素质二连</span><br>  restricted_token.<span class="hljs-built_in">Init</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// Initialized with the current process token</span><br>  <span class="hljs-comment">// 如果有默认DACL，就设置下去</span><br>  <span class="hljs-keyword">if</span> (lockdown_default_dacl)<br>    restricted_token.<span class="hljs-built_in">SetLockdownDefaultDacl</span>();<br><br>  <span class="hljs-comment">// 这两个是用于开绿灯的白名单，一个是不要DenyOnly的SID，一个是不要删除的特权</span><br>  <span class="hljs-comment">// 这就看出了chrome的狠毒，除了白名单的指派其他一无所有。</span><br>  std::vector&lt;base::string16&gt; privilege_exceptions;<br>  std::vector&lt;Sid&gt; sid_exceptions;<br><br>  <span class="hljs-type">bool</span> deny_sids = <span class="hljs-literal">true</span>;<br>  <span class="hljs-type">bool</span> remove_privileges = <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// TokenLevel是chrome封装的，到这里再会头看它定义处的注释，是否就豁然开朗了？</span><br>  <span class="hljs-comment">// 下面的分支处理，不过是对不同level的定义，部署3个代表（restricting SID/Deny Only SID/Privileges）</span><br>  <span class="hljs-keyword">switch</span> (security_level) &#123;<br>    <span class="hljs-comment">// 无需保护，关闭sid deny和privilege remove</span><br>    <span class="hljs-keyword">case</span> USER_UNPROTECTED: &#123;<br>      deny_sids = <span class="hljs-literal">false</span>;<br>      remove_privileges = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> USER_RESTRICTED_SAME_ACCESS: &#123;<br>      deny_sids = <span class="hljs-literal">false</span>;<br>      remove_privileges = <span class="hljs-literal">false</span>;<br><br>      <span class="hljs-type">unsigned</span> err_code = restricted_token.<span class="hljs-built_in">AddRestrictingSidAllSids</span>();<br>      <span class="hljs-keyword">if</span> (ERROR_SUCCESS != err_code)<br>        <span class="hljs-keyword">return</span> err_code;<br><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> USER_NON_ADMIN: &#123;<br>      sid_exceptions.<span class="hljs-built_in">push_back</span>(WinBuiltinUsersSid);<br>      sid_exceptions.<span class="hljs-built_in">push_back</span>(WinWorldSid);<br>      sid_exceptions.<span class="hljs-built_in">push_back</span>(WinInteractiveSid);<br>      sid_exceptions.<span class="hljs-built_in">push_back</span>(WinAuthenticatedUserSid);<br>      privilege_exceptions.<span class="hljs-built_in">push_back</span>(SE_CHANGE_NOTIFY_NAME);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> USER_INTERACTIVE: &#123;<br>      sid_exceptions.<span class="hljs-built_in">push_back</span>(WinBuiltinUsersSid);<br>      sid_exceptions.<span class="hljs-built_in">push_back</span>(WinWorldSid);<br>      sid_exceptions.<span class="hljs-built_in">push_back</span>(WinInteractiveSid);<br>      sid_exceptions.<span class="hljs-built_in">push_back</span>(WinAuthenticatedUserSid);<br>      privilege_exceptions.<span class="hljs-built_in">push_back</span>(SE_CHANGE_NOTIFY_NAME);<br>      restricted_token.<span class="hljs-built_in">AddRestrictingSid</span>(WinBuiltinUsersSid);<br>      restricted_token.<span class="hljs-built_in">AddRestrictingSid</span>(WinWorldSid);<br>      restricted_token.<span class="hljs-built_in">AddRestrictingSid</span>(WinRestrictedCodeSid);<br>      restricted_token.<span class="hljs-built_in">AddRestrictingSidCurrentUser</span>();<br>      restricted_token.<span class="hljs-built_in">AddRestrictingSidLogonSession</span>();<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> USER_LIMITED: &#123;<br>      sid_exceptions.<span class="hljs-built_in">push_back</span>(WinBuiltinUsersSid);<br>      sid_exceptions.<span class="hljs-built_in">push_back</span>(WinWorldSid);<br>      sid_exceptions.<span class="hljs-built_in">push_back</span>(WinInteractiveSid);<br>      privilege_exceptions.<span class="hljs-built_in">push_back</span>(SE_CHANGE_NOTIFY_NAME);<br>      restricted_token.<span class="hljs-built_in">AddRestrictingSid</span>(WinBuiltinUsersSid);<br>      restricted_token.<span class="hljs-built_in">AddRestrictingSid</span>(WinWorldSid);<br>      restricted_token.<span class="hljs-built_in">AddRestrictingSid</span>(WinRestrictedCodeSid);<br><br>      <span class="hljs-comment">// This token has to be able to create objects in BNO.</span><br>      <span class="hljs-comment">// Unfortunately, on Vista+, it needs the current logon sid</span><br>      <span class="hljs-comment">// in the token to achieve this. You should also set the process to be</span><br>      <span class="hljs-comment">// low integrity level so it can&#x27;t access object created by other</span><br>      <span class="hljs-comment">// processes.</span><br>      restricted_token.<span class="hljs-built_in">AddRestrictingSidLogonSession</span>();<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> USER_RESTRICTED: &#123;<br>      privilege_exceptions.<span class="hljs-built_in">push_back</span>(SE_CHANGE_NOTIFY_NAME);<br>      restricted_token.<span class="hljs-built_in">AddUserSidForDenyOnly</span>();<br>      restricted_token.<span class="hljs-built_in">AddRestrictingSid</span>(WinRestrictedCodeSid);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> USER_LOCKDOWN: &#123;<br>      restricted_token.<span class="hljs-built_in">AddUserSidForDenyOnly</span>();<br>      restricted_token.<span class="hljs-built_in">AddRestrictingSid</span>(WinNullSid);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">default</span>: &#123; <span class="hljs-keyword">return</span> ERROR_BAD_ARGUMENTS; &#125;<br>  &#125;<br><br>  DWORD err_code = ERROR_SUCCESS;<br>  <span class="hljs-keyword">if</span> (deny_sids) &#123;<br>    err_code = restricted_token.<span class="hljs-built_in">AddAllSidsForDenyOnly</span>(&amp;sid_exceptions);<br>    <span class="hljs-keyword">if</span> (ERROR_SUCCESS != err_code)<br>      <span class="hljs-keyword">return</span> err_code;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (remove_privileges) &#123;<br>    err_code = restricted_token.<span class="hljs-built_in">DeleteAllPrivileges</span>(&amp;privilege_exceptions);<br>    <span class="hljs-keyword">if</span> (ERROR_SUCCESS != err_code)<br>      <span class="hljs-keyword">return</span> err_code;<br>  &#125;<br><br>  <span class="hljs-comment">// 这个只是填充个成员变量罢了</span><br>  restricted_token.<span class="hljs-built_in">SetIntegrityLevel</span>(integrity_level);<br><br>  <span class="hljs-comment">// lockdown token是PRIMARY而initial token是IMPERSONATION</span><br>  <span class="hljs-comment">// IMPERSONATION是个临时的token</span><br>  <span class="hljs-keyword">switch</span> (token_type) &#123;<br>    <span class="hljs-keyword">case</span> PRIMARY: &#123;<br>      err_code = restricted_token.<span class="hljs-built_in">GetRestrictedToken</span>(token);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> IMPERSONATION: &#123;<br>      err_code = restricted_token.<span class="hljs-built_in">GetRestrictedTokenForImpersonation</span>(token);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">default</span>: &#123;<br>      err_code = ERROR_BAD_ARGUMENTS;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> err_code;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spawntarget-related"><code>SpawnTarget related</code></h2><p>回到<code>BrokerServicesBase::SpawnTarget</code>中，通过<code>policy_base-&gt;MakeToken</code>做出了三个token后，将initial和lockdown传给了<code>TargetProcess</code>构造器，new出target进程对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TargetProcess* target = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TargetProcess</span>(<br>      std::<span class="hljs-built_in">move</span>(initial_token), std::<span class="hljs-built_in">move</span>(lockdown_token), job.<span class="hljs-built_in">Get</span>(),<br>      thread_pool_.<span class="hljs-built_in">get</span>(),<br>      profile ? profile-&gt;<span class="hljs-built_in">GetImpersonationCapabilities</span>() : std::<span class="hljs-built_in">vector</span>&lt;Sid&gt;());<br></code></pre></td></tr></table></figure><p>而在构造器中，仅仅只是将两个token的所有权移给了成员<code>lockdown_token_</code>和<code>initial_token_</code>。此后在<code>TargetProcess::Create</code>中调用<code>CreateProcessAsUserW</code>API时，使用了lockdown。该API的调用也是Windows使用token的定式。</p><p>所以target进程在创建的时候，使用的是lockdowntoken作为process的token。</p><p>此后，<code>TargetProcess::Create</code>继续处理initial token：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (initial_token_.<span class="hljs-built_in">IsValid</span>()) &#123;<br>    HANDLE impersonation_token = initial_token_.<span class="hljs-built_in">Get</span>();<br>    base::win::ScopedHandle app_container_token;<br>  <span class="hljs-comment">// 这里是判断是否应用了AC，如果是的话，就用AC的app_container_token取代initial token</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetAppContainerImpersonationToken</span>(<br>            process_info.<span class="hljs-built_in">process_handle</span>(), impersonation_token,<br>            impersonation_capabilities_, &amp;app_container_token)) &#123;<br>      impersonation_token = app_container_token.<span class="hljs-built_in">Get</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Change the token of the main thread of the new process for the</span><br>    <span class="hljs-comment">// impersonation token with more rights. This allows the target to start;</span><br>    <span class="hljs-comment">// otherwise it will crash too early for us to help.</span><br>  <span class="hljs-comment">// 主线程临时使用这个impersonation token</span><br>    HANDLE temp_thread = process_info.<span class="hljs-built_in">thread_handle</span>();<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">SetThreadToken</span>(&amp;temp_thread, impersonation_token)) &#123;<br>      *win_error = ::<span class="hljs-built_in">GetLastError</span>();<br>      ::<span class="hljs-built_in">TerminateProcess</span>(process_info.<span class="hljs-built_in">process_handle</span>(), <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_SET_THREAD_TOKEN;<br>    &#125;<br>  <span class="hljs-comment">// 只能用一次，这个东西此后就没用了，关闭掉</span><br>    initial_token_.<span class="hljs-built_in">Close</span>();<br>  &#125;<br></code></pre></td></tr></table></figure><p>返回到<code>SpawnTarget</code>，此后会继续判断lowboxtoken的合法性，如果有就<code>target-&gt;AssignLowBoxToken(lowbox_token);</code>。关于这个lowbox的使用意义，我暂时不深究。</p><p>此时，target进程已经做出来了，token也配置好了，但target是挂起的状态。</p><p><code>SpawnTarget</code>在<code>target-&gt;Create</code>之后_section,access, false, 0)) { *win_error = ::GetLastError(); returnSBOX_ERROR_DUPLICATE_SHARED_SECTION; }</p><p>void* shared_memory = ::MapViewOfFile( shared_section_.Get(),FILE_MAP_WRITE | FILE_MAP_READ, 0, 0, 0); if (!shared_memory) {*win_error = ::GetLastError(); returnSBOX_ERROR_MAP_VIEW_OF_SHARED_SECTION; }</p><p>// 通过MapViewOfFile的共享内存方式，把policy传给targetCopyPolicyToTarget(policy, shared_policy_size,reinterpret_cast&lt;char*&gt;(shared_memory) + shared_IPC_size);</p><p>ResultCode ret; // Set the global variables in the target. These arenot used on the broker. g_shared_section = target_shared_section; ret =TransferVariable("g_shared_section", &amp;g_shared_section,sizeof(g_shared_section)); g_shared_section = nullptr; if (SBOX_ALL_OK!= ret) { <em>win_error = ::GetLastError(); return ret; }g_shared_IPC_size = shared_IPC_size; ret =TransferVariable("g_shared_IPC_size", &amp;g_shared_IPC_size,sizeof(g_shared_IPC_size)); g_shared_IPC_size = 0; if (SBOX_ALL_OK !=ret) { </em>win_error = ::GetLastError(); return ret; }g_shared_policy_size = shared_policy_size; ret =TransferVariable("g_shared_policy_size", &amp;g_shared_policy_size,sizeof(g_shared_policy_size)); g_shared_policy_size = 0; if (SBOX_ALL_OK!= ret) { *win_error = ::GetLastError(); return ret; }</p><p>ipc_server_.reset(new SharedMemIPCServer(sandbox_process_info_.process_handle(),sandbox_process_info_.process_id(), thread_pool_, ipc_dispatcher));</p><p>if (!ipc_server_-&gt;Init(shared_memory, shared_IPC_size,kIPCChannelSize)) return SBOX_ERROR_NO_SPACE;</p><p>// After this point we cannot use this handle anymore.::CloseHandle(sandbox_process_info_.TakeThreadHandle());</p><p>return SBOX_ALL_OK; } <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>到这里，broker能对target进程做的就都做完了。而控制target运行的runner则又是另一片天地了。<br><br>回头看`TargetServicesBase::LowerToken`:<br><br>​```cpp<br><span class="hljs-comment">// Failure here is a breach of security so the process is terminated.</span><br>void TargetServicesBase::<span class="hljs-constructor">LowerToken()</span> &#123;<br>  <span class="hljs-keyword">if</span> (ERROR_SUCCESS !=<br>      <span class="hljs-constructor">SetProcessIntegrityLevel(<span class="hljs-params">g_shared_delayed_integrity_level</span>)</span>)<br>    ::<span class="hljs-constructor">TerminateProcess(::GetCurrentProcess()</span>, SBOX_FATAL_INTEGRITY);<br>  process_state_.<span class="hljs-constructor">SetRevertedToSelf()</span>;<br> <br>  <span class="hljs-comment">// If the client code as called RegOpenKey, advapi32.dll has cached some</span><br>  <span class="hljs-comment">// handles. The following code gets rid of them.</span><br>  <span class="hljs-comment">// 这个API名称虽然不起眼，但却大有作为，实际上他完成了从撤销impersonate到恢复primary token的过程</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-constructor">RevertToSelf()</span>)<br>    ::<span class="hljs-constructor">TerminateProcess(::GetCurrentProcess()</span>, SBOX_FATAL_DROPTOKEN);<br>  <span class="hljs-comment">// 这些先不关心，处理cache handle</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-constructor">FlushCachedRegHandles()</span>)<br>    ::<span class="hljs-constructor">TerminateProcess(::GetCurrentProcess()</span>, SBOX_FATAL_FLUSHANDLES);<br>  <span class="hljs-keyword">if</span> (ERROR_SUCCESS != ::<span class="hljs-constructor">RegDisablePredefinedCache()</span>)<br>    ::<span class="hljs-constructor">TerminateProcess(::GetCurrentProcess()</span>, SBOX_FATAL_CACHEDISABLE);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-constructor">WarmupWindowsLocales()</span>)<br>    ::<span class="hljs-constructor">TerminateProcess(::GetCurrentProcess()</span>, SBOX_FATAL_WARMUP);<br>  <span class="hljs-built_in">bool</span> is_csrss_connected = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-constructor">CloseOpenHandles(&amp;<span class="hljs-params">is_csrss_connected</span>)</span>)<br>    ::<span class="hljs-constructor">TerminateProcess(::GetCurrentProcess()</span>, SBOX_FATAL_CLOSEHANDLES);<br>  process_state_.<span class="hljs-constructor">SetCsrssConnected(<span class="hljs-params">is_csrss_connected</span>)</span>;<br>  <span class="hljs-comment">// 处理mitigation</span><br>  <span class="hljs-comment">// Enabling mitigations must happen last otherwise handle closing breaks</span><br>  <span class="hljs-keyword">if</span> (g_shared_delayed_mitigations<span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">      </span>!<span class="hljs-constructor">ApplyProcessMitigationsToCurrentProcess(<span class="hljs-params">g_shared_delayed_mitigations</span>)</span>)<br>    ::<span class="hljs-constructor">TerminateProcess(::GetCurrentProcess()</span>, SBOX_FATAL_MITIGATION);<br>&#125;<br><br><span class="hljs-comment">// 这个就一目了然了，使用新的integrity_level</span><br>DWORD <span class="hljs-constructor">SetProcessIntegrityLevel(IntegrityLevel <span class="hljs-params">integrity_level</span>)</span> &#123;<br>  <span class="hljs-comment">// We don&#x27;t check for an invalid level here because we&#x27;ll just let it</span><br>  <span class="hljs-comment">// fail on the SetTokenIntegrityLevel call later on.</span><br>  <span class="hljs-keyword">if</span> (integrity_level<span class="hljs-operator"> == </span>INTEGRITY_LEVEL_LAST) &#123;<br>    <span class="hljs-comment">// No mandatory level specified, we don&#x27;t change it.</span><br>    return ERROR_SUCCESS;<br>  &#125;<br><br>  HANDLE token_handle;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-constructor">OpenProcessToken(GetCurrentProcess()</span>, TOKEN_ADJUST_DEFAULT,<br>                          &amp;token_handle))<br>    return ::<span class="hljs-constructor">GetLastError()</span>;<br><br>  base::win::ScopedHandle token(token_handle);<br><br>  return <span class="hljs-constructor">SetTokenIntegrityLevel(<span class="hljs-params">token</span>.Get()</span>, integrity_level);<br>&#125;<br><br><span class="hljs-comment">// 这些早先已经看过了</span><br>DWORD <span class="hljs-constructor">SetTokenIntegrityLevel(HANDLE <span class="hljs-params">token</span>, IntegrityLevel <span class="hljs-params">integrity_level</span>)</span> &#123;<br>  const wchar_t* integrity_level_str = <span class="hljs-constructor">GetIntegrityLevelString(<span class="hljs-params">integrity_level</span>)</span>;<br>  <span class="hljs-keyword">if</span> (!integrity_level_str) &#123;<br>    <span class="hljs-comment">// No mandatory level specified, we don&#x27;t change it.</span><br>    return ERROR_SUCCESS;<br>  &#125;<br><br>  PSID integrity_sid = nullptr;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-constructor">ConvertStringSidToSid(<span class="hljs-params">integrity_level_str</span>, &amp;<span class="hljs-params">integrity_sid</span>)</span>)<br>    return ::<span class="hljs-constructor">GetLastError()</span>;<br><br>  TOKEN_MANDATORY_LABEL label = &#123;&#125;;<br>  label.Label.Attributes = SE_GROUP_INTEGRITY;<br>  label.Label.Sid = integrity_sid;<br><br>  DWORD size = sizeof(TOKEN_MANDATORY_LABEL) + ::<span class="hljs-constructor">GetLengthSid(<span class="hljs-params">integrity_sid</span>)</span>;<br>  <span class="hljs-built_in">bool</span> result = ::<span class="hljs-constructor">SetTokenInformation(<span class="hljs-params">token</span>, TokenIntegrityLevel, &amp;<span class="hljs-params">label</span>, <span class="hljs-params">size</span>)</span>;<br>  auto last_error = ::<span class="hljs-constructor">GetLastError()</span>;<br>  ::<span class="hljs-constructor">LocalFree(<span class="hljs-params">integrity_sid</span>)</span>;<br><br>  return result ? ERROR_SUCCESS : last_error;<br>&#125;<br><br>const wchar_t* <span class="hljs-constructor">GetIntegrityLevelString(IntegrityLevel <span class="hljs-params">integrity_level</span>)</span> &#123;<br>  switch (integrity_level) &#123;<br>    case INTEGRITY_LEVEL_SYSTEM:<br>      return L<span class="hljs-string">&quot;S-1-16-16384&quot;</span>;<br>    case INTEGRITY_LEVEL_HIGH:<br>      return L<span class="hljs-string">&quot;S-1-16-12288&quot;</span>;<br>    case INTEGRITY_LEVEL_MEDIUM:<br>      return L<span class="hljs-string">&quot;S-1-16-8192&quot;</span>;<br>    case INTEGRITY_LEVEL_MEDIUM_LOW:<br>      return L<span class="hljs-string">&quot;S-1-16-6144&quot;</span>;<br>    case INTEGRITY_LEVEL_LOW:<br>      return L<span class="hljs-string">&quot;S-1-16-4096&quot;</span>;<br>    case INTEGRITY_LEVEL_BELOW_LOW:<br>      return L<span class="hljs-string">&quot;S-1-16-2048&quot;</span>;<br>    case INTEGRITY_LEVEL_UNTRUSTED:<br>      return L<span class="hljs-string">&quot;S-1-16-0&quot;</span>;<br>    case INTEGRITY_LEVEL_LAST:<br>      return nullptr;<br>  &#125;<br><br>  <span class="hljs-constructor">NOTREACHED()</span>;<br>  return nullptr;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>说白了，除了token有两个，initial和lockdown，mitigation和IL也有两个，后者更为严格且作为delayed项。当<code>LowerToken</code>时一并设置下去，而它们都是由broker的policy_base一早就设置好了的，并通过IPC传给了target。</p><h2 id="policybase-related"><code>PolicyBase</code> related</h2><p>到此，broker对target的所作所为，涉及到token的地方，就全都清楚了。而在<code>LowerToken</code>处我们发现还有个delayedIL设置了下去，这个IL并非由broker控制，而是传入到<code>SpawnTarget</code>时，policy_base已经设置好了。</p><p>而<code>PolicyBase</code>的Owner就尤为关键了，policy的创建是由<code>BrokerServices::CreatePolicy</code>控制的，那么policy对象应该是独立的，在<code>SpawnTarget</code>之前，policy会调用成员函数来设置各种组件，比如我们研究的token。</p><p>在sandbox的源码中，可以参考一些test单元测试文件来验证猜想(policy_target_test.cc)。</p><p>随便贴一个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Launches the app in the sandbox and ask it to wait in an</span><br><span class="hljs-comment">// infinite loop. Waits for 2 seconds and then check if the</span><br><span class="hljs-comment">// desktop associated with the app thread is not the same as the</span><br><span class="hljs-comment">// current desktop.</span><br><span class="hljs-built_in">TEST</span>(PolicyTargetTest, DesktopPolicy) &#123;<br>  BrokerServices* broker = <span class="hljs-built_in">GetBroker</span>();<br><br>  <span class="hljs-comment">// Precreate the desktop.</span><br>  scoped_refptr&lt;TargetPolicy&gt; temp_policy = broker-&gt;<span class="hljs-built_in">CreatePolicy</span>();<br>  temp_policy-&gt;<span class="hljs-built_in">CreateAlternateDesktop</span>(<span class="hljs-literal">false</span>);<br>  temp_policy = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-built_in">ASSERT_TRUE</span>(broker);<br><br>  <span class="hljs-comment">// Get the path to the sandboxed app.</span><br>  <span class="hljs-type">wchar_t</span> prog_name[MAX_PATH];<br>  <span class="hljs-built_in">GetModuleFileNameW</span>(<span class="hljs-literal">nullptr</span>, prog_name, MAX_PATH);<br><br>  <span class="hljs-function">base::string16 <span class="hljs-title">arguments</span><span class="hljs-params">(<span class="hljs-string">L&quot;\&quot;&quot;</span>)</span></span>;<br>  arguments += prog_name;<br>  arguments += <span class="hljs-string">L&quot;\&quot; -child 0 wait&quot;</span>;  <span class="hljs-comment">// Don&#x27;t care about the &quot;state&quot; argument.</span><br><br>  <span class="hljs-comment">// Launch the app.</span><br>  ResultCode result = SBOX_ALL_OK;<br>  ResultCode warning_result = SBOX_ALL_OK;<br>  DWORD last_error = ERROR_SUCCESS;<br>  base::win::ScopedProcessInformation target;<br><br>  scoped_refptr&lt;TargetPolicy&gt; policy = broker-&gt;<span class="hljs-built_in">CreatePolicy</span>();<br>  policy-&gt;<span class="hljs-built_in">SetAlternateDesktop</span>(<span class="hljs-literal">false</span>);<br>  policy-&gt;<span class="hljs-built_in">SetTokenLevel</span>(USER_INTERACTIVE, USER_LOCKDOWN);<br>  PROCESS_INFORMATION temp_process_info = &#123;&#125;;<br>  result =<br>      broker-&gt;<span class="hljs-built_in">SpawnTarget</span>(prog_name, arguments.<span class="hljs-built_in">c_str</span>(), policy, &amp;warning_result,<br>                          &amp;last_error, &amp;temp_process_info);<br>  base::string16 desktop_name = policy-&gt;<span class="hljs-built_in">GetAlternateDesktop</span>();<br>  policy = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-built_in">EXPECT_EQ</span>(SBOX_ALL_OK, result);<br>  <span class="hljs-keyword">if</span> (result == SBOX_ALL_OK)<br>    target.<span class="hljs-built_in">Set</span>(temp_process_info);<br><br>  <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-number">1u</span>, ::<span class="hljs-built_in">ResumeThread</span>(target.<span class="hljs-built_in">thread_handle</span>()));<br><br>  <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-built_in">static_cast</span>&lt;DWORD&gt;(WAIT_TIMEOUT),<br>            ::<span class="hljs-built_in">WaitForSingleObject</span>(target.<span class="hljs-built_in">process_handle</span>(), <span class="hljs-number">2000</span>));<br><br>  <span class="hljs-built_in">EXPECT_NE</span>(::<span class="hljs-built_in">GetThreadDesktop</span>(target.<span class="hljs-built_in">thread_id</span>()),<br>            ::<span class="hljs-built_in">GetThreadDesktop</span>(::<span class="hljs-built_in">GetCurrentThreadId</span>()));<br><br>  HDESK desk = ::<span class="hljs-built_in">OpenDesktop</span>(desktop_name.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, DESKTOP_ENUMERATE);<br>  <span class="hljs-built_in">EXPECT_TRUE</span>(desk);<br>  <span class="hljs-built_in">EXPECT_TRUE</span>(::<span class="hljs-built_in">CloseDesktop</span>(desk));<br>  <span class="hljs-built_in">EXPECT_TRUE</span>(::<span class="hljs-built_in">TerminateProcess</span>(target.<span class="hljs-built_in">process_handle</span>(), <span class="hljs-number">0</span>));<br><br>  ::<span class="hljs-built_in">WaitForSingleObject</span>(target.<span class="hljs-built_in">process_handle</span>(), INFINITE);<br><br>  <span class="hljs-comment">// Close the desktop handle.</span><br>  temp_policy = broker-&gt;<span class="hljs-built_in">CreatePolicy</span>();<br>  temp_policy-&gt;<span class="hljs-built_in">DestroyAlternateDesktop</span>();<br>  temp_policy = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-comment">// Make sure the desktop does not exist anymore.</span><br>  desk = ::<span class="hljs-built_in">OpenDesktop</span>(desktop_name.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, DESKTOP_ENUMERATE);<br>  <span class="hljs-built_in">EXPECT_FALSE</span>(desk);<br>&#125;<br></code></pre></td></tr></table></figure><p>暂不用看懂所有逻辑，理解整个运营的方式即可。这个TEST是检查alternativedesktop的，在设置后，理应和用户当前的desktop不一致。</p><blockquote><p>Alternativedesktop也是policy三大组件之一，它比较简单，目的在于防止对用户desktop的其他window的攻击，比如全局hook，监听等等。本质上就是把target窗口隔离。</p></blockquote><p>关于Token的事儿暂时就说到这儿，chrome仅仅只是根据设计（TokenLevel和IntegrityLevel）按等级权限使用了Windows的restrictedtoken。其中还用到了impersonate机制。</p><p>想要理解这些设置是如何生效的，对象的过审检查是如何进行的，首先得了解Windows的对象安全机制。文首已经给出了非常nice的参考书，尽管《WindowsInternals》因为作者职位的敏感，文中的描述都是高度抽象且没有代码参照，但凭借google在手，还是能够有一定收获的。</p>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-Job-analysis</title>
    <link href="/2018/05/14/chromium-sandbox-Job-analysis/"/>
    <url>/2018/05/14/chromium-sandbox-Job-analysis/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第五篇，主要分析了windows平台下，Chromium包装的Job对象。阅读本篇前，最好阅读前四篇（本篇相对独立）。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-job-analysis">chromium-sandbox-Job-analysis</h1><p>Windows本身有一种称为Job的对象，用于管理多个进程，做资源限制、访问控制等。</p><blockquote><p>Jeffery的《Windows核心编程》专门用了一章的篇幅来讲述这个Job作业对象。</p></blockquote><p>在剖析<code>TargetPolicy</code>时，看到了3大组件+IL+Mitigation+other的组织结构。而target进程的job句柄是在<code>BrokerServicesBase::SpawnTarget</code>中通过<code>PolicyBase::MakeJobObject</code>new出来的。实际上这里new出来的对象并不是Windows原生的job对象，而是chrome的Job类，它封装了windows的job对象。</p><h2 id="sandbox.job"><code>sandbox.Job</code></h2><p>头文件中类定义可以看到很多有用的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Handles the creation of job objects based on a security profile.</span><br><span class="hljs-comment">// Sample usage:</span><br><span class="hljs-comment">//   Job job;</span><br><span class="hljs-comment">//   job.Init(JOB_LOCKDOWN, nullptr);  //no job name</span><br><span class="hljs-comment">//   job.AssignProcessToJob(process_handle);</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Job</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Job</span>();<br><br>  ~<span class="hljs-built_in">Job</span>();<br><br>  <span class="hljs-comment">// Initializes and creates the job object. The security of the job is based</span><br>  <span class="hljs-comment">// on the security_level parameter.</span><br>  <span class="hljs-comment">// job_name can be nullptr if the job is unnamed.</span><br>  <span class="hljs-comment">// If the chosen profile has too many ui restrictions, you can disable some</span><br>  <span class="hljs-comment">// by specifying them in the ui_exceptions parameters.</span><br>  <span class="hljs-comment">// If the function succeeds, the return value is ERROR_SUCCESS. If the</span><br>  <span class="hljs-comment">// function fails, the return value is the win32 error code corresponding to</span><br>  <span class="hljs-comment">// the error.</span><br>  <span class="hljs-comment">// job也是经典的constructor + init</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">Init</span><span class="hljs-params">(JobLevel security_level,<span class="hljs-comment">//决定Job对象安全级别，还记得chrome设定的JobLevel枚举量吗？</span></span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* job_name,<span class="hljs-comment">//名字可以没有，即匿名</span></span></span><br><span class="hljs-params"><span class="hljs-function">             DWORD ui_exceptions,<span class="hljs-comment">//根据profile，个别UI限制可以开绿灯</span></span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-type">size_t</span> memory_limit)</span></span>;<span class="hljs-comment">//应该是限制最大内存</span><br><br>  <span class="hljs-comment">// Assigns the process referenced by process_handle to the job.</span><br>  <span class="hljs-comment">// If the function succeeds, the return value is ERROR_SUCCESS. If the</span><br>  <span class="hljs-comment">// function fails, the return value is the win32 error code corresponding to</span><br>  <span class="hljs-comment">// the error.</span><br>  <span class="hljs-comment">// 把进程归属到Job对象，使用句柄HANDLE操控进程</span><br>  <span class="hljs-comment">// 注意此前在TargetProcess::Create中调用的是WinAPI AssignProcessToJobObject</span><br>  <span class="hljs-comment">// 巧在该函数实际上也是对该API的封装，作为一个Job类的预留接口，我在跟踪代码时除了测试单元并没有发现其他地方对此接口引用</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">AssignProcessToJob</span><span class="hljs-params">(HANDLE process_handle)</span></span>;<br><br>  <span class="hljs-comment">// Grants access to &quot;handle&quot; to the job. All processes in the job can</span><br>  <span class="hljs-comment">// subsequently recognize and use the handle.</span><br>  <span class="hljs-comment">// If the function succeeds, the return value is ERROR_SUCCESS. If the</span><br>  <span class="hljs-comment">// function fails, the return value is the win32 error code corresponding to</span><br>  <span class="hljs-comment">// the error.</span><br>  <span class="hljs-comment">//应该是调用之后，Job内的所有进程都可以访问传入的HANDLE</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">UserHandleGrantAccess</span><span class="hljs-params">(HANDLE handle)</span></span>;<br><br>  <span class="hljs-comment">// Revokes ownership to the job handle and returns it.</span><br>  <span class="hljs-comment">// If the object is not yet initialized, it returns an invalid handle.</span><br>  <span class="hljs-comment">// 转移owner</span><br>  base::<span class="hljs-function">win::ScopedHandle <span class="hljs-title">Take</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Handle to the job referenced by the object.</span><br>  base::win::ScopedHandle job_handle_;<span class="hljs-comment">//看起来是引用Windows Job对象的成员</span><br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(Job);<span class="hljs-comment">//禁用默认拷贝复制和默认赋值操作</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>Chrome的注释一贯很nice，对Job的使用给出了范例。</p><blockquote><ol type="1"><li><p><code>base::win::ScopedHandle</code>是个很复杂的类模板，日后写专门的文章再分析，暂时理解成Windows句柄的封装。</p></li><li><p>DISALLOW_COPY_AND_ASSIGN是个C++很常见的技巧，展开实际上就是:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Put this in the declarations for a class to be uncopyable and unassignable.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISALLOW_COPY_AND_ASSIGN(TypeName) \</span><br><span class="hljs-meta">  DISALLOW_COPY(TypeName);                 \</span><br><span class="hljs-meta">  DISALLOW_ASSIGN(TypeName)</span><br><br><span class="hljs-comment">// Put this in the declarations for a class to be uncopyable.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISALLOW_COPY(TypeName) \</span><br><span class="hljs-meta">  TypeName(const TypeName&amp;) = delete</span><br><br><span class="hljs-comment">// Put this in the declarations for a class to be unassignable.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISALLOW_ASSIGN(TypeName) TypeName&amp; operator=(const TypeName&amp;) = delete</span><br></code></pre></td></tr></table></figure><p>如此，相当于告知编译器不要产生默认赋值构造和默认赋值操作，对于不需要这两个成员的类来说，这种做法可以将一些语法或逻辑错误提到编译器来排解。</p></li></ol></blockquote><h3 id="constructordestructor">Constructor/Destructor</h3><p>public的成员不多，对Job来说，构造和析构都是public，是个比较单纯的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Job::<span class="hljs-built_in">Job</span>() : <span class="hljs-built_in">job_handle_</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;;<span class="hljs-comment">//只是简单的对私有成员变量零化</span><br>Job::~<span class="hljs-built_in">Job</span>()&#123;&#125;;<span class="hljs-comment">//这种纯粹就是好习惯，对C++来说，我个人的理解就是一定要不厌其烦</span><br></code></pre></td></tr></table></figure><h3 id="init"><code>Init()</code></h3><p><code>JobLevel</code>此前已经见过了，再贴一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The Job level specifies a set of decreasing security profiles for the</span><br><span class="hljs-comment">// Job object that the target process will be placed into.</span><br><span class="hljs-comment">// This table summarizes the security associated with each level:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  JobLevel        |General                            |Quota               |</span><br><span class="hljs-comment">//                  |restrictions                       |restrictions        |</span><br><span class="hljs-comment">// -----------------|---------------------------------- |--------------------|</span><br><span class="hljs-comment">// JOB_NONE         | No job is assigned to the         | None               |</span><br><span class="hljs-comment">//                  | sandboxed process.                |                    |</span><br><span class="hljs-comment">// -----------------|---------------------------------- |--------------------|</span><br><span class="hljs-comment">// JOB_UNPROTECTED  | None                              | *Kill on Job close.|</span><br><span class="hljs-comment">// -----------------|---------------------------------- |--------------------|</span><br><span class="hljs-comment">// JOB_INTERACTIVE  | *Forbid system-wide changes using |                    |</span><br><span class="hljs-comment">//                  |  SystemParametersInfo().          | *Kill on Job close.|</span><br><span class="hljs-comment">//                  | *Forbid the creation/switch of    |                    |</span><br><span class="hljs-comment">//                  |  Desktops.                        |                    |</span><br><span class="hljs-comment">//                  | *Forbids calls to ExitWindows().  |                    |</span><br><span class="hljs-comment">// -----------------|---------------------------------- |--------------------|</span><br><span class="hljs-comment">// JOB_LIMITED_USER | Same as INTERACTIVE_USER plus:    | *One active process|</span><br><span class="hljs-comment">//                  | *Forbid changes to the display    |  limit.            |</span><br><span class="hljs-comment">//                  |  settings.                        | *Kill on Job close.|</span><br><span class="hljs-comment">// -----------------|---------------------------------- |--------------------|</span><br><span class="hljs-comment">// JOB_RESTRICTED   | Same as LIMITED_USER plus:        | *One active process|</span><br><span class="hljs-comment">//                  | * No read/write to the clipboard. |  limit.            |</span><br><span class="hljs-comment">//                  | * No access to User Handles that  | *Kill on Job close.|</span><br><span class="hljs-comment">//                  |   belong to other processes.      |                    |</span><br><span class="hljs-comment">//                  | * Forbid message broadcasts.      |                    |</span><br><span class="hljs-comment">//                  | * Forbid setting global hooks.    |                    |</span><br><span class="hljs-comment">//                  | * No access to the global atoms   |                    |</span><br><span class="hljs-comment">//                  |   table.                          |                    |</span><br><span class="hljs-comment">// -----------------|-----------------------------------|--------------------|</span><br><span class="hljs-comment">// JOB_LOCKDOWN     | Same as RESTRICTED                | *One active process|</span><br><span class="hljs-comment">//                  |                                   |  limit.            |</span><br><span class="hljs-comment">//                  |                                   | *Kill on Job close.|</span><br><span class="hljs-comment">//                  |                                   | *Kill on unhandled |</span><br><span class="hljs-comment">//                  |                                   |  exception.        |</span><br><span class="hljs-comment">//                  |                                   |                    |</span><br><span class="hljs-comment">// In the context of the above table, &#x27;user handles&#x27; refers to the handles of</span><br><span class="hljs-comment">// windows, bitmaps, menus, etc. Files, treads and registry handles are kernel</span><br><span class="hljs-comment">// handles and are not affected by the job level settings.</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">JobLevel</span> &#123;<br>  JOB_LOCKDOWN = <span class="hljs-number">0</span>,<br>  JOB_RESTRICTED,<br>  JOB_LIMITED_USER,<br>  JOB_INTERACTIVE,<br>  JOB_UNPROTECTED,<br>  JOB_NONE<br>&#125;;<br></code></pre></td></tr></table></figure><p>枚举量的范围对应<code>Job</code>的权限高低，注释同样非常友好，不必多言。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">Job::Init</span><span class="hljs-params">(JobLevel security_level,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* job_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                DWORD ui_exceptions,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">size_t</span> memory_limit)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (job_handle_.<span class="hljs-built_in">IsValid</span>())<span class="hljs-comment">//防止二次初始化</span><br>    <span class="hljs-keyword">return</span> ERROR_ALREADY_INITIALIZED;<br><br>  <span class="hljs-comment">//这里果然用到了Windows API来创建Job对象，安全属性参数为nullptr实际上是表示使用默认安全属性，而非无</span><br>  <span class="hljs-comment">//base::win::ScopedHandle的Set操作建立了Windows Job对象和job_handle_的联系</span><br>  job_handle_.<span class="hljs-built_in">Set</span>(::<span class="hljs-built_in">CreateJobObject</span>(<span class="hljs-literal">nullptr</span>,  <span class="hljs-comment">// No security attribute</span><br>                                    job_name));<br>  <span class="hljs-keyword">if</span> (!job_handle_.<span class="hljs-built_in">IsValid</span>())<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br><br>  <span class="hljs-comment">//这就是Windows Job对象的日常了，扩展限制信息和基础UI限制</span><br>  JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = &#123;&#125;;<br>  JOBOBJECT_BASIC_UI_RESTRICTIONS jbur = &#123;&#125;;<br><br>  <span class="hljs-comment">// Set the settings for the different security levels. Note: The higher levels</span><br>  <span class="hljs-comment">// inherit from the lower levels.</span><br>  <span class="hljs-comment">// 这里要根据传入的JobLevel，也就是第一个参数来分类</span><br>  <span class="hljs-keyword">switch</span> (security_level) &#123;<br>    <span class="hljs-keyword">case</span> JOB_LOCKDOWN: &#123;<br>      jeli.BasicLimitInformation.LimitFlags |=<br>          JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION;<span class="hljs-comment">//最严格的权限，这里的flag标志也确实符合上面enum定义的描述，UNHANDLED_EXCEPTION时直接go die</span><br>      FALLTHROUGH;<span class="hljs-comment">//注意这里是穿透的，并非break，因为flag的设置从低到高有着子集的关系，所以这也算是一种编码时的小技巧。</span><br>    &#125;<br>    <span class="hljs-keyword">case</span> JOB_RESTRICTED: &#123;<br>      jbur.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_WRITECLIPBOARD;<br>      jbur.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_READCLIPBOARD;<span class="hljs-comment">//读写剪贴板</span><br>      jbur.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_HANDLES;<span class="hljs-comment">//UI HANDLES</span><br>      jbur.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_GLOBALATOMS;<span class="hljs-comment">//全局原子表</span><br>      FALLTHROUGH;<br>    &#125;<br>    <span class="hljs-keyword">case</span> JOB_LIMITED_USER: &#123;<br>      jbur.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_DISPLAYSETTINGS;<br>      jeli.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_ACTIVE_PROCESS;<br>      jeli.BasicLimitInformation.ActiveProcessLimit = <span class="hljs-number">1</span>;<br>      FALLTHROUGH;<br>    &#125;<br>    <span class="hljs-keyword">case</span> JOB_INTERACTIVE: &#123;<br>      jbur.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS;<br>      jbur.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_DESKTOP;<br>      jbur.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_EXITWINDOWS;<br>      FALLTHROUGH;<br>    &#125;<br>    <span class="hljs-keyword">case</span> JOB_UNPROTECTED: &#123;<br>      <span class="hljs-keyword">if</span> (memory_limit) &#123;<br>        jeli.BasicLimitInformation.LimitFlags |=<br>            JOB_OBJECT_LIMIT_PROCESS_MEMORY;<br>        jeli.ProcessMemoryLimit = memory_limit;<span class="hljs-comment">//这一层面仅仅有着内存限制的设定</span><br>      &#125;<br><br>      jeli.BasicLimitInformation.LimitFlags |=<br>          JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">default</span>: &#123; <span class="hljs-keyword">return</span> ERROR_BAD_ARGUMENTS; &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//权限限制设定下去 </span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">SetInformationJobObject</span>(job_handle_.<span class="hljs-built_in">Get</span>(),<br>                                 JobObjectExtendedLimitInformation, &amp;jeli,<br>                                 <span class="hljs-built_in">sizeof</span>(jeli))) &#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br>  &#125;<br><br>  <span class="hljs-comment">//开绿灯的UI限制要放行</span><br>  jbur.UIRestrictionsClass = jbur.UIRestrictionsClass &amp; (~ui_exceptions);<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">SetInformationJobObject</span>(job_handle_.<span class="hljs-built_in">Get</span>(),<br>                                 JobObjectBasicUIRestrictions, &amp;jbur,<br>                                 <span class="hljs-built_in">sizeof</span>(jbur))) &#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Init中Job对象的用法、权限的设置直接查MSDN吧。对这些Windows组合技定式的理解，没有什么捷径，多查MSDN+stackoverflow。</p></blockquote><h3 id="assignprocesstojob"><code>AssignProcessToJob()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">Job::AssignProcessToJob</span><span class="hljs-params">(HANDLE process_handle)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!job_handle_.<span class="hljs-built_in">IsValid</span>())<span class="hljs-comment">//心智健全检查</span><br>    <span class="hljs-keyword">return</span> ERROR_NO_DATA;<br><br>  <span class="hljs-comment">// 封装了AssignProcessToJobObject WinAPI</span><br>  <span class="hljs-comment">// 实际上由于当前PolicyBase::MakeJobObject的实现返回的是HANDLE，而不是Job对象</span><br>  <span class="hljs-comment">// 所以这个接口函数并没有被PolicyBase这个Policy实现体用到，它是直接调用了WinAPI</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">AssignProcessToJobObject</span>(job_handle_.<span class="hljs-built_in">Get</span>(), process_handle))<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br><br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="userhandlegrantaccess"><code>UserHandleGrantAccess()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">Job::UserHandleGrantAccess</span><span class="hljs-params">(HANDLE handle)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!job_handle_.<span class="hljs-built_in">IsValid</span>())<span class="hljs-comment">//心智健全检查</span><br>    <span class="hljs-keyword">return</span> ERROR_NO_DATA;<br><br>  <span class="hljs-comment">//依然是WinAPI，第三个参数为true表示允许</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">UserHandleGrantAccess</span>(handle, job_handle_.<span class="hljs-built_in">Get</span>(),<br>                               <span class="hljs-literal">true</span>)) &#123;  <span class="hljs-comment">// Access allowed.</span><br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="take"><code>Take()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">base::<span class="hljs-function">win::ScopedHandle <span class="hljs-title">Job::Take</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(job_handle_);<br>  <span class="hljs-comment">//左值引用转右值引用，避免拷贝操作（对象没变化，只是转移了所有权），另一方面由于默认拷贝构造的禁用，直接return job_handle_会报错。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一旦调用了Take之后，Job对象就失去了job_handle_这个WindowsJob对象的所有权，当然也就不能再使用了。</p><p>这个函数在<code>PolicyBase::MakeJobObject</code>结尾处调用。</p><h2 id="brokerservicesbase-related"><code>BrokerServicesBase</code>related</h2><p>尽管Job封装的人模狗样，但对于policy来说，policy是怎样使用的Job才是最关键的。</p><p>我们从<code>BrokerServicesBase::SpawnTarget</code>开始探索Job的身世。</p><p>首先步入<code>PolicyBase::MakeJobObject</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">base::win::ScopedHandle job;<br>result = policy_base-&gt;<span class="hljs-built_in">MakeJobObject</span>(&amp;job);<br><span class="hljs-comment">/* ------------------------------------------------------------------ */</span><br><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::MakeJobObject</span><span class="hljs-params">(base::win::ScopedHandle* job)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (job_level_ != JOB_NONE) &#123;<br>    <span class="hljs-comment">// Create the windows job object.</span><br>    <span class="hljs-comment">// constructor + init在栈上部署Job对象</span><br>    Job job_obj;<br>    DWORD result =<br>        job_obj.<span class="hljs-built_in">Init</span>(job_level_, <span class="hljs-literal">nullptr</span>, ui_exceptions_, memory_limit_);<br>    <span class="hljs-keyword">if</span> (ERROR_SUCCESS != result)<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><span class="hljs-comment">// 立即剥离了HANDLE的所有权，作为OUT型参数返回</span><br>    *job = job_obj.<span class="hljs-built_in">Take</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 处理不需要job的情况，空的ScopedHandle对象实际上是INVALID_HANDLE</span><br>    *job = base::win::<span class="hljs-built_in">ScopedHandle</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>此后在new TargetProcess对象时传入Job HANDLE，进入构造器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> TargetProcess* target = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TargetProcess</span>(<br>      std::<span class="hljs-built_in">move</span>(initial_token), std::<span class="hljs-built_in">move</span>(lockdown_token), job.<span class="hljs-built_in">Get</span>(),<br>      thread_pool_.<span class="hljs-built_in">get</span>(),<br>      profile ? profile-&gt;<span class="hljs-built_in">GetImpersonationCapabilities</span>() : std::<span class="hljs-built_in">vector</span>&lt;Sid&gt;());<br><span class="hljs-comment">/* ------------------------------------------------------------------ */</span><br>TargetProcess::<span class="hljs-built_in">TargetProcess</span>(base::win::ScopedHandle initial_token,<br>                             base::win::ScopedHandle lockdown_token,<br>                             HANDLE job,<br>                             ThreadProvider* thread_pool,<br>                             <span class="hljs-type">const</span> std::vector&lt;Sid&gt;&amp; impersonation_capabilities)<br>    <span class="hljs-comment">// This object owns everything initialized here except thread_pool and</span><br>    <span class="hljs-comment">// the job_ handle. The Job handle is closed by BrokerServices and results</span><br>    <span class="hljs-comment">// eventually in a call to our dtor.</span><br>    : <span class="hljs-built_in">lockdown_token_</span>(std::<span class="hljs-built_in">move</span>(lockdown_token)),<br>      <span class="hljs-built_in">initial_token_</span>(std::<span class="hljs-built_in">move</span>(initial_token)),<br>      <span class="hljs-built_in">job_</span>(job),<span class="hljs-comment">//所以这个HANDLE最终由TargetProcess的job_成员存储</span><br>      <span class="hljs-built_in">thread_pool_</span>(thread_pool),<br>      <span class="hljs-built_in">base_address_</span>(<span class="hljs-literal">nullptr</span>),<br>      <span class="hljs-built_in">impersonation_capabilities_</span>(impersonation_capabilities) &#123;&#125;<br></code></pre></td></tr></table></figure><p>从设计的角度来看，job对象本身就是管理target进程的，target进程对象存储jobHANDLE也是天经地义。Policy作为中间介入层，它控制了target对象最终拿到的job是个什么样的job，而是什么样的job又取决于policy设定的<code>JobLevel</code>。</p><p>然而job的处理并没有结束，上面函数传参的时候，仅仅是复制了HANDLE值，<code>TargetProcess</code>存储的也仅仅是个值罢了。job的归属究竟在何处？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">if</span> (job.<span class="hljs-built_in">IsValid</span>()) &#123;<br>    std::unique_ptr&lt;JobTracker&gt; tracker =<br>        std::<span class="hljs-built_in">make_unique</span>&lt;JobTracker&gt;(std::<span class="hljs-built_in">move</span>(job), policy_base);<br><br>    <span class="hljs-comment">// There is no obvious recovery after failure here. Previous version with</span><br>    <span class="hljs-comment">// SpawnCleanup() caused deletion of TargetProcess twice. crbug.com/480639</span><br>    <span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">AssociateCompletionPort</span>(tracker-&gt;job.<span class="hljs-built_in">Get</span>(), job_port_.<span class="hljs-built_in">Get</span>(),<br>                                  tracker.<span class="hljs-built_in">get</span>()));<br> tracker_list_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(tracker));<br><span class="hljs-comment">/* ------------------------------------------------------------------ */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AssociateCompletionPort</span><span class="hljs-params">(HANDLE job, HANDLE port, <span class="hljs-type">void</span>* key)</span> </span>&#123;<br>  JOBOBJECT_ASSOCIATE_COMPLETION_PORT job_acp = &#123;key, port&#125;;<br>  <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">SetInformationJobObject</span>(job,<br>                                   JobObjectAssociateCompletionPortInformation,<br>                                   &amp;job_acp, <span class="hljs-built_in">sizeof</span>(job_acp))<br>             ? <span class="hljs-literal">true</span><br>             : <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还记得<code>BrokerServices::tracker_list_</code>吗？它是个<code>std::list&lt;std::unique_ptr&lt;JobTracker&gt;&gt;</code>。这货将所有的<code>JobTracker</code>对象指针集成在一起管理。<code>std::move(job)</code>意味着局部对象job的所属正式移交给了tracker，而tracker本身又把job和policy_base对象关联在一起。</p><p>进一步，<code>AssociateCompletionPort</code>把该job和IO完成端口联系起来。</p><h3 id="jobtracker"><code>JobTracker</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Helper structure that allows the Broker to associate a job notification</span><br><span class="hljs-comment">// with a job object and with a policy.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">JobTracker</span> &#123;<br>  <span class="hljs-built_in">JobTracker</span>(base::win::ScopedHandle job,<br>             scoped_refptr&lt;sandbox::PolicyBase&gt; policy)<br>      : <span class="hljs-built_in">job</span>(std::<span class="hljs-built_in">move</span>(job)), <span class="hljs-built_in">policy</span>(policy) &#123;&#125;<span class="hljs-comment">// job owner再次转移给内部成员job</span><br>  ~<span class="hljs-built_in">JobTracker</span>() &#123; <span class="hljs-built_in">FreeResources</span>(); &#125;<br><br>  <span class="hljs-comment">// Releases the Job and notifies the associated Policy object to release its</span><br>  <span class="hljs-comment">// resources as well.</span><br>  <span class="hljs-comment">// 这才是关联policy的真实目的，在BrokerServicesBase::TargetEventsThread中可以看到</span><br>  <span class="hljs-comment">// JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO发生时，就要释放它的policy的资源</span><br>  <span class="hljs-comment">// 因为policy此时不再管辖任何target进程了</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FreeResources</span><span class="hljs-params">()</span></span>;<br><br>  base::win::ScopedHandle job;<br>  scoped_refptr&lt;sandbox::PolicyBase&gt; policy;<br>&#125;;<br></code></pre></td></tr></table></figure><p>封装这样一个东西，实际上是为了broker可以把job的通知事件同时与该job对象和制定job规格的policy联系起来。</p><h4 id="freeresources"><code>FreeResources</code></h4><p>那么，展开来看就很清晰了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">JobTracker::FreeResources</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (policy) &#123;<br>    <span class="hljs-comment">// 先终止Job对象</span><br>    <span class="hljs-type">bool</span> res = ::<span class="hljs-built_in">TerminateJobObject</span>(job.<span class="hljs-built_in">Get</span>(), sandbox::SBOX_ALL_OK);<br>    <span class="hljs-built_in">DCHECK</span>(res);<br>    <span class="hljs-comment">// Closing the job causes the target process to be destroyed so this needs</span><br>    <span class="hljs-comment">// to happen before calling OnJobEmpty().</span><br>    HANDLE stale_job_handle = job.<span class="hljs-built_in">Get</span>();<br>    job.<span class="hljs-built_in">Close</span>();<br><br>    <span class="hljs-comment">// In OnJobEmpty() we don&#x27;t actually use the job handle directly.</span><br>    <span class="hljs-comment">// 原来OnJobEmpty这个事件的驱动者在这儿</span><br>    policy-&gt;<span class="hljs-built_in">OnJobEmpty</span>(stale_job_handle);<br>    policy = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 揪出policy管理的targets_中，已经GG的target并删除</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PolicyBase::OnJobEmpty</span><span class="hljs-params">(HANDLE job)</span> </span>&#123;<br>  <span class="hljs-function">AutoLock <span class="hljs-title">lock</span><span class="hljs-params">(&amp;lock_)</span></span>;<br>  TargetSet::iterator it;<br>  <span class="hljs-keyword">for</span> (it = targets_.<span class="hljs-built_in">begin</span>(); it != targets_.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    <span class="hljs-keyword">if</span> ((*it)-&gt;<span class="hljs-built_in">Job</span>() == job)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (it == targets_.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  TargetProcess* target = *it;<br>  targets_.<span class="hljs-built_in">erase</span>(it);<br>  <span class="hljs-keyword">delete</span> target;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="targetpolicy-related"><code>TargetPolicy</code> related</h2><p>Job最为policy的3大组件之一，在<code>PolicyBase</code>中也有丰富的接口函数，比如上面已经看到的<code>MakeJobObject</code>和<code>OnJobEmpty</code>。</p><p>其他的几个set/get方法只是单纯的成员传递：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetJobLevel</span><span class="hljs-params">(JobLevel job_level, <span class="hljs-type">uint32_t</span> ui_exceptions)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (memory_limit_ &amp;&amp; job_level == JOB_NONE) &#123;<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>  &#125;<br>  job_level_ = job_level;<br>  ui_exceptions_ = ui_exceptions;<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br><br><span class="hljs-function">JobLevel <span class="hljs-title">PolicyBase::GetJobLevel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> job_level_;<br>&#125;<br><br><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetJobMemoryLimit</span><span class="hljs-params">(<span class="hljs-type">size_t</span> memory_limit)</span> </span>&#123;<br>  memory_limit_ = memory_limit;<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些已经在分析<code>TargetPolicy</code>一节中看到过了。</p><h2 id="targetprocess-related"><code>TargetProcess</code> related</h2><p>如上分析，<code>TargetProcess</code>仅仅保存了一个所属job对象的HANDLE。而该类中涉及到job的接口只有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Returns the handle to the job object that the target process belongs to.</span><br><span class="hljs-function">HANDLE <span class="hljs-title">Job</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> job_; &#125;<br></code></pre></td></tr></table></figure><p>这个函数在<code>PolicyBase::OnJobEmpty</code>中用来迭代<code>PolicyBase::targets_</code>，以job匹配。</p><p>到此，Job相关的内容目前都已经搞清楚了。</p>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-TargetPolicy-analysis</title>
    <link href="/2018/05/13/chromium-sandbox-TargetPolicy-analysis/"/>
    <url>/2018/05/13/chromium-sandbox-TargetPolicy-analysis/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第四篇，主要分析了windows平台下，对chrome的target进程应用安全策略的管家——TargetPolicy类。阅读本篇前，请先阅读前三篇。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-targetpolicy-analysis">chromium-sandbox-TargetPolicy-analysis</h1><p>policy和target进程的关系在看过前三篇后，相必已是十分清楚了。<code>TargetPolicy</code>由<code>BrokerServicesBase::CreatePolicy</code>创建，policy对象管理<code>BrokerServicesBase::SpawnTarget</code>生成的<code>TargetProcess</code>对象。</p><p>而<code>TargetPolicy</code>实际上也是个抽象基类，chrome实际使用的是<code>PolicyBase</code>这个派生类对象，使用父类指针指向子类对象。</p><h2 id="targetpolicy"><code>TargetPolicy</code></h2><p>先看看抽象基类，定义了哪些接口规范：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetPolicy</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Windows subsystems that can have specific rules.</span><br>  <span class="hljs-comment">// Note: The process subsystem(SUBSY_PROCESS) does not evaluate the request</span><br>  <span class="hljs-comment">// exactly like the CreateProcess API does. See the comment at the top of</span><br>  <span class="hljs-comment">// process_thread_dispatcher.cc for more details.</span><br>  <span class="hljs-comment">// Windows子系统包含的各种特定规则，包含文件、命名管道、进程、注册表、命名异步对象以及Win32K禁闭策略</span><br>  <span class="hljs-comment">// Policy会分门别类的根据某个rule来判定动作的仲裁结果，以Semantics表示</span><br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">SubSystem</span> &#123;<br>    SUBSYS_FILES,           <span class="hljs-comment">// Creation and opening of files and pipes.</span><br>    SUBSYS_NAMED_PIPES,     <span class="hljs-comment">// Creation of named pipes.</span><br>    SUBSYS_PROCESS,         <span class="hljs-comment">// Creation of child processes.</span><br>    SUBSYS_REGISTRY,        <span class="hljs-comment">// Creation and opening of registry keys.</span><br>    SUBSYS_SYNC,            <span class="hljs-comment">// Creation of named sync objects.</span><br>    SUBSYS_WIN32K_LOCKDOWN  <span class="hljs-comment">// Win32K Lockdown related policy.</span><br>  &#125;;<br><br>  <span class="hljs-comment">// Allowable semantics when a rule is matched.</span><br>  <span class="hljs-comment">// rule仲裁结果，对于各个不同的子系统，都有对应的几个枚举值</span><br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Semantics</span> &#123;<br>    FILES_ALLOW_ANY,       <span class="hljs-comment">// Allows open or create for any kind of access that</span><br>                           <span class="hljs-comment">// the file system supports.</span><br>    FILES_ALLOW_READONLY,  <span class="hljs-comment">// Allows open or create with read access only.</span><br>    FILES_ALLOW_QUERY,     <span class="hljs-comment">// Allows access to query the attributes of a file.</span><br>    FILES_ALLOW_DIR_ANY,   <span class="hljs-comment">// Allows open or create with directory semantics</span><br>                           <span class="hljs-comment">// only.</span><br>    NAMEDPIPES_ALLOW_ANY,  <span class="hljs-comment">// Allows creation of a named pipe.</span><br>    PROCESS_MIN_EXEC,      <span class="hljs-comment">// Allows to create a process with minimal rights</span><br>                           <span class="hljs-comment">// over the resulting process and thread handles.</span><br>                           <span class="hljs-comment">// No other parameters besides the command line are</span><br>                           <span class="hljs-comment">// passed to the child process.</span><br>    PROCESS_ALL_EXEC,      <span class="hljs-comment">// Allows the creation of a process and return full</span><br>                           <span class="hljs-comment">// access on the returned handles.</span><br>                           <span class="hljs-comment">// This flag can be used only when the main token of</span><br>                           <span class="hljs-comment">// the sandboxed application is at least INTERACTIVE.</span><br>    EVENTS_ALLOW_ANY,      <span class="hljs-comment">// Allows the creation of an event with full access.</span><br>    EVENTS_ALLOW_READONLY,  <span class="hljs-comment">// Allows opening an even with synchronize access.</span><br>    REG_ALLOW_READONLY,     <span class="hljs-comment">// Allows readonly access to a registry key.</span><br>    REG_ALLOW_ANY,          <span class="hljs-comment">// Allows read and write access to a registry key.</span><br>    FAKE_USER_GDI_INIT,     <span class="hljs-comment">// Fakes user32 and gdi32 initialization. This can</span><br>                            <span class="hljs-comment">// be used to allow the DLLs to load and initialize</span><br>                            <span class="hljs-comment">// even if the process cannot access that subsystem.</span><br>    IMPLEMENT_OPM_APIS      <span class="hljs-comment">// Implements FAKE_USER_GDI_INIT and also exposes</span><br>                            <span class="hljs-comment">// IPC calls to handle Output Protection Manager</span><br>                            <span class="hljs-comment">// APIs.</span><br>  &#125;;<br><br>  <span class="hljs-comment">// Increments the reference count of this object. The reference count must</span><br>  <span class="hljs-comment">// be incremented if this interface is given to another component.</span><br>  <span class="hljs-comment">// 下面两个是引用计数相关</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">AddRef</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Decrements the reference count of this object. When the reference count</span><br>  <span class="hljs-comment">// is zero the object is automatically destroyed.</span><br>  <span class="hljs-comment">// Indicates that the caller is done with this interface. After calling</span><br>  <span class="hljs-comment">// release no other method should be called.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Release</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 下面分布了三大组件（token，job，alternative desktop）的接口函数</span><br>  <span class="hljs-comment">// Sets the security level for the target process&#x27; two tokens.</span><br>  <span class="hljs-comment">// This setting is permanent and cannot be changed once the target process is</span><br>  <span class="hljs-comment">// spawned.</span><br>  <span class="hljs-comment">// 两个token不可更改</span><br>  <span class="hljs-comment">// initial: the security level for the initial token. This is the token that</span><br>  <span class="hljs-comment">//   is used by the process from the creation of the process until the moment</span><br>  <span class="hljs-comment">//   the process calls TargetServices::LowerToken() or the process calls</span><br>  <span class="hljs-comment">//   win32&#x27;s RevertToSelf(). Once this happens the initial token is no longer</span><br>  <span class="hljs-comment">//   available and the lockdown token is in effect. Using an initial token is</span><br>  <span class="hljs-comment">//   not compatible with AppContainer, see SetAppContainer.</span><br>  <span class="hljs-comment">// lockdown: the security level for the token that comes into force after the</span><br>  <span class="hljs-comment">//   process calls TargetServices::LowerToken() or the process calls</span><br>  <span class="hljs-comment">//   RevertToSelf(). See the explanation of each level in the TokenLevel</span><br>  <span class="hljs-comment">//   definition.</span><br>  <span class="hljs-comment">// Return value: SBOX_ALL_OK if the setting succeeds and false otherwise.</span><br>  <span class="hljs-comment">//   Returns false if the lockdown value is more permissive than the initial</span><br>  <span class="hljs-comment">//   value.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Important: most of the sandbox-provided security relies on this single</span><br>  <span class="hljs-comment">// setting. The caller should strive to set the lockdown level as restricted</span><br>  <span class="hljs-comment">// as possible.</span><br>  <span class="hljs-comment">// 设置initial和lockdown Token的接口由policy提供，token作为安全限制当然应该由policy控制</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">SetTokenLevel</span><span class="hljs-params">(TokenLevel initial, TokenLevel lockdown)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Returns the initial token level.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> TokenLevel <span class="hljs-title">GetInitialTokenLevel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Returns the lockdown token level.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> TokenLevel <span class="hljs-title">GetLockdownTokenLevel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Sets the security level of the Job Object to which the target process will</span><br>  <span class="hljs-comment">// belong. This setting is permanent and cannot be changed once the target</span><br>  <span class="hljs-comment">// process is spawned. The job controls the global security settings which</span><br>  <span class="hljs-comment">// can not be specified in the token security profile.</span><br>  <span class="hljs-comment">// job_level: the security level for the job. See the explanation of each</span><br>  <span class="hljs-comment">//   level in the JobLevel definition.</span><br>  <span class="hljs-comment">// ui_exceptions: specify what specific rights that are disabled in the</span><br>  <span class="hljs-comment">//   chosen job_level that need to be granted. Use this parameter to avoid</span><br>  <span class="hljs-comment">//   selecting the next permissive job level unless you need all the rights</span><br>  <span class="hljs-comment">//   that are granted in such level.</span><br>  <span class="hljs-comment">//   The exceptions can be specified as a combination of the following</span><br>  <span class="hljs-comment">//   constants:</span><br>  <span class="hljs-comment">// JOB_OBJECT_UILIMIT_HANDLES : grant access to all user-mode handles. These</span><br>  <span class="hljs-comment">//   include windows, icons, menus and various GDI objects. In addition the</span><br>  <span class="hljs-comment">//   target process can set hooks, and broadcast messages to other processes</span><br>  <span class="hljs-comment">//   that belong to the same desktop.</span><br>  <span class="hljs-comment">// JOB_OBJECT_UILIMIT_READCLIPBOARD : grant read-only access to the clipboard.</span><br>  <span class="hljs-comment">// JOB_OBJECT_UILIMIT_WRITECLIPBOARD : grant write access to the clipboard.</span><br>  <span class="hljs-comment">// JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS : allow changes to the system-wide</span><br>  <span class="hljs-comment">//   parameters as defined by the Win32 call SystemParametersInfo().</span><br>  <span class="hljs-comment">// JOB_OBJECT_UILIMIT_DISPLAYSETTINGS : allow programmatic changes to the</span><br>  <span class="hljs-comment">//  display settings.</span><br>  <span class="hljs-comment">// JOB_OBJECT_UILIMIT_GLOBALATOMS : allow access to the global atoms table.</span><br>  <span class="hljs-comment">// JOB_OBJECT_UILIMIT_DESKTOP : allow the creation of new desktops.</span><br>  <span class="hljs-comment">// JOB_OBJECT_UILIMIT_EXITWINDOWS : allow the call to ExitWindows().</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Return value: SBOX_ALL_OK if the setting succeeds and false otherwise.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Note: JOB_OBJECT_XXXX constants are defined in winnt.h and documented at</span><br>  <span class="hljs-comment">// length in:</span><br>  <span class="hljs-comment">//   http://msdn2.microsoft.com/en-us/library/ms684152.aspx</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Note: the recommended level is JOB_RESTRICTED or JOB_LOCKDOWN.</span><br>  <span class="hljs-comment">// 除了token外，还有job的安全限制</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">SetJobLevel</span><span class="hljs-params">(JobLevel job_level,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">uint32_t</span> ui_exceptions)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Returns the job level.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> JobLevel <span class="hljs-title">GetJobLevel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Sets a hard limit on the size of the commit set for the sandboxed process.</span><br>  <span class="hljs-comment">// If the limit is reached, the process will be terminated with</span><br>  <span class="hljs-comment">// SBOX_FATAL_MEMORY_EXCEEDED (7012).</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">SetJobMemoryLimit</span><span class="hljs-params">(<span class="hljs-type">size_t</span> memory_limit)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Specifies the desktop on which the application is going to run. If the</span><br>  <span class="hljs-comment">// desktop does not exist, it will be created. If alternate_winstation is</span><br>  <span class="hljs-comment">// set to true, the desktop will be created on an alternate window station.</span><br>  <span class="hljs-comment">// windows下除了job、token外，还需要设置alternate desktop而不能用user desktop，这三大组件连同IntegrityLevel可以参考chrome的sandbox.md文档</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">SetAlternateDesktop</span><span class="hljs-params">(<span class="hljs-type">bool</span> alternate_winstation)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Returns the name of the alternate desktop used. If an alternate window</span><br>  <span class="hljs-comment">// station is specified, the name is prepended by the window station name,</span><br>  <span class="hljs-comment">// followed by a backslash.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> base::string16 <span class="hljs-title">GetAlternateDesktop</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Precreates the desktop and window station, if any.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">CreateAlternateDesktop</span><span class="hljs-params">(<span class="hljs-type">bool</span> alternate_winstation)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Destroys the desktop and windows station.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">DestroyAlternateDesktop</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// IntegrityLevel是三大组件以外的一个“冗余”安全项</span><br>  <span class="hljs-comment">// Sets the integrity level of the process in the sandbox. Both the initial</span><br>  <span class="hljs-comment">// token and the main token will be affected by this. If the integrity level</span><br>  <span class="hljs-comment">// is set to a level higher than the current level, the sandbox will fail</span><br>  <span class="hljs-comment">// to start.</span><br>  <span class="hljs-comment">// 实际上最终是设置token的一个子集SID</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">SetIntegrityLevel</span><span class="hljs-params">(IntegrityLevel level)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Returns the initial integrity level used.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> IntegrityLevel <span class="hljs-title">GetIntegrityLevel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Sets the integrity level of the process in the sandbox. The integrity level</span><br>  <span class="hljs-comment">// will not take effect before you call LowerToken. User Interface Privilege</span><br>  <span class="hljs-comment">// Isolation is not affected by this setting and will remain off for the</span><br>  <span class="hljs-comment">// process in the sandbox. If the integrity level is set to a level higher</span><br>  <span class="hljs-comment">// than the current level, the sandbox will fail to start.</span><br>  <span class="hljs-comment">// LowerToken中使用了全局变量g_shared_delayed_integrity_level来设置进程token的SID</span><br>  <span class="hljs-comment">// 这货应该就是设置g_shared_delayed_integrity_level的，在LowerToken后这个IL才生效</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">SetDelayedIntegrityLevel</span><span class="hljs-params">(IntegrityLevel level)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Sets the LowBox token for sandboxed process. This is mutually exclusive</span><br>  <span class="hljs-comment">// with SetAppContainer method.</span><br>  <span class="hljs-comment">// 这个是win8以上才有的lowbox token</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">SetLowBox</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* sid)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Sets the mitigations enabled when the process is created. Most of these</span><br>  <span class="hljs-comment">// are implemented as attributes passed via STARTUPINFOEX. So they take</span><br>  <span class="hljs-comment">// effect before any thread in the target executes. The declaration of</span><br>  <span class="hljs-comment">// MitigationFlags is followed by a detailed description of each flag.</span><br>  <span class="hljs-comment">// 除了3+1的安全限制外，进程的缓解措施部署也依靠policy维护</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">SetProcessMitigations</span><span class="hljs-params">(MitigationFlags flags)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Returns the currently set mitigation flags.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> MitigationFlags <span class="hljs-title">GetProcessMitigations</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Sets process mitigation flags that don&#x27;t take effect before the call to</span><br>  <span class="hljs-comment">// LowerToken().</span><br>  <span class="hljs-comment">// 与IL一样，人性化的提供了LowerToken()前后的mitigation部署</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">SetDelayedProcessMitigations</span><span class="hljs-params">(MitigationFlags flags)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Returns the currently set delayed mitigation flags.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> MitigationFlags <span class="hljs-title">GetDelayedProcessMitigations</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Disconnect the target from CSRSS when TargetServices::LowerToken() is</span><br>  <span class="hljs-comment">// called inside the target.</span><br>  <span class="hljs-comment">// 一旦LowerToken那么就与csrss断开</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">SetDisconnectCsrss</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Sets the interceptions to operate in strict mode. By default, interceptions</span><br>  <span class="hljs-comment">// are performed in &quot;relaxed&quot; mode, where if something inside NTDLL.DLL is</span><br>  <span class="hljs-comment">// already patched we attempt to intercept it anyway. Setting interceptions</span><br>  <span class="hljs-comment">// to strict mode means that when we detect that the function is patched we&#x27;ll</span><br>  <span class="hljs-comment">// refuse to perform the interception.</span><br>  <span class="hljs-comment">// 拦截操作为严格模式，默认是宽松模式。</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">SetStrictInterceptions</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Set the handles the target process should inherit for stdout and</span><br>  <span class="hljs-comment">// stderr.  The handles the caller passes must remain valid for the</span><br>  <span class="hljs-comment">// lifetime of the policy object.  This only has an effect on</span><br>  <span class="hljs-comment">// Windows Vista and later versions.  These methods accept pipe and</span><br>  <span class="hljs-comment">// file handles, but not console handles.</span><br>  <span class="hljs-comment">// 句柄拥有者必须维持其生命周期，这里只接收管道和文件句柄，控制台句柄不行</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">SetStdoutHandle</span><span class="hljs-params">(HANDLE handle)</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">SetStderrHandle</span><span class="hljs-params">(HANDLE handle)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Adds a policy rule effective for processes spawned using this policy.</span><br>  <span class="hljs-comment">// subsystem: One of the above enumerated windows subsystems.</span><br>  <span class="hljs-comment">// semantics: One of the above enumerated FileSemantics.</span><br>  <span class="hljs-comment">// pattern: A specific full path or a full path with wildcard patterns.</span><br>  <span class="hljs-comment">//   The valid wildcards are:</span><br>  <span class="hljs-comment">//   &#x27;*&#x27; : Matches zero or more character. Only one in series allowed.</span><br>  <span class="hljs-comment">//   &#x27;?&#x27; : Matches a single character. One or more in series are allowed.</span><br>  <span class="hljs-comment">// Examples:</span><br>  <span class="hljs-comment">//   &quot;c:\\documents and settings\\vince\\*.dmp&quot;</span><br>  <span class="hljs-comment">//   &quot;c:\\documents and settings\\*\\crashdumps\\*.dmp&quot;</span><br>  <span class="hljs-comment">//   &quot;c:\\temp\\app_log_?????_chrome.txt&quot;</span><br>  <span class="hljs-comment">// 这个就是结合上面两个枚举，给各种资源开红绿灯，Interception会用到</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">AddRule</span><span class="hljs-params">(SubSystem subsystem,</span></span><br><span class="hljs-params"><span class="hljs-function">                             Semantics semantics,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* pattern)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Adds a dll that will be unloaded in the target process before it gets</span><br>  <span class="hljs-comment">// a chance to initialize itself. Typically, dlls that cause the target</span><br>  <span class="hljs-comment">// to crash go here.</span><br>  <span class="hljs-comment">// target初始化前需要unload的dll放在这儿</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">AddDllToUnload</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Adds a handle that will be closed in the target process after lockdown.</span><br>  <span class="hljs-comment">// A nullptr value for handle_name indicates all handles of the specified</span><br>  <span class="hljs-comment">// type. An empty string for handle_name indicates the handle is unnamed.</span><br>  <span class="hljs-comment">// lockdown之后target进程中需要关闭的句柄</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">AddKernelObjectToClose</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* handle_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* handle_name)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Adds a handle that will be shared with the target process. Does not take</span><br>  <span class="hljs-comment">// ownership of the handle.</span><br>  <span class="hljs-comment">// target进程共享的句柄，但并非ownership</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">AddHandleToShare</span><span class="hljs-params">(HANDLE handle)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Locks down the default DACL of the created lockdown and initial tokens</span><br>  <span class="hljs-comment">// to restrict what other processes are allowed to access a process&#x27; kernel</span><br>  <span class="hljs-comment">// resources.</span><br>  <span class="hljs-comment">// 这几个不太了解</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">SetLockdownDefaultDacl</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Enable OPM API redirection when in Win32k lockdown.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">SetEnableOPMRedirection</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// Enable OPM API emulation when in Win32k lockdown.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">GetEnableOPMRedirection</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Configure policy to use an AppContainer profile. |package_name| is the</span><br>  <span class="hljs-comment">// name of the profile to use. Specifying True for |create_profile| ensures</span><br>  <span class="hljs-comment">// the profile exists, if set to False process creation will fail if the</span><br>  <span class="hljs-comment">// profile has not already been created.</span><br>  <span class="hljs-comment">// 这个是AppContainer相关，暂时不管</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">AddAppContainerProfile</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* package_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">bool</span> create_profile)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Get the configured AppContainerProfile.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> scoped_refptr&lt;AppContainerProfile&gt; <span class="hljs-title">GetAppContainerProfile</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br> <span class="hljs-keyword">protected</span>:<br>  ~<span class="hljs-built_in">TargetPolicy</span>() &#123;&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>一个抽象基类就已经囊括四海了，与policy对象耦合的主要是两个模块，一个是target进程，另一个就是interceptions。</p><h3 id="tokenlevel"><code>TokenLevel</code></h3><p>3+1组合中，alternativedesktop没啥好说的，主要是防止窗口之间消息的苟且。而Job和Token则核心在于一个level：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The Token level specifies a set of  security profiles designed to</span><br><span class="hljs-comment">// provide the bulk of the security of sandbox.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  TokenLevel                 |Restricting   |Deny Only       |Privileges|</span><br><span class="hljs-comment">//                             |Sids          |Sids            |          |</span><br><span class="hljs-comment">// ----------------------------|--------------|----------------|----------|</span><br><span class="hljs-comment">// USER_LOCKDOWN               | Null Sid     | All            | None     |</span><br><span class="hljs-comment">// ----------------------------|--------------|----------------|----------|</span><br><span class="hljs-comment">// USER_RESTRICTED             | RESTRICTED   | All            | Traverse |</span><br><span class="hljs-comment">// ----------------------------|--------------|----------------|----------|</span><br><span class="hljs-comment">// USER_LIMITED                | Users        | All except:    | Traverse |</span><br><span class="hljs-comment">//                             | Everyone     | Users          |          |</span><br><span class="hljs-comment">//                             | RESTRICTED   | Everyone       |          |</span><br><span class="hljs-comment">//                             |              | Interactive    |          |</span><br><span class="hljs-comment">// ----------------------------|--------------|----------------|----------|</span><br><span class="hljs-comment">// USER_INTERACTIVE            | Users        | All except:    | Traverse |</span><br><span class="hljs-comment">//                             | Everyone     | Users          |          |</span><br><span class="hljs-comment">//                             | RESTRICTED   | Everyone       |          |</span><br><span class="hljs-comment">//                             | Owner        | Interactive    |          |</span><br><span class="hljs-comment">//                             |              | Local          |          |</span><br><span class="hljs-comment">//                             |              | Authent-users  |          |</span><br><span class="hljs-comment">//                             |              | User           |          |</span><br><span class="hljs-comment">// ----------------------------|--------------|----------------|----------|</span><br><span class="hljs-comment">// USER_NON_ADMIN              | None         | All except:    | Traverse |</span><br><span class="hljs-comment">//                             |              | Users          |          |</span><br><span class="hljs-comment">//                             |              | Everyone       |          |</span><br><span class="hljs-comment">//                             |              | Interactive    |          |</span><br><span class="hljs-comment">//                             |              | Local          |          |</span><br><span class="hljs-comment">//                             |              | Authent-users  |          |</span><br><span class="hljs-comment">//                             |              | User           |          |</span><br><span class="hljs-comment">// ----------------------------|--------------|----------------|----------|</span><br><span class="hljs-comment">// USER_RESTRICTED_SAME_ACCESS | All          | None           | All      |</span><br><span class="hljs-comment">// ----------------------------|--------------|----------------|----------|</span><br><span class="hljs-comment">// USER_UNPROTECTED            | None         | None           | All      |</span><br><span class="hljs-comment">// ----------------------------|--------------|----------------|----------|</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The above restrictions are actually a transformation that is applied to</span><br><span class="hljs-comment">// the existing broker process token. The resulting token that will be</span><br><span class="hljs-comment">// applied to the target process depends both on the token level selected</span><br><span class="hljs-comment">// and on the broker token itself.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  The LOCKDOWN and RESTRICTED are designed to allow access to almost</span><br><span class="hljs-comment">//  nothing that has security associated with and they are the recommended</span><br><span class="hljs-comment">//  levels to run sandboxed code specially if there is a chance that the</span><br><span class="hljs-comment">//  broker is process might be started by a user that belongs to the Admins</span><br><span class="hljs-comment">//  or power users groups.</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">TokenLevel</span> &#123;<br>  USER_LOCKDOWN = <span class="hljs-number">0</span>,<br>  USER_RESTRICTED,<br>  USER_LIMITED,<br>  USER_INTERACTIVE,<br>  USER_NON_ADMIN,<br>  USER_RESTRICTED_SAME_ACCESS,<br>  USER_UNPROTECTED,<br>  USER_LAST<br>&#125;;<br></code></pre></td></tr></table></figure><p>注释已经给出了非常详细的描述。</p><h3 id="joblevel"><code>JobLevel</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The Job level specifies a set of decreasing security profiles for the</span><br><span class="hljs-comment">// Job object that the target process will be placed into.</span><br><span class="hljs-comment">// This table summarizes the security associated with each level:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  JobLevel        |General                            |Quota               |</span><br><span class="hljs-comment">//                  |restrictions                       |restrictions        |</span><br><span class="hljs-comment">// -----------------|---------------------------------- |--------------------|</span><br><span class="hljs-comment">// JOB_NONE         | No job is assigned to the         | None               |</span><br><span class="hljs-comment">//                  | sandboxed process.                |                    |</span><br><span class="hljs-comment">// -----------------|---------------------------------- |--------------------|</span><br><span class="hljs-comment">// JOB_UNPROTECTED  | None                              | *Kill on Job close.|</span><br><span class="hljs-comment">// -----------------|---------------------------------- |--------------------|</span><br><span class="hljs-comment">// JOB_INTERACTIVE  | *Forbid system-wide changes using |                    |</span><br><span class="hljs-comment">//                  |  SystemParametersInfo().          | *Kill on Job close.|</span><br><span class="hljs-comment">//                  | *Forbid the creation/switch of    |                    |</span><br><span class="hljs-comment">//                  |  Desktops.                        |                    |</span><br><span class="hljs-comment">//                  | *Forbids calls to ExitWindows().  |                    |</span><br><span class="hljs-comment">// -----------------|---------------------------------- |--------------------|</span><br><span class="hljs-comment">// JOB_LIMITED_USER | Same as INTERACTIVE_USER plus:    | *One active process|</span><br><span class="hljs-comment">//                  | *Forbid changes to the display    |  limit.            |</span><br><span class="hljs-comment">//                  |  settings.                        | *Kill on Job close.|</span><br><span class="hljs-comment">// -----------------|---------------------------------- |--------------------|</span><br><span class="hljs-comment">// JOB_RESTRICTED   | Same as LIMITED_USER plus:        | *One active process|</span><br><span class="hljs-comment">//                  | * No read/write to the clipboard. |  limit.            |</span><br><span class="hljs-comment">//                  | * No access to User Handles that  | *Kill on Job close.|</span><br><span class="hljs-comment">//                  |   belong to other processes.      |                    |</span><br><span class="hljs-comment">//                  | * Forbid message broadcasts.      |                    |</span><br><span class="hljs-comment">//                  | * Forbid setting global hooks.    |                    |</span><br><span class="hljs-comment">//                  | * No access to the global atoms   |                    |</span><br><span class="hljs-comment">//                  |   table.                          |                    |</span><br><span class="hljs-comment">// -----------------|-----------------------------------|--------------------|</span><br><span class="hljs-comment">// JOB_LOCKDOWN     | Same as RESTRICTED                | *One active process|</span><br><span class="hljs-comment">//                  |                                   |  limit.            |</span><br><span class="hljs-comment">//                  |                                   | *Kill on Job close.|</span><br><span class="hljs-comment">//                  |                                   | *Kill on unhandled |</span><br><span class="hljs-comment">//                  |                                   |  exception.        |</span><br><span class="hljs-comment">//                  |                                   |                    |</span><br><span class="hljs-comment">// In the context of the above table, &#x27;user handles&#x27; refers to the handles of</span><br><span class="hljs-comment">// windows, bitmaps, menus, etc. Files, treads and registry handles are kernel</span><br><span class="hljs-comment">// handles and are not affected by the job level settings.</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">JobLevel</span> &#123;<br>  JOB_LOCKDOWN = <span class="hljs-number">0</span>,<br>  JOB_RESTRICTED,<br>  JOB_LIMITED_USER,<br>  JOB_INTERACTIVE,<br>  JOB_UNPROTECTED,<br>  JOB_NONE<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="integritylevel"><code>IntegrityLevel</code></h3><p>IL实际上最终会折射成token的子集SID。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// List of all the integrity levels supported in the sandbox. This is used</span><br><span class="hljs-comment">// only on Windows Vista and newer. You can&#x27;t set the integrity level of the</span><br><span class="hljs-comment">// process in the sandbox to a level higher than yours.</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IntegrityLevel</span> &#123;<br>  INTEGRITY_LEVEL_SYSTEM,<br>  INTEGRITY_LEVEL_HIGH,<br>  INTEGRITY_LEVEL_MEDIUM,<br>  INTEGRITY_LEVEL_MEDIUM_LOW,<br>  INTEGRITY_LEVEL_LOW,<br>  INTEGRITY_LEVEL_BELOW_LOW,<br>  INTEGRITY_LEVEL_UNTRUSTED,<br>  INTEGRITY_LEVEL_LAST<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过给不同进程不同的权限，也就做到了沙盒的资源限制的目的。这种机制的立足点在于，沙盒必须是进程粒度。</p><p>缓解措施相关此前已经看过了，都是些老生长谈的东西，不多说了。</p><h2 id="policybase"><code>PolicyBase</code></h2><p>真正的实现还是得看派生类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PolicyBase</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> TargetPolicy &#123;<span class="hljs-comment">//不会再派生了</span><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">PolicyBase</span>();<br><br>  <span class="hljs-comment">// TargetPolicy:</span><br>  <span class="hljs-comment">// 这些都是必须要override的方法</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRef</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Release</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">SetTokenLevel</span><span class="hljs-params">(TokenLevel initial, TokenLevel lockdown)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">TokenLevel <span class="hljs-title">GetInitialTokenLevel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">TokenLevel <span class="hljs-title">GetLockdownTokenLevel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">SetJobLevel</span><span class="hljs-params">(JobLevel job_level, <span class="hljs-type">uint32_t</span> ui_exceptions)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">JobLevel <span class="hljs-title">GetJobLevel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">SetJobMemoryLimit</span><span class="hljs-params">(<span class="hljs-type">size_t</span> memory_limit)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">SetAlternateDesktop</span><span class="hljs-params">(<span class="hljs-type">bool</span> alternate_winstation)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">base::string16 <span class="hljs-title">GetAlternateDesktop</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">CreateAlternateDesktop</span><span class="hljs-params">(<span class="hljs-type">bool</span> alternate_winstation)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyAlternateDesktop</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">SetIntegrityLevel</span><span class="hljs-params">(IntegrityLevel integrity_level)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">IntegrityLevel <span class="hljs-title">GetIntegrityLevel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">SetDelayedIntegrityLevel</span><span class="hljs-params">(IntegrityLevel integrity_level)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">SetLowBox</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* sid)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">SetProcessMitigations</span><span class="hljs-params">(MitigationFlags flags)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">MitigationFlags <span class="hljs-title">GetProcessMitigations</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">SetDelayedProcessMitigations</span><span class="hljs-params">(MitigationFlags flags)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">MitigationFlags <span class="hljs-title">GetDelayedProcessMitigations</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">SetDisconnectCsrss</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetStrictInterceptions</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">SetStdoutHandle</span><span class="hljs-params">(HANDLE handle)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">SetStderrHandle</span><span class="hljs-params">(HANDLE handle)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">AddRule</span><span class="hljs-params">(SubSystem subsystem,</span></span><br><span class="hljs-params"><span class="hljs-function">                     Semantics semantics,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* pattern)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">AddDllToUnload</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">AddKernelObjectToClose</span><span class="hljs-params">(<span class="hljs-type">const</span> base::char16* handle_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> base::char16* handle_name)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddHandleToShare</span><span class="hljs-params">(HANDLE handle)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetLockdownDefaultDacl</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetEnableOPMRedirection</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetEnableOPMRedirection</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">AddAppContainerProfile</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* package_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">bool</span> create_profile)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">scoped_refptr&lt;AppContainerProfile&gt; <span class="hljs-title">GetAppContainerProfile</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// 除了override的纯虚接口，还有几个help函数或者是combo函数</span><br>  <span class="hljs-comment">// Get the AppContainer profile as its internal type.</span><br>  <span class="hljs-comment">// 这个应该就是GetAppContainerProfile内部所用，AppContainerProfileBase应该是干实业的派生类</span><br>  <span class="hljs-function">scoped_refptr&lt;AppContainerProfileBase&gt; <span class="hljs-title">GetAppContainerProfileBase</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Creates a Job object with the level specified in a previous call to</span><br>  <span class="hljs-comment">// SetJobLevel().</span><br>  <span class="hljs-comment">// 这个在SpawnTarget中调用，用于生成job对象</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">MakeJobObject</span><span class="hljs-params">(base::win::ScopedHandle* job)</span></span>;<br><br>  <span class="hljs-comment">// Creates the two tokens with the levels specified in a previous call to</span><br>  <span class="hljs-comment">// SetTokenLevel(). Also creates a lowbox token if specified based on the</span><br>  <span class="hljs-comment">// lowbox SID.</span><br>  <span class="hljs-comment">// 这个也在SpawnTarget中调用，用于生成三个token</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">MakeTokens</span><span class="hljs-params">(base::win::ScopedHandle* initial,</span></span><br><span class="hljs-params"><span class="hljs-function">                        base::win::ScopedHandle* lockdown,</span></span><br><span class="hljs-params"><span class="hljs-function">                        base::win::ScopedHandle* lowbox)</span></span>;<br><br>  <span class="hljs-function">PSID <span class="hljs-title">GetLowBoxSid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Adds a target process to the internal list of targets. Internally a</span><br>  <span class="hljs-comment">// call to TargetProcess::Init() is issued.</span><br>  <span class="hljs-comment">// 多个target维护成内部的链表，通过这个接口来include TargetProcess</span><br>  <span class="hljs-comment">// 要知道Policy管理TargetProcess，同一个Policy对象意味着同样的安全限制，很多target进程的安全限制当然是一致的，所以都由一个Policy来管理。</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">AddTarget</span><span class="hljs-params">(TargetProcess* target)</span></span>;<br><br>  <span class="hljs-comment">// Called when there are no more active processes in a Job.</span><br>  <span class="hljs-comment">// Removes a Job object associated with this policy and the target associated</span><br>  <span class="hljs-comment">// with the job.</span><br>  <span class="hljs-comment">// job内target process全部终止时的事件响应，那么它的驱动是谁呢？</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OnJobEmpty</span><span class="hljs-params">(HANDLE job)</span></span>;<br><br>  <span class="hljs-comment">// 根据传入的params以及service id，进行可行性裁决</span><br>  <span class="hljs-comment">// 这牵扯到PolicyProcessor、PolicyOpcode这一套Policy裁决引擎机制</span><br>  <span class="hljs-function">EvalResult <span class="hljs-title">EvalPolicy</span><span class="hljs-params">(<span class="hljs-type">int</span> service, CountedParameterSetBase* params)</span></span>;<br><br>  <span class="hljs-function">HANDLE <span class="hljs-title">GetStdoutHandle</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function">HANDLE <span class="hljs-title">GetStderrHandle</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Returns the list of handles being shared with the target process.</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> base::HandlesToInheritVector&amp; <span class="hljs-title">GetHandlesBeingShared</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//实际上就是std::vector&lt;HANDLE&gt;</span><br><br> <span class="hljs-keyword">private</span>:<br>  ~<span class="hljs-built_in">PolicyBase</span>();<span class="hljs-comment">//外部只能new，不能delete。唯一的delete位置在Release中，private权限保护了自释放机制</span><br><br>  <span class="hljs-comment">// Sets up interceptions for a new target.</span><br>  <span class="hljs-comment">// 为target部署Interceptions</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">SetupAllInterceptions</span><span class="hljs-params">(TargetProcess* target)</span></span>;<br><br>  <span class="hljs-comment">// Sets up the handle closer for a new target.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetupHandleCloser</span><span class="hljs-params">(TargetProcess* target)</span></span>;<br><br>  <span class="hljs-comment">// AddRule内部所用helper</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">AddRuleInternal</span><span class="hljs-params">(SubSystem subsystem,</span></span><br><span class="hljs-params"><span class="hljs-function">                             Semantics semantics,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* pattern)</span></span>;<br><br>  <span class="hljs-comment">// This lock synchronizes operations on the targets_ collection.</span><br>  CRITICAL_SECTION lock_;<span class="hljs-comment">//对targets_集合的异步锁</span><br>  <span class="hljs-comment">// Maintains the list of target process associated with this policy.</span><br>  <span class="hljs-comment">// The policy takes ownership of them.</span><br>  <span class="hljs-comment">//这个targets_链表就是policy和TargetProcess的纽带了，保存了被该policy管理的所有target进程</span><br>  <span class="hljs-keyword">typedef</span> std::list&lt;TargetProcess*&gt; TargetSet;<br>  TargetSet targets_;<br>  <span class="hljs-comment">// Standard object-lifetime reference counter.</span><br>  <span class="hljs-keyword">volatile</span> LONG ref_count;<br>  <span class="hljs-comment">// The user-defined global policy settings.</span><br>  TokenLevel lockdown_level_;<br>  TokenLevel initial_level_;<br>  JobLevel job_level_;<br>  <span class="hljs-type">uint32_t</span> ui_exceptions_;<br>  <span class="hljs-type">size_t</span> memory_limit_;<br>  <span class="hljs-type">bool</span> use_alternate_desktop_;<br>  <span class="hljs-type">bool</span> use_alternate_winstation_;<br>  <span class="hljs-comment">// Helps the file system policy initialization.</span><br>  <span class="hljs-type">bool</span> file_system_init_;<br>  <span class="hljs-type">bool</span> relaxed_interceptions_;<br>  HANDLE stdout_handle_;<br>  HANDLE stderr_handle_;<br>  IntegrityLevel integrity_level_;<br>  IntegrityLevel delayed_integrity_level_;<br>  MitigationFlags mitigations_;<br>  MitigationFlags delayed_mitigations_;<br>  <span class="hljs-type">bool</span> is_csrss_connected_;<br>  <span class="hljs-comment">// Object in charge of generating the low level policy.</span><br>  <span class="hljs-comment">// Low level policy是架在PolicyOpcode和OpcodeFactory的一套rule裁决机制</span><br>  <span class="hljs-comment">// 下面两个类型都是这套机制用到的非常那个重要的结构，前者负责生成low level policy，后者存储policy</span><br>  <span class="hljs-comment">// 这些在日后分析policy engine及low-level policy时会详细展开。</span><br>  LowLevelPolicy* policy_maker_;<br>  <span class="hljs-comment">// Memory structure that stores the low level policy.</span><br>  PolicyGlobal* policy_;<br>  <span class="hljs-comment">// The list of dlls to unload in the target process.</span><br>  std::vector&lt;base::string16&gt; blacklisted_dlls_;<br>  <span class="hljs-comment">// This is a map of handle-types to names that we need to close in the</span><br>  <span class="hljs-comment">// target process. A null set means we need to close all handles of the</span><br>  <span class="hljs-comment">// given type.</span><br>  HandleCloser handle_closer_;<br>  PSID lowbox_sid_;<br>  base::win::ScopedHandle lowbox_directory_;<br>  std::unique_ptr&lt;Dispatcher&gt; dispatcher_;<br>  <span class="hljs-type">bool</span> lockdown_default_dacl_;<br><br>  <span class="hljs-type">static</span> HDESK alternate_desktop_handle_;<br>  <span class="hljs-type">static</span> HWINSTA alternate_winstation_handle_;<br>  <span class="hljs-type">static</span> HDESK alternate_desktop_local_winstation_handle_;<br>  <span class="hljs-type">static</span> IntegrityLevel alternate_desktop_integrity_level_label_;<br>  <span class="hljs-type">static</span> IntegrityLevel<br>      alternate_desktop_local_winstation_integrity_level_label_;<br><br>  <span class="hljs-comment">// Contains the list of handles being shared with the target process.</span><br>  <span class="hljs-comment">// This list contains handles other than the stderr/stdout handles which are</span><br>  <span class="hljs-comment">// shared with the target at times.</span><br>  <span class="hljs-comment">// 保存那些可以继承的句柄，包括stderr/stdout（如果父进程IsValid的话）</span><br>  base::HandlesToInheritVector handles_to_share_;<br>  <span class="hljs-type">bool</span> enable_opm_redirection_;<span class="hljs-comment">//这货我还不知道是干啥的</span><br><br>  scoped_refptr&lt;AppContainerProfileBase&gt; app_container_profile_;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(PolicyBase);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="构造和析构"><code>构造和析构</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PolicyBase::<span class="hljs-built_in">PolicyBase</span>()<br>    : <span class="hljs-built_in">ref_count</span>(<span class="hljs-number">1</span>),<span class="hljs-comment">//以1初始化</span><br>      <span class="hljs-built_in">lockdown_level_</span>(USER_LOCKDOWN),<br>      <span class="hljs-built_in">initial_level_</span>(USER_LOCKDOWN),<br>      <span class="hljs-built_in">job_level_</span>(JOB_LOCKDOWN),<br>      <span class="hljs-built_in">ui_exceptions_</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">memory_limit_</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">use_alternate_desktop_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">use_alternate_winstation_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">file_system_init_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">relaxed_interceptions_</span>(<span class="hljs-literal">true</span>),<br>      <span class="hljs-built_in">stdout_handle_</span>(INVALID_HANDLE_VALUE),<br>      <span class="hljs-built_in">stderr_handle_</span>(INVALID_HANDLE_VALUE),<br>      <span class="hljs-built_in">integrity_level_</span>(INTEGRITY_LEVEL_LAST),<br>      <span class="hljs-built_in">delayed_integrity_level_</span>(INTEGRITY_LEVEL_LAST),<br>      <span class="hljs-built_in">mitigations_</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">delayed_mitigations_</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">is_csrss_connected_</span>(<span class="hljs-literal">true</span>),<br>      <span class="hljs-built_in">policy_maker_</span>(<span class="hljs-literal">nullptr</span>),<br>      <span class="hljs-built_in">policy_</span>(<span class="hljs-literal">nullptr</span>),<br>      <span class="hljs-built_in">lowbox_sid_</span>(<span class="hljs-literal">nullptr</span>),<br>      <span class="hljs-built_in">lockdown_default_dacl_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">enable_opm_redirection_</span>(<span class="hljs-literal">false</span>) &#123;<br>  ::<span class="hljs-built_in">InitializeCriticalSection</span>(&amp;lock_);<br>  dispatcher_.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TopLevelDispatcher</span>(<span class="hljs-keyword">this</span>));<br>&#125;<br><br>PolicyBase::~<span class="hljs-built_in">PolicyBase</span>() &#123;<br>  TargetSet::iterator it;<br>  <span class="hljs-keyword">for</span> (it = targets_.<span class="hljs-built_in">begin</span>(); it != targets_.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    TargetProcess* target = (*it);<br>    <span class="hljs-keyword">delete</span> target;<br>  &#125;<br>  <span class="hljs-keyword">delete</span> policy_maker_;<br>  <span class="hljs-keyword">delete</span> policy_;<br><br>  <span class="hljs-keyword">if</span> (lowbox_sid_)<br>    ::<span class="hljs-built_in">LocalFree</span>(lowbox_sid_);<br><br>  ::<span class="hljs-built_in">DeleteCriticalSection</span>(&amp;lock_);<br>&#125;<br></code></pre></td></tr></table></figure><p>构造器没啥好说的，不过是成员变量初始化。至于析构，首先要删除所有的target对象，然后清理内部的policy相关对象以及其他资源。</p><h3 id="引用计数"><code>引用计数</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PolicyBase::AddRef</span><span class="hljs-params">()</span> </span>&#123;<br>  ::<span class="hljs-built_in">InterlockedIncrement</span>(&amp;ref_count);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PolicyBase::Release</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == ::<span class="hljs-built_in">InterlockedDecrement</span>(&amp;ref_count))<br>    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>都是原子操作，调用Release时，如果减到0就自我delete（还记得private析构吗）。</p><h3 id="token相关">token相关</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetTokenLevel</span><span class="hljs-params">(TokenLevel initial, TokenLevel lockdown)</span> </span>&#123;<br>  <span class="hljs-comment">// initial token必须得比lockdown token权限高</span><br>  <span class="hljs-keyword">if</span> (initial &lt; lockdown) &#123;<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>  &#125;<br>  <span class="hljs-comment">// 仅仅只是设定成员罢了，没有Windows系统上做实际生效的操作</span><br>  initial_level_ = initial;<br>  lockdown_level_ = lockdown;<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br><br><span class="hljs-function">TokenLevel <span class="hljs-title">PolicyBase::GetInitialTokenLevel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> initial_level_;<br>&#125;<br><br><span class="hljs-function">TokenLevel <span class="hljs-title">PolicyBase::GetLockdownTokenLevel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> lockdown_level_;<br>&#125;<br><br><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetLowBox</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* sid)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (base::win::<span class="hljs-built_in">GetVersion</span>() &lt; base::win::VERSION_WIN8)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_UNSUPPORTED;<br><br>  <span class="hljs-built_in">DCHECK</span>(sid);<br>  <span class="hljs-comment">// 如果app_container_profile_存在的话，是不能自行设置lowbox的，走app_container_profile_自己的那套体系</span><br>  <span class="hljs-keyword">if</span> (lowbox_sid_ || app_container_profile_)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ConvertStringSidToSid</span>(sid, &amp;lowbox_sid_))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br><br><span class="hljs-comment">// 对外直接接口，这是抽象基类没有定义的，也就是说抽象基类本不关心三个token是如何做出来的</span><br><span class="hljs-comment">// 但派生类的实现中，将三个token的make也放在了policy中</span><br><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::MakeTokens</span><span class="hljs-params">(base::win::ScopedHandle* initial,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  base::win::ScopedHandle* lockdown,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  base::win::ScopedHandle* lowbox)</span> </span>&#123;<br>  <span class="hljs-comment">// Create the &#x27;naked&#x27; token. This will be the permanent token associated</span><br>  <span class="hljs-comment">// with the process and therefore with any thread that is not impersonating.</span><br>  <span class="hljs-comment">// CreateRestrictedToken是个很复杂的东西，整集了tokenLevel、token和IL所有相关内容</span><br>  <span class="hljs-comment">// lockdown是OUT型参数，这里暂时简单理解成根据lockdown_level_和integrity_level_等条件做出了一个</span><br>  <span class="hljs-comment">// 需要的lockdown token，lockdown为句柄</span><br>  <span class="hljs-comment">// 实际上就是根据chrome的level分类填充info，最终通过CreateRestrictedToken API来创建windows的token</span><br>  DWORD result =<br>      <span class="hljs-built_in">CreateRestrictedToken</span>(lockdown_level_, integrity_level_, PRIMARY,<br>                            lockdown_default_dacl_, lockdown);<br>  <span class="hljs-keyword">if</span> (ERROR_SUCCESS != result)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>  <span class="hljs-comment">// alternate desktop相关，想要理解这些代码，需要先理解Windows这方面的安全机制</span><br>  <span class="hljs-comment">// If we&#x27;re launching on the alternate desktop we need to make sure the</span><br>  <span class="hljs-comment">// integrity label on the object is no higher than the sandboxed process&#x27;s</span><br>  <span class="hljs-comment">// integrity level. So, we lower the label on the desktop process if it&#x27;s</span><br>  <span class="hljs-comment">// not already low enough for our process.</span><br>  <span class="hljs-keyword">if</span> (use_alternate_desktop_ &amp;&amp; integrity_level_ != INTEGRITY_LEVEL_LAST) &#123;<br>    <span class="hljs-comment">// Integrity label enum is reversed (higher level is a lower value).</span><br>    <span class="hljs-built_in">static_assert</span>(INTEGRITY_LEVEL_SYSTEM &lt; INTEGRITY_LEVEL_UNTRUSTED,<br>                  <span class="hljs-string">&quot;Integrity level ordering reversed.&quot;</span>);<br>    HDESK desktop_handle = <span class="hljs-literal">nullptr</span>;<br>    IntegrityLevel desktop_integrity_level_label;<br>    <span class="hljs-keyword">if</span> (use_alternate_winstation_) &#123;<br>      desktop_handle = alternate_desktop_handle_;<br>      desktop_integrity_level_label = alternate_desktop_integrity_level_label_;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      desktop_handle = alternate_desktop_local_winstation_handle_;<br>      desktop_integrity_level_label =<br>          alternate_desktop_local_winstation_integrity_level_label_;<br>    &#125;<br>    <span class="hljs-comment">// If the desktop_handle hasn&#x27;t been created for any reason, skip this.</span><br>    <span class="hljs-keyword">if</span> (desktop_handle &amp;&amp; desktop_integrity_level_label &lt; integrity_level_) &#123;<br>      result =<br>          <span class="hljs-built_in">SetObjectIntegrityLabel</span>(desktop_handle, SE_WINDOW_OBJECT, <span class="hljs-string">L&quot;&quot;</span>,<br>                                  <span class="hljs-built_in">GetIntegrityLevelString</span>(integrity_level_));<br>      <span class="hljs-keyword">if</span> (ERROR_SUCCESS != result)<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>      <span class="hljs-keyword">if</span> (use_alternate_winstation_) &#123;<br>        alternate_desktop_integrity_level_label_ = integrity_level_;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        alternate_desktop_local_winstation_integrity_level_label_ =<br>            integrity_level_;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// lowbox相关</span><br>  <span class="hljs-keyword">if</span> (lowbox_sid_) &#123;<br>    <span class="hljs-keyword">if</span> (!lowbox_directory_.<span class="hljs-built_in">IsValid</span>()) &#123;<br>      result =<br>          <span class="hljs-built_in">CreateLowBoxObjectDirectory</span>(lowbox_sid_, <span class="hljs-literal">true</span>, &amp;lowbox_directory_);<br>      <span class="hljs-built_in">DCHECK</span>(result == ERROR_SUCCESS);<br>    &#125;<br><br>    <span class="hljs-comment">// The order of handles isn&#x27;t important in the CreateLowBoxToken call.</span><br>    <span class="hljs-comment">// The kernel will maintain a reference to the object directory handle.</span><br>    HANDLE saved_handles[<span class="hljs-number">1</span>] = &#123;lowbox_directory_.<span class="hljs-built_in">Get</span>()&#125;;<br>    DWORD saved_handles_count = lowbox_directory_.<span class="hljs-built_in">IsValid</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function">Sid <span class="hljs-title">package_sid</span><span class="hljs-params">(lowbox_sid_)</span></span>;<br>    <span class="hljs-function">SecurityCapabilities <span class="hljs-title">caps</span><span class="hljs-params">(package_sid)</span></span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateLowBoxToken</span>(lockdown-&gt;<span class="hljs-built_in">Get</span>(), PRIMARY, &amp;caps, saved_handles,<br>                          saved_handles_count, lowbox) != ERROR_SUCCESS) &#123;<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Create the &#x27;better&#x27; token. We use this token as the one that the main</span><br>  <span class="hljs-comment">// thread uses when booting up the process. It should contain most of</span><br>  <span class="hljs-comment">// what we need (before reaching main( ))</span><br>  <span class="hljs-comment">// 创建initial token</span><br>  result =<br>      <span class="hljs-built_in">CreateRestrictedToken</span>(initial_level_, integrity_level_, IMPERSONATION,<br>                            lockdown_default_dacl_, initial);<br>  <span class="hljs-keyword">if</span> (ERROR_SUCCESS != result)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br><br><span class="hljs-function">PSID <span class="hljs-title">PolicyBase::GetLowBoxSid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> lowbox_sid_;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="job相关">Job相关</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetJobLevel</span><span class="hljs-params">(JobLevel job_level, <span class="hljs-type">uint32_t</span> ui_exceptions)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (memory_limit_ &amp;&amp; job_level == JOB_NONE) &#123;<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>  &#125;<br>  job_level_ = job_level;<br>  ui_exceptions_ = ui_exceptions;<span class="hljs-comment">//job的ui绿灯，在分析job时会看到</span><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br><br><span class="hljs-function">JobLevel <span class="hljs-title">PolicyBase::GetJobLevel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> job_level_;<br>&#125;<br><br><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetJobMemoryLimit</span><span class="hljs-params">(<span class="hljs-type">size_t</span> memory_limit)</span> </span>&#123;<br>  memory_limit_ = memory_limit;<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br><br><span class="hljs-comment">//对外直接接口，job的生成也被派生类归纳到了policy中</span><br><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::MakeJobObject</span><span class="hljs-params">(base::win::ScopedHandle* job)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (job_level_ != JOB_NONE) &#123;<br>    <span class="hljs-comment">// Create the windows job object.</span><br>    Job job_obj;<br>    DWORD result =<br>        job_obj.<span class="hljs-built_in">Init</span>(job_level_, <span class="hljs-literal">nullptr</span>, ui_exceptions_, memory_limit_);<br>    <span class="hljs-keyword">if</span> (ERROR_SUCCESS != result)<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>    *job = job_obj.<span class="hljs-built_in">Take</span>();<span class="hljs-comment">//转移owner</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    *job = base::win::<span class="hljs-built_in">ScopedHandle</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="alternate-desktop相关">Alternate Desktop相关</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetAlternateDesktop</span><span class="hljs-params">(<span class="hljs-type">bool</span> alternate_winstation)</span> </span>&#123;<br>  use_alternate_desktop_ = <span class="hljs-literal">true</span>;<br>  use_alternate_winstation_ = alternate_winstation;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">CreateAlternateDesktop</span>(alternate_winstation);<br>&#125;<br><br><span class="hljs-function">base::string16 <span class="hljs-title">PolicyBase::GetAlternateDesktop</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-comment">// No alternate desktop or winstation. Return an empty string.</span><br>  <span class="hljs-keyword">if</span> (!use_alternate_desktop_ &amp;&amp; !use_alternate_winstation_) &#123;<br>    <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (use_alternate_winstation_) &#123;<br>    <span class="hljs-comment">// The desktop and winstation should have been created by now.</span><br>    <span class="hljs-comment">// If we hit this scenario, it means that the user ignored the failure</span><br>    <span class="hljs-comment">// during SetAlternateDesktop, so we ignore it here too.</span><br>    <span class="hljs-keyword">if</span> (!alternate_desktop_handle_ || !alternate_winstation_handle_) &#123;<br>      <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetFullDesktopName</span>(alternate_winstation_handle_,<br>                              alternate_desktop_handle_);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (!alternate_desktop_local_winstation_handle_) &#123;<br>      <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetFullDesktopName</span>(<span class="hljs-literal">nullptr</span>,<br>                              alternate_desktop_local_winstation_handle_);<br>  &#125;<br>&#125;<br><br><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::CreateAlternateDesktop</span><span class="hljs-params">(<span class="hljs-type">bool</span> alternate_winstation)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (alternate_winstation) &#123;<br>    <span class="hljs-comment">// Check if it&#x27;s already created.</span><br>    <span class="hljs-keyword">if</span> (alternate_winstation_handle_ &amp;&amp; alternate_desktop_handle_)<br>      <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br><br>    <span class="hljs-built_in">DCHECK</span>(!alternate_winstation_handle_);<br>    <span class="hljs-comment">// Create the window station.</span><br>    ResultCode result = <span class="hljs-built_in">CreateAltWindowStation</span>(&amp;alternate_winstation_handle_);<br>    <span class="hljs-keyword">if</span> (SBOX_ALL_OK != result)<br>      <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-comment">// Verify that everything is fine.</span><br>    <span class="hljs-keyword">if</span> (!alternate_winstation_handle_ ||<br>        <span class="hljs-built_in">GetWindowObjectName</span>(alternate_winstation_handle_).<span class="hljs-built_in">empty</span>())<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_CREATE_DESKTOP;<br><br>    <span class="hljs-comment">// Create the destkop.</span><br>    result = <span class="hljs-built_in">CreateAltDesktop</span>(alternate_winstation_handle_,<br>                              &amp;alternate_desktop_handle_);<br>    <span class="hljs-keyword">if</span> (SBOX_ALL_OK != result)<br>      <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-comment">// Verify that everything is fine.</span><br>    <span class="hljs-keyword">if</span> (!alternate_desktop_handle_ ||<br>        <span class="hljs-built_in">GetWindowObjectName</span>(alternate_desktop_handle_).<span class="hljs-built_in">empty</span>())<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_CREATE_DESKTOP;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Check if it already exists.</span><br>    <span class="hljs-keyword">if</span> (alternate_desktop_local_winstation_handle_)<br>      <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br><br>    <span class="hljs-comment">// Create the destkop.</span><br>    <span class="hljs-comment">// 实际上底层用到了SetProcessWindowStation和CreateDesktop API</span><br>    ResultCode result =<br>        <span class="hljs-built_in">CreateAltDesktop</span>(<span class="hljs-literal">nullptr</span>, &amp;alternate_desktop_local_winstation_handle_);<br>    <span class="hljs-keyword">if</span> (SBOX_ALL_OK != result)<br>      <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-comment">// Verify that everything is fine.</span><br>    <span class="hljs-keyword">if</span> (!alternate_desktop_local_winstation_handle_ ||<br>        <span class="hljs-built_in">GetWindowObjectName</span>(alternate_desktop_local_winstation_handle_).<span class="hljs-built_in">empty</span>())<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_CREATE_DESKTOP;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PolicyBase::DestroyAlternateDesktop</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (use_alternate_winstation_) &#123;<br>    <span class="hljs-keyword">if</span> (alternate_desktop_handle_) &#123;<br>      ::<span class="hljs-built_in">CloseDesktop</span>(alternate_desktop_handle_);<br>      alternate_desktop_handle_ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (alternate_winstation_handle_) &#123;<br>      ::<span class="hljs-built_in">CloseWindowStation</span>(alternate_winstation_handle_);<br>      alternate_winstation_handle_ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (alternate_desktop_local_winstation_handle_) &#123;<br>      ::<span class="hljs-built_in">CloseDesktop</span>(alternate_desktop_local_winstation_handle_);<br>      alternate_desktop_local_winstation_handle_ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的WinAPI封装细节就不展开了，固定的概念固定的使用套路，我个人称之为“原语”。</p><p>比如以<code>GetFullDesktopName</code>做例子，实际上非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">base::string16 <span class="hljs-title">GetFullDesktopName</span><span class="hljs-params">(HWINSTA winsta, HDESK desktop)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!desktop) &#123;<br>    <span class="hljs-built_in">NOTREACHED</span>();<br>    <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>();<br>  &#125;<br><br>  base::string16 name;<br>  <span class="hljs-keyword">if</span> (winsta) &#123;<br>    name = <span class="hljs-built_in">GetWindowObjectName</span>(winsta);<br>    name += <span class="hljs-string">L&#x27;\\&#x27;</span>;<br>  &#125;<br><br>  name += <span class="hljs-built_in">GetWindowObjectName</span>(desktop);<br>  <span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-function">base::string16 <span class="hljs-title">GetWindowObjectName</span><span class="hljs-params">(HANDLE handle)</span> </span>&#123;<br>  <span class="hljs-comment">// Get the size of the name.</span><br>  DWORD size = <span class="hljs-number">0</span>;<br>  ::<span class="hljs-built_in">GetUserObjectInformation</span>(handle, UOI_NAME, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, &amp;size);<br><br>  <span class="hljs-keyword">if</span> (!size) &#123;<br>    <span class="hljs-built_in">NOTREACHED</span>();<br>    <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// Create the buffer that will hold the name.</span><br>  <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">wchar_t</span>[]&gt; <span class="hljs-title">name_buffer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">wchar_t</span>[size])</span></span>;<br><br>  <span class="hljs-comment">// Query the name of the object.</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">GetUserObjectInformation</span>(handle, UOI_NAME, name_buffer.<span class="hljs-built_in">get</span>(), size,<br>                                  &amp;size)) &#123;<br>    <span class="hljs-built_in">NOTREACHED</span>();<br>    <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">string16</span>(name_buffer.<span class="hljs-built_in">get</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>归咎于API GetUserObjectInformation的强大。</p><h3 id="integritylevel相关">IntegrityLevel相关</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetIntegrityLevel</span><span class="hljs-params">(IntegrityLevel integrity_level)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (app_container_profile_)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>  integrity_level_ = integrity_level;<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br><br><span class="hljs-function">IntegrityLevel <span class="hljs-title">PolicyBase::GetIntegrityLevel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> integrity_level_;<br>&#125;<br><br><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetDelayedIntegrityLevel</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    IntegrityLevel integrity_level)</span> </span>&#123;<br>  delayed_integrity_level_ = integrity_level;<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>只是简单的传值，另外注意使用了appcontainer，就不能用integrity_level（实际上也没必要）。</p><h3 id="缓解措施相关">缓解措施相关</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetProcessMitigations</span><span class="hljs-params">(MitigationFlags flags)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (app_container_profile_ || !<span class="hljs-built_in">CanSetProcessMitigationsPreStartup</span>(flags))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>  mitigations_ = flags;<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br><br><span class="hljs-function">MitigationFlags <span class="hljs-title">PolicyBase::GetProcessMitigations</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> mitigations_;<br>&#125;<br><br><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::SetDelayedProcessMitigations</span><span class="hljs-params">(MitigationFlags flags)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CanSetProcessMitigationsPostStartup</span>(flags))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>  delayed_mitigations_ = flags;<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br><br><span class="hljs-function">MitigationFlags <span class="hljs-title">PolicyBase::GetDelayedProcessMitigations</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> delayed_mitigations_;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="target管理">Target管理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">PolicyBase::AddTarget</span><span class="hljs-params">(TargetProcess* target)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (policy_)<br>    policy_maker_-&gt;<span class="hljs-built_in">Done</span>();<br><br>  <span class="hljs-comment">// 先部署target的一些基础设施</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ApplyProcessMitigationsToSuspendedProcess</span>(target-&gt;<span class="hljs-built_in">Process</span>(),<br>                                                 mitigations_)) &#123;<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_APPLY_ASLR_MITIGATIONS;<br>  &#125;<br><br>  <span class="hljs-comment">// 部署target的Interceptions</span><br>  ResultCode ret = <span class="hljs-built_in">SetupAllInterceptions</span>(target);<br><br>  <span class="hljs-keyword">if</span> (ret != SBOX_ALL_OK)<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// 关闭句柄</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetupHandleCloser</span>(target))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_SETUP_HANDLE_CLOSER;<br><br>  DWORD win_error = ERROR_SUCCESS;<br>  <span class="hljs-comment">// Initialize the sandbox infrastructure for the target.</span><br>  <span class="hljs-comment">// TODO(wfh) do something with win_error code here.</span><br>  ret = target-&gt;<span class="hljs-built_in">Init</span>(dispatcher_.<span class="hljs-built_in">get</span>(), policy_, kIPCMemSize, kPolMemSize,<br>                     &amp;win_error);<br><br>  <span class="hljs-keyword">if</span> (ret != SBOX_ALL_OK)<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// 注意这里把delayed_integrity_level_给了g_shared_delayed_integrity_level</span><br>  <span class="hljs-comment">// 并把这个g_shared_delayed_integrity_level传给了broker，所以broker的LowerToken才能使用</span><br>  <span class="hljs-comment">// 合法的g_shared_delayed_integrity_level值</span><br>  g_shared_delayed_integrity_level = delayed_integrity_level_;<br>  ret = target-&gt;<span class="hljs-built_in">TransferVariable</span>(<span class="hljs-string">&quot;g_shared_delayed_integrity_level&quot;</span>,<br>                                 &amp;g_shared_delayed_integrity_level,<br>                                 <span class="hljs-built_in">sizeof</span>(g_shared_delayed_integrity_level));<br>  g_shared_delayed_integrity_level = INTEGRITY_LEVEL_LAST;<br>  <span class="hljs-keyword">if</span> (SBOX_ALL_OK != ret)<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// Add in delayed mitigations and pseudo-mitigations enforced at startup.</span><br>  <span class="hljs-comment">// 这个和g_shared_delayed_integrity_level同理，TransferVariable的作用也就显现了出来</span><br>  <span class="hljs-comment">// 跨进程传递全局变量值（两个进程都有这个全局变量，当然不是共享，只是同名）</span><br>  g_shared_delayed_mitigations =<br>      delayed_mitigations_ | <span class="hljs-built_in">FilterPostStartupProcessMitigations</span>(mitigations_);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CanSetProcessMitigationsPostStartup</span>(g_shared_delayed_mitigations))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br>  ret = target-&gt;<span class="hljs-built_in">TransferVariable</span>(<span class="hljs-string">&quot;g_shared_delayed_mitigations&quot;</span>,<br>                                 &amp;g_shared_delayed_mitigations,<br>                                 <span class="hljs-built_in">sizeof</span>(g_shared_delayed_mitigations));<br>  g_shared_delayed_mitigations = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (SBOX_ALL_OK != ret)<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-function">AutoLock <span class="hljs-title">lock</span><span class="hljs-params">(&amp;lock_)</span></span>;<br>  targets_.<span class="hljs-built_in">push_back</span>(target);<span class="hljs-comment">//终于放进去了</span><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="onjobempty"><code>OnJobEmpty()</code></h3><p>这个应该是收到job释放的消息，此时target就不要了，通过他的job来检索。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PolicyBase::OnJobEmpty</span><span class="hljs-params">(HANDLE job)</span> </span>&#123;<br>  <span class="hljs-function">AutoLock <span class="hljs-title">lock</span><span class="hljs-params">(&amp;lock_)</span></span>;<br>  TargetSet::iterator it;<br>  <span class="hljs-keyword">for</span> (it = targets_.<span class="hljs-built_in">begin</span>(); it != targets_.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    <span class="hljs-keyword">if</span> ((*it)-&gt;<span class="hljs-built_in">Job</span>() == job)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (it == targets_.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  TargetProcess* target = *it;<br>  targets_.<span class="hljs-built_in">erase</span>(it);<br>  <span class="hljs-keyword">delete</span> target;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本章节因为牵扯了大量的下层模块，所以初学者一定是一脸懵逼的（我第一次看这部分代码亦是如此），等到各个模块逐个击破后，也就豁然开朗了。</p><p>了解Policy这个安全管家的结构即可，这也是本次分析之旅的目的。</p>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-TargetProcess-analysis</title>
    <link href="/2018/05/13/chromium-sandbox-TargetProcess-analysis/"/>
    <url>/2018/05/13/chromium-sandbox-TargetProcess-analysis/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第三篇，主要分析了windows平台下，chrome的target进程的核心类TargetProcess。阅读本篇前，请先阅读前两篇。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-targetprocess-analysis">Chromium-sandbox-TargetProcess-analysis</h1><h2 id="targetprocess"><code>TargetProcess</code></h2><p>TargetServices的全局对象实例只是用于提供服务的，设置token、IntegrityLevel、Mitigations等安全组件。</p><p>Target进程的生产此前已在<code>BrokerServicesBase::SpawnTarget</code>中看到了，<code>TargetProcess</code>对象由policy对象接管，而policy对象通过<code>BrokerServicesBase::tracker_list_</code>相联系。</p><p>现在就来看看<code>TargetProcess</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TargetProcess models a target instance (child process). Objects of this</span><br><span class="hljs-comment">// class are owned by the Policy used to create them.</span><br><span class="hljs-comment">// TargetProcess对象表示一个target实例，即子进程，对象由创建它的Policy接管</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetProcess</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// The constructor takes ownership of |initial_token| and |lockdown_token|</span><br>  <span class="hljs-built_in">TargetProcess</span>(base::win::ScopedHandle initial_token,<br>                base::win::ScopedHandle lockdown_token,<br>                HANDLE job,<br>                ThreadProvider* thread_pool,<br>                <span class="hljs-type">const</span> std::vector&lt;Sid&gt;&amp; impersonation_capabilities);<br>  ~<span class="hljs-built_in">TargetProcess</span>();<br><br>  <span class="hljs-comment">// TODO(cpu): Currently there does not seem to be a reason to implement</span><br>  <span class="hljs-comment">// reference counting for this class since is internal, but kept the</span><br>  <span class="hljs-comment">// the same interface so the interception framework does not need to be</span><br>  <span class="hljs-comment">// touched at this point.</span><br>  <span class="hljs-comment">// 注释简述了对internal class定义空的引用计数接口函数的原因，和拦截框架有关</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRef</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Release</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>  <span class="hljs-comment">// Creates the new target process. The process is created suspended.</span><br>  <span class="hljs-comment">// 进程的创建，在BrokerServicesBase中我们看到new之后立即Create</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* exe_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* command_line,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">bool</span> inherit_handles,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">const</span> base::win::StartupInformation&amp; startup_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                    base::win::ScopedProcessInformation* target_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                    DWORD* win_error)</span></span>;<br><br>  <span class="hljs-comment">// Assign a new lowbox token to the process post creation. The process</span><br>  <span class="hljs-comment">// must still be in its initial suspended state, however this still</span><br>  <span class="hljs-comment">// might fail in the presence of third-party software.</span><br>  <span class="hljs-comment">// 这个和lowbow token有关，调用时进程必须得是初始化时的挂起态</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">AssignLowBoxToken</span><span class="hljs-params">(<span class="hljs-type">const</span> base::win::ScopedHandle&amp; token)</span></span>;<br><br>  <span class="hljs-comment">// Destroys the target process.</span><br>  <span class="hljs-comment">// 终止</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Terminate</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Creates the IPC objects such as the BrokerDispatcher and the</span><br>  <span class="hljs-comment">// IPC server. The IPC server uses the services of the thread_pool.</span><br>  <span class="hljs-comment">// IPC相关</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">Init</span><span class="hljs-params">(Dispatcher* ipc_dispatcher,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">void</span>* policy,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">uint32_t</span> shared_IPC_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">uint32_t</span> shared_policy_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                  DWORD* win_error)</span></span>;<br><br>  <span class="hljs-comment">// 下面是一些资源获取相关函数</span><br>  <span class="hljs-comment">// Returns the handle to the target process.</span><br>  <span class="hljs-function">HANDLE <span class="hljs-title">Process</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> sandbox_process_info_.<span class="hljs-built_in">process_handle</span>(); &#125;<br><br>  <span class="hljs-comment">// Returns the handle to the job object that the target process belongs to.</span><br>  <span class="hljs-function">HANDLE <span class="hljs-title">Job</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> job_; &#125;<br><br>  <span class="hljs-comment">// Returns the address of the target main exe. This is used by the</span><br>  <span class="hljs-comment">// interceptions framework.</span><br>  <span class="hljs-function">HMODULE <span class="hljs-title">MainModule</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;HMODULE&gt;(base_address_);<br>  &#125;<br><br>  <span class="hljs-comment">// Returns the name of the executable.</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> exe_name_.<span class="hljs-built_in">get</span>(); &#125;<br><br>  <span class="hljs-comment">// Returns the process id.</span><br>  <span class="hljs-function">DWORD <span class="hljs-title">ProcessId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> sandbox_process_info_.<span class="hljs-built_in">process_id</span>(); &#125;<br><br>  <span class="hljs-comment">// Returns the handle to the main thread.</span><br>  <span class="hljs-function">HANDLE <span class="hljs-title">MainThread</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> sandbox_process_info_.<span class="hljs-built_in">thread_handle</span>(); &#125;<br><br>  <span class="hljs-comment">// broker和target间传输32位变量</span><br>  <span class="hljs-comment">// Transfers a 32-bit variable between the broker and the target.</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">TransferVariable</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">void</span>* address, <span class="hljs-type">size_t</span> size)</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Details of the target process.</span><br>  base::win::ScopedProcessInformation sandbox_process_info_;<br>  <span class="hljs-comment">// The token associated with the process. It provides the core of the</span><br>  <span class="hljs-comment">// sbox security.</span><br>  <span class="hljs-comment">// 禁闭锁，这个是沙盒限制中token限制的核心</span><br>  base::win::ScopedHandle lockdown_token_;<br>  <span class="hljs-comment">// The token given to the initial thread so that the target process can</span><br>  <span class="hljs-comment">// start. It has more powers than the lockdown_token.</span><br>  <span class="hljs-comment">// 起始时使用的token，这个时候因为有很多需要高权限的任务要处理</span><br>  <span class="hljs-comment">// TargetServices的LowerToken的一个应用就是从initial到lockdown token</span><br>  base::win::ScopedHandle initial_token_;<br>  <span class="hljs-comment">// Kernel handle to the shared memory used by the IPC server.</span><br>  <span class="hljs-comment">// IPC server用到的共享内存</span><br>  base::win::ScopedHandle shared_section_;<br>  <span class="hljs-comment">// Job object containing the target process.</span><br>  <span class="hljs-comment">// 包含该target进程的job</span><br>  HANDLE job_;<br>  <span class="hljs-comment">// Reference to the IPC subsystem.</span><br>  <span class="hljs-comment">// IPC server是SharedMemIPCServer对象，这里维护了该server地址</span><br>  std::unique_ptr&lt;SharedMemIPCServer&gt; ipc_server_;<br>  <span class="hljs-comment">// Provides the threads used by the IPC. This class does not own this pointer.</span><br>  <span class="hljs-comment">// IPC server会借用线程池对象来作为处理Msg的工具，这里维护了线程池对象地址</span><br>  ThreadProvider* thread_pool_;<br>  <span class="hljs-comment">// Base address of the main executable</span><br>  <span class="hljs-type">void</span>* base_address_;<br>  <span class="hljs-comment">// Full name of the target executable.</span><br>  std::unique_ptr&lt;<span class="hljs-type">wchar_t</span>, base::FreeDeleter&gt; exe_name_;<br>  <span class="hljs-comment">/// List of capability sids for use when impersonating in an AC process.</span><br>  <span class="hljs-comment">// 和AppContainer相关的一个结构，应用AC时会指定一个Sid列表</span><br>  std::vector&lt;Sid&gt; impersonation_capabilities_;<br><br>  <span class="hljs-comment">// Function used for testing.</span><br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> TargetProcess* <span class="hljs-title">MakeTestTargetProcess</span><span class="hljs-params">(HANDLE process,</span></span><br><span class="hljs-params"><span class="hljs-function">                                              HMODULE base_address)</span></span>;<br><br>  <span class="hljs-built_in">DISALLOW_IMPLICIT_CONSTRUCTORS</span>(TargetProcess);<span class="hljs-comment">//TargetProcess的构造非常严格，杜绝一切自作聪明的隐式转换</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>大部分成员相对来说还是见名知意的，IPC以及拦截框架自成篇幅，这里暂时规避。</p><h3 id="构造和析构">构造和析构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  参考SpawnTarget中的调用：</span><br><span class="hljs-comment">    TargetProcess* target = new TargetProcess(</span><br><span class="hljs-comment">      std::move(initial_token), std::move(lockdown_token), job.Get(),</span><br><span class="hljs-comment">      thread_pool_.get(),</span><br><span class="hljs-comment">      profile ? profile-&gt;GetImpersonationCapabilities() : std::vector&lt;Sid&gt;());</span><br><span class="hljs-comment">*/</span><br>TargetProcess::<span class="hljs-built_in">TargetProcess</span>(base::win::ScopedHandle initial_token,<br>                             base::win::ScopedHandle lockdown_token,<br>                             HANDLE job,<br>                             ThreadProvider* thread_pool,<br>                             <span class="hljs-type">const</span> std::vector&lt;Sid&gt;&amp; impersonation_capabilities)<br>    <span class="hljs-comment">// This object owns everything initialized here except thread_pool and</span><br>    <span class="hljs-comment">// the job_ handle. The Job handle is closed by BrokerServices and results</span><br>    <span class="hljs-comment">// eventually in a call to our dtor.</span><br>  <span class="hljs-comment">// 实际上就是非常简单的成员初始化，lockdown/initial token，job, IPC server用到的thread_pool以及SID集合都是传进来的，base_address_此时未知所以先NULL</span><br>    : <span class="hljs-built_in">lockdown_token_</span>(std::<span class="hljs-built_in">move</span>(lockdown_token)),<br>      <span class="hljs-built_in">initial_token_</span>(std::<span class="hljs-built_in">move</span>(initial_token)),<br>      <span class="hljs-built_in">job_</span>(job),<br>      <span class="hljs-built_in">thread_pool_</span>(thread_pool),<br>      <span class="hljs-built_in">base_address_</span>(<span class="hljs-literal">nullptr</span>),<br>      <span class="hljs-built_in">impersonation_capabilities_</span>(impersonation_capabilities) &#123;&#125;<br></code></pre></td></tr></table></figure><p>此前在<code>BrokerServicesBase::SpawnTarget</code>中的构造体如此：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">base::win::ScopedProcessInformation process_info;<br>TargetProcess* target = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TargetProcess</span>(<br>    std::<span class="hljs-built_in">move</span>(initial_token), std::<span class="hljs-built_in">move</span>(lockdown_token), job.<span class="hljs-built_in">Get</span>(),<br>    thread_pool_.<span class="hljs-built_in">get</span>(),<br>    profile ? profile-&gt;<span class="hljs-built_in">GetImpersonationCapabilities</span>() : std::<span class="hljs-built_in">vector</span>&lt;Sid&gt;());<br></code></pre></td></tr></table></figure><p>显然各个功能部件都是外部造出来的，但是<code>TargetProcess</code>内部或掌控或关联了这些外部组件。</p><p>再看析构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TargetProcess::~<span class="hljs-built_in">TargetProcess</span>() &#123;<br>  <span class="hljs-comment">// Give a chance to the process to die. In most cases the JOB_KILL_ON_CLOSE</span><br>  <span class="hljs-comment">// will take effect only when the context changes. As far as the testing went,</span><br>  <span class="hljs-comment">// this wait was enough to switch context and kill the processes in the job.</span><br>  <span class="hljs-comment">// If this process is already dead, the function will return without waiting.</span><br>  <span class="hljs-comment">// For now, this wait is there only to do a best effort to prevent some leaks</span><br>  <span class="hljs-comment">// from showing up in purify.</span><br>  <span class="hljs-comment">// 进程如果还在，就手动终止</span><br>  <span class="hljs-keyword">if</span> (sandbox_process_info_.<span class="hljs-built_in">IsValid</span>()) &#123;<br>    ::<span class="hljs-built_in">WaitForSingleObject</span>(sandbox_process_info_.<span class="hljs-built_in">process_handle</span>(), <span class="hljs-number">50</span>);<br>    <span class="hljs-comment">// Terminate the process if it&#x27;s still alive, as its IPC server is going</span><br>    <span class="hljs-comment">// away. 1 is RESULT_CODE_KILLED.</span><br>    ::<span class="hljs-built_in">TerminateProcess</span>(sandbox_process_info_.<span class="hljs-built_in">process_handle</span>(), <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// ipc_server_ references our process handle, so make sure the former is shut</span><br>  <span class="hljs-comment">// down before the latter is closed (by ScopedProcessInformation).</span><br>  ipc_server_.<span class="hljs-built_in">reset</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="create"><code>Create()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Creates the target (child) process suspended and assigns it to the job</span><br><span class="hljs-comment">// object.</span><br><span class="hljs-comment">// 构造函数中job已经进来了，所以这个函数会创建process对象并与之关联</span><br><span class="hljs-function">ResultCode <span class="hljs-title">TargetProcess::Create</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* exe_path,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* command_line,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> inherit_handles,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> base::win::StartupInformation&amp; startup_info,</span></span><br><span class="hljs-params"><span class="hljs-function">    base::win::ScopedProcessInformation* target_info,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD* win_error)</span> </span>&#123;<br>  exe_name_.<span class="hljs-built_in">reset</span>(_wcsdup(exe_path));<br><br>  <span class="hljs-comment">// the command line needs to be writable by CreateProcess().</span><br>  <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">wchar_t</span>, base::FreeDeleter&gt; <span class="hljs-title">cmd_line</span><span class="hljs-params">(_wcsdup(command_line))</span></span>;<br><br>  <span class="hljs-comment">// 基本的几个标志位，没什么好解释的</span><br>  <span class="hljs-comment">// Start the target process suspended.</span><br>  DWORD flags =<br>      CREATE_SUSPENDED | CREATE_UNICODE_ENVIRONMENT | DETACHED_PROCESS;<br><br>  <span class="hljs-keyword">if</span> (startup_info.<span class="hljs-built_in">has_extended_startup_info</span>())<br>    flags |= EXTENDED_STARTUPINFO_PRESENT;<br><br>  <span class="hljs-keyword">if</span> (job_ &amp;&amp; base::win::<span class="hljs-built_in">GetVersion</span>() &lt; base::win::VERSION_WIN8) &#123;<br>    <span class="hljs-comment">// Windows 8 implements nested jobs, but for older systems we need to</span><br>    <span class="hljs-comment">// break out of any job we&#x27;re in to enforce our restrictions.</span><br>    <span class="hljs-comment">// win8以后可以嵌套关联job，对于win8以下，属于job的父进程的子进程不属于该job</span><br>    flags |= CREATE_BREAKAWAY_FROM_JOB;<br>  &#125;<br><br>  <span class="hljs-comment">// 使用传入的参数创建进程</span><br>  PROCESS_INFORMATION temp_process_info = &#123;&#125;;<br>  <span class="hljs-comment">// 这个函数说来话长，以lockdown_token指定的安全上下文环境创建进程</span><br>  <span class="hljs-comment">// 参考&lt;https://msdn.microsoft.com/en-us/library/ms682429.aspx&gt;</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">CreateProcessAsUserW</span>(lockdown_token_.<span class="hljs-built_in">Get</span>(), exe_path, cmd_line.<span class="hljs-built_in">get</span>(),<br>                              <span class="hljs-literal">nullptr</span>,  <span class="hljs-comment">// No security attribute.</span><br>                              <span class="hljs-literal">nullptr</span>,  <span class="hljs-comment">// No thread attribute.</span><br>                              inherit_handles, flags,<br>                              <span class="hljs-literal">nullptr</span>,  <span class="hljs-comment">// Use the environment of the caller.</span><br>                              <span class="hljs-literal">nullptr</span>,  <span class="hljs-comment">// Use current directory of the caller.</span><br>                              startup_info.<span class="hljs-built_in">startup_info</span>(),<br>                              &amp;temp_process_info)) &#123;<br>    *win_error = ::<span class="hljs-built_in">GetLastError</span>();<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CREATE_PROCESS;<br>  &#125;<br>  <span class="hljs-comment">// 应该是用于OUT参数target_info</span><br>  base::<span class="hljs-function">win::ScopedProcessInformation <span class="hljs-title">process_info</span><span class="hljs-params">(temp_process_info)</span></span>;<br><br>  <span class="hljs-keyword">if</span> (job_) &#123;<br>    <span class="hljs-comment">// Assign the suspended target to the windows job object.</span><br>    <span class="hljs-comment">// 把target进程与job绑定</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">AssignProcessToJobObject</span>(job_, process_info.<span class="hljs-built_in">process_handle</span>())) &#123;<br>      *win_error = ::<span class="hljs-built_in">GetLastError</span>();<br>      ::<span class="hljs-built_in">TerminateProcess</span>(process_info.<span class="hljs-built_in">process_handle</span>(), <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_ASSIGN_PROCESS_TO_JOB_OBJECT;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (initial_token_.<span class="hljs-built_in">IsValid</span>()) &#123;<br>    HANDLE impersonation_token = initial_token_.<span class="hljs-built_in">Get</span>();<br>    base::win::ScopedHandle app_container_token;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetAppContainerImpersonationToken</span>(<br>            process_info.<span class="hljs-built_in">process_handle</span>(), impersonation_token,<br>            impersonation_capabilities_, &amp;app_container_token)) &#123;<br>      impersonation_token = app_container_token.<span class="hljs-built_in">Get</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Change the token of the main thread of the new process for the</span><br>    <span class="hljs-comment">// impersonation token with more rights. This allows the target to start;</span><br>    <span class="hljs-comment">// otherwise it will crash too early for us to help.</span><br>    HANDLE temp_thread = process_info.<span class="hljs-built_in">thread_handle</span>();<br>    <span class="hljs-comment">// 先用inititial token（如果有AppContainer，就用appcontainer那套）设置target进程</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">SetThreadToken</span>(&amp;temp_thread, impersonation_token)) &#123;<br>      *win_error = ::<span class="hljs-built_in">GetLastError</span>();<br>      ::<span class="hljs-built_in">TerminateProcess</span>(process_info.<span class="hljs-built_in">process_handle</span>(), <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_SET_THREAD_TOKEN;<br>    &#125;<br>    initial_token_.<span class="hljs-built_in">Close</span>();<span class="hljs-comment">//从现在起initial_token就不会再用到了</span><br>  &#125;<br><br>  <span class="hljs-comment">// 这里果然把process_info给了OUT参数target_info</span><br>  <span class="hljs-keyword">if</span> (!target_info-&gt;<span class="hljs-built_in">DuplicateFrom</span>(process_info)) &#123;<br>    *win_error = ::<span class="hljs-built_in">GetLastError</span>();  <span class="hljs-comment">// This may or may not be correct.</span><br>    ::<span class="hljs-built_in">TerminateProcess</span>(process_info.<span class="hljs-built_in">process_handle</span>(), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_DUPLICATE_TARGET_INFO;<br>  &#125;<br><br>  <span class="hljs-comment">// process对象已经有了，可以获取基址了</span><br>  base_address_ = <span class="hljs-built_in">GetProcessBaseAddress</span>(process_info.<span class="hljs-built_in">process_handle</span>());<br>  <span class="hljs-built_in">DCHECK</span>(base_address_);<br>  <span class="hljs-keyword">if</span> (!base_address_) &#123;<br>    *win_error = ::<span class="hljs-built_in">GetLastError</span>();<br>    ::<span class="hljs-built_in">TerminateProcess</span>(process_info.<span class="hljs-built_in">process_handle</span>(), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_FIND_BASE_ADDRESS;<br>  &#125;<br><br>  <span class="hljs-comment">// sandbox_process_info保存target的进程信息，这里直接转移ownership</span><br>  sandbox_process_info_.<span class="hljs-built_in">Set</span>(process_info.<span class="hljs-built_in">Take</span>());<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="transfervariable"><code>TransferVariable()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">TargetProcess::TransferVariable</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">void</span>* address,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!sandbox_process_info_.<span class="hljs-built_in">IsValid</span>())<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_UNEXPECTED_CALL;<br><br>  <span class="hljs-type">void</span>* child_var = address;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SANDBOX_EXPORTS</span><br>  HMODULE <span class="hljs-keyword">module</span> = ::<span class="hljs-built_in">LoadLibrary</span>(exe_name_.<span class="hljs-built_in">get</span>());<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">module</span>)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>  child_var = ::<span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-keyword">module</span>, name);<br>  ::<span class="hljs-built_in">FreeLibrary</span>(<span class="hljs-keyword">module</span>);<br><br>  <span class="hljs-keyword">if</span> (!child_var)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>  <span class="hljs-comment">// 因为偏移相对基址固定，所以可以计算运行时的child_var地址</span><br>  <span class="hljs-type">size_t</span> offset =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(child_var) - <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-keyword">module</span>);<br>  child_var = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-built_in">MainModule</span>()) + offset;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">//address和size是传入的，写入地址值到address起始处</span><br>  <span class="hljs-comment">//注释说是broker和target传数据用，那address应该是共享内存</span><br>  SIZE_T written;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">WriteProcessMemory</span>(sandbox_process_info_.<span class="hljs-built_in">process_handle</span>(), child_var,<br>                            address, size, &amp;written))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>  <span class="hljs-keyword">if</span> (written != size)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数实际上非常有用，只是它的精髓在于参数的来源，某个很重要的组件会用到它。</p><h3 id="terminate"><code>Terminate()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TargetProcess::Terminate</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!sandbox_process_info_.<span class="hljs-built_in">IsValid</span>())<br>    <span class="hljs-keyword">return</span>;<br><br>  ::<span class="hljs-built_in">TerminateProcess</span>(sandbox_process_info_.<span class="hljs-built_in">process_handle</span>(), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="assignlowboxtoken"><code>AssignLowBoxToken()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">TargetProcess::AssignLowBoxToken</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> base::win::ScopedHandle&amp; token)</span> </span>&#123;<br>  <span class="hljs-comment">// 专门给Win8以上用的第三个token——lowbox</span><br>  <span class="hljs-comment">// 这个lowbox具体限制了什么，甚至initial和lockdown具体的限制等到分析Policy时才清楚</span><br>  <span class="hljs-keyword">if</span> (!token.<span class="hljs-built_in">IsValid</span>())<br>    <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>  PROCESS_ACCESS_TOKEN process_access_token = &#123;&#125;;<br>  process_access_token.token = token.<span class="hljs-built_in">Get</span>();<br><br>  NtSetInformationProcess SetInformationProcess = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-built_in">ResolveNTFunctionPtr</span>(<span class="hljs-string">&quot;NtSetInformationProcess&quot;</span>, &amp;SetInformationProcess);<br><br>  <span class="hljs-comment">//使用NtSetInformationProcess来替换</span><br>  NTSTATUS status = <span class="hljs-built_in">SetInformationProcess</span>(<br>      sandbox_process_info_.<span class="hljs-built_in">process_handle</span>(),<br>      <span class="hljs-built_in">static_cast</span>&lt;PROCESS_INFORMATION_CLASS&gt;(NtProcessInformationAccessToken),<br>      &amp;process_access_token, <span class="hljs-built_in">sizeof</span>(process_access_token));<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(status)) &#123;<br>    ::<span class="hljs-built_in">SetLastError</span>(<span class="hljs-built_in">GetLastErrorFromNtStatus</span>(status));<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_SET_LOW_BOX_TOKEN;<br>  &#125;<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-TargetServices-analysis</title>
    <link href="/2018/05/13/chromium-sandbox-TargetServices-analysis/"/>
    <url>/2018/05/13/chromium-sandbox-TargetServices-analysis/</url>
    
    <content type="html"><![CDATA[<p>本篇是sandbox源码剖析的第二篇，主要分析了windows平台下，chrome的target进程的APIInterface类TargetServices。阅读本篇前，请先阅读第一篇。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-targetservices-analysis">chromium-sandbox-TargetServices-analysis</h1><h2 id="targetservices"><code>TargetServices</code></h2><p>broker进程对应的是<code>BrokerServices</code>，而像renderer进程这种target进程则对应<code>TargetServices</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TargetServices models the current process from the perspective</span><br><span class="hljs-comment">// of a target process. To obtain a pointer to it use</span><br><span class="hljs-comment">// Sandbox::GetTargetServices(). Note that this call returns a non-null</span><br><span class="hljs-comment">// pointer only if this process is in fact a target. A process is a target</span><br><span class="hljs-comment">// only if the process was spawned by a call to BrokerServices::SpawnTarget().</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This API allows the target to gain access to resources with a high</span><br><span class="hljs-comment">// privilege token and then when it is ready to perform dangerous activities</span><br><span class="hljs-comment">// (such as download content from the web) it can lower its token and</span><br><span class="hljs-comment">// enter into locked-down (sandbox) mode.</span><br><span class="hljs-comment">// The typical usage is as follows:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   TargetServices* target_services = Sandbox::GetTargetServices();</span><br><span class="hljs-comment">//   if (target_services) &#123;</span><br><span class="hljs-comment">//     // We are the target.</span><br><span class="hljs-comment">//     target_services-&gt;Init();</span><br><span class="hljs-comment">//     // Do work that requires high privileges here.</span><br><span class="hljs-comment">//     // ....</span><br><span class="hljs-comment">//     // When ready to enter lock-down mode call LowerToken:</span><br><span class="hljs-comment">//     target_services-&gt;LowerToken();</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For more information see the BrokerServices API documentation.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetServices</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Initializes the target. Must call this function before any other.</span><br>  <span class="hljs-comment">// returns ALL_OK if successful. All other return values imply failure.</span><br>  <span class="hljs-comment">// If the return is ERROR_GENERIC, you can call ::GetLastError() to get</span><br>  <span class="hljs-comment">// more information.</span><br>  <span class="hljs-comment">// 经典的Init</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Discards the impersonation token and uses the lower token, call before</span><br>  <span class="hljs-comment">// processing any untrusted data or running third-party code. If this call</span><br>  <span class="hljs-comment">// fails the current process could be terminated immediately.</span><br>  <span class="hljs-comment">// 用于切换init token到lower token，之所以有这样的设计，是因为在关小黑屋之前，</span><br>  <span class="hljs-comment">// 有一些需要高权限处理的任务要预先处理</span><br>  <span class="hljs-comment">// target进程不是一开始就关小黑屋，而是调用之后才关禁闭</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">LowerToken</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Returns the ProcessState object. Through that object it&#x27;s possible to have</span><br>  <span class="hljs-comment">// information about the current state of the process, such as whether</span><br>  <span class="hljs-comment">// LowerToken has been called or not.</span><br>  <span class="hljs-comment">// 获取进程的状态，ProcessState本身是个类，描述了进程状态以及csrss的连接状况</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ProcessState* <span class="hljs-title">GetState</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br> <span class="hljs-keyword">protected</span>:<br>  ~<span class="hljs-built_in">TargetServices</span>() &#123;&#125;<span class="hljs-comment">//抽象基类，外部不会直接实例化基类</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>和<code>BrokerServices</code>的设计如出一辙，在阅读派生类<code>TargetServicesBase</code>前，先看看<code>ProcessState</code>。</p><h2 id="processstate"><code>ProcessState</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessState</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ProcessState</span>();<br>  <span class="hljs-comment">// 几个RT时作为参照的状态判断，这几个函数都不会修改对象成员</span><br>  <span class="hljs-comment">// Returns true if kernel32.dll has been loaded.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsKernel32Loaded</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-comment">// Returns true if main has been called.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InitCalled</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-comment">// Returns true if LowerToken has been called.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">RevertedToSelf</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-comment">// Returns true if Csrss is connected.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsCsrssConnected</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-comment">// 上面的可以看成是status的get，那么有get就会有set</span><br>  <span class="hljs-comment">// Set the current state.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetKernel32Loaded</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetInitCalled</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetRevertedToSelf</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetCsrssConnected</span><span class="hljs-params">(<span class="hljs-type">bool</span> csrss_connected)</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> process_state_;<br>  <span class="hljs-type">bool</span> csrss_connected_;<br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(ProcessState);<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以说是一目了然，<code>process_state</code>是个int值，几个状态的判定有着拓扑顺序，该值随着状态的设置而逐一递增，向下是包含关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ProcessState::<span class="hljs-built_in">ProcessState</span>() : <span class="hljs-built_in">process_state_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">csrss_connected_</span>(<span class="hljs-literal">true</span>) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ProcessState::IsKernel32Loaded</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> process_state_ != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ProcessState::InitCalled</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> process_state_ &gt; <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ProcessState::RevertedToSelf</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> process_state_ &gt; <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ProcessState::IsCsrssConnected</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> csrss_connected_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessState::SetKernel32Loaded</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!process_state_)<br>    process_state_ = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessState::SetInitCalled</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (process_state_ &lt; <span class="hljs-number">2</span>)<br>    process_state_ = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessState::SetRevertedToSelf</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (process_state_ &lt; <span class="hljs-number">3</span>)<br>    process_state_ = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessState::SetCsrssConnected</span><span class="hljs-params">(<span class="hljs-type">bool</span> csrss_connected)</span> </span>&#123;<br>  csrss_connected_ = csrss_connected;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出<code>ProcessState</code>提供的仅仅是Set/Get接口罢了，真正的驱动者才有意义。</p><h2 id="targetservicebase"><code>TargetServiceBase</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This class is an implementation of the  TargetServices.</span><br><span class="hljs-comment">// Look in the documentation of sandbox::TargetServices for more info.</span><br><span class="hljs-comment">// Do NOT add a destructor to this class without changing the implementation of</span><br><span class="hljs-comment">// the factory method.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetServicesBase</span> : <span class="hljs-keyword">public</span> TargetServices &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TargetServicesBase</span>();<br><br>  <span class="hljs-comment">// Public interface of TargetServices.</span><br>  <span class="hljs-comment">// 三个纯虚函数的override</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">Init</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LowerToken</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ProcessState* <span class="hljs-title">GetState</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<span class="hljs-comment">//TargetServiceBase才是ProcessState的真正驱动者</span><br><br>  <span class="hljs-comment">// Factory method.</span><br>  <span class="hljs-comment">// 静态工厂方法，提供给SandboxFactory类使用</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> TargetServicesBase* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Sends a simple IPC Message that has a well-known answer. Returns true</span><br>  <span class="hljs-comment">// if the IPC was successful and false otherwise. There are 2 versions of</span><br>  <span class="hljs-comment">// this test: 1 and 2. The first one send a simple message while the</span><br>  <span class="hljs-comment">// second one send a message with an in/out param.</span><br>  <span class="hljs-comment">// 一个用于测试IPC的函数，有两个版本</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TestIPCPing</span><span class="hljs-params">(<span class="hljs-type">int</span> version)</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  ~<span class="hljs-built_in">TargetServicesBase</span>() &#123;&#125;<span class="hljs-comment">// 限制该类对象只能在堆上，或由静态方法析构，这里显然是后者</span><br>  ProcessState process_state_;<span class="hljs-comment">// 这个就是第三方驱动者了，target需要持有一个成员来描述进程状态</span><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(TargetServicesBase);<span class="hljs-comment">//禁用拷贝构造和赋值操作</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>对比<code>BrokerServicesBase</code>，target显然要小一些，且target并没有应用单例模式，从Singleton继承<code>GetInstance</code>方法，所以自己提供了<code>GetInstance</code>方法供工厂类使用。</p><p>展开各成员看看具体做了什么。</p><h3 id="构造和析构"><code>构造和析构</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TargetServicesBase::<span class="hljs-built_in">TargetServicesBase</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><p>析构并未定义，只是以private权限做了声明，这里表示只能由static静态<code>GetInstance</code>方法操纵。根据类头的提示"DoNOT add a destructor to this class without changing the implementationof the factorymethod."，如果不修改工厂方法的实现机制，无需添加析构器。</p><h3 id="getinstance"><code>GetInstance()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TargetServicesBase* <span class="hljs-title">TargetServicesBase::GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Leak on purpose TargetServicesBase.</span><br>  <span class="hljs-keyword">if</span> (!g_target_services)<br>    g_target_services = <span class="hljs-built_in">new</span> (g_target_services_memory) TargetServicesBase;<br>  <span class="hljs-keyword">return</span> g_target_services;<br>&#125;<br></code></pre></td></tr></table></figure><p>非常奇怪的方法，搞了个全局指针，而对象分配在了<code>g_target_services_memory</code>起始处的内存空间。所以这实际上也是单例模式，只是对象部署在了全局变量的内存空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Used as storage for g_target_services, because other allocation facilities</span><br><span class="hljs-comment">// are not available early. We can&#x27;t use a regular function static because on</span><br><span class="hljs-comment">// VS2015, because the CRT tries to acquire a lock to guard initialization, but</span><br><span class="hljs-comment">// this code runs before the CRT is initialized.</span><br><span class="hljs-type">char</span> g_target_services_memory[<span class="hljs-built_in">sizeof</span>(TargetServicesBase)];<br>TargetServicesBase* g_target_services = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p>看起来和VS2015的CRT守护初始化时获取锁的机制有关，我也不懂。</p><h3 id="init"><code>Init()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">TargetServicesBase::Init</span><span class="hljs-params">()</span> </span>&#123;<br>  process_state_.<span class="hljs-built_in">SetInitCalled</span>();<span class="hljs-comment">//process_state_ =&gt; 2</span><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getstate"><code>GetState()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ProcessState* <span class="hljs-title">TargetServicesBase::GetState</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> &amp;process_state_;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lowertoken"><code>LowerToken()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Failure here is a breach of security so the process is terminated.</span><br><span class="hljs-comment">// 出于安全性考虑，这个函数必须成功</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TargetServicesBase::LowerToken</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// IntegrityLevel是应用在sandbox上的一种策略，思想源于Windows OS的IL</span><br>  <span class="hljs-comment">// 这里使用的IL也是个全局量，应该是在call入前由其他角色设定好了</span><br>  <span class="hljs-keyword">if</span> (ERROR_SUCCESS !=<br>      <span class="hljs-built_in">SetProcessIntegrityLevel</span>(g_shared_delayed_integrity_level))<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_INTEGRITY);<br>  <span class="hljs-comment">// 改ProcessState的标志</span><br>  process_state_.<span class="hljs-built_in">SetRevertedToSelf</span>(); .<span class="hljs-comment">// process_state_ =&gt; 3</span><br>  <span class="hljs-comment">// If the client code as called RegOpenKey, advapi32.dll has cached some</span><br>  <span class="hljs-comment">// handles. The following code gets rid of them.</span><br>  <span class="hljs-comment">// 清空缓存的handle</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">RevertToSelf</span>())<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_DROPTOKEN);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">FlushCachedRegHandles</span>())<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_FLUSHANDLES);<br>  <span class="hljs-keyword">if</span> (ERROR_SUCCESS != ::<span class="hljs-built_in">RegDisablePredefinedCache</span>())<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_CACHEDISABLE);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WarmupWindowsLocales</span>())<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_WARMUP);<br>  <span class="hljs-type">bool</span> is_csrss_connected = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CloseOpenHandles</span>(&amp;is_csrss_connected))<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_CLOSEHANDLES);<br>  process_state_.<span class="hljs-built_in">SetCsrssConnected</span>(is_csrss_connected);<br>  <span class="hljs-comment">// Enabling mitigations must happen last otherwise handle closing breaks</span><br>  <span class="hljs-comment">// 如果有mitigation，激活，使用的依然是全局量g_shared_delayed_mitigations</span><br>  <span class="hljs-keyword">if</span> (g_shared_delayed_mitigations &amp;&amp;<br>      !<span class="hljs-built_in">ApplyProcessMitigationsToCurrentProcess</span>(g_shared_delayed_mitigations))<br>    ::<span class="hljs-built_in">TerminateProcess</span>(::<span class="hljs-built_in">GetCurrentProcess</span>(), SBOX_FATAL_MITIGATION);<br>&#125;<br></code></pre></td></tr></table></figure><p>IntegrityLevel是sandbox使用的一种划分权限的等级制度，应用到各个进程上，不同类型的进程有着不同的IL，思想源于WindowsOS本身的IL，sandbox对他进行了包装：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// List of all the integrity levels supported in the sandbox. This is used</span><br><span class="hljs-comment">// only on Windows Vista and newer. You can&#x27;t set the integrity level of the</span><br><span class="hljs-comment">// process in the sandbox to a level higher than yours.</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IntegrityLevel</span> &#123;<br>  INTEGRITY_LEVEL_SYSTEM,<br>  INTEGRITY_LEVEL_HIGH,<br>  INTEGRITY_LEVEL_MEDIUM,<br>  INTEGRITY_LEVEL_MEDIUM_LOW,<br>  INTEGRITY_LEVEL_LOW,<br>  INTEGRITY_LEVEL_BELOW_LOW,<br>  INTEGRITY_LEVEL_UNTRUSTED,<br>  INTEGRITY_LEVEL_LAST<br>&#125;;<br></code></pre></td></tr></table></figure><p>展开看<code>SetProcessIntegrityLevel</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">SetProcessIntegrityLevel</span><span class="hljs-params">(IntegrityLevel integrity_level)</span> </span>&#123;<br>  <span class="hljs-comment">// We don&#x27;t check for an invalid level here because we&#x27;ll just let it</span><br>  <span class="hljs-comment">// fail on the SetTokenIntegrityLevel call later on.</span><br>  <span class="hljs-keyword">if</span> (integrity_level == INTEGRITY_LEVEL_LAST) &#123;<br>    <span class="hljs-comment">// No mandatory level specified, we don&#x27;t change it.</span><br>    <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>  &#125;<br><br>  HANDLE token_handle;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">OpenProcessToken</span>(<span class="hljs-built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_DEFAULT,<br>                          &amp;token_handle))<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br><br>  <span class="hljs-comment">// 我不太懂为什么要多此一举搞个智能指针，直接传HANDLE不行吗？</span><br>  base::<span class="hljs-function">win::ScopedHandle <span class="hljs-title">token</span><span class="hljs-params">(token_handle)</span></span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">SetTokenIntegrityLevel</span>(token.<span class="hljs-built_in">Get</span>(), integrity_level);<br>&#125;<br></code></pre></td></tr></table></figure><p>打开了进程Token后，对其进行IL进行调整：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">SetTokenIntegrityLevel</span><span class="hljs-params">(HANDLE token, IntegrityLevel integrity_level)</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* integrity_level_str = <span class="hljs-built_in">GetIntegrityLevelString</span>(integrity_level);<span class="hljs-comment">//这个函数做了IL到SID字符串的映射</span><br>  <span class="hljs-keyword">if</span> (!integrity_level_str) &#123;<br>    <span class="hljs-comment">// No mandatory level specified, we don&#x27;t change it.</span><br>    <span class="hljs-keyword">return</span> ERROR_SUCCESS;<br>  &#125;<br><br>  <span class="hljs-comment">// PSID就是Windows本身提供的SID，它是Token的子集。</span><br>  <span class="hljs-comment">// Windows API常规套路，素质三连(convert-&gt;set-&gt;free)</span><br>  PSID integrity_sid = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">ConvertStringSidToSid</span>(integrity_level_str, &amp;integrity_sid))<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">GetLastError</span>();<br><br>  TOKEN_MANDATORY_LABEL label = &#123;&#125;;<br>  label.Label.Attributes = SE_GROUP_INTEGRITY;<br>  label.Label.Sid = integrity_sid;<br><br>  DWORD size = <span class="hljs-built_in">sizeof</span>(TOKEN_MANDATORY_LABEL) + ::<span class="hljs-built_in">GetLengthSid</span>(integrity_sid);<br>  <span class="hljs-type">bool</span> result = ::<span class="hljs-built_in">SetTokenInformation</span>(token, TokenIntegrityLevel, &amp;label, size);<br>  <span class="hljs-keyword">auto</span> last_error = ::<span class="hljs-built_in">GetLastError</span>();<br>  ::<span class="hljs-built_in">LocalFree</span>(integrity_sid);<br><br>  <span class="hljs-keyword">return</span> result ? ERROR_SUCCESS : last_error;<br>&#125;<br><br><span class="hljs-comment">// SID str都是硬编码的</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* <span class="hljs-title">GetIntegrityLevelString</span><span class="hljs-params">(IntegrityLevel integrity_level)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (integrity_level) &#123;<br>    <span class="hljs-keyword">case</span> INTEGRITY_LEVEL_SYSTEM:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">L&quot;S-1-16-16384&quot;</span>;<br>    <span class="hljs-keyword">case</span> INTEGRITY_LEVEL_HIGH:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">L&quot;S-1-16-12288&quot;</span>;<br>    <span class="hljs-keyword">case</span> INTEGRITY_LEVEL_MEDIUM:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">L&quot;S-1-16-8192&quot;</span>;<br>    <span class="hljs-keyword">case</span> INTEGRITY_LEVEL_MEDIUM_LOW:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">L&quot;S-1-16-6144&quot;</span>;<br>    <span class="hljs-keyword">case</span> INTEGRITY_LEVEL_LOW:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">L&quot;S-1-16-4096&quot;</span>;<br>    <span class="hljs-keyword">case</span> INTEGRITY_LEVEL_BELOW_LOW:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">L&quot;S-1-16-2048&quot;</span>;<br>    <span class="hljs-keyword">case</span> INTEGRITY_LEVEL_UNTRUSTED:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">L&quot;S-1-16-0&quot;</span>;<br>    <span class="hljs-keyword">case</span> INTEGRITY_LEVEL_LAST:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">NOTREACHED</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此也就搞懂了，chrome所谓的IntergrityLevel不过是折射成了Windows进程中Token的SID。</p><p>mitigation则表示待应用到进程的各缓解措施。<code>MitigationFlags</code>是一组缓解措施flag常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// These flags correspond to various process-level mitigations (eg. ASLR and</span><br><span class="hljs-comment">// DEP). Most are implemented via UpdateProcThreadAttribute() plus flags for</span><br><span class="hljs-comment">// the PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY attribute argument; documented</span><br><span class="hljs-comment">// here: http://msdn.microsoft.com/en-us/library/windows/desktop/ms686880</span><br><span class="hljs-comment">// Some mitigations are implemented directly by the sandbox or emulated to</span><br><span class="hljs-comment">// the greatest extent possible when not directly supported by the OS.</span><br><span class="hljs-comment">// Flags that are unsupported for the target OS will be silently ignored.</span><br><span class="hljs-comment">// Flags that are invalid for their application (pre or post startup) will</span><br><span class="hljs-comment">// return SBOX_ERROR_BAD_PARAMS.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint64_t</span> MitigationFlags;<br><br><span class="hljs-comment">// 值的设定显然是“按位或”经典设计</span><br><span class="hljs-comment">// Permanently enables DEP for the target process. Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_DEP_ENABLE.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_DEP = <span class="hljs-number">0x00000001</span>;<br><br><span class="hljs-comment">// Permanently Disables ATL thunk emulation when DEP is enabled. Valid</span><br><span class="hljs-comment">// only when MITIGATION_DEP is passed. Corresponds to not passing</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_DEP_ATL_THUNK_ENABLE.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_DEP_NO_ATL_THUNK = <span class="hljs-number">0x00000002</span>;<br><br><span class="hljs-comment">// Enables Structured exception handling override prevention. Must be</span><br><span class="hljs-comment">// enabled prior to process start. Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_SEHOP = <span class="hljs-number">0x00000004</span>;<br><br><span class="hljs-comment">// Forces ASLR on all images in the child process. In debug builds, must be</span><br><span class="hljs-comment">// enabled after startup. Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON .</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_RELOCATE_IMAGE = <span class="hljs-number">0x00000008</span>;<br><br><span class="hljs-comment">// Refuses to load DLLs that cannot support ASLR. In debug builds, must be</span><br><span class="hljs-comment">// enabled after startup. Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_RELOCATE_IMAGE_REQUIRED = <span class="hljs-number">0x00000010</span>;<br><br><span class="hljs-comment">// Terminates the process on Windows heap corruption. Coresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_HEAP_TERMINATE = <span class="hljs-number">0x00000020</span>;<br><br><span class="hljs-comment">// Sets a random lower bound as the minimum user address. Must be</span><br><span class="hljs-comment">// enabled prior to process start. On 32-bit processes this is</span><br><span class="hljs-comment">// emulated to a much smaller degree. Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_BOTTOM_UP_ASLR = <span class="hljs-number">0x00000040</span>;<br><br><span class="hljs-comment">// Increases the randomness range of bottom-up ASLR to up to 1TB. Must be</span><br><span class="hljs-comment">// enabled prior to process start and with MITIGATION_BOTTOM_UP_ASLR.</span><br><span class="hljs-comment">// Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_HIGH_ENTROPY_ASLR = <span class="hljs-number">0x00000080</span>;<br><br><span class="hljs-comment">// Immediately raises an exception on a bad handle reference. Must be</span><br><span class="hljs-comment">// enabled after startup. Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_STRICT_HANDLE_CHECKS = <span class="hljs-number">0x00000100</span>;<br><br><span class="hljs-comment">// Sets the DLL search order to LOAD_LIBRARY_SEARCH_DEFAULT_DIRS. Additional</span><br><span class="hljs-comment">// directories can be added via the Windows AddDllDirectory() function.</span><br><span class="hljs-comment">// http://msdn.microsoft.com/en-us/library/windows/desktop/hh310515</span><br><span class="hljs-comment">// Must be enabled after startup.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_DLL_SEARCH_ORDER = <span class="hljs-number">0x00000200</span>;<br><br><span class="hljs-comment">// Changes the mandatory integrity level policy on the current process&#x27; token</span><br><span class="hljs-comment">// to enable no-read and no-execute up. This prevents a lower IL process from</span><br><span class="hljs-comment">// opening the process token for impersonate/duplicate/assignment.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_HARDEN_TOKEN_IL_POLICY = <span class="hljs-number">0x00000400</span>;<br><br><span class="hljs-comment">// Prevents the process from making Win32k calls. Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Applications linked to user32.dll or gdi32.dll make Win32k calls during</span><br><span class="hljs-comment">// setup, even if Win32k is not otherwise used. So they also need to add a rule</span><br><span class="hljs-comment">// with SUBSYS_WIN32K_LOCKDOWN and semantics FAKE_USER_GDI_INIT to allow the</span><br><span class="hljs-comment">// initialization to succeed.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_WIN32K_DISABLE = <span class="hljs-number">0x00000800</span>;<br><br><span class="hljs-comment">// Prevents certain built-in third party extension points from being used.</span><br><span class="hljs-comment">// - App_Init DLLs</span><br><span class="hljs-comment">// - Winsock Layered Service Providers (LSPs)</span><br><span class="hljs-comment">// - Global Windows Hooks (NOT thread-targeted hooks)</span><br><span class="hljs-comment">// - Legacy Input Method Editors (IMEs)</span><br><span class="hljs-comment">// I.e.: Disable legacy hooking mechanisms.  Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_EXTENSION_POINT_DISABLE = <span class="hljs-number">0x00001000</span>;<br><br><span class="hljs-comment">// Prevents the process from generating dynamic code or modifying executable</span><br><span class="hljs-comment">// code. Second option to allow thread-specific opt-out.</span><br><span class="hljs-comment">// - VirtualAlloc with PAGE_EXECUTE_*</span><br><span class="hljs-comment">// - VirtualProtect with PAGE_EXECUTE_*</span><br><span class="hljs-comment">// - MapViewOfFile with FILE_MAP_EXECUTE | FILE_MAP_WRITE</span><br><span class="hljs-comment">// - SetProcessValidCallTargets for CFG</span><br><span class="hljs-comment">// Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON and</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON_ALLOW_OPT_OUT.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_DYNAMIC_CODE_DISABLE = <span class="hljs-number">0x00002000</span>;<br><span class="hljs-type">const</span> MitigationFlags MITIGATION_DYNAMIC_CODE_DISABLE_WITH_OPT_OUT = <span class="hljs-number">0x00004000</span>;<br><span class="hljs-comment">// The following per-thread flag can be used with the</span><br><span class="hljs-comment">// ApplyMitigationsToCurrentThread API.  Requires the above process mitigation</span><br><span class="hljs-comment">// to be set on the current process.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_DYNAMIC_CODE_OPT_OUT_THIS_THREAD = <span class="hljs-number">0x00008000</span>;<br><br><span class="hljs-comment">// Prevents the process from loading non-system fonts into GDI.</span><br><span class="hljs-comment">// Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_NONSYSTEM_FONT_DISABLE = <span class="hljs-number">0x00010000</span>;<br><br><span class="hljs-comment">// Prevents the process from loading binaries NOT signed by MS.</span><br><span class="hljs-comment">// Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_FORCE_MS_SIGNED_BINS = <span class="hljs-number">0x00020000</span>;<br><br><span class="hljs-comment">// Blocks mapping of images from remote devices. Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_REMOTE_ALWAYS_ON.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_IMAGE_LOAD_NO_REMOTE = <span class="hljs-number">0x00040000</span>;<br><br><span class="hljs-comment">// Blocks mapping of images that have the low manditory label. Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_LOW_LABEL_ALWAYS_ON.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_IMAGE_LOAD_NO_LOW_LABEL = <span class="hljs-number">0x00080000</span>;<br><br><span class="hljs-comment">// Forces image load preference to prioritize the Windows install System32</span><br><span class="hljs-comment">// folder before dll load dir, application dir and any user dirs set.</span><br><span class="hljs-comment">// - Affects IAT resolution standard search path only, NOT direct LoadLibrary or</span><br><span class="hljs-comment">//   executable search path.</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_PREFER_SYSTEM32_ALWAYS_ON.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_IMAGE_LOAD_PREFER_SYS32 = <span class="hljs-number">0x00100000</span>;<br><br><span class="hljs-comment">// Prevents hyperthreads from interfering with indirect branch predictions.</span><br><span class="hljs-comment">// (SPECTRE Variant 2 mitigation.)  Corresponds to</span><br><span class="hljs-comment">// PROCESS_CREATION_MITIGATION_POLICY2_RESTRICT_INDIRECT_BRANCH_PREDICTION_ALWAYS_ON.</span><br><span class="hljs-type">const</span> MitigationFlags MITIGATION_RESTRICT_INDIRECT_BRANCH_PREDICTION =<br>    <span class="hljs-number">0x00200000</span>;<br></code></pre></td></tr></table></figure><p>其中大部分漏洞缓解措施，搞二进制安全的老司机大都耳熟能详。</p><p>看看如何Apply：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ApplyProcessMitigationsToCurrentProcess</span><span class="hljs-params">(MitigationFlags flags)</span> </span>&#123;<br>  <span class="hljs-comment">//判断startup后是否可以设置这些flags，实际上就是按位判断</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CanSetProcessMitigationsPostStartup</span>(flags))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  base::win::Version version = base::win::<span class="hljs-built_in">GetVersion</span>();<br>  HMODULE <span class="hljs-keyword">module</span> = ::<span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;kernel32.dll&quot;</span>);<br><br>  <span class="hljs-comment">// 对各种flag进行处理</span><br>  <span class="hljs-comment">// DLL search order，win8以上在kernel32.dll引入</span><br>  <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_DLL_SEARCH_ORDER) &#123;<br>    SetDefaultDllDirectoriesFunction set_default_dll_directories =<br>        <span class="hljs-built_in">reinterpret_cast</span>&lt;SetDefaultDllDirectoriesFunction&gt;(<br>            ::<span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-keyword">module</span>, <span class="hljs-string">&quot;SetDefaultDllDirectories&quot;</span>));<br><br>    <span class="hljs-comment">// Check for SetDefaultDllDirectories since it requires KB2533623.</span><br>    <span class="hljs-comment">// 设置从默认目录搜索DLL，猜测是防止从当前目录加载恶意DLL吧</span><br>    <span class="hljs-keyword">if</span> (set_default_dll_directories) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set_default_dll_directories</span>(LOAD_LIBRARY_SEARCH_DEFAULT_DIRS) &amp;&amp;<br>          ERROR_ACCESS_DENIED != ::<span class="hljs-built_in">GetLastError</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 堆污染时直接终止，这个往往非常头疼</span><br>  <span class="hljs-comment">// Set the heap to terminate on corruption</span><br>  <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_HEAP_TERMINATE) &#123;<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">HeapSetInformation</span>(<span class="hljs-literal">nullptr</span>, HeapEnableTerminationOnCorruption,<br>                              <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>) &amp;&amp;<br>        ERROR_ACCESS_DENIED != ::<span class="hljs-built_in">GetLastError</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//阻止更低IL进程访问进程token</span><br>  <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_HARDEN_TOKEN_IL_POLICY) &#123;<br>    DWORD error = <span class="hljs-built_in">HardenProcessIntegrityLevelPolicy</span>();<span class="hljs-comment">//封装了win的设定原语</span><br>    <span class="hljs-keyword">if</span> ((error != ERROR_SUCCESS) &amp;&amp; (error != ERROR_ACCESS_DENIED))<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(_WIN64)  <span class="hljs-comment">// DEP is always enabled on 64-bit.</span></span><br>  <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_DEP) &#123;<br>    DWORD dep_flags = PROCESS_DEP_ENABLE;<br><br>    <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_DEP_NO_ATL_THUNK)<br>      dep_flags |= PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION;<br><br>    <span class="hljs-comment">// 利用的是SetProcessDEPPolicy</span><br>    SetProcessDEPPolicyFunction set_process_dep_policy =<br>        <span class="hljs-built_in">reinterpret_cast</span>&lt;SetProcessDEPPolicyFunction&gt;(<br>            ::<span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-keyword">module</span>, <span class="hljs-string">&quot;SetProcessDEPPolicy&quot;</span>));<br>    <span class="hljs-keyword">if</span> (set_process_dep_policy) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set_process_dep_policy</span>(dep_flags) &amp;&amp;<br>          ERROR_ACCESS_DENIED != ::<span class="hljs-built_in">GetLastError</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">// This is all we can do in Win7 and below.</span><br>  <span class="hljs-comment">// Win7以下能设置的都设置了，使用SetProcessMitigationPolicy</span><br>  <span class="hljs-keyword">if</span> (version &lt; base::win::VERSION_WIN8)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  SetProcessMitigationPolicyFunction set_process_mitigation_policy =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;SetProcessMitigationPolicyFunction&gt;(<br>          ::<span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-keyword">module</span>, <span class="hljs-string">&quot;SetProcessMitigationPolicy&quot;</span>));<br>  <span class="hljs-keyword">if</span> (!set_process_mitigation_policy)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// Enable ASLR policies.</span><br>  <span class="hljs-comment">// ASLR</span><br>  <span class="hljs-comment">// 借助的是SetProcessMitigationPolicy</span><br>  <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_RELOCATE_IMAGE) &#123;<br>    PROCESS_MITIGATION_ASLR_POLICY policy = &#123;&#125;;<br>    policy.EnableForceRelocateImages = <span class="hljs-literal">true</span>;<br>    policy.DisallowStrippedImages =<br>        (flags &amp; MITIGATION_RELOCATE_IMAGE_REQUIRED) ==<br>        MITIGATION_RELOCATE_IMAGE_REQUIRED;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set_process_mitigation_policy</span>(ProcessASLRPolicy, &amp;policy,<br>                                       <span class="hljs-built_in">sizeof</span>(policy)) &amp;&amp;<br>        ERROR_ACCESS_DENIED != ::<span class="hljs-built_in">GetLastError</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Enable strict handle policies.</span><br>  <span class="hljs-comment">// 句柄的严格控制，一旦出现bad handle引用，立即抛异常</span><br>  <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_STRICT_HANDLE_CHECKS) &#123;<br>    PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY policy = &#123;&#125;;<br>    policy.HandleExceptionsPermanentlyEnabled =<br>        policy.RaiseExceptionOnInvalidHandleReference = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set_process_mitigation_policy</span>(ProcessStrictHandleCheckPolicy, &amp;policy,<br>                                       <span class="hljs-built_in">sizeof</span>(policy)) &amp;&amp;<br>        ERROR_ACCESS_DENIED != ::<span class="hljs-built_in">GetLastError</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Enable system call policies.</span><br>  <span class="hljs-comment">// 系统调用的禁止</span><br>  <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_WIN32K_DISABLE) &#123;<br>    PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY policy = &#123;&#125;;<br>    policy.DisallowWin32kSystemCalls = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set_process_mitigation_policy</span>(ProcessSystemCallDisablePolicy, &amp;policy,<br>                                       <span class="hljs-built_in">sizeof</span>(policy)) &amp;&amp;<br>        ERROR_ACCESS_DENIED != ::<span class="hljs-built_in">GetLastError</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Enable extension point policies.</span><br>  <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_EXTENSION_POINT_DISABLE) &#123;<br>    PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = &#123;&#125;;<br>    policy.DisableExtensionPoints = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set_process_mitigation_policy</span>(ProcessExtensionPointDisablePolicy,<br>                                       &amp;policy, <span class="hljs-built_in">sizeof</span>(policy)) &amp;&amp;<br>        ERROR_ACCESS_DENIED != ::<span class="hljs-built_in">GetLastError</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (version &lt; base::win::VERSION_WIN8_1)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// Enable dynamic code policies.</span><br>  <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_DYNAMIC_CODE_DISABLE ||<br>      flags &amp; MITIGATION_DYNAMIC_CODE_DISABLE_WITH_OPT_OUT) &#123;<br>    PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = &#123;&#125;;<br>    policy.ProhibitDynamicCode = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// Per-thread opt-out is only supported on &gt;= Anniversary.</span><br>    <span class="hljs-keyword">if</span> (version &gt;= base::win::VERSION_WIN10_RS1 &amp;&amp;<br>        flags &amp; MITIGATION_DYNAMIC_CODE_DISABLE_WITH_OPT_OUT) &#123;<br>      policy.AllowThreadOptOut = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set_process_mitigation_policy</span>(ProcessDynamicCodePolicy, &amp;policy,<br>                                       <span class="hljs-built_in">sizeof</span>(policy)) &amp;&amp;<br>        ERROR_ACCESS_DENIED != ::<span class="hljs-built_in">GetLastError</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//win10以下系统，能设定的也都设定了</span><br>  <span class="hljs-keyword">if</span> (version &lt; base::win::VERSION_WIN10)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// Enable font policies.</span><br>  <span class="hljs-comment">// win10可以禁用非系统字体的加载</span><br>  <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_NONSYSTEM_FONT_DISABLE) &#123;<br>    PROCESS_MITIGATION_FONT_DISABLE_POLICY policy = &#123;&#125;;<br>    policy.DisableNonSystemFonts = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set_process_mitigation_policy</span>(ProcessFontDisablePolicy, &amp;policy,<br>                                       <span class="hljs-built_in">sizeof</span>(policy)) &amp;&amp;<br>        ERROR_ACCESS_DENIED != ::<span class="hljs-built_in">GetLastError</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (version &lt; base::win::VERSION_WIN10_TH2)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// Enable binary signing policies.</span><br>  <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_FORCE_MS_SIGNED_BINS) &#123;<br>    PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY policy = &#123;&#125;;<br>    <span class="hljs-comment">// Allow only MS signed binaries.</span><br>    policy.MicrosoftSignedOnly = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> there are two other flags available to allow</span><br>    <span class="hljs-comment">// 1) Only Windows Store signed.</span><br>    <span class="hljs-comment">// 2) MS-signed, Win Store signed, and WHQL signed binaries.</span><br>    <span class="hljs-comment">// Support not added at the moment.</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set_process_mitigation_policy</span>(ProcessSignaturePolicy, &amp;policy,<br>                                       <span class="hljs-built_in">sizeof</span>(policy)) &amp;&amp;<br>        ERROR_ACCESS_DENIED != ::<span class="hljs-built_in">GetLastError</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Enable image load policies.</span><br>  <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_IMAGE_LOAD_NO_REMOTE ||<br>      flags &amp; MITIGATION_IMAGE_LOAD_NO_LOW_LABEL ||<br>      flags &amp; MITIGATION_IMAGE_LOAD_PREFER_SYS32) &#123;<br>    PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = &#123;&#125;;<br>    <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_IMAGE_LOAD_NO_REMOTE)<br>      policy.NoRemoteImages = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (flags &amp; MITIGATION_IMAGE_LOAD_NO_LOW_LABEL)<br>      policy.NoLowMandatoryLabelImages = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// PreferSystem32 is only supported on &gt;= Anniversary.</span><br>    <span class="hljs-keyword">if</span> (version &gt;= base::win::VERSION_WIN10_RS1 &amp;&amp;<br>        flags &amp; MITIGATION_IMAGE_LOAD_PREFER_SYS32) &#123;<br>      policy.PreferSystem32Images = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set_process_mitigation_policy</span>(ProcessImageLoadPolicy, &amp;policy,<br>                                       <span class="hljs-built_in">sizeof</span>(policy)) &amp;&amp;<br>        ERROR_ACCESS_DENIED != ::<span class="hljs-built_in">GetLastError</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>每一种缓解措施，详细展开怕是篇幅过巨，本文旨在理解代码的架构。</p><h3 id="testipcping"><code>TestIPCPing()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The broker services a &#x27;test&#x27; IPC service with the IPC_PING_TAG tag.</span><br><span class="hljs-comment">// broker有个test IPC服务器，使用IPC_PING_TAG标记</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TargetServicesBase::TestIPCPing</span><span class="hljs-params">(<span class="hljs-type">int</span> version)</span> </span>&#123;<br>  <span class="hljs-type">void</span>* memory = <span class="hljs-built_in">GetGlobalIPCMemory</span>();<br>  <span class="hljs-keyword">if</span> (!memory)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// SharedMemIPCClient是共享内存的IPC client，CrossCallReturn是返回时server填充的结构体</span><br>  <span class="hljs-function">SharedMemIPCClient <span class="hljs-title">ipc</span><span class="hljs-params">(memory)</span></span>;<br>  CrossCallReturn answer = &#123;<span class="hljs-number">0</span>&#125;;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == version) &#123;<br>    <span class="hljs-type">uint32_t</span> tick1 = ::<span class="hljs-built_in">GetTickCount</span>();<br>    <span class="hljs-type">uint32_t</span> cookie = <span class="hljs-number">717115</span>;<br>    <span class="hljs-comment">// CrossCall完成IPC请求，返回时answer已经被server填充好了</span><br>    <span class="hljs-comment">// CrossCall封装了很多细节，具体分析到IPC机制时再展开</span><br>    ResultCode code = <span class="hljs-built_in">CrossCall</span>(ipc, IPC_PING1_TAG, cookie, &amp;answer);<br><br>    <span class="hljs-keyword">if</span> (SBOX_ALL_OK != code) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// We should get two extended returns values from the IPC, one is the</span><br>    <span class="hljs-comment">// tick count on the broker and the other is the cookie times two.</span><br>    <span class="hljs-keyword">if</span> ((answer.extended_count != <span class="hljs-number">2</span>)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// We test the first extended answer to be within the bounds of the tick</span><br>    <span class="hljs-comment">// count only if there was no tick count wraparound.</span><br>    <span class="hljs-type">uint32_t</span> tick2 = ::<span class="hljs-built_in">GetTickCount</span>();<br>    <span class="hljs-keyword">if</span> (tick2 &gt;= tick1) &#123;<br>      <span class="hljs-keyword">if</span> ((answer.extended[<span class="hljs-number">0</span>].unsigned_int &lt; tick1) ||<br>          (answer.extended[<span class="hljs-number">0</span>].unsigned_int &gt; tick2)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (answer.extended[<span class="hljs-number">1</span>].unsigned_int != cookie * <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == version) &#123;<br>    <span class="hljs-comment">// 版本2的处理只是带上了参数，参数是个counted_buffer，携带了值cookie 717111</span><br>    <span class="hljs-comment">// 参数值具体意义不明，这个得分析对端server才懂</span><br>    <span class="hljs-type">uint32_t</span> cookie = <span class="hljs-number">717111</span>;<br>    <span class="hljs-function">InOutCountedBuffer <span class="hljs-title">counted_buffer</span><span class="hljs-params">(&amp;cookie, <span class="hljs-keyword">sizeof</span>(cookie))</span></span>;<br>    ResultCode code = <span class="hljs-built_in">CrossCall</span>(ipc, IPC_PING2_TAG, counted_buffer, &amp;answer);<br><br>    <span class="hljs-keyword">if</span> (SBOX_ALL_OK != code) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cookie != <span class="hljs-number">717111</span> * <span class="hljs-number">3</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这货和类主体架构关系不大，牵扯的大都是进程通信IPC的内容，以后分析到了再回头看。</p><h2 id="gettargetserivces"><code>GetTargetSerivces()</code></h2><p>再看工厂方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// GetTargetServices implementation must follow the same technique as the</span><br><span class="hljs-comment">// GetBrokerServices, but in this case the logic is the opposite.</span><br><span class="hljs-function">TargetServices* <span class="hljs-title">SandboxFactory::GetTargetServices</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Can&#x27;t be the target if the section handle is not valid.</span><br>  <span class="hljs-comment">// 这里就与BrokerServices相反了，也就是说执行到这里时，g_shared_section应该已经被初始化过了</span><br>  <span class="hljs-keyword">if</span> (!g_shared_section)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// We are the target</span><br>  s_is_broker = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// Creates and returns the target services implementation.</span><br>  <span class="hljs-keyword">return</span> TargetServicesBase::<span class="hljs-built_in">GetInstance</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总之，<code>TargetServices</code>相关的目的就是对target进程部署IntegrityLevel、Mitigation选项等。<code>LowerToken()</code>即是降权的核心接口。</p>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chromium-sandbox-BrokerServices-analysis</title>
    <link href="/2018/05/13/chromium-sandbox-BrokerServices/"/>
    <url>/2018/05/13/chromium-sandbox-BrokerServices/</url>
    
    <content type="html"><![CDATA[<p>最近一个半月一直在研究浏览器安全，在通读了浏览器安全白皮书，研读了各种优质相关资源后，将第一个目标锁定了chromium的sandbox。起初是对沙盒逃逸感兴趣，但深入到sandbox源码并分析了一些escape的writeup后，发现实际上沙盒逃逸的攻击面是不一而论的，仅仅搞懂了sandbox的原理依旧不够，sandbox的上下层接口往往才是安全焦点。然而我一直信奉“知其所以然”这一信条，研读chrome源码一方面可以提高对C++编码的理解，另一方面也更有机会揪出隐藏较深的bug乃至安全漏洞，这是庞大的googlefuzzer大军所做不到的。本篇是sandbox源码剖析的第一篇，主要分析了windows平台下，chrome的broker进程APIInterface类BrokerServices。</p><p>想要流程的阅读本系列你需要以下几个条件： 1.较高水平的C++编码能力（至少通读C++ Primer5th，刷过课后题，有一定编码量）。 2. 熟悉WindowsAPI编程，尤其是安全相关的内容。 3.对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p><span id="more"></span><h1id="chromium-sandbox-brokerservices-analysis">Chromium-sandbox-BrokerServices-analysis</h1><p>Chrome的browser进程也就是主进程叫做broker。</p><p>在研读<code>BrokerServices</code>和<code>TargetServices</code>之前，一定要先阅读chrome的一些文档：</p><ul><li>多进程架构</li><li>Chromium是如何展示网页的</li><li>沙盒</li><li>沙盒_FAQ</li></ul><h2 id="sandbox.brokerservices"><code>sandbox.BrokerServices</code></h2><p>显然应该在sandbox namespace中，直接看类头定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// BrokerServices exposes all the broker API.</span><br><span class="hljs-comment">// The basic use is to start the target(s) and wait for them to end.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This API is intended to be called in the following order</span><br><span class="hljs-comment">// (error checking omitted):</span><br><span class="hljs-comment">//  BrokerServices* broker = SandboxFactory::GetBrokerServices();</span><br><span class="hljs-comment">//  broker-&gt;Init();</span><br><span class="hljs-comment">//  PROCESS_INFORMATION target;</span><br><span class="hljs-comment">//  broker-&gt;SpawnTarget(target_exe_path, target_args, &amp;target);</span><br><span class="hljs-comment">//  ::ResumeThread(target-&gt;hThread);</span><br><span class="hljs-comment">//  // -- later you can call:</span><br><span class="hljs-comment">//  broker-&gt;WaitForAllTargets(option);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 彻头彻尾的抽象基类，只提供了4个纯虚函数接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BrokerServices</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Initializes the broker. Must be called before any other on this class.</span><br>  <span class="hljs-comment">// returns ALL_OK if successful. All other return values imply failure.</span><br>  <span class="hljs-comment">// If the return is ERROR_GENERIC, you can call ::GetLastError() to get</span><br>  <span class="hljs-comment">// more information.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">//chrome经典的Init</span><br><br>  <span class="hljs-comment">// Returns the interface pointer to a new, empty policy object. Use this</span><br>  <span class="hljs-comment">// interface to specify the sandbox policy for new processes created by</span><br>  <span class="hljs-comment">// SpawnTarget()</span><br>  <span class="hljs-comment">// 对生成的target进程所应用的沙盒策略，这是标准的职能分离</span><br>  <span class="hljs-comment">// scoped_refptr是个类模板，实现了智能指针机制，指向TargetPolicy对象</span><br>  <span class="hljs-comment">// TargetPolicy是个管理target进程Policy的对象，policy相当复杂，暂不关心</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> scoped_refptr&lt;TargetPolicy&gt; <span class="hljs-title">CreatePolicy</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Creates a new target (child process) in a suspended state.</span><br>  <span class="hljs-comment">// Parameters:</span><br>  <span class="hljs-comment">//   exe_path: This is the full path to the target binary. This parameter</span><br>  <span class="hljs-comment">//   can be null and in this case the exe path must be the first argument</span><br>  <span class="hljs-comment">//   of the command_line.</span><br>  <span class="hljs-comment">//   command_line: The arguments to be passed as command line to the new</span><br>  <span class="hljs-comment">//   process. This can be null if the exe_path parameter is not null.</span><br>  <span class="hljs-comment">//   policy: This is the pointer to the policy object for the sandbox to</span><br>  <span class="hljs-comment">//   be created.</span><br>  <span class="hljs-comment">//   last_warning: The argument will contain an indication on whether</span><br>  <span class="hljs-comment">//   the process security was initialized completely, Only set if the</span><br>  <span class="hljs-comment">//   process can be used without a serious compromise in security.</span><br>  <span class="hljs-comment">//   last_error: If an error or warning is returned from this method this</span><br>  <span class="hljs-comment">//   parameter will hold the last Win32 error value.</span><br>  <span class="hljs-comment">//   target: returns the resulting target process information such as process</span><br>  <span class="hljs-comment">//   handle and PID just as if CreateProcess() had been called. The caller is</span><br>  <span class="hljs-comment">//   responsible for closing the handles returned in this structure.</span><br>  <span class="hljs-comment">// Returns:</span><br>  <span class="hljs-comment">//   ALL_OK if successful. All other return values imply failure.</span><br>  <span class="hljs-comment">// 实际上就是CreateProcess的封装了</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">SpawnTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* exe_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* command_line,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 scoped_refptr&lt;TargetPolicy&gt; policy,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 ResultCode* last_warning,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 DWORD* last_error,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 PROCESS_INFORMATION* target)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// This call blocks (waits) for all the targets to terminate.</span><br>  <span class="hljs-comment">// Returns:</span><br>  <span class="hljs-comment">//   ALL_OK if successful. All other return values imply failure.</span><br>  <span class="hljs-comment">//   If the return is ERROR_GENERIC, you can call ::GetLastError() to get</span><br>  <span class="hljs-comment">//   more information.</span><br>  <span class="hljs-comment">// 实际上就是WaitForSingleObject的封装</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ResultCode <span class="hljs-title">WaitForAllTargets</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">//因为是虚基类，所以析构是protected，除了子类析构时会递归调用到，其他地方不该被调用到，这种提权可以在编译器发现一些语法错误</span><br>  ~<span class="hljs-built_in">BrokerServices</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>软件设计层面实际上broker就是多个target的monitor进程，通过IPC通信。<code>BrokerServices</code>类实际上并不是broker进程，而是为broker进程提供的一个API调用面。broker可以通过它的API来完成创建policy、创建target进程等工作。头起始也给出了broker进程中使用它来创建target的用法范例，尽管相对于<code>SpawnTarget</code>来说，有些过时了。</p><h3id="sandboxfactorygetbrokerservices"><code>SandboxFactory::GetBrokerServices()</code></h3><p>值得一提的是，范例中的broker对象创建使用的是<code>SandboxFactory::GetBrokerServices()</code>工厂方法，展开来看一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// sandbox的工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SandboxFactory</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Returns the Broker API interface, returns nullptr if this process is the</span><br>  <span class="hljs-comment">// target.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> BrokerServices* <span class="hljs-title">GetBrokerServices</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//生产broker</span><br><br>  <span class="hljs-comment">// Returns the Target API interface, returns nullptr if this process is the</span><br>  <span class="hljs-comment">// broker.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> TargetServices* <span class="hljs-title">GetTargetServices</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//生产target</span><br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">DISALLOW_IMPLICIT_CONSTRUCTORS</span>(SandboxFactory);<br>  <span class="hljs-comment">//禁用了隐式构造器，当然也包括默认赋值和默认复制构造</span><br>  <span class="hljs-comment">//这是因为SandboxFactory类提供的两个public方法都是static，所以SandboxFactory无需实例化，这一操作同样可以在编译器发现问题。</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们暂时只关心<code>GetBrokerServices()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// GetBrokerServices: the current implementation relies on a shared section</span><br><span class="hljs-comment">// that is created by the broker and opened by the target.</span><br><span class="hljs-function">BrokerServices* <span class="hljs-title">SandboxFactory::GetBrokerServices</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Can&#x27;t be the broker if the shared section is open.</span><br>  <span class="hljs-comment">// 看起来这个HANDLE有效时，其调用进程不是broker，而是target</span><br>  <span class="hljs-comment">// 根据g_shared_section的注释来看，它作为target/broker间IPC和policy交互的共享内存的句柄，所以我猜测它的初始化应该在broker进程调用该函数之后。</span><br>  <span class="hljs-keyword">if</span> (g_shared_section)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// If the shared section does not exist we are the broker, then create</span><br>  <span class="hljs-comment">// the broker object.</span><br>  <span class="hljs-comment">// s_is_broker是个static全局量，看起来也只在两个工厂方法里用到，分别表示是否是broker进程，但因为是个static的全局变量，该文件的其他位置也没有用到这货，可能是个reserved备胎吧。</span><br>  s_is_broker = <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">//这里就是关键的对象生成了，BrokerServices是抽象基类显然不干实业，BrokerServices的派生类是BrokerServicesBase，负责干活。</span><br>  <span class="hljs-keyword">return</span> BrokerServicesBase::<span class="hljs-built_in">GetInstance</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2id="sandbox.brokerservicesbase"><code>sandbox.BrokerServicesBase</code></h2><p>抽象基类没什么好深入的，行至<code>BrokerServicesBase::GetInstance()</code>也就山穷水尽了，这波看派生类操作就行了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// BrokerServicesBase ---------------------------------------------------------</span><br><span class="hljs-comment">// Broker implementation version 0</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This is an implementation of the interface BrokerServices and</span><br><span class="hljs-comment">// of the associated TargetProcess interface. In this implementation</span><br><span class="hljs-comment">// TargetProcess is a friend of BrokerServices where the later manages a</span><br><span class="hljs-comment">// collection of the former.</span><br><span class="hljs-comment">// 公有多继承BrokerServices和SingletonBase&lt;BrokerServicesBase&gt;类</span><br><span class="hljs-comment">// SingletonBase是个类模板，这里是对BrokerServicesBase应用了单例模式</span><br><span class="hljs-comment">// final表示不可被派生，也就表示这是最终实现体。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BrokerServicesBase</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> BrokerServices,<br>                                 <span class="hljs-keyword">public</span> SingletonBase&lt;BrokerServicesBase&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">BrokerServicesBase</span>();<br><br>  ~<span class="hljs-built_in">BrokerServicesBase</span>();<br><br>  <span class="hljs-comment">// BrokerServices interface.</span><br>  <span class="hljs-comment">// 4个纯虚函数的override</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">Init</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">scoped_refptr&lt;TargetPolicy&gt; <span class="hljs-title">CreatePolicy</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">SpawnTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* exe_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* command_line,</span></span><br><span class="hljs-params"><span class="hljs-function">                         scoped_refptr&lt;TargetPolicy&gt; policy,</span></span><br><span class="hljs-params"><span class="hljs-function">                         ResultCode* last_warning,</span></span><br><span class="hljs-params"><span class="hljs-function">                         DWORD* last_error,</span></span><br><span class="hljs-params"><span class="hljs-function">                         PROCESS_INFORMATION* target)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function">ResultCode <span class="hljs-title">WaitForAllTargets</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// Checks if the supplied process ID matches one of the broker&#x27;s active</span><br>  <span class="hljs-comment">// target processes</span><br>  <span class="hljs-comment">// Returns:</span><br>  <span class="hljs-comment">//   true if there is an active target process for this ID, otherwise false.</span><br>  <span class="hljs-comment">// 检查指定进程ID是否在broker的活跃目标进程集中                             </span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsActiveTarget</span><span class="hljs-params">(DWORD process_id)</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// The routine that the worker thread executes. It is in charge of</span><br>  <span class="hljs-comment">// notifications and cleanup-related tasks.</span><br>  <span class="hljs-comment">// 工作线程routine，负责通知和清理相关的任务。</span><br>  <span class="hljs-comment">// 应该是有谁用该static函数作为一个独立运行的线程，但既然是private，就应该源于内部</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> DWORD WINAPI <span class="hljs-title">TargetEventsThread</span><span class="hljs-params">(PVOID param)</span></span>;<br><br>  <span class="hljs-comment">// The completion port used by the job objects to communicate events to</span><br>  <span class="hljs-comment">// the worker thread.</span><br>  <span class="hljs-comment">// base::win::ScopedHandle是对Windows句柄HANDLE的一个封装，暂不理</span><br>  base::win::ScopedHandle job_port_;<span class="hljs-comment">//Job对象用此I/O完成端口与工作线程进行事件通信</span><br><br>  <span class="hljs-comment">// Handle to a manual-reset event that is signaled when the total target</span><br>  <span class="hljs-comment">// process count reaches zero.</span><br>  base::win::ScopedHandle no_targets_;<span class="hljs-comment">//这是个手动重置event，当全部target进程计数降到0时，signaled置信</span><br><br>  <span class="hljs-comment">// Handle to the worker thread that reacts to job notifications.</span><br>  base::win::ScopedHandle job_thread_;<span class="hljs-comment">//响应job通知的工作线程句柄</span><br><br>  <span class="hljs-comment">// Lock used to protect the list of targets from being modified by 2</span><br>  <span class="hljs-comment">// threads at the same time.</span><br>  CRITICAL_SECTION lock_;<span class="hljs-comment">//锁，防止target链同时被两个线程修改</span><br><br>  <span class="hljs-comment">// Provides a pool of threads that are used to wait on the IPC calls.</span><br>  std::unique_ptr&lt;ThreadProvider&gt; thread_pool_;<span class="hljs-comment">//线程池，用于等待IPC调用</span><br><br>  <span class="hljs-comment">// List of the trackers for closing and cleanup purposes.</span><br>  std::list&lt;std::unique_ptr&lt;JobTracker&gt;&gt; tracker_list_;<span class="hljs-comment">//关闭和清理的tracker list</span><br><br>  <span class="hljs-comment">// Provides a fast lookup to identify sandboxed processes that belong to a</span><br>  <span class="hljs-comment">// job. Consult |jobless_process_handles_| for handles of processes without</span><br>  <span class="hljs-comment">// jobs.</span><br>  std::set&lt;DWORD&gt; child_process_ids_;<span class="hljs-comment">//属于job对象的沙盒进程id集，可用于快速检索</span><br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(BrokerServicesBase);<span class="hljs-comment">//禁用默认复制构造和默认赋值操作，这是因为BrokerServicesBase是单例模式，只应该有构造和析构</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="构造和析构">构造和析构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp">BrokerServicesBase::<span class="hljs-built_in">BrokerServicesBase</span>() &#123;&#125;<span class="hljs-comment">// 纯粹是好习惯</span><br><br><span class="hljs-comment">// The destructor should only be called when the Broker process is terminating.</span><br><span class="hljs-comment">// Since BrokerServicesBase is a singleton, this is called from the CRT</span><br><span class="hljs-comment">// termination handlers, if this code lives on a DLL it is called during</span><br><span class="hljs-comment">// DLL_PROCESS_DETACH in other words, holding the loader lock, so we cannot</span><br><span class="hljs-comment">// wait for threads here.</span><br>BrokerServicesBase::~<span class="hljs-built_in">BrokerServicesBase</span>() &#123;<br>  <span class="hljs-comment">// If there is no port Init() was never called successfully.</span><br>  <span class="hljs-keyword">if</span> (!job_port_.<span class="hljs-built_in">IsValid</span>())<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// Closing the port causes, that no more Job notifications are delivered to</span><br>  <span class="hljs-comment">// the worker thread and also causes the thread to exit. This is what we</span><br>  <span class="hljs-comment">// want to do since we are going to close all outstanding Jobs and notifying</span><br>  <span class="hljs-comment">// the policy objects ourselves.</span><br>  <span class="hljs-comment">// 关闭I/O完成端口，Job通知不再转给工作线程，工作线程也会退出</span><br>  ::<span class="hljs-built_in">PostQueuedCompletionStatus</span>(job_port_.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, THREAD_CTRL_QUIT, <span class="hljs-literal">nullptr</span>);<br><br>  <span class="hljs-comment">// 等待工作线程退出</span><br>  <span class="hljs-keyword">if</span> (job_thread_.<span class="hljs-built_in">IsValid</span>() &amp;&amp;<br>      WAIT_TIMEOUT == ::<span class="hljs-built_in">WaitForSingleObject</span>(job_thread_.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">1000</span>)) &#123;<br>    <span class="hljs-comment">// Cannot clean broker services.</span><br>    <span class="hljs-built_in">NOTREACHED</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//资源清理</span><br>  tracker_list_.<span class="hljs-built_in">clear</span>();<br>  thread_pool_.<span class="hljs-built_in">reset</span>();<br><br>  ::<span class="hljs-built_in">DeleteCriticalSection</span>(&amp;lock_);<br>&#125;<br></code></pre></td></tr></table></figure><p>析构函数的调用时机仅仅在Broker进程被终止时。</p><p>Broker是单例，终止时要么由CRT的terminationhandler调用，要么在DLL_PROCESS_DETACH时机调用（这说明代码在DLL上）。</p><p>实际上直接看析构还是有点懵逼的，先看<code>Init</code>更好些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The broker uses a dedicated worker thread that services the job completion</span><br><span class="hljs-comment">// port to perform policy notifications and associated cleanup tasks.</span><br><span class="hljs-function">ResultCode <span class="hljs-title">BrokerServicesBase::Init</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (job_port_.<span class="hljs-built_in">IsValid</span>() || thread_pool_)<span class="hljs-comment">//防止二次Init</span><br>    <span class="hljs-keyword">return</span> SBOX_ERROR_UNEXPECTED_CALL;<br><br>  <span class="hljs-comment">//初始化用户态临界区锁</span><br>  ::<span class="hljs-built_in">InitializeCriticalSection</span>(&amp;lock_);<br><br>  <span class="hljs-comment">//创建IO完成端口，job_port是个封装的windows HANDLE类，Set方法关联</span><br>  job_port_.<span class="hljs-built_in">Set</span>(::<span class="hljs-built_in">CreateIoCompletionPort</span>(INVALID_HANDLE_VALUE, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>  <span class="hljs-keyword">if</span> (!job_port_.<span class="hljs-built_in">IsValid</span>())<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>  <span class="hljs-comment">//同样的套路创建Event和Thread对象，都没有设置安全属性</span><br>  <span class="hljs-comment">//event匿名，设置为手动reset，nonsignaled态</span><br>  no_targets_.<span class="hljs-built_in">Set</span>(::<span class="hljs-built_in">CreateEventW</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nullptr</span>));<br><br>  <span class="hljs-comment">//创建的线程入口就是static成员TargetEventsThread，传入的参数是对象broker本身</span><br>  job_thread_.<span class="hljs-built_in">Set</span>(::<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,  <span class="hljs-comment">// Default security and stack.</span><br>                                 TargetEventsThread, <span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>));<br>  <span class="hljs-keyword">if</span> (!job_thread_.<span class="hljs-built_in">IsValid</span>())<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_GENERIC;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<code>Init</code>函数就是对资源的初始化以及<code>TargetEventsThread</code>线程的启动。</p><blockquote><p><code>ResultCode</code>作为sandbox中泛用的返回值，是个枚举类型，可参考sandbox_types.h文件定义。</p></blockquote><h3 id="spawntarget"><code>SpawnTarget</code></h3><p>暂且先不管这个线程做什么，先看看Target进程是如何由broker生成的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// SpawnTarget does all the interesting sandbox setup and creates the target</span><br><span class="hljs-comment">// process inside the sandbox.</span><br><span class="hljs-comment">// 负责沙盒的安装、target进程的创建，是个相当复杂的函数</span><br><span class="hljs-function">ResultCode <span class="hljs-title">BrokerServicesBase::SpawnTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* exe_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* command_line,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           scoped_refptr&lt;TargetPolicy&gt; policy,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           ResultCode* last_warning,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           DWORD* last_error,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           PROCESS_INFORMATION* target_info)</span> </span>&#123;<br>  <span class="hljs-comment">//target process二进制全路径，这里不能为NULL</span><br>  <span class="hljs-comment">//实际上这里的实现体和虚基类的说法不太一致，虚基类的纯虚接口允许exe_path为NULL，但此时command_line的第一元必须为exe_path</span><br>  <span class="hljs-keyword">if</span> (!exe_path)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br>  <span class="hljs-comment">//应用于target进程的policy也不能为空，必须要提前通过CreatePolicy创建好，传入参数在该函数内关联，暂且先不管CreatePolicy做了什么。</span><br>  <span class="hljs-keyword">if</span> (!policy)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br>  <span class="hljs-comment">// Even though the resources touched by SpawnTarget can be accessed in</span><br>  <span class="hljs-comment">// multiple threads, the method itself cannot be called from more than</span><br>  <span class="hljs-comment">// 1 thread. This is to protect the global variables used while setting up</span><br>  <span class="hljs-comment">// the child process.</span><br>  <span class="hljs-comment">// 这里的static局部变量以及锁是对线程重入做的限制，尽管SpawnTarget中资源可以被多个线程访问，但该方法本身一次只能有1个线程调用</span><br>  <span class="hljs-type">static</span> DWORD thread_id = ::<span class="hljs-built_in">GetCurrentThreadId</span>();<br>  <span class="hljs-comment">// 到这里如果两次id不一致，说明是A-&gt;B-&gt;A，B改变了A设置的static thread_id</span><br>  <span class="hljs-comment">// 这个时候A就应该终止，由B继续进行</span><br>  <span class="hljs-built_in">DCHECK</span>(thread_id == ::<span class="hljs-built_in">GetCurrentThreadId</span>());<br>  *last_warning = SBOX_ALL_OK;<br><br>  <span class="hljs-comment">// 其实我不是很懂为什么要搞个static的thread_id，直接上锁不就行了吗，是为了记录thread_id吗？</span><br>  <span class="hljs-comment">// 上锁，AutoLock是个自动获取和释放CRITICAL_SECTION锁的类</span><br>  <span class="hljs-comment">// lock是个栈局部变量，函数返回后对象会析构，析构会release锁</span><br>  <span class="hljs-function">AutoLock <span class="hljs-title">lock</span><span class="hljs-params">(&amp;lock_)</span></span>;<br><br>  <span class="hljs-comment">// This downcast is safe as long as we control CreatePolicy()</span><br>  <span class="hljs-comment">// policy尽管是 scoped_refptr&lt;TargetPolicy&gt;对象，但实际上CreatePolicy()时父类引用调用的是子类PolicyBase对象成员函数，标准的多态</span><br>  <span class="hljs-comment">// 之所以做了向下转型，是因为虚基类TargetPolicy并没有定义要如何实现安全策略，使用了token、job等策略的PolicyBase只是一种实现体罢了。这就是OO的魅力，扩展性极强。</span><br>  <span class="hljs-comment">// 当然，向下转型的使用前提是，必须已知父类引用指向的是某个具体的派生类，且只能是该派生类。</span><br>  <span class="hljs-function">scoped_refptr&lt;PolicyBase&gt; <span class="hljs-title">policy_base</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&lt;PolicyBase*&gt;(policy.get()))</span></span>;<br><br>  <span class="hljs-comment">// Construct the tokens and the job object that we are going to associate</span><br>  <span class="hljs-comment">// with the soon to be created target process.</span><br>  <span class="hljs-comment">// 构造三个信令token以及job对象，与即将创建的target进程相关联</span><br>  base::win::ScopedHandle initial_token;<br>  base::win::ScopedHandle lockdown_token;<br>  base::win::ScopedHandle lowbox_token;<br>  ResultCode result = SBOX_ALL_OK;<br><br>  <span class="hljs-comment">// 可以看到三个信令token的部署是policy_base执行的，token是policy的三大核心之一（另外两个是job和alternative desktop）</span><br>  <span class="hljs-comment">// 至于token是如何部署的，这个疑问留到解剖TargetPolicy时再探索</span><br>  result =<br>      policy_base-&gt;<span class="hljs-built_in">MakeTokens</span>(&amp;initial_token, &amp;lockdown_token, &amp;lowbox_token);<br>  <span class="hljs-keyword">if</span> (SBOX_ALL_OK != result)<br>    <span class="hljs-keyword">return</span> result;<br>  <span class="hljs-comment">// lowbox_token必须要Win8以上才可用</span><br>  <span class="hljs-comment">// 我觉着把这个逻辑放在MakeTokens后面挺奇怪的</span><br>  <span class="hljs-keyword">if</span> (lowbox_token.<span class="hljs-built_in">IsValid</span>() &amp;&amp;<br>      base::win::<span class="hljs-built_in">GetVersion</span>() &lt; base::win::VERSION_WIN8) &#123;<br>    <span class="hljs-comment">// We don&#x27;t allow lowbox_token below Windows 8.</span><br>    <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>  &#125;<br><br>  <span class="hljs-comment">// policy的三大核心之job部署，依然是依赖policy_base</span><br>  base::win::ScopedHandle job;<br>  result = policy_base-&gt;<span class="hljs-built_in">MakeJobObject</span>(&amp;job);<br>  <span class="hljs-keyword">if</span> (SBOX_ALL_OK != result)<br>    <span class="hljs-keyword">return</span> result;<br><br>  <span class="hljs-comment">// StartupInformation是windows的STARTUPINFOEX的封装</span><br>  <span class="hljs-comment">// spawn进程的时候会用到，这个结构理应耳熟能详</span><br>  <span class="hljs-comment">// Initialize the startup information from the policy.</span><br>  base::win::StartupInformation startup_info;<br>  <span class="hljs-comment">// The liftime of |mitigations|, |inherit_handle_list| and</span><br>  <span class="hljs-comment">// |child_process_creation| have to be at least as long as</span><br>  <span class="hljs-comment">// |startup_info| because |UpdateProcThreadAttribute| requires that</span><br>  <span class="hljs-comment">// its |lpValue| parameter persist until |DeleteProcThreadAttributeList| is</span><br>  <span class="hljs-comment">// called; StartupInformation&#x27;s destructor makes such a call.</span><br>  DWORD64 mitigations[<span class="hljs-number">2</span>];<br>  std::vector&lt;HANDLE&gt; inherited_handle_list;<br>  DWORD child_process_creation = PROCESS_CREATION_CHILD_PROCESS_RESTRICTED;<br><br>  <span class="hljs-comment">//sandbox的进程还需要使用额外的AlternateDesktop，而非User的Desktop</span><br>  <span class="hljs-comment">// alternate desktop就是policy三大核心的第三个</span><br>  base::string16 desktop = policy_base-&gt;<span class="hljs-built_in">GetAlternateDesktop</span>();<br>  <span class="hljs-keyword">if</span> (!desktop.<span class="hljs-built_in">empty</span>()) &#123;<br>    startup_info.<span class="hljs-built_in">startup_info</span>()-&gt;lpDesktop =<br>        <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">wchar_t</span>*&gt;(desktop.<span class="hljs-built_in">c_str</span>());<span class="hljs-comment">//statup_info指定拿到的alternate desktop</span><br>  &#125;<br><br>  <span class="hljs-type">bool</span> inherit_handles = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-type">int</span> attribute_count = <span class="hljs-number">0</span>;<span class="hljs-comment">//这货记录policy三大核心之外的其他feature的个数，比如mitigation、target是否可生产子进程等</span><br><br>  <span class="hljs-type">size_t</span> mitigations_size;<br>  <span class="hljs-comment">//将sandbox flags转换成PROC_THREAD_ATTRIBUTE_SECURITY_CAPABILITIES policy flags，为UpdateProcThreadAttribute()所用</span><br>  <span class="hljs-comment">// mitigation实际上也由policy掌控，但policy掌控的毕竟只是抽象的flag</span><br>  <span class="hljs-comment">// 这里需要把他做一个转换，转换成windows API可以直接使用的结构</span><br>  <span class="hljs-comment">// 而UpdateProcThreadAttribute不过是对API的一层封装</span><br>  <span class="hljs-built_in">ConvertProcessMitigationsToPolicy</span>(policy_base-&gt;<span class="hljs-built_in">GetProcessMitigations</span>(),<br>                                    &amp;mitigations[<span class="hljs-number">0</span>], &amp;mitigations_size);<br>  <span class="hljs-keyword">if</span> (mitigations[<span class="hljs-number">0</span>] || mitigations[<span class="hljs-number">1</span>])<br>    ++attribute_count;<br><br>  <span class="hljs-type">bool</span> restrict_child_process_creation = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">//Win10_TH2以上，policy的Job权限低于JOB_LIMITED_USER则不允许target创建子进程</span><br>  <span class="hljs-keyword">if</span> (base::win::<span class="hljs-built_in">GetVersion</span>() &gt;= base::win::VERSION_WIN10_TH2 &amp;&amp;<br>      policy_base-&gt;<span class="hljs-built_in">GetJobLevel</span>() &lt;= JOB_LIMITED_USER) &#123;<br>    restrict_child_process_creation = <span class="hljs-literal">true</span>;<br>    ++attribute_count;<br>  &#125;<br><br>  <span class="hljs-comment">// 看起来policy的标准输出和错误句柄需要作为继承句柄</span><br>  HANDLE stdout_handle = policy_base-&gt;<span class="hljs-built_in">GetStdoutHandle</span>();<br>  HANDLE stderr_handle = policy_base-&gt;<span class="hljs-built_in">GetStderrHandle</span>();<br><br>  <span class="hljs-keyword">if</span> (stdout_handle != INVALID_HANDLE_VALUE)<br>    inherited_handle_list.<span class="hljs-built_in">push_back</span>(stdout_handle);<br><br>  <span class="hljs-comment">// Handles in the list must be unique.</span><br>  <span class="hljs-keyword">if</span> (stderr_handle != stdout_handle &amp;&amp; stderr_handle != INVALID_HANDLE_VALUE)<br>    inherited_handle_list.<span class="hljs-built_in">push_back</span>(stderr_handle);<br><br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; policy_handle_list = policy_base-&gt;<span class="hljs-built_in">GetHandlesBeingShared</span>();<br><br>  <span class="hljs-comment">//标准输出，标准错误和policy的所有共享句柄全部放入inherited_handle_list</span><br>  <span class="hljs-keyword">for</span> (HANDLE handle : policy_handle_list)<br>    inherited_handle_list.<span class="hljs-built_in">push_back</span>(handle);<br><br>  <span class="hljs-keyword">if</span> (inherited_handle_list.<span class="hljs-built_in">size</span>())<br>    ++attribute_count;<br><br>  <span class="hljs-comment">//AppContainer可以在Win8以上使用</span><br>  scoped_refptr&lt;AppContainerProfileBase&gt; profile =<br>      policy_base-&gt;<span class="hljs-built_in">GetAppContainerProfileBase</span>();<br>  <span class="hljs-keyword">if</span> (profile) &#123;<br>    <span class="hljs-keyword">if</span> (base::win::<span class="hljs-built_in">GetVersion</span>() &lt; base::win::VERSION_WIN8)<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>    ++attribute_count;<br>    <span class="hljs-keyword">if</span> (profile-&gt;<span class="hljs-built_in">GetEnableLowPrivilegeAppContainer</span>()) &#123;<br>      <span class="hljs-comment">// LPAC first supported in RS1.</span><br>      <span class="hljs-comment">// Win10_RS1以上可以应用LPAC</span><br>      <span class="hljs-keyword">if</span> (base::win::<span class="hljs-built_in">GetVersion</span>() &lt; base::win::VERSION_WIN10_RS1)<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br>      ++attribute_count;<span class="hljs-comment">// LPAC与AC各算一次计数</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//初始化startup_info的线程属性列表，attribute_count记录了属性的个数</span><br>  <span class="hljs-keyword">if</span> (!startup_info.<span class="hljs-built_in">InitializeProcThreadAttributeList</span>(attribute_count))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_PROC_THREAD_ATTRIBUTES;<br><br>  <span class="hljs-comment">//UpdateProcThreadAttribute用以更新线程属性PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY</span><br>  <span class="hljs-keyword">if</span> (mitigations[<span class="hljs-number">0</span>] || mitigations[<span class="hljs-number">1</span>]) &#123;<br>    <span class="hljs-keyword">if</span> (!startup_info.<span class="hljs-built_in">UpdateProcThreadAttribute</span>(<br>            PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &amp;mitigations[<span class="hljs-number">0</span>],<br>            mitigations_size)) &#123;<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_PROC_THREAD_ATTRIBUTES;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//如果有子进程不允许创建的限制，那么还要更新PROC_THREAD_ATTRIBUTE_CHILD_PROCESS_POLICY这一属性</span><br>  <span class="hljs-keyword">if</span> (restrict_child_process_creation) &#123;<br>    <span class="hljs-keyword">if</span> (!startup_info.<span class="hljs-built_in">UpdateProcThreadAttribute</span>(<br>            PROC_THREAD_ATTRIBUTE_CHILD_PROCESS_POLICY, &amp;child_process_creation,<br>            <span class="hljs-built_in">sizeof</span>(child_process_creation))) &#123;<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_PROC_THREAD_ATTRIBUTES;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//更新PROC_THREAD_ATTRIBUTE_HANDLE_LIST属性</span><br>  <span class="hljs-keyword">if</span> (inherited_handle_list.<span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (!startup_info.<span class="hljs-built_in">UpdateProcThreadAttribute</span>(<br>            PROC_THREAD_ATTRIBUTE_HANDLE_LIST, &amp;inherited_handle_list[<span class="hljs-number">0</span>],<br>            <span class="hljs-built_in">sizeof</span>(HANDLE) * inherited_handle_list.<span class="hljs-built_in">size</span>())) &#123;<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_PROC_THREAD_ATTRIBUTES;<br>    &#125;<br>    startup_info.<span class="hljs-built_in">startup_info</span>()-&gt;dwFlags |= STARTF_USESTDHANDLES;<br>    startup_info.<span class="hljs-built_in">startup_info</span>()-&gt;hStdInput = INVALID_HANDLE_VALUE;<br>    <span class="hljs-comment">// policy的标准输出和错误句柄为新进程使用，同时也在可继承句柄列表中</span><br>    startup_info.<span class="hljs-built_in">startup_info</span>()-&gt;hStdOutput = stdout_handle;<br>    startup_info.<span class="hljs-built_in">startup_info</span>()-&gt;hStdError = stderr_handle;<br>    <span class="hljs-comment">// Allowing inheritance of handles is only secure now that we</span><br>    <span class="hljs-comment">// have limited which handles will be inherited.</span><br>    inherit_handles = <span class="hljs-literal">true</span>;<span class="hljs-comment">//仅在控制了哪些句柄可以被继承的情况下，允许继承句柄才是安全的</span><br>  &#125;<br><br>  <span class="hljs-comment">// Declared here to ensure they stay in scope until after process creation.</span><br>  std::unique_ptr&lt;SecurityCapabilities&gt; security_capabilities;<br>  DWORD all_applications_package_policy =<br>      PROCESS_CREATION_ALL_APPLICATION_PACKAGES_OPT_OUT;<br><br>  <span class="hljs-comment">//如果应用了AppContainer，还要更新PROC_THREAD_ATTRIBUTE_SECURITY_CAPABILITIES</span><br>  <span class="hljs-comment">// SecurityCapabilities对象源于profile，AC相关的部分我还没有看，暂时不清楚技术内幕</span><br>  <span class="hljs-keyword">if</span> (profile) &#123;<br>    security_capabilities = profile-&gt;<span class="hljs-built_in">GetSecurityCapabilities</span>();<br>    <span class="hljs-keyword">if</span> (!startup_info.<span class="hljs-built_in">UpdateProcThreadAttribute</span>(<br>            PROC_THREAD_ATTRIBUTE_SECURITY_CAPABILITIES,<br>            security_capabilities.<span class="hljs-built_in">get</span>(), <span class="hljs-built_in">sizeof</span>(SECURITY_CAPABILITIES))) &#123;<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_PROC_THREAD_ATTRIBUTES;<br>    &#125;<br>    <span class="hljs-comment">//如果应用了LPAC，还要更新PROC_THREAD_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY</span><br>    <span class="hljs-keyword">if</span> (profile-&gt;<span class="hljs-built_in">GetEnableLowPrivilegeAppContainer</span>()) &#123;<br>      <span class="hljs-keyword">if</span> (!startup_info.<span class="hljs-built_in">UpdateProcThreadAttribute</span>(<br>              PROC_THREAD_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY,<br>              &amp;all_applications_package_policy,<br>              <span class="hljs-built_in">sizeof</span>(all_applications_package_policy))) &#123;<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_PROC_THREAD_ATTRIBUTES;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Construct the thread pool here in case it is expensive.</span><br>  <span class="hljs-comment">// The thread pool is shared by all the targets</span><br>  <span class="hljs-comment">// 首次创建target时，初始化线程池</span><br>  <span class="hljs-comment">// Win2kThreadPool是Win2k线程池API的实现</span><br>  <span class="hljs-comment">// 这里使用的是个std::unique_ptr，防止其他指针指向该对象</span><br>  <span class="hljs-keyword">if</span> (!thread_pool_)<br>    thread_pool_ = std::<span class="hljs-built_in">make_unique</span>&lt;Win2kThreadPool&gt;();<br><br>  <span class="hljs-comment">// Create the TargetProcess object and spawn the target suspended. Note that</span><br>  <span class="hljs-comment">// Brokerservices does not own the target object. It is owned by the Policy.</span><br>  <span class="hljs-comment">// 创建TargetProcess对象，生成挂起的target进程。</span><br>  <span class="hljs-comment">// target不属于BrokerServices，它实际上属于Policy。</span><br>  <span class="hljs-comment">// base::win::ScopedProcessInformation是对PROCESS_INFORMATION的封装</span><br>  base::win::ScopedProcessInformation process_info;<br>  <span class="hljs-comment">// 创建TargetProcess对象</span><br>  <span class="hljs-comment">// 传递各种policy相关资源，注意如果没有用AppContainer就使用Sid机制</span><br>  TargetProcess* target = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TargetProcess</span>(<br>      std::<span class="hljs-built_in">move</span>(initial_token), std::<span class="hljs-built_in">move</span>(lockdown_token), job.<span class="hljs-built_in">Get</span>(),<br>      thread_pool_.<span class="hljs-built_in">get</span>(),<br>      profile ? profile-&gt;<span class="hljs-built_in">GetImpersonationCapabilities</span>() : std::<span class="hljs-built_in">vector</span>&lt;Sid&gt;());<br><br>  <span class="hljs-comment">// 创建target进程，传递命令行参数、继承句柄、启动信息、进程信息</span><br>  <span class="hljs-comment">// 尽管此时还不了解TargetProcess的Create实现，但已经能嗅到CreateProcess的气息了。这些参数传的太堂而皇之了。</span><br>  result = target-&gt;<span class="hljs-built_in">Create</span>(exe_path, command_line, inherit_handles, startup_info,<br>                          &amp;process_info, last_error);<br><br>  <span class="hljs-keyword">if</span> (result != SBOX_ALL_OK) &#123;<br>    <span class="hljs-built_in">SpawnCleanup</span>(target);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-comment">// lowbox_token是win8以上独有的，单独处理，TargetProcess特意给了个接口</span><br>  <span class="hljs-keyword">if</span> (lowbox_token.<span class="hljs-built_in">IsValid</span>()) &#123;<br>    *last_warning = target-&gt;<span class="hljs-built_in">AssignLowBoxToken</span>(lowbox_token);<br>    <span class="hljs-comment">// If this fails we continue, but report the error as a warning.</span><br>    <span class="hljs-comment">// This is due to certain configurations causing the setting of the</span><br>    <span class="hljs-comment">// token to fail post creation, and we&#x27;d rather continue if possible.</span><br>    <span class="hljs-comment">// lowbox_token的失败是可以接受的，仅仅记录错误继续前行</span><br>    <span class="hljs-keyword">if</span> (*last_warning != SBOX_ALL_OK)<br>      *last_error = ::<span class="hljs-built_in">GetLastError</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// Now the policy is the owner of the target.</span><br>  <span class="hljs-comment">// policy正式接管target</span><br>  result = policy_base-&gt;<span class="hljs-built_in">AddTarget</span>(target);<br><br>  <span class="hljs-keyword">if</span> (result != SBOX_ALL_OK) &#123;<br>    *last_error = ::<span class="hljs-built_in">GetLastError</span>();<br>    <span class="hljs-built_in">SpawnCleanup</span>(target);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-comment">// We are going to keep a pointer to the policy because we&#x27;ll call it when</span><br>  <span class="hljs-comment">// the job object generates notifications using the completion port.</span><br>  <span class="hljs-comment">// policy和target关联起来了，但broker生成的policy目前却没法找到</span><br>  <span class="hljs-comment">// broker通过tracker_list_成员维护tracker，而tracker维护job和policy</span><br>  <span class="hljs-comment">// 注意局部变量对象job通过std::move转移了owner</span><br>  <span class="hljs-comment">// 通过JobTracker将job通知与job和policy对象联系起来</span><br>  <span class="hljs-keyword">if</span> (job.<span class="hljs-built_in">IsValid</span>()) &#123;<br>    std::unique_ptr&lt;JobTracker&gt; tracker =<br>        std::<span class="hljs-built_in">make_unique</span>&lt;JobTracker&gt;(std::<span class="hljs-built_in">move</span>(job), policy_base);<br><br>    <span class="hljs-comment">// There is no obvious recovery after failure here. Previous version with</span><br>    <span class="hljs-comment">// SpawnCleanup() caused deletion of TargetProcess twice. crbug.com/480639</span><br>    <span class="hljs-comment">// 将IO完成端口句柄job_port_与job对象相关联</span><br>    <span class="hljs-comment">// tracker指针做key,IO完成端口句柄做value</span><br>    <span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">AssociateCompletionPort</span>(tracker-&gt;job.<span class="hljs-built_in">Get</span>(), job_port_.<span class="hljs-built_in">Get</span>(),<br>                                  tracker.<span class="hljs-built_in">get</span>()));<br><br>    <span class="hljs-comment">// Save the tracker because in cleanup we might need to force closing</span><br>    <span class="hljs-comment">// the Jobs.</span><br>    <span class="hljs-comment">// tracker是unique_ptr，所以不能直接复制，需要std::move右值引用来转换owner为tracker_list_成员</span><br>    tracker_list_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(tracker));<br>    <span class="hljs-comment">// 维护target进程的id</span><br>    child_process_ids_.<span class="hljs-built_in">insert</span>(process_info.<span class="hljs-built_in">process_id</span>());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Leak policy_base. This needs to outlive the child process, but there&#x27;s</span><br>    <span class="hljs-comment">// nothing that tracks that lifetime properly if there&#x27;s no job object.</span><br>    <span class="hljs-comment">// TODO(wfh): Find a way to make this have the correct lifetime.</span><br>    policy_base-&gt;<span class="hljs-built_in">AddRef</span>();<br><br>    <span class="hljs-comment">// We have to signal the event once here because the completion port will</span><br>    <span class="hljs-comment">// never get a message that this target is being terminated thus we should</span><br>    <span class="hljs-comment">// not block WaitForAllTargets until we have at least one target with job.</span><br>    <span class="hljs-comment">// 大概的意思就是，这个target没有job对象，所以终止时也没办法通知IO完成端口</span><br>    <span class="hljs-comment">// 这就可能导致在当前没有任何一个其他拥有job对象的target时，一旦调用WaitForAllTargets</span><br>    <span class="hljs-comment">// 就会因为收不到该进程终止的消息而永久阻塞，所以这里在没有其他拥有job对象的target进程存在的情况下启动这样一个进程时</span><br>    <span class="hljs-comment">// 就手工置信no_targets_信号量，防止WaitForAllTargets的阻塞</span><br>    <span class="hljs-comment">// 但这也意味着这种游离于IO完成端口管理之外的target，lifetime不受控制</span><br>    <span class="hljs-comment">// 我暂时也不清楚什么样的target会落入到这里</span><br>    <span class="hljs-keyword">if</span> (child_process_ids_.<span class="hljs-built_in">empty</span>())<br>      ::<span class="hljs-built_in">SetEvent</span>(no_targets_.<span class="hljs-built_in">Get</span>());<br>  &#125;<br><br>  <span class="hljs-comment">//process_info转交给OUT型参数target_info（owner）</span><br>  *target_info = process_info.<span class="hljs-built_in">Take</span>();<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为涉及了大量的外部对象，所以在没有拆解耦合对象的情况下，很多细节暂时不纠结，看到了再说。</p><h3 id="waitforalltargets"><code>WaitForAllTargets()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">BrokerServicesBase::WaitForAllTargets</span><span class="hljs-params">()</span> </span>&#123;<br>  ::<span class="hljs-built_in">WaitForSingleObject</span>(no_targets_.<span class="hljs-built_in">Get</span>(), INFINITE);<br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就很简单了，<code>no_targets_</code>置信时<code>WaitForSingleObject</code>会返回，这就表示所有target都退出了。</p><h3 id="isactivetarget"><code>IsActiveTarget()</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BrokerServicesBase::IsActiveTarget</span><span class="hljs-params">(DWORD process_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 上锁是为了在迭代child_process_ids_时，不受其他线程修改的影响</span><br>  <span class="hljs-function">AutoLock <span class="hljs-title">lock</span><span class="hljs-params">(&amp;lock_)</span></span>;<br>  <span class="hljs-keyword">return</span> child_process_ids_.<span class="hljs-built_in">find</span>(process_id) != child_process_ids_.<span class="hljs-built_in">end</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="createpolicy"><code>CreatePolicy()</code></h3><p>作为<code>BrokerServicesBase</code>中非常重要的组成部分，对target进程的管理、安全策略都由policy控制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">scoped_refptr&lt;TargetPolicy&gt; <span class="hljs-title">BrokerServicesBase::CreatePolicy</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// If you change the type of the object being created here you must also</span><br>  <span class="hljs-comment">// change the downcast to it in SpawnTarget().</span><br>  <span class="hljs-comment">// 父类指针引用子类对象，标准的多态</span><br>  <span class="hljs-function">scoped_refptr&lt;TargetPolicy&gt; <span class="hljs-title">policy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> PolicyBase)</span></span>;<br>  <span class="hljs-comment">// PolicyBase starts with refcount 1.</span><br>  policy-&gt;<span class="hljs-built_in">Release</span>();<br>  <span class="hljs-keyword">return</span> policy;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上也没做什么，单纯的new出一个<code>PolicyBase</code>对象并返回其智能指针罢了。</p><p>而在<code>SpawnTarget</code>中也确实看到了使用的是<code>PolicyBase</code>对象的指针引用了这个对象，并做了各种安全设定、target绑定。</p><p>具体的安全设定是如何实现的，限于篇幅，这里就不展开了，本次分析旨在缕清Broker和Target的关系，以及各结构是如何编制在一起，形成了哪些效果等。具体的TargetProcess，TargetPolicy以及派生类PolicyBase等日后单独分析。</p><h3 id="targeteventsthread"><code>TargetEventsThread</code></h3><p>最后的重中之重，需要弄清楚target事件的处理线程都做了些什么。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The worker thread stays in a loop waiting for asynchronous notifications</span><br><span class="hljs-comment">// from the job objects. Right now we only care about knowing when the last</span><br><span class="hljs-comment">// process on a job terminates, but in general this is the place to tell</span><br><span class="hljs-comment">// the policy about events.</span><br><span class="hljs-comment">// 循环等待各个target的job对象的异步通知</span><br><span class="hljs-comment">// 当前仅关心最后一个进程何时退出，实际上它可以用来通知policy event的发生</span><br><span class="hljs-comment">// （这是因为绑定IO完成端口与job对象时，tracker指针做了key，而tracker维护了job和policy）</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">BrokerServicesBase::TargetEventsThread</span><span class="hljs-params">(PVOID param)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!param)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">//broker中这个线程名叫BrokerEvent</span><br>  base::PlatformThread::<span class="hljs-built_in">SetName</span>(<span class="hljs-string">&quot;BrokerEvent&quot;</span>);<br><br>  <span class="hljs-comment">//param实际上就是BrokerServicesBase对象，以this传入</span><br>  BrokerServicesBase* broker = <span class="hljs-built_in">reinterpret_cast</span>&lt;BrokerServicesBase*&gt;(param);<br>  HANDLE port = broker-&gt;job_port_.<span class="hljs-built_in">Get</span>();<span class="hljs-comment">//IO完成端口句柄</span><br>  HANDLE no_targets = broker-&gt;no_targets_.<span class="hljs-built_in">Get</span>();<span class="hljs-comment">//no_targets_事件句柄</span><br><br>  <span class="hljs-type">int</span> target_counter = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> untracked_target_counter = <span class="hljs-number">0</span>;<br>  ::<span class="hljs-built_in">ResetEvent</span>(no_targets);<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    DWORD events = <span class="hljs-number">0</span>;<br>    ULONG_PTR key = <span class="hljs-number">0</span>;<br>    LPOVERLAPPED ovl = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// IO完成端口获取事件</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">GetQueuedCompletionStatus</span>(port, &amp;events, &amp;key, &amp;ovl, INFINITE)) &#123;<br>      <span class="hljs-comment">// this call fails if the port has been closed before we have a</span><br>      <span class="hljs-comment">// chance to service the last packet which is &#x27;exit&#x27; anyway so</span><br>      <span class="hljs-comment">// this is not an error.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 具体key代表什么现在不得而知，得拆解IO完成端口的信源才行</span><br>    <span class="hljs-keyword">if</span> (key &gt; THREAD_CTRL_LAST) &#123;<br>      <span class="hljs-comment">// The notification comes from a job object. There are nine notifications</span><br>      <span class="hljs-comment">// that jobs can send and some of them depend on the job attributes set.</span><br>      <span class="hljs-comment">// 看起来key大于THREAD_CTRL_LAST时表示通知是从job对象发过来的，一共有9种通知</span><br>      <span class="hljs-comment">// 原来这个key就是JobTracker指针，在前面SpawnTarget中创建JobTracker时，曾用此作为JOBOBJECT_ASSOCIATE_COMPLETION_PORT的第一元素，port作为第二元素</span><br>      <span class="hljs-comment">// 而JobTracker本身是job和policy的关联</span><br>      JobTracker* tracker = <span class="hljs-built_in">reinterpret_cast</span>&lt;JobTracker*&gt;(key);<br><br>      <span class="hljs-comment">// events指定哪种通知</span><br>      <span class="hljs-keyword">switch</span> (events) &#123;<br>        <span class="hljs-keyword">case</span> JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO: &#123;<br>          <span class="hljs-comment">// The job object has signaled that the last process associated</span><br>          <span class="hljs-comment">// with it has terminated. Assuming there is no way for a process</span><br>          <span class="hljs-comment">// to appear out of thin air in this job, it safe to assume that</span><br>          <span class="hljs-comment">// we can tell the policy to destroy the target object, and for</span><br>          <span class="hljs-comment">// us to release our reference to the policy object.</span><br>          <span class="hljs-comment">// job对象告知最后一个进程已终止，通过tracker来释放所有相关资源。</span><br>          tracker-&gt;<span class="hljs-built_in">FreeResources</span>();<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">case</span> JOB_OBJECT_MSG_NEW_PROCESS: &#123;<br>          DWORD handle = <span class="hljs-built_in">static_cast</span>&lt;DWORD&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(ovl));<br>          &#123;<br>            <span class="hljs-function">AutoLock <span class="hljs-title">lock</span><span class="hljs-params">(&amp;broker-&gt;lock_)</span></span>;<br>            <span class="hljs-type">size_t</span> count = broker-&gt;child_process_ids_.<span class="hljs-built_in">count</span>(handle);<br>            <span class="hljs-comment">// Child process created from sandboxed process.</span><br>            <span class="hljs-comment">// 如果新创建的进程不在broker的child_process_ids中，说明是沙盒中某个target进程创建的子进程，此时要untracked_target_counter递增以维护计数</span><br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<br>              untracked_target_counter++;<br>          &#125;<br>          <span class="hljs-comment">// 无论是target进程还是某个target创建的子进程，都要递增计数</span><br>          ++target_counter;<br>          <span class="hljs-comment">// 当从0到1时，no_targets event也需要手工nonsignaled</span><br>          <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == target_counter) &#123;<br>            ::<span class="hljs-built_in">ResetEvent</span>(no_targets);<br>          &#125;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">case</span> JOB_OBJECT_MSG_EXIT_PROCESS:<br>        <span class="hljs-keyword">case</span> JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS: &#123;<br>          <span class="hljs-type">size_t</span> erase_result = <span class="hljs-number">0</span>;<br>          &#123;<br>            <span class="hljs-function">AutoLock <span class="hljs-title">lock</span><span class="hljs-params">(&amp;broker-&gt;lock_)</span></span>;<br>            <span class="hljs-comment">// 删除对应的process id</span><br>            erase_result = broker-&gt;child_process_ids_.<span class="hljs-built_in">erase</span>(<br>                <span class="hljs-built_in">static_cast</span>&lt;DWORD&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(ovl)));<br>          &#125;<br>          <span class="hljs-keyword">if</span> (erase_result != <span class="hljs-number">1U</span>) &#123;<br>            <span class="hljs-comment">// The process was untracked e.g. a child process of the target.</span><br>            <span class="hljs-comment">// 不在child_process_ids_中，说明是target生成的子进程</span><br>            --untracked_target_counter;<br>            <span class="hljs-built_in">DCHECK</span>(untracked_target_counter &gt;= <span class="hljs-number">0</span>);<br>          &#125;<br>          --target_counter;<br>          <span class="hljs-comment">// 和楼上相反的操作</span><br>          <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == target_counter)<br>            ::<span class="hljs-built_in">SetEvent</span>(no_targets);<br><br>          <span class="hljs-built_in">DCHECK</span>(target_counter &gt;= <span class="hljs-number">0</span>);<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>          <span class="hljs-comment">// 这种情况为什么还要递增计数，我不太懂</span><br>          <span class="hljs-comment">// 会不会有某种手法一直发这个消息，让int型的untracked_target_counter和target_counter溢出？</span><br>        <span class="hljs-keyword">case</span> JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT: &#123;<br>          <span class="hljs-comment">// A child process attempted and failed to create a child process.</span><br>          <span class="hljs-comment">// Windows does not reveal the process id.</span><br>          untracked_target_counter++;<br>          target_counter++;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>          <span class="hljs-comment">// 一旦超过了内存限制，直接终止job</span><br>        <span class="hljs-keyword">case</span> JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT: &#123;<br>          <span class="hljs-type">bool</span> res = ::<span class="hljs-built_in">TerminateJobObject</span>(tracker-&gt;job.<span class="hljs-built_in">Get</span>(),<br>                                          SBOX_FATAL_MEMORY_EXCEEDED);<br>          <span class="hljs-built_in">DCHECK</span>(res);<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">default</span>: &#123;<br>          <span class="hljs-built_in">NOTREACHED</span>();<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (THREAD_CTRL_QUIT == key) &#123;<br>      <span class="hljs-comment">// The broker object is being destroyed so the thread needs to exit.</span><br>      <span class="hljs-comment">// 如果key是THREAD_CTRL_QUIT，那么broker对象就已经被销毁了，这个线程也就没有存在的必要了。（该线程是static成员，和broker实例的lifetime没关系）</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// We have not implemented more commands.</span><br>      <span class="hljs-built_in">NOTREACHED</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-built_in">NOTREACHED</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，对<code>BrokerServices</code>有了一个大体的认识。</p><h2 id="appendix">Appendix</h2><h3 id="singletonbase"><code>SingletonBase</code></h3><p>broker的工厂方法<code>SandboxFactory::GetBrokerServices()</code>最终是调用<code>BrokerServicesBase::GetInstance()</code>，这是继承单例类模板<code>SingletonBase</code>的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Basic implementation of a singleton which calls the destructor</span><br><span class="hljs-comment">// when the exe is shutting down or the DLL is being unloaded.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Derived&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonBase</span> &#123;<br> <span class="hljs-keyword">public</span>:<br> <span class="hljs-comment">//相当标准的饿汉单例模式实现，SingletonBase没必要产生实例，所以直接将GetInstance作为static public方法公开即可</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> Derived* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//这里如果没有static，问题就大了:)</span><br>    <span class="hljs-type">static</span> Derived* instance = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (!instance) &#123;<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>      <span class="hljs-comment">// Microsoft CRT extension. In an exe this this called after</span><br>      <span class="hljs-comment">// winmain returns, in a dll is called in DLL_PROCESS_DETACH</span><br>      <span class="hljs-comment">// 这个是MS的特权，在winmain返回或DLL_PROCESS_DETACH触发时调用注册的函数</span><br>      _onexit(OnExit);<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// this is the function that gets called by the CRT when the</span><br>  <span class="hljs-comment">// process is shutting down.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __cdecl <span class="hljs-title">OnExit</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 防止退出后继续使用GetInstance？这个不是太懂</span><br>    <span class="hljs-function"><span class="hljs-keyword">delete</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="autolock"><code>AutoLock</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Automatically acquires and releases a lock when the object is</span><br><span class="hljs-comment">// is destroyed.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoLock</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Acquires the lock.</span><br>  <span class="hljs-comment">// 这个构造器是显式的，防止了某些情况下编译器自作聪明的CRITICAL_SECTION对象到AutoLock的转换。</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">AutoLock</span><span class="hljs-params">(CRITICAL_SECTION* lock)</span> : lock_(lock) &#123;</span><br>    ::<span class="hljs-built_in">EnterCriticalSection</span>(lock);<span class="hljs-comment">//上锁</span><br>  &#125;<br><br>  <span class="hljs-comment">// Releases the lock;</span><br>  ~<span class="hljs-built_in">AutoLock</span>() &#123; ::<span class="hljs-built_in">LeaveCriticalSection</span>(lock_); <span class="hljs-comment">//释放锁&#125;</span><br><br> <span class="hljs-keyword">private</span>:<br>  CRITICAL_SECTION* lock_;<br>  <span class="hljs-built_in">DISALLOW_IMPLICIT_CONSTRUCTORS</span>(AutoLock);<span class="hljs-comment">//禁用了默认构造器、复制构造、赋值操作</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>AutoLock</code>简化了编码工作，也防止了编码时忘记release而编译不会报错的尴尬。实际上就是利用栈上对象会在函数返回后自动析构的特性来实现自动release，另一方面，构造函数中直接上锁也省去了调用enter的麻烦。</p><h3 id="scopedhandle"><code>ScopedHandle</code></h3><p>实际上它是<code>GenericScopedHandle&lt;HandleTraits, VerifierTraits&gt;</code>的typedef。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The traits class for Win32 handles that can be closed via CloseHandle() API.</span><br><span class="hljs-comment">// 该类仅有3个public static函数，所以不会用于实例化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleTraits</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">typedef</span> HANDLE Handle;<br><br>  <span class="hljs-comment">// 用于关闭句柄的static public成员</span><br>  <span class="hljs-comment">// Closes the handle.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> BASE_EXPORT <span class="hljs-title">CloseHandle</span><span class="hljs-params">(HANDLE handle)</span></span>;<br><br>  <span class="hljs-comment">// 判断句柄是否有效，NULL或INVALID_HANDLE_VALUE均表示无效</span><br>  <span class="hljs-comment">// Returns true if the handle value is valid.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">IsHandleValid</span><span class="hljs-params">(HANDLE handle)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> handle != <span class="hljs-literal">NULL</span> &amp;&amp; handle != INVALID_HANDLE_VALUE;<br>  &#125;<br><br>  <span class="hljs-comment">// 返回NULL</span><br>  <span class="hljs-comment">// Returns NULL handle value.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> HANDLE <span class="hljs-title">NullHandle</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">DISALLOW_IMPLICIT_CONSTRUCTORS</span>(HandleTraits);<span class="hljs-comment">//拒绝所有隐式构造器</span><br>&#125;;<br><br><span class="hljs-comment">// Performs actual run-time tracking.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BASE_EXPORT</span> VerifierTraits &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">typedef</span> HANDLE Handle;<br><br>  <span class="hljs-comment">//同样只有两个static public方法，不用于实例化</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">StartTracking</span><span class="hljs-params">(HANDLE handle, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* owner,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">const</span> <span class="hljs-type">void</span>* pc1, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* pc2)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">StopTracking</span><span class="hljs-params">(HANDLE handle, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* owner,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-type">const</span> <span class="hljs-type">void</span>* pc1, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* pc2)</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">DISALLOW_IMPLICIT_CONSTRUCTORS</span>(VerifierTraits);<br>&#125;;<br><br><span class="hljs-comment">// 几个static函数的实现体，全都用到了ScopedHandleVerifier::Get()</span><br><span class="hljs-comment">// 看起来ScopedHandleVerifier做了各种功能的抽离，这几个static仅仅只是壳子</span><br><span class="hljs-comment">// Static.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HandleTraits::CloseHandle</span><span class="hljs-params">(HANDLE handle)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ScopedHandleVerifier::<span class="hljs-built_in">Get</span>()-&gt;<span class="hljs-built_in">CloseHandle</span>(handle);<br>&#125;<br><br><span class="hljs-comment">// Static.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VerifierTraits::StartTracking</span><span class="hljs-params">(HANDLE handle, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* owner,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">const</span> <span class="hljs-type">void</span>* pc1, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* pc2)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ScopedHandleVerifier::<span class="hljs-built_in">Get</span>()-&gt;<span class="hljs-built_in">StartTracking</span>(handle, owner, pc1, pc2);<br>&#125;<br><br><span class="hljs-comment">// Static.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VerifierTraits::StopTracking</span><span class="hljs-params">(HANDLE handle, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* owner,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* pc1, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* pc2)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ScopedHandleVerifier::<span class="hljs-built_in">Get</span>()-&gt;<span class="hljs-built_in">StopTracking</span>(handle, owner, pc1, pc2);<br>&#125;<br><span class="hljs-comment">// ScopedHandleVerifier相当复杂，这里就不展开了</span><br><br><span class="hljs-comment">// Generic wrapper for raw handles that takes care of closing handles</span><br><span class="hljs-comment">// automatically. The class interface follows the style of</span><br><span class="hljs-comment">// the ScopedFILE class with two additions:</span><br><span class="hljs-comment">//   - IsValid() method can tolerate multiple invalid handle values such as NULL</span><br><span class="hljs-comment">//     and INVALID_HANDLE_VALUE (-1) for Win32 handles.</span><br><span class="hljs-comment">//   - Set() (and the constructors and assignment operators that call it)</span><br><span class="hljs-comment">//     preserve the Windows LastError code. This ensures that GetLastError() can</span><br><span class="hljs-comment">//     be called after stashing a handle in a GenericScopedHandle object. Doing</span><br><span class="hljs-comment">//     this explicitly is necessary because of bug 528394 and VC++ 2015.</span><br><span class="hljs-comment">// windows原生HANDLE的包裹，它会负责自动关闭句柄。</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Traits</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Verifier</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericScopedHandle</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Traits::Handle Handle;<br><br>  <span class="hljs-comment">// 各种构造器</span><br>  <span class="hljs-built_in">GenericScopedHandle</span>() : <span class="hljs-built_in">handle_</span>(Traits::<span class="hljs-built_in">NullHandle</span>()) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GenericScopedHandle</span><span class="hljs-params">(Handle handle)</span> : handle_(Traits::NullHandle()) &#123;</span><br>    <span class="hljs-built_in">Set</span>(handle);<br>  &#125;<br><br>  <span class="hljs-comment">// 移动构造函数，other得是右值引用</span><br>  <span class="hljs-built_in">GenericScopedHandle</span>(GenericScopedHandle&amp;&amp; other)<br>      : <span class="hljs-built_in">handle_</span>(Traits::<span class="hljs-built_in">NullHandle</span>()) &#123;<br>    <span class="hljs-built_in">Set</span>(other.<span class="hljs-built_in">Take</span>());<br>  &#125;<br><br>  ~<span class="hljs-built_in">GenericScopedHandle</span>() &#123;<br>    <span class="hljs-built_in">Close</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsValid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Traits::<span class="hljs-built_in">IsHandleValid</span>(handle_);<br>  &#125;<br><br>  <span class="hljs-comment">// 移动赋值操作，other得是右值引用</span><br>  GenericScopedHandle&amp; <span class="hljs-keyword">operator</span>=(GenericScopedHandle&amp;&amp; other) &#123;<br>    <span class="hljs-built_in">DCHECK_NE</span>(<span class="hljs-keyword">this</span>, &amp;other);<br>    <span class="hljs-built_in">Set</span>(other.<span class="hljs-built_in">Take</span>());<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Set</span><span class="hljs-params">(Handle handle)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (handle_ != handle) &#123;<br>      <span class="hljs-comment">// Preserve old LastError to avoid bug 528394.</span><br>      <span class="hljs-keyword">auto</span> last_error = ::<span class="hljs-built_in">GetLastError</span>();<br>      <span class="hljs-built_in">Close</span>();<br><br>      <span class="hljs-keyword">if</span> (Traits::<span class="hljs-built_in">IsHandleValid</span>(handle)) &#123;<br>        handle_ = handle;<br>        Verifier::<span class="hljs-built_in">StartTracking</span>(handle, <span class="hljs-keyword">this</span>, BASE_WIN_GET_CALLER,<br>                                <span class="hljs-built_in">GetProgramCounter</span>());<br>      &#125;<br>      ::<span class="hljs-built_in">SetLastError</span>(last_error);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function">Handle <span class="hljs-title">Get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> handle_;<br>  &#125;<br><br>  <span class="hljs-comment">// Transfers ownership away from this object.</span><br>  <span class="hljs-function">Handle <span class="hljs-title">Take</span><span class="hljs-params">()</span> </span>&#123;<br>    Handle temp = handle_;<br>    handle_ = Traits::<span class="hljs-built_in">NullHandle</span>();<br>    <span class="hljs-keyword">if</span> (Traits::<span class="hljs-built_in">IsHandleValid</span>(temp)) &#123;<br>      Verifier::<span class="hljs-built_in">StopTracking</span>(temp, <span class="hljs-keyword">this</span>, BASE_WIN_GET_CALLER,<br>                             <span class="hljs-built_in">GetProgramCounter</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>  &#125;<br><br>  <span class="hljs-comment">// Explicitly closes the owned handle.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Traits::<span class="hljs-built_in">IsHandleValid</span>(handle_)) &#123;<br>      Verifier::<span class="hljs-built_in">StopTracking</span>(handle_, <span class="hljs-keyword">this</span>, BASE_WIN_GET_CALLER,<br>                             <span class="hljs-built_in">GetProgramCounter</span>());<br><br>      Traits::<span class="hljs-built_in">CloseHandle</span>(handle_);<br>      handle_ = Traits::<span class="hljs-built_in">NullHandle</span>();<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">FRIEND_TEST_ALL_PREFIXES</span>(ScopedHandleTest, ActiveVerifierWrongOwner);<br>  <span class="hljs-built_in">FRIEND_TEST_ALL_PREFIXES</span>(ScopedHandleTest, ActiveVerifierUntrackedHandle);<br>  Handle handle_;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(GenericScopedHandle);<span class="hljs-comment">//默认赋值操作和复制构造被禁</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>每个包裹HANDLE的对象都应该是唯一的，可以转换所有者，但不能复制，所以才有了移动复制构造和移动赋值，但却禁用默认赋值和默认赋值构造。</p><h3 id="scoped_refptr"><code>scoped_refptr</code></h3><p>一个封装好的智能(smart)指针类，用于那些需要引用计数的对象，自动的对象计数可以防止内存泄露（忘记release）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//</span><br><span class="hljs-comment">// A smart pointer class for reference counted objects.  Use this class instead</span><br><span class="hljs-comment">// of calling AddRef and Release manually on a reference counted object to</span><br><span class="hljs-comment">// avoid common memory leaks caused by forgetting to Release an object</span><br><span class="hljs-comment">// reference.  Sample usage:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   class MyFoo : public RefCounted&lt;MyFoo&gt; &#123;</span><br><span class="hljs-comment">//    ...</span><br><span class="hljs-comment">//    private:</span><br><span class="hljs-comment">//     friend class RefCounted&lt;MyFoo&gt;;  // Allow destruction by RefCounted&lt;&gt;.</span><br><span class="hljs-comment">//     ~MyFoo();                        // Destructor must be private/protected.</span><br><span class="hljs-comment">//   &#125;;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   void some_function() &#123;</span><br><span class="hljs-comment">//     scoped_refptr&lt;MyFoo&gt; foo = MakeRefCounted&lt;MyFoo&gt;();</span><br><span class="hljs-comment">//     foo-&gt;Method(param);</span><br><span class="hljs-comment">//     // |foo| is released when this function returns</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   void some_other_function() &#123;</span><br><span class="hljs-comment">//     scoped_refptr&lt;MyFoo&gt; foo = MakeRefCounted&lt;MyFoo&gt;();</span><br><span class="hljs-comment">//     ...</span><br><span class="hljs-comment">//     foo = nullptr;  // explicitly releases |foo|</span><br><span class="hljs-comment">//     ...</span><br><span class="hljs-comment">//     if (foo)</span><br><span class="hljs-comment">//       foo-&gt;Method(param);</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The above examples show how scoped_refptr&lt;T&gt; acts like a pointer to T.</span><br><span class="hljs-comment">// Given two scoped_refptr&lt;T&gt; classes, it is also possible to exchange</span><br><span class="hljs-comment">// references between the two objects, like so:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   &#123;</span><br><span class="hljs-comment">//     scoped_refptr&lt;MyFoo&gt; a = MakeRefCounted&lt;MyFoo&gt;();</span><br><span class="hljs-comment">//     scoped_refptr&lt;MyFoo&gt; b;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//     b.swap(a);</span><br><span class="hljs-comment">//     // now, |b| references the MyFoo object, and |a| references nullptr.</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// To make both |a| and |b| in the above example reference the same MyFoo</span><br><span class="hljs-comment">// object, simply use the assignment operator:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   &#123;</span><br><span class="hljs-comment">//     scoped_refptr&lt;MyFoo&gt; a = MakeRefCounted&lt;MyFoo&gt;();</span><br><span class="hljs-comment">//     scoped_refptr&lt;MyFoo&gt; b;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//     b = a;</span><br><span class="hljs-comment">//     // now, |a| and |b| each own a reference to the same MyFoo object.</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Also see Chromium&#x27;s ownership and calling conventions:</span><br><span class="hljs-comment">// https://chromium.googlesource.com/chromium/src/+/lkgr/styleguide/c++/c++.md#object-ownership-and-calling-conventions</span><br><span class="hljs-comment">// Specifically:</span><br><span class="hljs-comment">//   If the function (at least sometimes) takes a ref on a refcounted object,</span><br><span class="hljs-comment">//   declare the param as scoped_refptr&lt;T&gt;. The caller can decide whether it</span><br><span class="hljs-comment">//   wishes to transfer ownership (by calling std::move(t) when passing t) or</span><br><span class="hljs-comment">//   retain its ref (by simply passing t directly).</span><br><span class="hljs-comment">//   In other words, use scoped_refptr like you would a std::unique_ptr except</span><br><span class="hljs-comment">//   in the odd case where it&#x27;s required to hold on to a ref while handing one</span><br><span class="hljs-comment">//   to another component (if a component merely needs to use t on the stack</span><br><span class="hljs-comment">//   without keeping a ref: pass t as a raw T*).</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">scoped_refptr</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">typedef</span> T element_type;<br><br>  <span class="hljs-comment">//下面都是封装指针的常规操作，可以参考STL中iterator对指针的封装</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">scoped_refptr</span><span class="hljs-params">()</span> </span>= <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-comment">// Constructs from raw pointer. constexpr if |p| is null.</span><br>  <span class="hljs-comment">// 原生指针做参数的构造器</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">scoped_refptr</span><span class="hljs-params">(T* p)</span> : ptr_(p) &#123;</span><br>    <span class="hljs-keyword">if</span> (ptr_)<br>      <span class="hljs-built_in">AddRef</span>(ptr_);<br>  &#125;<br><br>  <span class="hljs-comment">// Copy constructor. This is required in addition to the copy conversion</span><br>  <span class="hljs-comment">// constructor below.</span><br>  <span class="hljs-comment">// 拷贝构造，直接中继原生指针构造</span><br>  <span class="hljs-built_in">scoped_refptr</span>(<span class="hljs-type">const</span> scoped_refptr&amp; r) : <span class="hljs-built_in">scoped_refptr</span>(r.ptr_) &#123;&#125;<br><br>  <span class="hljs-comment">// Copy conversion constructor.</span><br>  <span class="hljs-comment">// 拷贝转换构造，因为指针可能类型不同，这需要引入另一个类模板，且需要判断U到T是否允许转换</span><br>  <span class="hljs-comment">// 依然中继原生指针构造</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U,<br>            <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>                std::is_convertible&lt;U*, T*&gt;::value&gt;::type&gt;<br>  <span class="hljs-built_in">scoped_refptr</span>(<span class="hljs-type">const</span> scoped_refptr&lt;U&gt;&amp; r) : <span class="hljs-built_in">scoped_refptr</span>(r.ptr_) &#123;&#125;<br><br>  <span class="hljs-comment">// Move constructor. This is required in addition to the move conversion</span><br>  <span class="hljs-comment">// constructor below.</span><br>  <span class="hljs-comment">// 移动构造</span><br>  <span class="hljs-built_in">scoped_refptr</span>(scoped_refptr&amp;&amp; r) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">ptr_</span>(r.ptr_) &#123; r.ptr_ = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//注意要清空右值引用r本体 &#125;</span><br><br>  <span class="hljs-comment">// Move conversion constructor.</span><br>  <span class="hljs-comment">// 移动转换构造</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U,<br>            <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>                std::is_convertible&lt;U*, T*&gt;::value&gt;::type&gt;<br>  <span class="hljs-built_in">scoped_refptr</span>(scoped_refptr&lt;U&gt;&amp;&amp; r) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">ptr_</span>(r.ptr_) &#123;<br>    r.ptr_ = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//析构</span><br>  ~<span class="hljs-built_in">scoped_refptr</span>() &#123;<br>    <span class="hljs-built_in">static_assert</span>(!base::subtle::<span class="hljs-built_in">IsRefCountPreferenceOverridden</span>(<br>                      <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(<span class="hljs-literal">nullptr</span>)),<br>                  <span class="hljs-string">&quot;It&#x27;s unsafe to override the ref count preference.&quot;</span><br>                  <span class="hljs-string">&quot; Please remove REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE&quot;</span><br>                  <span class="hljs-string">&quot; from subclasses.&quot;</span>);<br>    <span class="hljs-keyword">if</span> (ptr_)<br>      <span class="hljs-built_in">Release</span>(ptr_);<br>  &#125;<br><br>  <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ptr_; &#125;<br><br>  <span class="hljs-comment">// 解引用</span><br>  T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-built_in">DCHECK</span>(ptr_);<br>    <span class="hljs-keyword">return</span> *ptr_;<br>  &#125;<br><br>  <span class="hljs-comment">// 解引用</span><br>  T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-built_in">DCHECK</span>(ptr_);<br>    <span class="hljs-keyword">return</span> ptr_;<br>  &#125;<br><br>  <span class="hljs-comment">// 赋值操作</span><br>  scoped_refptr&amp; <span class="hljs-keyword">operator</span>=(T* p) &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> = <span class="hljs-built_in">scoped_refptr</span>(p); &#125;<br><br>  <span class="hljs-comment">// Unified assignment operator.</span><br>  <span class="hljs-comment">// 指针直接赋值也可以，给了特权，实际上内部做了交换</span><br>  scoped_refptr&amp; <span class="hljs-keyword">operator</span>=(scoped_refptr r) <span class="hljs-keyword">noexcept</span> &#123;<br>    <span class="hljs-built_in">swap</span>(r);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(scoped_refptr&amp; r)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; std::<span class="hljs-built_in">swap</span>(ptr_, r.ptr_); &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ptr_ != <span class="hljs-literal">nullptr</span>; &#125;<br><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> scoped_refptr&lt;U&gt;&amp; rhs) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> ptr_ == rhs.<span class="hljs-built_in">get</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> scoped_refptr&lt;U&gt;&amp; rhs) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">operator</span>==(rhs);<br>  &#125;<br><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> scoped_refptr&lt;U&gt;&amp; rhs) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> ptr_ &lt; rhs.<span class="hljs-built_in">get</span>();<br>  &#125;<br><br> <span class="hljs-keyword">protected</span>:<br>  T* ptr_ = <span class="hljs-literal">nullptr</span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> scoped_refptr&lt;U&gt; <span class="hljs-title">base::AdoptRef</span><span class="hljs-params">(U*)</span></span>;<span class="hljs-comment">//通过原生指针创建scoped_refptr而不增加引用计数</span><br>  <span class="hljs-built_in">scoped_refptr</span>(T* p, base::subtle::AdoptRefTag) : <span class="hljs-built_in">ptr_</span>(p) &#123;&#125;<br><br>  <span class="hljs-comment">// Friend required for move constructors that set r.ptr_ to null.</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">scoped_refptr</span>;<span class="hljs-comment">//移动构造器中对r.ptr置空，需要声明friend</span><br><br>  <span class="hljs-comment">// Non-inline helpers to allow:</span><br>  <span class="hljs-comment">//     class Opaque;</span><br>  <span class="hljs-comment">//     extern template class scoped_refptr&lt;Opaque&gt;;</span><br>  <span class="hljs-comment">// Otherwise the compiler will complain that Opaque is an incomplete type.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">AddRef</span><span class="hljs-params">(T* ptr)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Release</span><span class="hljs-params">(T* ptr)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chromium</tag>
      
      <tag>chromium-sandbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中断内幕</title>
    <link href="/2017/12/21/Linux%E4%B8%AD%E6%96%AD%E5%86%85%E5%B9%95/"/>
    <url>/2017/12/21/Linux%E4%B8%AD%E6%96%AD%E5%86%85%E5%B9%95/</url>
    
    <content type="html"><![CDATA[<p>近年来陆陆续续对Linux内核各模块做些研究，本文是对Linux内核中断的一点研究。主要参考ULK以及毛批，结合自己的一些深入的理解，以及从源代码中翻箱倒柜获取的心得。</p><span id="more"></span><h1 id="linux中断内幕">Linux中断内幕</h1><p>早在学习8086汇编的时候，就接触过中断的概念。而在现代操作系统如Linux,Windows上，对中断的理解，概多源于道听途说，也就一知半解，时常被各种细分的术语搞得云里雾里。在阅读了大量的文献与Linux相关源码后，我将对Linux的中断内幕进行一波小小的归纳。有道是纸上得来终觉浅。</p><blockquote><p>外中断、内中断、硬中断、软中断、异常、陷阱、错误、终止、可编程中断/异常、IRQ、Tasklet、工作队列</p><p>如果你对这些了如指掌，辨识得清清楚楚，绕过本文即可。</p></blockquote><h2 id="中断的宏观意义">中断的宏观意义</h2><p>毛批和ULK在谈到中断时，标题都是将中断和异常并列而论，甚至毛批中将系统调用这么个子类也放在了标题，或许是因为系统调用太重要了。</p><p>在研究了大量的资料后，私以为使用宏观意义的中断概念来做标题或许更佳，这也是本文标题的由来。</p><p>追根溯源，中断只是个宏观概念，参见程序员素质二连，要么轮询、要么中断。这一思想在程序设计中随处可见，如自旋锁和睡眠锁，前者一直在BB着：“我现在可以起床了吗”，而后者则不声不响，等待其他人（进程）的唤醒（Heyguy，it's time to get up!）。</p><p>所以中断的意义，我引用鱼C甲鱼兄的诠释：中断就是你在房间里看苍老师的片儿，你妈妈突然进来告诉你让你下去打酱油，于是你按下暂停键，出去打酱油，回来之后再continue。</p><p>一个严格的归纳：从本质上来讲，中断是一种电信号，当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器（如8259A）。如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，跳到中断处理程序的入口点，进行中断处理。</p><h2 id="中断分类">中断分类</h2><p>从信号源来分，中断有两种，由外部的硬件设备产生（这称为外中断）或者是CPU内部产生的（这称为内中断，内部产生可以有两种，一种是指令执行出错比如除0，另一种是使用软中断指令intx）。而从另一个角度来看，由硬件引起的叫硬中断，软件引起的叫软中断。Linux中软中断是个“二义”的概念，之所打上引号，是因为实际上殊途同归，后面会谈到。</p><p>Linux中很难看到内外中断的说法，但是软硬中断则随处可见。按照我的理解，外中断就是硬中断，而内中断不完全是软中断（之所以这样说，是因为硬中断是Linux处理IRQ的上半部分，下半部分交由软中断完成，这里的软中断入口方式和直接使用intx指令不同，但最终结果都是找服务例程），采用软硬是为了更好的区分中断信号是硬件给的还是由软件产生的。</p><p>而按照Intel手册的区分，中断应该分为同步中断和异步中断。显然，硬中断是异步的，因为你不知道它什么时候来搞事情（如键盘中断）。相反的，软中断则是同步的，因为只有在一条指令终止执行后CPU才会发出中断（如系统调用）。</p><p>Intel手册将异步中断称为中断(interrupt)，同步中断称为异常(exception)。它们的不同已经清楚了，而共同点则是都有一个中断服务例程，也就是具体要做的事（例子中的打酱油）。</p><p><strong>为了区分宏观意义的中断和异步中断，下文统一将前者称为中断，后者称为interrupt。</strong></p><h3 id="interrupt">Interrupt</h3><p>Interrupt分为可屏蔽中断(maskable interrupt)和非屏蔽中断(nonmaskableinterrupt)。可屏蔽中断由两种状态：已屏蔽(masked)和未屏蔽(unmasked)，非屏蔽中断顾名思义不可屏蔽（有限的几个危急事件如硬件故障，所以我们常说硬中断是可屏蔽的，这并不包括nonmaskableinterrupt）。</p><h3 id="exception">Exception</h3><p>Exception分为三类，错误(fault)、陷阱(trap)和终止(abort)。</p><p>三者的区别主要在于返回的位置不同。fault在返回后依然会重新执行引起故障的指令（缺页异常就是fault，要保证连贯性）；trap返回后执行下一条指令（调试器断点）；abort则不会返回，这往往意味着发生了一个严重错误，异常中止处理程序会终止引起abort的进程。</p><h3 id="小结">小结</h3><p>所以中断分为四类：interrupt, fault, trap和abort。</p><table><thead><tr class="header"><th>类别</th><th>原因</th><th>异步/同步</th><th>返回行为</th></tr></thead><tbody><tr class="odd"><td>interrupt</td><td>来自I/O设备的信号</td><td>异步</td><td>总是返回到下一条指令</td></tr><tr class="even"><td>fault</td><td>潜在可恢复的错误</td><td>同步</td><td>返回到当前指令</td></tr><tr class="odd"><td>trap</td><td>有意的异常</td><td>同步</td><td>总是返回到下一条指令</td></tr><tr class="even"><td>abort</td><td>不可恢复的错误</td><td>同步</td><td>不返回</td></tr></tbody></table><h2 id="irq">IRQ</h2><p>IRQ和中断的关联，我直接引用blcblc的归纳：</p><p><strong>中断处理程序比一个进程要“轻”（中断的上下文很少，建立或终止中断处理需要的时间也很少）</strong></p><p>中断处理是内核执行的最敏感的任务之一，因此它必须满足下列约束：</p><p>​ ◎当内核正打算去完成一些别的事情时，中断随时会到来。因此，内核的目标就是让中断尽可能快地处理完，尽其所能把更多的处理向后推迟。因此，内核响应中断后需要进行的操作分为两部分：关键而紧急的部分，内核立即执行；其余推迟的部分，内核随后执行。​◎因为中断随时会到来，所以内核可能正在处理其中的一个中断时，另一个不同类型的中断又发生了。内核应该尽可能地允许这种情况发生，因为这能维持更多的I/O设备得到处理的机会。因此，中断处理程序必须编写成使相应的内核控制路径能以嵌套的方式执行。当最后一个内核控制路径终止时，内核必须能恢复被中断进程的执行，或者，如果中断信号已导致了重新调度，内核也应能切换到另外的进程。​◎尽管内核在处理前一个中断时可以接受一个新的中断，但在内核代码中还是存在一些临界区，在临界区中，中断必须被禁止。必须尽可能地限制这样的临界区，因为根据以前的要求，内核，尤其是中断处理程序，应该在大部分时间内以开中断的方式运行。</p><p>因为外部设备不能直接发出中断，而必须通过中断控制器的标准组件来请求中断，<strong>所以这种请求更正确的叫法是IRQ，或中断请求（InterruptRequest）</strong>。中断不能由处理器外部的外设直接产生，而必须借助于一个称为可编程中断控制器（programmableinterrupt controller,<strong>PIC</strong>）的标准组件来请求，该组件存在于每个系统中。外部设备，会有电路连接到用于向中断控制器发送中断请求的组件。控制器在执行了各种电工任务之后，将中断请求转发到CPU的中断输入中。</p><p><strong>每个能够发出中断请求的硬件设备控制器都有这么一条名为IRQ的输出线</strong>。所有现有的IRQ线都会与这个中断控制器（PIC）的硬件电路的输入引脚相连。下面来看看这种中断控制器执行下列动作：</p><p>​ 1) 监视IRQ线，检查产生的信号。如果有一条或两条以上的IRQ线上产生信号，就选择引脚编号较小的IRQ线。</p><p>​ 2) 如果一个引发信号出现在IRQ线上：</p><p>​ a) 把接收到的引发信号转换成对应的向量（索引）。</p><p>​ b)把这个向量存放在中断控器的一个I/O端口，<strong>从而允许CPU通过数据总线读取此向量</strong>。</p><p>​ c)<strong>把引发信号发送到处理器的INTR引脚，即产生一个中断</strong>。</p><p>​ d)等待，<strong>直到CPU通过把这个中断信号写进可编程中断控制器的一个I/O端口来确认它</strong>；当这种情况发生时，清INTR线。</p><p>​ 3) 返回到第一步。</p><p>​IRQ线是从0开始顺序编号的，因此，第一条IRQ线通常表示成IRQ0。与IRQn关联的Intel缺省向量是n+32。如前所述，通过向中断控制器端口发布合适的指令，就可以修改IRQ和向量之间的映射。</p><p>​可以有选择地禁止每条IRQ线。因此，<strong>可以对PIC编程从而禁止IRQ</strong>，也就是说，可以告诉PIC停止对给定的IRQ线发布中断，或者激活它们，<strong>禁止的中断是丢失不了的，它们一旦激活，PIC就又把它们发送到CPU。</strong>这个特点被大多数中断处理程序使用，因为这允许中断处理程序逐次地处理同一类型的IRQ。</p><h2 id="idt">IDT</h2><p>中断描述符表（<em>Interrupt DescriptorTable，IDT</em>）是一个系统表，它与每一个中断或异常向量相联系，每一个向量在表中存放的是相应的中断或异常处理程序的入口地址。内核在允许中断发生前，也就是在系统初始化时，必须把IDT 表的初始化地址装载到 <code>idtr</code>寄存器中，初始化表中的每一项。</p><p>当处于实模式下时，IDT 被初始化并由 BIOS 程序所使用。然而，一旦 Linux开始接管，IDT 就被移到 RAM 的另一个区域，并进行第二次初始化，因为 Linux不使用任何 BIOS程序，而使用自己专门的中断服务程序（例程）（<em>interrupt serviceroutine，ISR</em>）。中断和异常处理程序很像常规的 C 函数</p><p>IDT的格式和GDT和LDT相似，表中每一项对应一个中断(interrupt orexception)向量，每个向量由8个字节组成，共256项。<code>idtr</code>使IDT可以位于内存的任何地方，它指定IDT的线性基地址及其限制（最大长度）。在允许中断之前，必须用<code>lidt</code>汇编指令来初始化<code>idtr</code>。</p><p>IDT包含三种类型描述符作为表项，任务门描述符、中断门描述符和陷阱门描述符。</p><p><img src="20171220_1.jpg" /></p><ul><li>任务门：<ul><li>当中断信号发生时，必须取代当前进程的那个进程的TSS选择符放在任务门中。</li><li>TSS段选择符和CS、DS相似，通过GDT和LDT指向特殊的“系统段”中的一种，称为任务状态段。TSS用于保护现场，包括CPU中所有与具体进程有关的寄存器内容（包含页面目录指针CR3）以及3个堆栈指针。</li><li>P标志位为1表示在内存中，DPL描述项优先级别，类型码为00101。</li><li>中断发生时，如果CPU找到的项是任务门，且DPL安检通过，CPU就将现场保存在TSS中，将任务门指向的任务变成当前任务，实现任务切换。（为了完成切换回路，CPU还有一个TR寄存器，用于指向当前的TSS）</li><li>Intel硬件设计任务门旨在让OS使用它来完成进程切换，但Linux并没有采用这一硬件特性，实际上Linux仅在处理Defaultfault Exception时使用了任务门，表示一种内核错误。</li></ul></li><li>中断门：<ul><li>包含段选择符和中断或异常处理程序的段内偏移量。当控制权转移到一个适当的段时，处理器清IF标志，从而关闭将来会发生的可屏蔽中断。</li><li>指向的是一个子程序，所以除了段选择码外，还需要结合段内偏移</li></ul></li><li>陷阱门：<ul><li>与中断们类似，只是控制权传递到一个适当的段时处理器不修改IF标志。</li><li>通过类型码区分中断门和陷阱门。</li></ul></li></ul><blockquote><p>实际上还有个调用门，它和中断门、陷阱门结构一致，类型码不同。IDT中不包含调用门，Linux不用它做中断处理。</p><p>Linux分别抽离了三个陷阱门和一个中断门，美其名曰系统中断门和系统门。前者用于用户态进程访问陷阱门（门DPL值为3），通过系统门激活3个异常处理程序，分别对应向量4,5,128，也就是<code>into</code>，<code>bound</code>和<code>int 80H</code>三个指令；后者也是用户态访问中断门（DPL为3），提供向量3相关的处理程序，也就是<code>int 3</code>,单步中断。除了这四个个DPL为3的中断/陷阱门外，其他的DPL都是0，且Linux也把它们称为中断/陷阱门。</p></blockquote><h3 id="idt初始化">IDT初始化</h3><p>内核初始化阶段完成虚存管理初始化后会调用trap_init()和init_IRQ()初始化IDT：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 调用trap_init()来设置系统规定的异常与中断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> __init <span class="hljs-title">trap_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_EISA</span><br><span class="hljs-type">void</span> __iomem *p = <span class="hljs-built_in">ioremap</span>(<span class="hljs-number">0x0FFFD9</span>, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">readl</span>(p) == <span class="hljs-string">&#x27;E&#x27;</span>+(<span class="hljs-string">&#x27;I&#x27;</span>&lt;&lt;<span class="hljs-number">8</span>)+(<span class="hljs-string">&#x27;S&#x27;</span>&lt;&lt;<span class="hljs-number">16</span>)+(<span class="hljs-string">&#x27;A&#x27;</span>&lt;&lt;<span class="hljs-number">24</span>)) &#123;<br>EISA_bus = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">iounmap</span>(p);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_LOCAL_APIC</span><br><span class="hljs-built_in">init_apic_mappings</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 设置了0~19的中断/异常处理程序,这些都是intel所规定的,除些之后设置了系统调用入口(用户空间的 int SYSCALL_VECTOR )</span><br><span class="hljs-comment">  */</span><br><span class="hljs-built_in">set_trap_gate</span>(<span class="hljs-number">0</span>,&amp;divide_error);<br><span class="hljs-built_in">set_intr_gate</span>(<span class="hljs-number">1</span>,&amp;debug);<br><span class="hljs-built_in">set_intr_gate</span>(<span class="hljs-number">2</span>,&amp;nmi);<br><span class="hljs-built_in">set_system_intr_gate</span>(<span class="hljs-number">3</span>, &amp;int3); <span class="hljs-comment">/* int3-5 can be called from all */</span><br><span class="hljs-built_in">set_system_gate</span>(<span class="hljs-number">4</span>,&amp;overflow);<br><span class="hljs-built_in">set_system_gate</span>(<span class="hljs-number">5</span>,&amp;bounds);<br><span class="hljs-built_in">set_trap_gate</span>(<span class="hljs-number">6</span>,&amp;invalid_op);<br><span class="hljs-built_in">set_trap_gate</span>(<span class="hljs-number">7</span>,&amp;device_not_available);<br><span class="hljs-comment">/* 通过GDT_ENTRY_DOUBLEFAULT_TSS 取得GDT 第32 表项的值填充eip和esp</span><br><span class="hljs-comment"> * 并在私有栈上执行doublefault_fn() 异常处理函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">set_task_gate</span>(<span class="hljs-number">8</span>,GDT_ENTRY_DOUBLEFAULT_TSS);<br><span class="hljs-built_in">set_trap_gate</span>(<span class="hljs-number">9</span>,&amp;coprocessor_segment_overrun);<br><span class="hljs-built_in">set_trap_gate</span>(<span class="hljs-number">10</span>,&amp;invalid_TSS);<br><span class="hljs-built_in">set_trap_gate</span>(<span class="hljs-number">11</span>,&amp;segment_not_present);<br><span class="hljs-built_in">set_trap_gate</span>(<span class="hljs-number">12</span>,&amp;stack_segment);<br><span class="hljs-built_in">set_trap_gate</span>(<span class="hljs-number">13</span>,&amp;general_protection);<br><span class="hljs-built_in">set_intr_gate</span>(<span class="hljs-number">14</span>,&amp;page_fault);<br><span class="hljs-built_in">set_trap_gate</span>(<span class="hljs-number">15</span>,&amp;spurious_interrupt_bug);<br><span class="hljs-built_in">set_trap_gate</span>(<span class="hljs-number">16</span>,&amp;coprocessor_error);<br><span class="hljs-built_in">set_trap_gate</span>(<span class="hljs-number">17</span>,&amp;alignment_check);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_MCE</span><br><span class="hljs-built_in">set_trap_gate</span>(<span class="hljs-number">18</span>,&amp;machine_check);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">set_trap_gate</span>(<span class="hljs-number">19</span>,&amp;simd_coprocessor_error);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 系统调用</span><br><span class="hljs-comment"> * 内核初始化期间,建立对应于向量128的中断描述符表表项</span><br><span class="hljs-comment"> * 当用户态进程发出 int $0x80 指令时,CPU切换到内核态并开始从地址system_call处开始执行指令</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">set_system_gate</span>(SYSCALL_VECTOR,&amp;system_call);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Should be a barrier for any external CPU state.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">cpu_init</span>();<br><br><span class="hljs-built_in">trap_init_hook</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>源码中也可以看出前文描述符的Linux门的分类。这些set操作无非就是对DPL进行了封装：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*设定中断门*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_intr_gate</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n, <span class="hljs-type">void</span> *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>_set_gate(idt_table+n,<span class="hljs-number">14</span>,<span class="hljs-number">0</span>,addr,__KERNEL_CS);<br>&#125;<br><br><span class="hljs-comment">/*设定系统中断门*/</span> <br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">set_system_intr_gate</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n, <span class="hljs-type">void</span> *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>_set_gate(idt_table+n, <span class="hljs-number">14</span>, <span class="hljs-number">3</span>, addr, __KERNEL_CS);<br>&#125;<br><br><span class="hljs-comment">/*设定陷阱门*/</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __init <span class="hljs-title">set_trap_gate</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n, <span class="hljs-type">void</span> *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>_set_gate(idt_table+n,<span class="hljs-number">15</span>,<span class="hljs-number">0</span>,addr,__KERNEL_CS);<br>&#125;<br><br><span class="hljs-comment">/*设定系统门*/</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __init <span class="hljs-title">set_system_gate</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n, <span class="hljs-type">void</span> *addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 设置如下字段</span><br><span class="hljs-comment">     *  Segment Selector: 内核代码段 __KERNEL_CS的段选择符</span><br><span class="hljs-comment">     *  Offset: 指向system_call()系统调用处理程序的指针</span><br><span class="hljs-comment">     *  Type: 设置为15，表示这个异常是一个陷阱，相应的处理程序不禁止可屏蔽中断</span><br><span class="hljs-comment">     *  DPL: 设置为3，这就允许用户态进程调用这个异常处理程序</span><br><span class="hljs-comment"> */</span><br>_set_gate(idt_table+n,<span class="hljs-number">15</span>,<span class="hljs-number">3</span>,addr,__KERNEL_CS);<br>&#125;<br><br><span class="hljs-comment">/*设定任务门*/</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __init <span class="hljs-title">set_task_gate</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gdt_entry)</span></span><br><span class="hljs-function"></span>&#123;<br>_set_gate(idt_table+n,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,(gdt_entry&lt;&lt;<span class="hljs-number">3</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>无非就是DPL, 类型码不同罢了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @gate_addr:相应IDT项的地址.</span><br><span class="hljs-comment"> * @type:设置IDT项的TYPE字段, 15表示系统门,14表示中断门.</span><br><span class="hljs-comment"> * @dpl:IDT项对应的DPL值,</span><br><span class="hljs-comment"> * @addr:中断处理程序的地址,</span><br><span class="hljs-comment"> * @seg:IDT中对应项的段选择符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _set_gate(gate_addr,type,dpl,addr,seg) \</span><br><span class="hljs-meta">do &#123; \</span><br><span class="hljs-meta">  int __d0, __d1; \</span><br><span class="hljs-meta">  __asm__ __volatile__ (<span class="hljs-string">&quot;movw %%dx,%%ax\n\t&quot;</span> \</span><br><span class="hljs-meta"><span class="hljs-string">&quot;movw %4,%%dx\n\t&quot;</span> \</span><br><span class="hljs-meta"><span class="hljs-string">&quot;movl %%eax,%0\n\t&quot;</span> \</span><br><span class="hljs-meta"><span class="hljs-string">&quot;movl %%edx,%1&quot;</span> \</span><br><span class="hljs-meta">:<span class="hljs-string">&quot;=m&quot;</span> (*((long *) (gate_addr))), \</span><br><span class="hljs-meta"> <span class="hljs-string">&quot;=m&quot;</span> (*(1+(long *) (gate_addr))), <span class="hljs-string">&quot;=&amp;a&quot;</span> (__d0), <span class="hljs-string">&quot;=&amp;d&quot;</span> (__d1) \</span><br><span class="hljs-meta">:<span class="hljs-string">&quot;i&quot;</span> ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \</span><br><span class="hljs-meta"> <span class="hljs-string">&quot;3&quot;</span> ((char *) (addr)),<span class="hljs-string">&quot;2&quot;</span> ((seg) &lt;&lt; 16)); \</span><br><span class="hljs-meta">&#125; while (0)</span><br></code></pre></td></tr></table></figure><p>牺牲可读性而提升效率的典型案例。AT&amp;T秀的我脑壳疼。</p><blockquote><p>读AT&amp;T要有耐性，先把输入输出部按部就班的和%x以及寄存器对应上，然后再读汇编指令。不清楚为什么要设计这么反人类的语法。。。</p></blockquote><p>再看对外部中断的IRQ初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*IRQ中断的设置*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> __init <span class="hljs-title">init_IRQ</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-comment">/* all the set up before the call gates are initialised */</span><br><span class="hljs-comment">//8259初始化，初始化了irq_desc[]数组</span><br><span class="hljs-built_in">pre_intr_init_hook</span>();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Cover the whole vector space, no vector can escape</span><br><span class="hljs-comment"> * us. (some of these will be overridden and become</span><br><span class="hljs-comment"> * &#x27;special&#x27; SMP interrupts)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过替换setup_idt() 所建立的中断门来更新IDT</span><br><span class="hljs-comment"> * interrupt 数组第n 项中存放IRQn 的中断处理程序的地址</span><br><span class="hljs-comment"> * 这里不包括128(0x80) 号中断向量相关的中断门，因为它用于系统调用的编程异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//FIRST_EXTERNAL_VECTOR:第一个可用号,前面部份均为系统保留</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; (NR_VECTORS - FIRST_EXTERNAL_VECTOR); i++) &#123;<br><span class="hljs-type">int</span> vector = FIRST_EXTERNAL_VECTOR + i;<br><span class="hljs-keyword">if</span> (i &gt;= NR_IRQS)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//跳过系统调用号</span><br><span class="hljs-keyword">if</span> (vector != SYSCALL_VECTOR) <br><span class="hljs-comment">//调用了set_intr_gate(vector, interrupt[i])为第n条中断线设置的中断处理函数为interrupt[n- FIRST_EXTERNAL_VECTOR].</span><br><span class="hljs-built_in">set_intr_gate</span>(vector, interrupt[i]);<br>&#125;<br><br><span class="hljs-comment">/* setup after call gates are initialised (usually add in</span><br><span class="hljs-comment"> * the architecture specific gates)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">intr_init_hook</span>();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Set the clock to HZ Hz, we already have a valid</span><br><span class="hljs-comment"> * vector now:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">setup_pit_timer</span>();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * External FPU? Set up irq13 if so, for</span><br><span class="hljs-comment"> * original braindamaged IBM FERR coupling.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (boot_cpu_data.hard_math &amp;&amp; !cpu_has_fpu)<br><span class="hljs-built_in">setup_irq</span>(FPU_IRQ, &amp;fpu_irq);<br><br><span class="hljs-built_in">irq_ctx_init</span>(<span class="hljs-built_in">smp_processor_id</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cpu处理流程">CPU处理流程</h3><p>CPU执行下一条指令前，控制单元会检查是否已经发生了一个interrupt或exception。如果有，则进行这些操作：</p><ol type="1"><li>确定关联的向量i</li><li>读由<code>idtr</code>指向的IDT表的第i项（忽略任务门，我们假设是个中断门或陷阱门）</li><li>从<code>gdtr</code>寄存器获得GDT基地址，在GDT中查找，读取IDT表项中选择符所标志的段描述符。这个描述符指定处理程序的基地址。</li><li>安检。将当前特权级CPL（<code>cs</code>寄存器低2位）与段描述符（GDT中）的DPL比较，如果CPL小于DPL则产生通用保护异常，因为中断处理程序的特权不能低于引起中断的程序的特权。对于编程异常，则进一步安检：比较CPL与IDT中门描述符的DPL，如果DPL小于CPL，也产生通用保护异常，这是为了防止用户程序访问特殊的陷阱门或中断门。</li><li>检查是否发生了特权级的变化（CPL是否不同于所选择的段描述符的DPL，用户栈-&gt;内核栈），如果是，控制单元必须开始使用与新的特权级相关的栈。操作如下：<ol type="1"><li>读<code>tr</code>寄存器，访问运行进程的TSS段</li><li>用与新特权级相关的栈段和栈指针的正确值装载<code>ss</code>和<code>esp</code>寄存器。这些值可以在TSS中找到。</li><li>在新的栈中保存<code>ss</code>和<code>esp</code>以前的值，这些值定义了与旧特权级相关的栈的逻辑地址。</li></ol></li><li>如果故障已发生，用引起异常的指令地址装载<code>cs</code>和<code>eip</code>寄存器，使得指令可以重新执行。</li><li>栈中保存<code>eflags</code>，<code>cs</code>和<code>eip</code>。</li><li>如果异常产生了一个硬件错误码，则也保存在栈中。</li><li>装载<code>cs</code>和<code>eip</code>，值分别是IDT表中第i项门描述符的段选择符和偏移量字段。这些值指定了处理程序的第一条指令的逻辑地址。</li></ol><p>处理完成后，程序的最后一定有一个<code>iret</code>指令，回到被中断的进程，过程如下：</p><ol type="1"><li>用保存在栈中的值装载<code>cs,eip</code>和<code>eflags</code>。如果曾经压了错误码，还需要<code>iret</code>前弹出（这个事情显然由处理例程做了，处理例程知道自己是interrupt还是exception）。</li><li>检查处理程序的CPL是否等于<code>cs</code>中最低两位的值（这意味着中断的进程和处理程序运行在同一特权级），如果是，<code>iret</code>终止执行；否则继续下一步。</li><li>从栈中装载<code>ss</code>和<code>esp</code>寄存器，因此返回到了旧特权级栈（内核栈-&gt;用户栈）。</li><li>检查<code>ds,es,fs,gs</code>段寄存器的内容，如果其中一个寄存器包含的选择符是一个段描述符，并且其DPL值小于CPL，那么，清相应的段寄存器。控制单元这么做是为了禁止用户应用程序（CPL=3）利用内核以前所利用的段寄存器（DPL=0）。</li></ol><p>一图胜千言：</p><p><img src="20171220_2.jpg" /></p><h3 id="irq数据结构">IRQ数据结构</h3><p>每个IDT表项都有一个中断请求队列，这个请求队列用一个<code>irq_desc_t</code>描述符描述，所有的<code>irq_desc_t</code>组成了<code>irq_desc[]</code>数组。</p><p><img src="20171220_4.jpg" /></p><p>Linux内核的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hw_interrupt_type</span> &#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-keyword">typename</span>;  <span class="hljs-comment">/*中断控制器的名字*/</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-params">(*startup)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq)</span></span>; <span class="hljs-comment">/*允许从IRQ线产生中断*/</span><br><span class="hljs-built_in">void</span> (*shutdown)(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq); <span class="hljs-comment">/*禁止从IRQ线产生中断*/</span><br><br><span class="hljs-comment">/*enable与disable函数在8259A中与上述的startup shutdown函数相同*/</span><br><span class="hljs-built_in">void</span> (*enable)(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq); <br><span class="hljs-built_in">void</span> (*disable)(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq); <br><br><span class="hljs-built_in">void</span> (*ack)(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq);  <span class="hljs-comment">/*在IRQ线上产生一个应答*/</span><br><span class="hljs-built_in">void</span> (*end)(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq);  <span class="hljs-comment">/*在IRQ处理程序终止时被调用*/</span><br><span class="hljs-built_in">void</span> (*set_affinity)(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq, <span class="hljs-type">cpumask_t</span> dest);  <span class="hljs-comment">/*在SMP系统中,设置IRQ处理的亲和力*/</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hw_interrupt_type</span>  hw_irq_controller;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">irq_desc</span> &#123;<br>hw_irq_controller *handler; <span class="hljs-comment">/*指向一个中断控制器的指针（用来控制该中断线行为的函数指针）*/</span><br><span class="hljs-type">void</span> *handler_data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">irqaction</span> *action;<span class="hljs-comment">/* IRQ action list */</span><span class="hljs-comment">/* 挂在IRQ上的中断处理程序 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> status;<span class="hljs-comment">/* IRQ status */</span> <span class="hljs-comment">/* IRQ的状态;IRQ 是否被禁止了，有关IRQ的设备当前是否正被自动检测*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> depth;<span class="hljs-comment">/* nested irq disables */</span> <span class="hljs-comment">/* 为0:该IRQ被启用,如果为一个正数,表示被禁用 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq_count;<span class="hljs-comment">/* For detecting broken interrupts */</span> <span class="hljs-comment">/*  该IRQ发生的中断的次数 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irqs_unhandled; <span class="hljs-comment">/*该IRQ线上没有被处理的IRQ总数*/</span><br><span class="hljs-type">spinlock_t</span> lock;<br>&#125; ____cacheline_aligned <span class="hljs-type">irq_desc_t</span>;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">irq_desc_t</span> irq_desc [NR_IRQS];<br></code></pre></td></tr></table></figure><p>在看<code>irqaction</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">irqaction</span> &#123;<br><span class="hljs-built_in">irqreturn_t</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *, <span class="hljs-keyword">struct</span> pt_regs *); <span class="hljs-comment">//中断处理例程</span><br><br><span class="hljs-comment">/*flags:</span><br><span class="hljs-comment"> *SA_INTERRUPT:中断嵌套</span><br><span class="hljs-comment"> *SA_SAMPLE_RANDOM:这个中断源于物理随机性</span><br><span class="hljs-comment"> *SA_SHIRQ:中断线共享</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags; <br><br><span class="hljs-type">cpumask_t</span> mask; <span class="hljs-comment">//在x86平台无用</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name; <span class="hljs-comment">//产生中断的硬件名字</span><br><span class="hljs-type">void</span> *dev_id; <span class="hljs-comment">//设备ID,一般由厂商指定</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">irqaction</span> *next; <span class="hljs-comment">//下一个irqaction.共享的时候,通常一根中断线对应很多硬件设备的中断处理例程</span><br><span class="hljs-type">int</span> irq;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">proc_dir_entry</span> *dir;<br>&#125;;<br></code></pre></td></tr></table></figure><p>handler即指向了最为重要的中断服务程序。IDT表初始化完成之初，这些中断服务队列都是空的，所以当CPU通过门进入了总服务程序后，仅仅是做了对中断控制器的<code>ack()</code>和<code>end()</code>表面应答，没什么实际内容。而一个真正的服务程序都是通过<code>request_irq()</code>登记的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设备驱动程序利用IRQ前，调用request_irq。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">request_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">irqreturn_t</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *, <span class="hljs-keyword">struct</span> pt_regs *),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> irqflags, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * devname, <span class="hljs-type">void</span> *dev_id)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">irqaction</span> * action;<br><span class="hljs-type">int</span> retval;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Sanity-check: shared interrupts must pass in a real dev-ID,</span><br><span class="hljs-comment"> * otherwise we&#x27;ll have trouble later trying to figure out</span><br><span class="hljs-comment"> * which interrupt is which (messes up the interrupt freeing</span><br><span class="hljs-comment"> * logic etc).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((irqflags &amp; SA_SHIRQ) &amp;&amp; !dev_id)<br><span class="hljs-keyword">return</span> -EINVAL;<br><span class="hljs-keyword">if</span> (irq &gt;= NR_IRQS)<br><span class="hljs-keyword">return</span> -EINVAL;<br><span class="hljs-keyword">if</span> (!handler)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 先建立一个新的irqaction描述符，并用参数值初始化它。</span><br><span class="hljs-comment"> */</span><br>action = <span class="hljs-built_in">kmalloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> irqaction), GFP_ATOMIC);<br><span class="hljs-keyword">if</span> (!action)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br>action-&gt;handler = handler;<br>action-&gt;flags = irqflags;<br><span class="hljs-built_in">cpus_clear</span>(action-&gt;mask);<br>action-&gt;name = devname;<br>action-&gt;next = <span class="hljs-literal">NULL</span>;<br>action-&gt;dev_id = dev_id;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * setup_irq函数把action描述符插入到合适的IRQ链表。</span><br><span class="hljs-comment"> */</span><br>retval = <span class="hljs-built_in">setup_irq</span>(irq, action);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果setup_irq返回一个错误码，</span><br><span class="hljs-comment"> * 说明IRQ线已经被另一个设备使用，并且设备不允许中断共享。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-built_in">kfree</span>(action);<br><br><span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><p>展开setup:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将irqaction插入到链表中</span><br><span class="hljs-comment"> * irq-IRQ号</span><br><span class="hljs-comment"> * new-要插入的描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setup_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq, <span class="hljs-keyword">struct</span> irqaction * <span class="hljs-keyword">new</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">irq_desc</span> *desc = irq_desc + irq;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">irqaction</span> *old, **p;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-type">int</span> shared = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (desc-&gt;handler == &amp;no_irq_type)<br><span class="hljs-keyword">return</span> -ENOSYS;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Some drivers like serial.c use request_irq() heavily,</span><br><span class="hljs-comment"> * so we have to be careful not to interfere with a</span><br><span class="hljs-comment"> * running system.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 如果中断可生成随机熵，则初始化随机熵机制</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>-&gt;flags &amp; SA_SAMPLE_RANDOM) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This function might sleep, we want to call it first,</span><br><span class="hljs-comment"> * outside of the atomic block.</span><br><span class="hljs-comment"> * Yes, this might clear the entropy pool if the wrong</span><br><span class="hljs-comment"> * driver is attempted to be loaded, without actually</span><br><span class="hljs-comment"> * installing a new handler, but is this really a problem,</span><br><span class="hljs-comment"> * only the sysadmin is able to do this.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">rand_initialize_irq</span>(irq);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The following block of code has to be executed atomically</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_lock_irqsave</span>(&amp;desc-&gt;lock,flags);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查是否已经有设备在使用这个IRQ了。</span><br><span class="hljs-comment"> */</span><br>p = &amp;desc-&gt;action;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 有设备在使用了。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((old = *p) != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-comment">/* Can&#x27;t share interrupts unless both agree to */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果有设备在使用这个IRQ线，就再次检查它是否允许共享IRQ。</span><br><span class="hljs-comment"> * 在这里，仅仅检查第一个挂接到IRQ上的设备是否允许共享就行了。</span><br><span class="hljs-comment"> * 其实，第一个设备允许共享就代表这个IRQ上的所有设备允许共享。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(old-&gt;flags &amp; <span class="hljs-keyword">new</span>-&gt;flags &amp; SA_SHIRQ)) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * IRQ线不允许共享，那就打开中断，并返回错误码。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;desc-&gt;lock,flags);<br><span class="hljs-keyword">return</span> -EBUSY;<br>&#125;<br><br><span class="hljs-comment">/* add new interrupt at end of irq queue */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在这里，我们已经知道设备上挂接了设备，那就循环，找到最后一个挂接的设备</span><br><span class="hljs-comment"> * 我们要插入的设备应该挂接到这个设备的后面。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">do</span> &#123;<br>p = &amp;old-&gt;next;<br>old = *p;<br>&#125; <span class="hljs-keyword">while</span> (old);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * IRQ上有设备，并且运行到这里了，表示IRQ允许共享。</span><br><span class="hljs-comment"> */</span><br>shared = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把action加到链表的末尾。</span><br><span class="hljs-comment"> */</span><br>*p = <span class="hljs-keyword">new</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断是否是与其他设备共享IRQ</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!shared) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不是共享IRQ，就说明本设备是IRQ上的第一个设备</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化相应IRQ描述符，</span><br><span class="hljs-comment"> * 清除IRQ_DISABLED， IRQ_AUTODETECT， IRQ_WAITING ，IRQ_INPROGRESS标志</span><br><span class="hljs-comment"> */</span><br>desc-&gt;depth = <span class="hljs-number">0</span>;<br>desc-&gt;status &amp;= ~(IRQ_DISABLED | IRQ_AUTODETECT |<br>  IRQ_WAITING | IRQ_INPROGRESS);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * startup 或enable是为了确保IRQ信号被激活。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (desc-&gt;handler-&gt;startup)<br>desc-&gt;handler-&gt;<span class="hljs-built_in">startup</span>(irq);<br><span class="hljs-keyword">else</span><br>desc-&gt;handler-&gt;<span class="hljs-built_in">enable</span>(irq);<br>&#125;<br><span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;desc-&gt;lock,flags);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 建立proc文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">new</span>-&gt;irq = irq;<br><span class="hljs-built_in">register_irq_proc</span>(irq);<br><span class="hljs-keyword">new</span>-&gt;dir = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">register_handler_proc</span>(irq, <span class="hljs-keyword">new</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在内核中，设备驱动程序一般都要通过<code>request_irq()</code>登记中断服务程序。</strong></p><h2 id="中断的嵌套">中断的嵌套</h2><p>Linux中断处理程序是无需重入的。当一个给定的中断处理在执行时，相应的中断线在所有处理器上都会被屏蔽掉，以防止在同一中断线上接收另一个新的中断。通常所有其他的中断都是打开的，所以这些不同中断线上的其他中断都能被处理，但当前中断线总是被禁止的。</p><p>由此可以看出，同一个中断处理程序绝对不会被同时调用以处理嵌套的中断。这大大简化了中断处理程序的编写（不然同步处理得烦死，硬件的设计也很理性，否则还不是坑自己）。</p><p>Linux下硬中断可以嵌套，且没有优先级的概念，也就是说任何一个中断都可以打断正在执行的中断（当然，根据前面的描述，同种中断除外）。软中断则不能嵌套，但同类型软中断可以在不同CPU上并行执行。</p><p><img src="20171220_3.jpg" /></p><blockquote><p>关于Linux软中断的疑问：</p><p>​ Q:Linux的下半部BH机制、软中断机制和<code>tasklet</code>机制。我印象中只有BH机制使用了<code>int</code>指令和中断向量表。软中断机制的软中断向量表难道不是内核自己维护的数据结构吗，软中断（<code>int</code>）和软中断（下半部）不应该是两码事吗？</p><p>​ A:软中断是软件引起的中断，区别于硬件引起的。可以由<code>int</code>指令引发然后执行中断向量表中的函数，也可以由内核设置标志位然后唤醒事先注册的处理函数。实现方式不同就是了。</p><p>​ r00tk1t:实际上我是赞同这一理解方式的，但严格来说<code>softirq</code>和软中断信号是两回事。关于此，毛批中的说法可能是最恰当的：硬中断是外部设备对CPU的中断，<code>softirq</code>通常是硬中断服务程序对内核的中断，而软中断信号是内核对某个进程的中断。后两者都是由软件产生的，只是来源不同，但最终处理殊途同归。</p></blockquote><h2 id="中断服务程序">中断服务程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/*interrupt数组定义*/<br>ENTRY(interrupt)<br>.text<br><br><br>vector=0<br>ENTRY(irq_entries_start)<br>.rept NR_IRQS<br>ALIGN<br>/*<br> * 把中断号减去256的结果保存在栈中，内核用负数表示所有的中断，因为正数表示系统调用，<br> * 当引用这个数的时候，可以对所有的中断处理程序都执行相同的代码，这段通用代码开始于标签common_interrupt<br> */<br>/*<br> * 相当于,interrupt[i]执行下列操作:<br> * Pushl $i-256  //中断号取负再压栈<br> * Jmp common_interrupt //跳转至一段公共的处理函数<br> */<br>1:pushl $vector-256<br>jmp common_interrupt<br>.data<br>.long 1b<br>.text<br>vector=vector+1<br>.endr<br></code></pre></td></tr></table></figure><p>之所以设计成了<code>$i-256</code>而不是直接push序号，是因为正数是给系统调用用的。common_interrupt是一个公共的处理函数，展开看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ALIGN<br><br>/*IRQ入口,中断入口*/<br>common_interrupt:<br>/*common_interrupt 首先调用 SAVE ALL保存寄存器*/<br>SAVE_ALL<br><br>/*寄存器保存后，栈顶的地址被存放到eax寄存器里面*/<br>movl %esp,%eax<br>/*<br> * 调用do_IRQ()函数,<br> * 调用相应的中断处理函数<br> */<br>call do_IRQ<br>/* <br> * 执行do_IRQ的ret指令的时候，控制转移到ret_from_intr()函数<br> * 从中断返回<br> */<br>jmp ret_from_intr<br><br>/*<br> * SAVE_ALL可以在栈中保存中断处理程序可能会使用的所有CPU寄存器<br> * 但eflags, cs, eip, ss 及esp除外，因为这些寄存器已经由控制单元自动保存了<br> * 然后这个宏把用户数据段的选择符装到ds和es寄存器<br> */<br>/*<br> * 相当于把中断发生时,硬件没有保存的寄存器压栈保存下来.把DS.ES设为了__USER_DS是有一定原因的,参考上节所述.<br> *<br> * 设置为__USER_DS的原因:<br> * (检查ds、es、fs及gs段寄存器的内容，如果其中一个寄存器包含的选择符是一个段描述符，并且其DPL值小于CPL，那么，清相关的段寄存器。<br> *  控制单元这么做是为了禁止用户态的程序利用内核以前所用的段寄存器。如果不清除这些寄存器的话，恶意的用户程序就会利用他们来访问内核地址空间。<br> *  注意到4: 举例说明一下.如果通过系统调用进入内核态.然后将DS,ES的值赋为__KERNEL_DS(在2.4 的内核里),处理完后(调用iret后),<br> *           恢复CS,EIP的值,此时CS的CPL是3.因为DS,ES被设为了__KERNEL_DS,所以其DPL是 0,所以要将DS,ES中的值清除.在2.6内核中,发生中断或异常后,<br> *           将DS,ES的值设为了__USER_DS,避免了上述的清除过程,提高了效率.)<br> */<br>#define SAVE_ALL \<br>cld; \<br>pushl %es; \<br>pushl %ds; \<br>pushl %eax; \<br>pushl %ebp; \<br>pushl %edi; \<br>pushl %esi; \<br>pushl %edx; \<br>pushl %ecx; \<br>pushl %ebx; \<br>movl $(__USER_DS), %edx; \<br>movl %edx, %ds; \<br>movl %edx, %es;<br></code></pre></td></tr></table></figure><p>SAVE_ALL的功能一目了然。注意到这里没有<code>eflags,cs,eip,ss,esp</code>。因为这些已经由控制单元自动保存了。</p><p>前面所做的一切，实际上都是为了给<code>do_IRQ()</code>建立一个模拟的子程序调用环境。而<code>do_IRQ()</code>就是处理具体中断请求队列的地方。</p><p>在展开<code>do_IRQ</code>之前，先看看返回到的地方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># userspace resumption stub bypassing syscall exit tracing<br>ALIGN<br><br>/*异常返回分析: 异常返回的后半部份与IRQ中断返回相比只是多了一个preempt_stop的处理.*/<br>ret_from_exception:<br>/**<br> * 在中断返回前，handle_IRQ_event调用local_irq_disable禁止了中断<br> * 所以在中断返回时，不用关中断，但是在异常返回时，需要将中断关闭。<br> */<br>preempt_stop<br><br>/*IRQ中断返回分析*/<br>ret_from_intr:<br>/**<br> * 把当前thread_info半截到ebp中。<br> */<br>GET_THREAD_INFO(%ebp) //取得当前过程的task描述符<br>/**<br> * 接下来判断EFLAGS和CS，确定是否运行在用户态，是否是VM模式。<br> */<br>movl EFLAGS(%esp), %eax# mix EFLAGS and CS //中断前的EFLAGS中的值存进EAX<br>movb CS(%esp), %al//将中断前的CS低16移至AL<br>//#至此EFLAGS 的H16和CS的L16构成了EAX的内容<br><br>testl $(VM_MASK | 3), %eax //EFLAGS中有一位表示是否运行在vm86模式中,CS的最低二位表示当前进程的运行级别<br>/**<br> * 如果是运行在内核态，并且不是VM模式，就跳到resume_kernel，<br> * 否则跳转到resume_userspace<br> */<br>jz resume_kernel# returning to kernel or vm86-space // 如果中断前不是在用户空间,且不是在VM86模式下,跳转到resume_kernel<br>/**<br> * 恢复用户态程序的流程入口。<br> */<br>ENTRY(resume_userspace)<br>/**<br> * 不清楚为什么还要禁用中断<br> */<br>//开中断,以防中断丢失  <br>// TODO: cli不是关中断么?<br> cli# make sure we don&#x27;t miss an interrupt<br># setting need_resched or sigpending<br># between sampling and the iret<br>/**<br> * 检查thread_info的flag<br> */<br>movl TI_flags(%ebp), %ecx //将task-&gt;flags成员的值存进ecx <br>/**<br> * 如果设置了_TIF_WORK_MASK中任何一位，就表示有等待处理的事情<br> * 跳到work_pending处理这些挂起的事件。<br> * 否则调用restore_all回到用户态。<br> */<br>andl $_TIF_WORK_MASK, %ecx# is there any work to be done on<br># int/exception return? //还有事情没做完?<br>jne work_pending //还有事情没做完?<br>jmp restore_all //所有事情都处理完了<br><br>....<br><br><br>//restore_all被定义成RESTRORE_ALL<br>restore_all:<br>    /*<br>     * 恢复保存在内核栈中的寄存器的值，并执行iret汇编指令以重新开始用户态的执行<br> */<br>RESTORE_ALL<br><br>......<br><br>#define RESTORE_ALL\<br>RESTORE_REGS\ //pop在SAVE_ALL中入栈的寄存器<br>addl $4, %esp;\  //记否?在SAVE_ALL之前压入了一个中断向量的负值或者是系统调用号<br>1:iret;\ //iret中断返回,交给硬件完成中断的返回工作<br>.section .fixup,&quot;ax&quot;;   \<br>2:sti;\<br>movl $(__USER_DS), %edx; \<br>movl %edx, %ds; \<br>movl %edx, %es; \<br>movl $11,%eax;\<br>call do_exit;\<br>.previous;\<br>.section __ex_table,&quot;a&quot;;\<br>.align 4;\<br>.long 1b,2b;\<br>.previous<br></code></pre></td></tr></table></figure><p>再看<code>do_IRQ()</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * do_IRQ执行与一个中断相关的所有中断服务例程.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">fastcall <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">do_IRQ</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* high bits used in ret_from_ code */</span><br><span class="hljs-type">int</span> irq = regs-&gt;orig_eax &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_4KSTACKS</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">irq_ctx</span> *curctx, *irqctx;<br>u32 *isp;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * irq_enter增加中断嵌套计数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">irq_enter</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_STACKOVERFLOW</span><br><span class="hljs-comment">/* Debugging check for stack overflow: is there less than 1KB free? */</span><br>&#123;<br><span class="hljs-type">long</span> esp;<br><br>__asm__ __volatile__(<span class="hljs-string">&quot;andl %%esp,%0&quot;</span> :<br><span class="hljs-string">&quot;=r&quot;</span> (esp) : <span class="hljs-string">&quot;0&quot;</span> (THREAD_SIZE - <span class="hljs-number">1</span>));<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(esp &lt; (<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> thread_info) + STACK_WARN))) &#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;do_IRQ: stack overflow: %ld\n&quot;</span>,<br>esp - <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> thread_info));<br><span class="hljs-built_in">dump_stack</span>();<br>&#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/*CONFIG_4KSTACKS: 如果thread_union大小为4KB*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_4KSTACKS</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果中断栈使用不同的的栈,就需要切换栈.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 执行current_thread_info 以获取与内核栈相连的thread_info描述符的地址保存到curctx</span><br><span class="hljs-comment"> */</span><br>curctx = (<span class="hljs-keyword">union</span> irq_ctx *) <span class="hljs-built_in">current_thread_info</span>();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 硬中断请求栈地址保存到irqctx</span><br><span class="hljs-comment"> */</span><br>irqctx = hardirq_ctx[<span class="hljs-built_in">smp_processor_id</span>()];<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * this is where we switch to the IRQ stack. However, if we are</span><br><span class="hljs-comment"> * already using the IRQ stack (because we interrupted a hardirq</span><br><span class="hljs-comment"> * handler) we can&#x27;t do that and just have to keep using the</span><br><span class="hljs-comment"> * current stack (which is the irq stack already after all)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当前在使用内核栈,而不是硬中断请求栈.就需要切换栈</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * curctx 和irqctx 相等，说明内核已经在使用硬件中断请求栈，</span><br><span class="hljs-comment"> * 这种情况发生在内核处理另外一个中断时又产生了中断请求的时候</span><br><span class="hljs-comment"> * 不相等就要切换内核栈</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (curctx != irqctx) &#123;<br><span class="hljs-type">int</span> arg1, arg2, ebx;<br><br><span class="hljs-comment">/* build the stack frame on the IRQ stack */</span><br>isp = (u32*) ((<span class="hljs-type">char</span>*)irqctx + <span class="hljs-built_in">sizeof</span>(*irqctx));<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保存当前进程描述符指针</span><br><span class="hljs-comment"> */</span><br>irqctx-&gt;tinfo.task = curctx-&gt;tinfo.task;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把esp栈指针寄存器的当前值存入irqctx的thread_info(内核oops时使用)</span><br><span class="hljs-comment"> * current_stack_pointer 用来在C 中获得当前的栈指针</span><br><span class="hljs-comment"> */</span><br>irqctx-&gt;tinfo.previous_esp = current_stack_pointer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将中断请求栈的栈顶装入esp,isp即为中断栈顶</span><br><span class="hljs-comment"> * 调用完__do_IRQ后,从ebx中恢复esp</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-string">&quot;       xchgl   %%ebx,%%esp      \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-string">&quot;       call    __do_IRQ         \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-string">&quot;       movl   %%ebx,%%esp      \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">: <span class="hljs-string">&quot;=a&quot;</span> (arg1), <span class="hljs-string">&quot;=d&quot;</span> (arg2), <span class="hljs-string">&quot;=b&quot;</span> (ebx)</span></span><br><span class="hljs-params"><span class="hljs-function">:  <span class="hljs-string">&quot;0&quot;</span> (irq),   <span class="hljs-string">&quot;1&quot;</span> (regs),  <span class="hljs-string">&quot;2&quot;</span> (isp)</span></span><br><span class="hljs-params"><span class="hljs-function">: <span class="hljs-string">&quot;memory&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;ecx&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br>&#125; <span class="hljs-keyword">else</span><span class="hljs-comment">/* 否则,发生了中断嵌套,不用切换 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>__do_IRQ(irq, regs);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递减中断计数器并检查是否有可延迟函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">irq_exit</span>();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 结束后,会返回ret_from_intr函数. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只是些外围的操作，增加嵌套深度，检查栈溢出等，核心处理在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * do_IRQ handles all normal device IRQ&#x27;s (the special</span><br><span class="hljs-comment"> * SMP cross-CPU interrupts have their own specific</span><br><span class="hljs-comment"> * handlers).</span><br><span class="hljs-comment"> */</span><br>fastcall <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __do_IRQ(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq, <span class="hljs-keyword">struct</span> pt_regs *regs)<br>&#123;<br><span class="hljs-type">irq_desc_t</span> *desc = irq_desc + irq;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">irqaction</span> * action;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> status;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 中断发生次数计数.</span><br><span class="hljs-comment"> */</span><br>kstat_this_cpu.irqs[irq]++;<br><span class="hljs-keyword">if</span> (desc-&gt;status &amp; IRQ_PER_CPU) &#123;<br><span class="hljs-type">irqreturn_t</span> action_ret;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * No locking required for CPU-local interrupts:</span><br><span class="hljs-comment"> */</span><br>desc-&gt;handler-&gt;<span class="hljs-built_in">ack</span>(irq);<br>action_ret = <span class="hljs-built_in">handle_IRQ_event</span>(irq, regs, desc-&gt;action);<br><span class="hljs-keyword">if</span> (!noirqdebug)<br><span class="hljs-built_in">note_interrupt</span>(irq, desc, action_ret);<br>desc-&gt;handler-&gt;<span class="hljs-built_in">end</span>(irq);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 虽然中断是关闭的,但是还是需要使用自旋锁保护desc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_lock</span>(&amp;desc-&gt;lock);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果是旧的8259A PIC,ack就是mask_and_ack_8259A,它应答PIC上的中断并禁用这条IRQ线.屏蔽IRQ线是为了确保在这个中断处理程序结束前,</span><br><span class="hljs-comment"> * CPU不进一步接受这种中断的出现.</span><br><span class="hljs-comment"> * do_IRQ是以禁止本地中断运行,事实上,CPU控制单元自动清eflags寄存器的IF标志.因为中断处理程序是通过IDT中断门调用的.</span><br><span class="hljs-comment"> * 不过,内核在执行这个中断的中断服务例程之前可能会重新激活本地中断.</span><br><span class="hljs-comment"> * 在使用APIC时,应答中断信赖于中断类型,可能是ack,也可能延迟到中断处理程序结束(也就是应答由end方法去做).</span><br><span class="hljs-comment"> * 无论如何,中断处理程序结束前,本地APIC不进一步接收这种中断,尽管这种中断可能会被其他CPU接受.</span><br><span class="hljs-comment"> */</span><br>desc-&gt;handler-&gt;<span class="hljs-built_in">ack</span>(irq);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * REPLAY is when Linux resends an IRQ that was dropped earlier</span><br><span class="hljs-comment"> * WAITING is used by probe to mark irqs that are being tested</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化主IRQ描述符的几个标志.设置IRQ_PENDING标志.也清除IRQ_WAITING和IRQ_REPLAY</span><br><span class="hljs-comment"> * 这几个标志可以很好的解决中断重入的问题.</span><br><span class="hljs-comment"> * IRQ_REPLAY标志是&quot;挽救丢失的中断&quot;所用.在此不详述.</span><br><span class="hljs-comment"> */</span><br>status = desc-&gt;status &amp; ~(IRQ_REPLAY | IRQ_WAITING);<br>status |= IRQ_PENDING; <span class="hljs-comment">/* we _want_ to handle it */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If the IRQ is disabled for whatever reason, we cannot</span><br><span class="hljs-comment"> * use the action we have.</span><br><span class="hljs-comment"> */</span><br>action = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * IRQ_DISABLED和IRQ_INPROGRESS被设置时,什么都不做(action==NULL)</span><br><span class="hljs-comment"> * 即使IRQ线被禁止,CPU也可能执行do_IRQ函数.首先,可能是因为挽救丢失的中断,其次,也可能是有问题的主板产生伪中断.</span><br><span class="hljs-comment"> * 所以,是否真的执行中断代码,需要根据IRQ_DISABLED标志来判断,而不仅仅是禁用IRQ线.</span><br><span class="hljs-comment"> * IRQ_INPROGRESS标志的作用是:如果一个CPU正在处理一个中断,那么它会设置它的IRQ_INPROGRESS.这样,其他CPU上发生同样的中断</span><br><span class="hljs-comment"> * 就可以检查是否在其他CPU上正在处理同种类型的中断,如果是,就什么都不做,这样做有以下好处:</span><br><span class="hljs-comment"> * 一是使内核结构简单,驱动程序的中断服务例程式不必是可重入的.二是可以避免弄脏当前CPU的硬件高速缓存.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(!(status &amp; (IRQ_DISABLED | IRQ_INPROGRESS)))) &#123;<br>action = desc-&gt;action;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 确定我们要处理了，就设置IRQ_INPROGRESS 标志，</span><br><span class="hljs-comment"> * 去除IRQ_PENDING 标志表示确认我们要处理这个中断了</span><br><span class="hljs-comment"> */</span><br>status &amp;= ~IRQ_PENDING; <span class="hljs-comment">/* we commit to handling */</span><br>status |= IRQ_INPROGRESS; <span class="hljs-comment">/* we are handling it */</span><br>&#125;<br>desc-&gt;status = status;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If there is no IRQ handler or it was disabled, exit early.</span><br><span class="hljs-comment"> * Since we set PENDING, if another processor is handling</span><br><span class="hljs-comment"> * a different instance of this same irq, the other processor</span><br><span class="hljs-comment"> * will take care of it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当前面两种情况出现时,不需要(或者是不需要马上)处理中断.就退出</span><br><span class="hljs-comment"> * 或者没有相关的中断服务例程时,也退出.当内核正在检测硬件设备时就会发生这种情况.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!action))<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Edge triggered interrupts need to remember</span><br><span class="hljs-comment"> * pending events.</span><br><span class="hljs-comment"> * This applies to any hw interrupts that allow a second</span><br><span class="hljs-comment"> * instance of the same irq to arrive while we are in do_IRQ</span><br><span class="hljs-comment"> * or in the handler. But the code here only handles the _second_</span><br><span class="hljs-comment"> * instance of the irq, not the third or fourth. So it is mostly</span><br><span class="hljs-comment"> * useful for irq hardware that does not mask cleanly in an</span><br><span class="hljs-comment"> * SMP environment.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这里是需要循环处理的,并不是说调用一次handle_IRQ_event就行了.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">irqreturn_t</span> action_ret;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 现在打开自旋锁了,那么,其他CPU可能也接收到同类中断,并设置IRQ_PENDING标志.</span><br><span class="hljs-comment"> * xie.baoyou注:请注意开关锁的使用方法.有点巧妙,不可言传.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_unlock</span>(&amp;desc-&gt;lock);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用中断服务例程.</span><br><span class="hljs-comment"> */</span><br>action_ret = <span class="hljs-built_in">handle_IRQ_event</span>(irq, regs, action);<br><br><span class="hljs-built_in">spin_lock</span>(&amp;desc-&gt;lock);<br><span class="hljs-keyword">if</span> (!noirqdebug)<br><span class="hljs-built_in">note_interrupt</span>(irq, desc, action_ret);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果其他CPU没有接收到同类中断,就退出</span><br><span class="hljs-comment"> * 否则,继续处理同类中断.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(!(desc-&gt;status &amp; IRQ_PENDING)))<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清除了IRQ_PENDING,如果再出现IRQ_PENDING,就说明是其他CPU上接收到了同类中断.</span><br><span class="hljs-comment"> * 注意,IRQ_PENDING仅仅是一个标志,如果在调用中断处理函数的过程中,来了多次的同类中断,则意味着只有一次被处理,其余的都丢失了.</span><br><span class="hljs-comment"> */</span><br>desc-&gt;status &amp;= ~IRQ_PENDING;<br>&#125;<br>desc-&gt;status &amp;= ~IRQ_INPROGRESS;<br><br>out:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The -&gt;end() handler has to deal with interrupts which got</span><br><span class="hljs-comment"> * disabled while the handler was running.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 现在准备退出了,end方法可能是应答中断(APIC),也可能是通过end_8259A_irq方法重新激活IRQ(只要不是伪中断).</span><br><span class="hljs-comment"> */</span><br>desc-&gt;handler-&gt;<span class="hljs-built_in">end</span>(irq);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 好,工作已经全部完成了,释放自旋锁吧.注意两个锁的配对使用方法.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_unlock</span>(&amp;desc-&gt;lock);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>感兴趣的是对服务例程的调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 执行中断服务例程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">fastcall <span class="hljs-type">int</span> <span class="hljs-title">handle_IRQ_event</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq, <span class="hljs-keyword">struct</span> pt_regs *regs,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">struct</span> irqaction *action)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret, retval = <span class="hljs-number">0</span>, status = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果没有设置SA_INTERRUPT，说明中断处理程序是可以在开中断情况下执行的</span><br><span class="hljs-comment"> * 这也是程序中少见的，调用local_irq_enable的地方。</span><br><span class="hljs-comment"> * 一般来说，调用local_irq_enable是危险的，不允许，绝不允许。这里只是例外。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(action-&gt;flags &amp; SA_INTERRUPT))<br><span class="hljs-built_in">local_irq_enable</span>();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一开始，action是irqaction链表的头，irqaction表示一个ISR</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * handler是中断服务例程的处理函数。它接收三个参数：</span><br><span class="hljs-comment"> * irq-IRQ号，它允许一个ISR处理几条IRQ。</span><br><span class="hljs-comment"> * dev_id-设备号，注册中断服务例程时指定，此时回传给处理函数。它允许一个ISR处理几个同类型的设备。</span><br><span class="hljs-comment"> * regs-指向内核栈的pt_regs。它允许ISR访问内核执行上下文。可是，哪个ISR会用它呢？</span><br><span class="hljs-comment"> */</span><br>ret = action-&gt;<span class="hljs-built_in">handler</span>(irq, action-&gt;dev_id, regs);<br><span class="hljs-keyword">if</span> (ret == IRQ_HANDLED)<br>status |= action-&gt;flags;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一般来说，handler处理了本次中断，就会返回1</span><br><span class="hljs-comment"> * 返回0和1是有用的，这样可以让内核判断中断是否被处理了。</span><br><span class="hljs-comment"> * 如果过多的中断没有被处理，就说明硬件有问题，产生了伪中断。</span><br><span class="hljs-comment"> */</span><br>retval |= ret;<br>action = action-&gt;next;<br>&#125; <span class="hljs-keyword">while</span> (action);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果中断是随机数的产生源，就添加一个随机因子。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (status &amp; SA_SAMPLE_RANDOM)<br><span class="hljs-built_in">add_interrupt_randomness</span>(irq);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 退出时，总是会关中断，这里不判断if (!(action-&gt;flags &amp; SA_INTERRUPT))</span><br><span class="hljs-comment"> * 是因为：判断的汇编指令比直接执行cli费时，既然无论如何都是需要保证处于关中断状态，为什么多作那些判断呢。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">local_irq_disable</span>();<br><br><span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终在泛用接口中通过<code>action-&gt;handler</code>找到特化接口。</p><p>附：中断和异常服务例程返回的流程图</p><p><img src="20171220_5.jpg" /></p><h2 id="硬中断服务例程的下半身">硬中断服务例程的下半身</h2><h3 id="softirq">softirq</h3><p>前面已星星点点渗透了软中断的定义。这里谈到的<code>softirq</code>即是指“硬件中断服务例程对内核的中断”。</p><p>前文也已了解到，之所以要有这种<code>softirq</code>，将硬中断的处理分成上下两部分，是因为兼顾硬中断及时的处理（比如网卡如果处理的慢了，一旦缓冲区满了就开始丢包）以及<code>softirq</code>任务的繁重，上下两部分的设计提高了效率，但却容易使后来者一时云里雾里。</p><p>而事实上，在Linux2.6内核中，早已不是最原始的仅通过<code>softirq</code>来实现的版本了。Linux对于下半部分的实现机制，除了<code>softirq</code>以外，还有<code>tasklet</code>和工作队列。<code>tasklet</code>实际上是通过软中断实现的，但和软中断有所不同。而工作队列则是另一回事了。</p><p><code>softirq</code>实际上应用场合很少，因为tasklet往往是足够用的，且更易编写，而<code>softirq</code>是在编译期间静态分配的，也就相对僵硬。</p><p><code>softirq</code>由一个数组表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所有的软中断，目前使用了前六个。数组的下标就是软中断的优先级。</span><br><span class="hljs-comment"> * 下标越低，优先级越高。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">softirq_action</span> softirq_vec[<span class="hljs-number">32</span>] __cacheline_aligned_in_smp;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">softirq_action</span><br>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 软中断处理函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">void</span>(*action)(<span class="hljs-keyword">struct</span> softirq_action *);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 回传给软中断处理函数的数据。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span>*data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>6个<code>softirq</code>分别是:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span><br>&#123;<br>HI_SOFTIRQ=<span class="hljs-number">0</span>,<span class="hljs-comment">//处理高优先级的tasklet</span><br>TIMER_SOFTIRQ,<span class="hljs-comment">//和时钟中断相关的tasklet</span><br>NET_TX_SOFTIRQ,<span class="hljs-comment">//把数据包传送到网卡</span><br>NET_RX_SOFTIRQ,<span class="hljs-comment">//从网卡接收到数据包</span><br>SCSI_SOFTIRQ,<span class="hljs-comment">//SCSI命令的后台中断处理</span><br>TASKLET_SOFTIRQ<span class="hljs-comment">//处理常规tasklet</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这里隐隐约约可以看出<code>tasklet</code>确实是依靠<code>softirq</code>实现的，且还有2种优先级，分别是最高和最低(数字越小优先级越高，<code>softirq</code>按优先级处理)。</p><p>把<code>softirq</code>放到这个数组中，就完成了<code>softirq</code>的注册，想要执行<code>softirq</code>必须先标记注册好的<code>softirq</code>，这个过程被称为触发<code>softirq</code>。</p><p>注册：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化软中断</span><br><span class="hljs-comment"> * nr-软中断下标</span><br><span class="hljs-comment"> * action-软中断处理函数</span><br><span class="hljs-comment"> * data-软中断处理函数的参数。执行处理函数时，将它回传给软中断。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">open_softirq</span><span class="hljs-params">(<span class="hljs-type">int</span> nr, <span class="hljs-type">void</span> (*action)(<span class="hljs-keyword">struct</span> softirq_action*), <span class="hljs-type">void</span> *data)</span></span><br><span class="hljs-function"></span>&#123;<br>softirq_vec[nr].data = data;<br>softirq_vec[nr].action = action;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>触发：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 激活软中断</span><br><span class="hljs-comment"> * nr-要激活的软中断下标</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> fastcall <span class="hljs-title">raise_softirq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 禁用本地CPU中断。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">local_irq_save</span>(flags);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * raise_softirq_irqoff是本函数的执行体，不过它是在关中断下运行。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">raise_softirq_irqoff</span>(nr);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 打开本地中断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">local_irq_restore</span>(flags);<br>&#125;<br></code></pre></td></tr></table></figure><p>通常，<strong>中断处理程序（就是上半部分）会在返回之前标记它的<code>softirq</code></strong>，所以不必担心，然后在合适的时刻就会执行该软中断。</p><p>合适的时刻：</p><ol type="1"><li>从一个硬件中断代码处返回时(可以展开看<code>do_IRQ()</code>最后的<code>irq_exit()</code>)</li><li>在<code>ksoftirqd</code>内核线程中</li><li>在那些显示检查和执行待处理的<code>softirq</code>的代码中</li></ol><p>不管是上面哪个时刻，软中断最终都是会被执行的，调用<code>do_softirq()</code>该函数会循环遍历（循环检查pending的每一个位，所以循环最多只能执行32次）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理挂起的软中断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">asmlinkage <span class="hljs-type">void</span> <span class="hljs-title">do_softirq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_info</span> *curctx;<br><span class="hljs-keyword">union</span> <span class="hljs-title class_">irq_ctx</span> *irqctx;<br>u32 *isp;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果in_interrupt返回真，说明系统要么是处于中断中，要么是禁用了软中断。</span><br><span class="hljs-comment"> * 请注意in_interrupt()的实现代码：preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK)</span><br><span class="hljs-comment"> * 它判断当前是否在硬件中断中，或者是否在软中断中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">in_interrupt</span>())<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在此时需要关闭中断，因为接下来我们需要将判断是否有挂起的中断</span><br><span class="hljs-comment"> * 如果不在关中断的情况下访问这个标志，那么，这个标志就可能被中断程序修改。</span><br><span class="hljs-comment"> * 从另一个方面来说，我们还会在后面切换堆栈，这也需要在关中断中进行。</span><br><span class="hljs-comment"> * 开中断的时机在__do_softirq中。当然，本函数结束时，也会恢复中断标志。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">local_irq_save</span>(flags);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">local_softirq_pending</span>()) &#123;<span class="hljs-comment">/* 有挂起的软中断 */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据配置来确定是否切换堆栈(请注意，本段代码受宏CONFIG_4KSTACKS的控制)。</span><br><span class="hljs-comment"> * 当然，这里用的是softirq_ctx而不是hardirq_ctx来保存当前进程。</span><br><span class="hljs-comment"> */</span><br>curctx = <span class="hljs-built_in">current_thread_info</span>();<br>irqctx = softirq_ctx[<span class="hljs-built_in">smp_processor_id</span>()];<br>irqctx-&gt;tinfo.task = curctx-&gt;task;<br>irqctx-&gt;tinfo.previous_esp = current_stack_pointer;<br><br><span class="hljs-comment">/* build the stack frame on the softirq stack */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * isp保存的是软中断栈的栈顶。</span><br><span class="hljs-comment"> * 可以放心的是，软中断在单个CPU上不会重入，而softirq_ctx是每CPU变量</span><br><span class="hljs-comment"> * 所以，在这里我们可以放心的切换栈顶了。</span><br><span class="hljs-comment"> */</span><br>isp = (u32*) ((<span class="hljs-type">char</span>*)irqctx + <span class="hljs-built_in">sizeof</span>(*irqctx));<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 切换栈到isp，并调用__do_softirq.</span><br><span class="hljs-comment"> * 然后再恢复栈（可能是恢复到中断栈、进程内核栈、内核线程栈）。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-string">&quot;       xchgl   %%ebx,%%esp     \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-string">&quot;       call    __do_softirq    \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-string">&quot;       movl    %%ebx,%%esp     \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">: <span class="hljs-string">&quot;=b&quot;</span>(isp)</span></span><br><span class="hljs-params"><span class="hljs-function">: <span class="hljs-string">&quot;0&quot;</span>(isp)</span></span><br><span class="hljs-params"><span class="hljs-function">: <span class="hljs-string">&quot;memory&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;edx&quot;</span>, <span class="hljs-string">&quot;ecx&quot;</span>, <span class="hljs-string">&quot;eax&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 恢复保存的IF 标志的状态并返回</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">local_irq_restore</span>(flags);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ksoftirqd</code>内核线程中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">ksoftirqd</span><span class="hljs-params">(<span class="hljs-type">void</span> * __bind_cpu)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">set_user_nice</span>(current, <span class="hljs-number">19</span>);<br>current-&gt;flags |= PF_NOFREEZE;<br><br><span class="hljs-built_in">set_current_state</span>(TASK_INTERRUPTIBLE);<br><br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">kthread_should_stop</span>()) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有挂起的中断，调度出去。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">local_softirq_pending</span>())<br><span class="hljs-built_in">schedule</span>();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在上次循环结尾处，可能设置状态为TASK_INTERRUPTIBLE，现在把它改过来。</span><br><span class="hljs-comment"> */</span><br>__set_current_state(TASK_RUNNING);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">local_softirq_pending</span>()) &#123;<br><span class="hljs-comment">/* Preempt disable stops cpu going offline.</span><br><span class="hljs-comment">   If already offline, we&#x27;ll be on wrong CPU:</span><br><span class="hljs-comment">   don&#x27;t process */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 现在是增加抢占计数，而不是软中断计数。</span><br><span class="hljs-comment"> * 增加软中断计数，防止软中断重入是在do_softirq中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">preempt_disable</span>();<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">cpu_is_offline</span>((<span class="hljs-type">long</span>)__bind_cpu))<br><span class="hljs-keyword">goto</span> wait_to_die;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 回想一下，do_softirq会设置软中断计数标志，而ininterrupt会根据这个标志返回是否处于中断上下文。</span><br><span class="hljs-comment"> * 其实，现在我们是在线程上下文执行do_softirq。</span><br><span class="hljs-comment"> * 所以说，ininterrupt有点名不符实。</span><br><span class="hljs-comment"> * liufeng: 线程上线问就不会发现有软中断计数器的增加?</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">do_softirq</span>();<br><span class="hljs-built_in">preempt_enable</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 增加一个调度点，仅此而已。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">cond_resched</span>();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有挂起的软中断，就将状态设置为TASK_INTERRUPTIBLE</span><br><span class="hljs-comment"> * 下次循环时，就会调度出去。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">set_current_state</span>(TASK_INTERRUPTIBLE);<br>&#125;<br>__set_current_state(TASK_RUNNING);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>wait_to_die:<br><span class="hljs-built_in">preempt_enable</span>();<br><span class="hljs-comment">/* Wait for kthread_stop */</span><br><span class="hljs-built_in">set_current_state</span>(TASK_INTERRUPTIBLE);<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">kthread_should_stop</span>()) &#123;<br><span class="hljs-built_in">schedule</span>();<br><span class="hljs-built_in">set_current_state</span>(TASK_INTERRUPTIBLE);<br>&#125;<br>__set_current_state(TASK_RUNNING);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tasklet">tasklet</h3><p>直接引用leno对<code>tasklet</code>的归纳。</p><p>因为<code>tasklet</code>是使用软中断实现的，所以<code>tasklet</code>本身就是个软中断，我们是通过<code>tasklet</code>来实现下半部的机制的，所以在处理方式上和软中断十分的相似，<code>tasklet</code>由<code>tasklet</code>结构体表示，每一个结构体单独代表一个<code>tasklet</code>，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * taskletra描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tasklet_struct</span><br>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向下一个描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tasklet_struct</span> *next;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * tasklet的状态。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> state;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 锁计数器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">atomic_t</span> count;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * tasklet功能函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">void</span> (*func)(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 传给功能函数的参数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中<code>tasklet</code>的状态一共只有三种：0，TASKLET_STATE_SCHED，TASKLET_STATE_RUN，只能在这三种之间取值，0表示啥也没有等待调度，SCHED表示已经调度，RUN表示该<code>tasklet</code>正在运行。</p><p>已经被调度的<code>tasklet</code>结构体存放在两种单处理器数据结构当中，分别是<code>tasklet_vec</code>（普通优先级的<code>tasklet</code>）和<code>tasklet_hi_vec</code>（高优先级的<code>tasklet</code>），几乎没区别，只是优先级不一样，调度的步骤如下</p><ol type="1"><li>检查tasklet的状态是否为TASKLET_STATE_SCHED，如果是，就证明不需要调度了，直接返回</li><li>调用_tasklet_schedule()函数进行调度</li><li>保存中断状态，禁止本地中断，防止数据被其他中断拿去更改</li><li>头插加入链表，就刚才说的那两个优先级不同的链表</li><li>唤起tasklet中断（封装好的软中断）</li><li>恢复中断并返</li></ol><p>运行的步骤如下：</p><ol type="1"><li>禁止中断，检测两个链表里面有没有东西</li><li>把当前处理器的该链表设置为NULL（意思就是我要把链表里的东西全弄完，先置成NULL）</li><li>允许响应中断</li><li>循环遍历<code>tasklet</code>链表上的每一个节点</li><li>如果是多处理器系统，查看节点状态如果是RUN就证明在其他处理器上运行中，直接跳到下一个节点（因为同一时间里，相同类型的<code>tasklet</code>只有一个能执行）</li><li>如果当前节点的状态不是RUN，就设置成RUN，以防其他处理器调用</li><li>检查count是不是0（看看别人是否正在占用）如果不是0则被禁止，跳到下一个挂起的<code>tasklet</code>去</li><li>安全确保，开始执行</li><li>一直循环，直到没有<code>tasklet</code>了（因为我们把链表置为NULL了，必须把拿出来的东西处理完）</li></ol><p>其实<code>tasklet</code>给人的感觉就是一个对软中断的封装的简单接口而已。。</p><p>每个处理器都有一组辅助处理软中断（当然也就包括<code>tasklet</code>）的内核线程，那么什么时候执行这些软中断呢，上面在软中断部分也阐述了，但是这样有个问题，那就是软中断如果继续调软中断，就会不停的执行软中断。。这样在处理器负载很严重的时候就不太好了，会导致用户空间进程饥饿，还有一种方案，那就是并不立即处理软中断，而是等待一段时间，但是在处理器比较闲的时候这么做很显然不太好，因为完全可以立即执行你却让处理器闲着。作为改进，<strong>当大量软中断出现的时候，内核会唤醒一组内核线程来处理这些负载</strong>，关键来了，<strong>这些带着软中断的线程的优先级会被设置到最低的优先级上（nice值取最高为19）</strong>，这样的话在处理器比较忙的时候，这些软中断不会跟用户空间进程争夺处理器资源，而且最终一定会被执行，处理器空闲的时候也可以直接得到运行。</p><blockquote><p>更为精细的叙述可以参考ULK。</p></blockquote><p>以<code>tasklet_schedule</code>为例，简单做展开，<code>tasklet_hi_schedule</code>就不展开了，毕竟理解了<code>softirq</code>，也就理解了<code>tasklet</code>，非常简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调度tasklet，将其挂到软中断中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">tasklet_schedule</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tasklet_struct *t)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查任务的TASKLET_STATE_SCHED标志，如果已经设置，就退出。</span><br><span class="hljs-comment"> * 设置了TASKLET_STATE_SCHED，表示它已经被调度到软中断上了，现在处于挂起状态</span><br><span class="hljs-comment"> * 不能(也不用)再调度了。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 既然TASKLET_STATE_SCHED标志已经保证一个tasklet不会在多个CPU上同时被插入到链表中，为什么还需要TASKLET_STATE_RUN标志呢？</span><br><span class="hljs-comment"> * 这是因为在调用回调函数前，TASKLET_STATE_SCHED可能被清除，如果只有TASKLET_STATE_SCHED这个标志的话，可能还是会造成过程重入。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">test_and_set_bit</span>(TASKLET_STATE_SCHED, &amp;t-&gt;state))<br>__tasklet_schedule(t);<br>  <br><span class="hljs-type">void</span> fastcall __tasklet_schedule(<span class="hljs-keyword">struct</span> tasklet_struct *t)<br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先禁止本地中断。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">local_irq_save</span>(flags);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将tasklet挂到tasklet_vec[n]链表的头。</span><br><span class="hljs-comment"> */</span><br>t-&gt;next = __get_cpu_var(tasklet_vec).list;<br>__get_cpu_var(tasklet_vec).list = t;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * raise_softirq_irqoff激活TASKLET_SOFTIRQ软中断。</span><br><span class="hljs-comment"> * 它与raise_soft相似，但是它假设已经关本地中断了。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">raise_softirq_irqoff</span>(TASKLET_SOFTIRQ);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 恢复IF标志。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">local_irq_restore</span>(flags);<br>&#125;<br>  <br><span class="hljs-function"><span class="hljs-keyword">inline</span> fastcall <span class="hljs-type">void</span> <span class="hljs-title">raise_softirq_irqoff</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 标记nr对应的软中断为挂起状态。</span><br><span class="hljs-comment"> */</span><br>__raise_softirq_irqoff(nr);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we&#x27;re in an interrupt or softirq, we&#x27;re done</span><br><span class="hljs-comment"> * (this also catches softirq-disabled code). We will</span><br><span class="hljs-comment"> * actually run the softirq once we return from</span><br><span class="hljs-comment"> * the irq or softirq.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Otherwise we wake up ksoftirqd to make sure we</span><br><span class="hljs-comment"> * schedule the softirq soon.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * in_interrupt是判断是否在中断上下文中。</span><br><span class="hljs-comment"> * 程序在中断上下文中，表示：要么当前禁用了软中断，要么处在硬中断嵌套中，此时都不用唤醒ksoftirqd内核线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">in_interrupt</span>())<br><span class="hljs-built_in">wakeup_softirqd</span>();<br>&#125;<br>  <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 唤醒本地CPU的ksoftirqd内核线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">wakeup_softirqd</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* Interrupts are disabled: no need to stop preemption */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> *tsk = __get_cpu_var(ksoftirqd);<br><br><span class="hljs-keyword">if</span> (tsk &amp;&amp; tsk-&gt;state != TASK_RUNNING)<br><span class="hljs-built_in">wake_up_process</span>(tsk);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工作队列">工作队列</h3><p>工作队列是另外一种比较新的将工作推后的形式，和之前的两种处理方式不同，它会把工作交给一个内核线程去执行，这就意味着是由进程上下文来处理了！就可以睡眠了！！（中断是不允许睡眠的，如果睡了将没有进程能唤醒他，形成死锁）所以很简单就可以在这两种方法之间做出选择。</p><p>每一个处理器都有一个对应的工作者线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 工作队列描述符，它包含有一个NR_CPUS个元素的数组。</span><br><span class="hljs-comment"> * 分多个队列的主要目的是每个CPU都有自己的工作队列，避免了多个CPU访问全局数据时，造成TLB不停刷新</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">workqueue_struct</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cpu_workqueue_struct</span> cpu_wq[NR_CPUS];<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> list; <span class="hljs-comment">/* Empty if single thread */</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 每个CPU的工作队列描述符</span><br><span class="hljs-comment"> * 工作队列与可延迟函数的主要区别在于：工作队列运行在进程上下文，而可延迟函数运行在中断上下文。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cpu_workqueue_struct</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保护该工作队列的自旋锁</span><br><span class="hljs-comment"> * 虽然每个CPU都有自己的工作队列，但是有时候也需要访问其他CPU的工作队列</span><br><span class="hljs-comment"> * 所以也需要自旋锁 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">spinlock_t</span> lock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * flush_workqueue使用的计数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">long</span> remove_sequence;<span class="hljs-comment">/* Least-recently added (next to run) */</span><br><span class="hljs-type">long</span> insert_sequence;<span class="hljs-comment">/* Next to add */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 挂起链表的头结点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> worklist;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待队列，其中的工作者线程因为等待更多的工作而处于睡眠状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">wait_queue_head_t</span> more_work;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待队列，其中的进程由于等待工作队列被刷新而处于睡眠状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">wait_queue_head_t</span> work_done;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向workqueue_struct的指针，workqueue_struct中包含了本描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">workqueue_struct</span> *wq;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向工作者线程的进程描述符指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">task_t</span> *thread;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当前的执行深度（当工作队列链表中的函数阻塞时，这个字段的值会比1大）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> run_depth;<span class="hljs-comment">/* Detect run_workqueue() recursion depth */</span><br>&#125; ____cacheline_aligned;<br></code></pre></td></tr></table></figure><p><code>cpu_wq</code>中的每一项对应系统中的一个处理器。</p><p>这些工作的结构体被连成链表，当链表上的所有工作都做完了之后，线程就会休眠</p><p>实现方式也很简单，</p><ol type="1"><li>线程首先把自己设置为休眠状态（只是设置，并没有立即进入休眠）并把自己加入等待队列</li><li>如果工作链表是空的，就用<code>schedule()</code>调度函数进入睡眠状态</li><li>如果链表中有对象，线程就不会睡眠了，就把自己的状态改为TASK_RUNNING，然后从等待队列中出来</li><li>如果链表非空，执行那些被退后的下半部分应该干的工作（就是循环一直找。。。）</li></ol><h3 id="下半部机制的选择">下半部机制的选择</h3><ul><li><strong>如果你对共享有很高的要求，虽然比较麻烦，但还是使用软中断吧，因为可以各种操作（虽然保障这些很麻烦）</strong></li><li><strong>如果你不是对共享有那么高的要求，推荐使用<code>tasklet</code>，因为两种同类型的<code>tasklet</code>不能同时并行</strong></li><li><strong>如果你想在进程上下文中解决下半部分的问题，使用工作队列吧，当然如果你想睡眠，你也没得选了</strong></li></ul><h2 id="参考文献">参考文献</h2><p>《Understanding the Linux Kernel, 3rd Edition》</p><p>《Linux内核源代码情景分析(上)》</p><p>http://blog.csdn.net/zhangskd/article/details/21992933</p><p>https://www.cnblogs.com/lenomirei/p/5562086.html</p><p>http://www.cnblogs.com/lenomirei/p/5564131.html</p><p>https://www.ibm.com/developerworks/cn/linux/l-cn-linuxkernelint/</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux-kernel</tag>
      
      <tag>ulk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核学习——内存管理之非连续内存区管理</title>
    <link href="/2017/10/25/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/"/>
    <url>/2017/10/25/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>非连续内存区管理内容较少，也比较简单，无非就是连续的线性地址到非连续物理内存区的映射。与内核永久内存映射和内核临时内存映射并称三大物理地址与线性地址之间的映射机制。了解非连续内存区管理前，最好优先阅读页框管理和内存区管理。</p><span id="more"></span><h1id="linux内存管理-非连续内存区管理">Linux内存管理-非连续内存区管理</h1><p>研究内存区管理时已经知道，内存区映射到一组连续的页框是非常好的做法，这可以充分利用高速缓存来提高效率。Linux还设计了一种机制来实现连续的线性地址映射到非连续的页框。这种方式避免了外碎片，但与此同时打乱了内核页表。Linux的非连续内存区必须是4K的倍数，IO驱动缓冲区，模块分配等都会用到非连续内存区。</p><h2 id="线性地址">线性地址</h2><p>从PAGE_OFFSET也就是0xc0000000，第4GB的线性地址查找空闲区，这1GB的线性地址空间如图：<img src="20171025_1.jpg" /></p><ol type="1"><li>内存区开始部分包含的是对前896M的RAM进行映射的线性地址，这一部分直接映射的物理内存末尾所对应的线性地址在high_memory变量中。</li><li>内存区结尾部分包含的是固定映射的线性地址。</li><li>PKMAP_BASE起始，查找用于高端内存页框的永久内核映射的线性地址。</li><li>其余的线性地址可以用于非连续内存区。物理内存映射末尾到第一个内存区之间有个8M的安全区，为了捕获内存越界访问。每个内存区之间也有4K的安全区来隔离非连续的内存区。</li></ol><p>对应的宏： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第一个非连续映射的内存区与连续映射的线性区末尾之间的安全区大小。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VMALLOC_OFFSET(8*1024*1024)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为非连续内存区保留的线性地址的起始地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VMALLOC_START(((unsigned long) high_memory + vmalloc_earlyreserve + \</span><br><span class="hljs-meta">2*VMALLOC_OFFSET-1) &amp; ~(VMALLOC_OFFSET-1))</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为非连续内存区保留的线性地址的结束地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIGHMEM</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMALLOC_END(PKMAP_BASE-2*PAGE_SIZE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMALLOC_END(FIXADDR_START-2*PAGE_SIZE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></p><h2 id="vm_struct">vm_struct</h2><p>每个非连续内存区都对应一个vm_struct的描述符： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 非连续内存区的描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_struct</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存区内第一个内存单元的线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span>*addr;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存区大小加4096(内存区之间的安全区的大小)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>size;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 非连续内存区映射的内存的类型。</span><br><span class="hljs-comment"> * VM_ALLOC表示使用vmalloc得到的页.</span><br><span class="hljs-comment"> * VM_MAP表示使用vmap映射的已经被分配的页。</span><br><span class="hljs-comment"> * VM_IOREMAP表示使用ioremap映射的硬件设备的板上内存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>flags;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向nr_pages数组的指针，该数组由指向页描述符的指针组成。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span>**pages;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存区填充的页的个数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>nr_pages;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一般为0,除非内存已经被创建来映射一个硬件设备IO共享内存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>phys_addr;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向下一个vm_struct结构的指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_struct</span>*next;<br>&#125;;<br></code></pre></td></tr></table></figure>描述符通过next形成链，链表第一个元素地址存放在vmlist中。flags标志非连续区映射的内存类型，VM_ALLOC表示使用vmalloc()得到页，VM_MAP表示使用vmap()得到页，VM_IOREMAP表示ioremap()得到页。</p><h2 id="查找空闲区域">查找空闲区域</h2><p>通过<code>get_vm_area()</code>，用kmalloc分配内存区，在vmlist上找线性地址的空闲区域。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在线性地址VMALLOC_START和VMALLOC_END之间查找一个空闲区域</span><br><span class="hljs-comment"> * size-将被创建的内存区的字节大小</span><br><span class="hljs-comment"> * flag-指定空闲区类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_struct</span> *<span class="hljs-built_in">get_vm_area</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)<br>&#123;<br><span class="hljs-keyword">return</span> __get_vm_area(size, flags, VMALLOC_START, VMALLOC_END);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_struct</span> *__get_vm_area(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_struct</span> **p, *tmp, *area;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> align = <span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr;<br><br><span class="hljs-keyword">if</span> (flags &amp; VM_IOREMAP) &#123;<br><span class="hljs-type">int</span> bit = <span class="hljs-built_in">fls</span>(size);<br><br><span class="hljs-keyword">if</span> (bit &gt; IOREMAP_MAX_ORDER)<br>bit = IOREMAP_MAX_ORDER;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bit &lt; PAGE_SHIFT)<br>bit = PAGE_SHIFT;<br><br>align = <span class="hljs-number">1ul</span> &lt;&lt; bit;<br>&#125;<br>addr = <span class="hljs-built_in">ALIGN</span>(start, align);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用kmalloc为vm_struct类型的新描述符获得一个内存区。</span><br><span class="hljs-comment"> */</span><br>area = <span class="hljs-built_in">kmalloc</span>(<span class="hljs-built_in">sizeof</span>(*area), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!area))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We always allocate a guard page.</span><br><span class="hljs-comment"> */</span><br>size += PAGE_SIZE;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!size)) &#123;<br><span class="hljs-built_in">kfree</span> (area);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为写获得vmlist_lock锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">write_lock</span>(&amp;vmlist_lock);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扫描vmlist链表，来查找线性地址的一个空闲区域。至少覆盖size+4096个地址(4096是安全区)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (p = &amp;vmlist; (tmp = *p) != <span class="hljs-literal">NULL</span> ;p = &amp;tmp-&gt;next) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 起始地址addr落在了其他已经分配的vm_struct的VA地址空间中间</span><br><span class="hljs-comment">         */</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)tmp-&gt;addr &lt; addr) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * addr 已经超过了前一个vm_struct所覆盖的真个VA地址空间，那么addr就更新到上一个vm_struct的VA地址空间最后面</span><br><span class="hljs-comment">             */</span><br><span class="hljs-keyword">if</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)tmp-&gt;addr + tmp-&gt;size &gt;= addr)<br>addr = <span class="hljs-built_in">ALIGN</span>(tmp-&gt;size + <br>     (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)tmp-&gt;addr, align);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 到达这里的条件是:</span><br><span class="hljs-comment">         *  tmp-&gt;addr &gt;= addr </span><br><span class="hljs-comment">         * 也就是 addr 没有落在其他已经分配的vm_struct的VA地址空间中间，即下一个vm_struct地址空间之前</span><br><span class="hljs-comment">         */</span><br><span class="hljs-keyword">if</span> ((size + addr) &lt; addr)<br><span class="hljs-keyword">goto</span> out;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * addr+size 也没有落在其他已经分配的vm_struct的VA地址空间中间，即下一个vm_struct地址空间之前</span><br><span class="hljs-comment">         */</span><br><span class="hljs-keyword">if</span> (size + addr &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)tmp-&gt;addr)<br><span class="hljs-keyword">goto</span> found;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 到达这里是 addr+size 落在了下一个已经分配的vm_struct的VA地址空间中间</span><br><span class="hljs-comment">         * addr就更新到下一个vm_struct的VA地址空间最后面</span><br><span class="hljs-comment">         */</span><br>addr = <span class="hljs-built_in">ALIGN</span>(tmp-&gt;size + (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)tmp-&gt;addr, align);<br><span class="hljs-keyword">if</span> (addr &gt; end - size)<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br>found:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果存在这样一个空闲区间，就初始化描述符的字段</span><br><span class="hljs-comment"> */</span><br>area-&gt;next = *p;<br>*p = area;<br><br>area-&gt;flags = flags;<br>area-&gt;addr = (<span class="hljs-type">void</span> *)addr;<br>area-&gt;size = size;<br>area-&gt;pages = <span class="hljs-literal">NULL</span>;<br>area-&gt;nr_pages = <span class="hljs-number">0</span>;<br>area-&gt;phys_addr = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放锁并返回内存区的起始地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">write_unlock</span>(&amp;vmlist_lock);<br><br><span class="hljs-keyword">return</span> area;<br><br>out:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有找到空闲区，就释放锁并释放先前得到的描述符，然后返回NULL。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">write_unlock</span>(&amp;vmlist_lock);<br><span class="hljs-built_in">kfree</span>(area);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">printk_ratelimit</span>())<br><span class="hljs-built_in">printk</span>(KERN_WARNING <span class="hljs-string">&quot;allocation failed: out of vmalloc space - use vmalloc=&lt;size&gt; to increase size.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="分配非连续内存区">分配非连续内存区</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 给内核分配一个非连续内存区。</span><br><span class="hljs-comment"> * size-所请求分配的内存区的大小。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">vmalloc</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>       <span class="hljs-keyword">return</span> __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL);<br>&#125;<br><br><span class="hljs-type">void</span> *__vmalloc(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size, <span class="hljs-type">int</span> gfp_mask, <span class="hljs-type">pgprot_t</span> prot)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_struct</span> *area;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> **pages;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_pages, array_size, i;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先将参数size设为4096的整数倍。</span><br><span class="hljs-comment"> */</span><br>size = <span class="hljs-built_in">PAGE_ALIGN</span>(size);<br><span class="hljs-keyword">if</span> (!size || (size &gt;&gt; PAGE_SHIFT) &gt; num_physpages)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过调用get_vm_area来创建一个新的描述符。并返回分配给这个内存区的线性地址。</span><br><span class="hljs-comment"> * 描述符的flags字段被初始化为VM_ALLOC，这意味着通过使用vmalloc函数，非连续页框将被映射到一个线性地址空间。</span><br><span class="hljs-comment"> */</span><br>area = <span class="hljs-built_in">get_vm_area</span>(size, VM_ALLOC);<br><span class="hljs-keyword">if</span> (!area)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>nr_pages = size &gt;&gt; PAGE_SHIFT;<br>array_size = (nr_pages * <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> page *));<br><br>area-&gt;nr_pages = nr_pages;<br><span class="hljs-comment">/* Please note that the recursion is strictly bounded. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为页描述符指针数组分配页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (array_size &gt; PAGE_SIZE)<br>pages = __vmalloc(array_size, gfp_mask, PAGE_KERNEL);<br><span class="hljs-keyword">else</span><br>pages = <span class="hljs-built_in">kmalloc</span>(array_size, (gfp_mask &amp; ~__GFP_HIGHMEM));<br>area-&gt;pages = pages;<br><span class="hljs-keyword">if</span> (!area-&gt;pages) &#123;<br><span class="hljs-built_in">remove_vm_area</span>(area-&gt;addr);<br><span class="hljs-built_in">kfree</span>(area);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-built_in">memset</span>(area-&gt;pages, <span class="hljs-number">0</span>, array_size);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重复调用alloc_page，为内存区分配nr_pages个页框。并把对应的页描述符放到area-&gt;pages中。</span><br><span class="hljs-comment"> * 必须使用area-&gt;pages数组是因为:页框可能属于ZONE_HIGHMEM内存管理区，此时它们不一定映射到一个线性地址上。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; area-&gt;nr_pages; i++) &#123;<br>area-&gt;pages[i] = <span class="hljs-built_in">alloc_page</span>(gfp_mask);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!area-&gt;pages[i])) &#123;<br><span class="hljs-comment">/* Successfully allocated i pages, free them in __vunmap() */</span><br>area-&gt;nr_pages = i;<br><span class="hljs-keyword">goto</span> fail;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 现在已经得到了一个连续的线性地址空间，并且分配了一组非连续的页框来映射这些地址。</span><br><span class="hljs-comment"> * 需要修改内核页表项，将二者对应起来。这是map_vm_area的工作。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">map_vm_area</span>(area, prot, &amp;pages))<br><span class="hljs-keyword">goto</span> fail;<br><span class="hljs-keyword">return</span> area-&gt;addr;<br><br>fail:<br><span class="hljs-built_in">vfree</span>(area-&gt;addr);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后的对应关系修正需要展开<code>map_vm_area</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将线性地址和页框对应起来</span><br><span class="hljs-comment"> * area-指向内存区的vm_struct描述符的指针</span><br><span class="hljs-comment"> * prot-已分配页框的保护位，它总是被置为0x63，对应着present,accessed,read/write及dirty.</span><br><span class="hljs-comment"> * pages-指向一个指针数组的变量的地址。该指针数组的指针指向页描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">map_vm_area</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_struct *area, <span class="hljs-type">pgprot_t</span> prot, <span class="hljs-keyword">struct</span> page ***pages)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先将内存区的开始和末尾的线性地址分配给局部变量address和end</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) area-&gt;addr;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end = address + (area-&gt;size-PAGE_SIZE);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> next;<br><span class="hljs-type">pgd_t</span> *pgd;<br><span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用pgd_offset_k来获得主内核页全局目录中的目录项。该目录项对应于内存区起始线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 更新根目录在swapper_pg_dir主内核页全局目录中的常规页表集合，</span><br><span class="hljs-comment"> * 这个页全局目录由主内存描述符的pgd字段所指向，而主内存描述符存放于init_mm遍历</span><br><span class="hljs-comment">     */</span><br>pgd = <span class="hljs-built_in">pgd_offset_k</span>(address);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得内核页表自旋锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_lock</span>(&amp;init_mm.page_table_lock);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此循环为每个页框建立页表项。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-built_in">pgd_index</span>(address); i &lt;= <span class="hljs-built_in">pgd_index</span>(end<span class="hljs-number">-1</span>); i++) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用pud_alloc来为新内存区创建一个页上级目录。并把它的物理地址写入内核页全局目录的合适表项。</span><br><span class="hljs-comment"> * 建立了PGD和PUD的联系(addr对应部分)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">pud_t</span> *pud = <span class="hljs-built_in">pud_alloc</span>(&amp;init_mm, pgd, address);<br><span class="hljs-keyword">if</span> (!pud) &#123;<br>err = -ENOMEM;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * next是本PUD项映射范围的结束地址</span><br><span class="hljs-comment">         */</span><br>next = (address + PGDIR_SIZE) &amp; PGDIR_MASK;<br><span class="hljs-keyword">if</span> (next &lt; address || next &gt; end)<br>next = end;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * map_area_pud函数为页上级目录所指向的所有页表建立对应关系。</span><br><span class="hljs-comment"> * 建立PUD以下映射关系</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">map_area_pud</span>(pud, address, next, prot, pages)) &#123;<br>err = -ENOMEM;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>address = next;<br>pgd++;<br>&#125;<br><br><span class="hljs-built_in">spin_unlock</span>(&amp;init_mm.page_table_lock);<br><span class="hljs-built_in">flush_cache_vmap</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) area-&gt;addr, end);<br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>还有一个vmap()，它会映射非连续内存区中已经分配的页框： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 它将映射非连续内存区中已经分配的页框。本质上，该函数接收一组指向页描述符的指针作为参数，</span><br><span class="hljs-comment"> * 调用get_vm_area得到一个新的vm_struct描述符。然后调用map_vm_area来映射页框。因此该函数与vmalloc类似，但是不分配页框。</span><br><span class="hljs-comment"> * 即页框pages已经在函数调用者中分配好了，只是还没有映射VA而已，这里完成映射</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">vmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page **pages, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-type">pgprot_t</span> prot)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_struct</span> *area;<br><br><span class="hljs-keyword">if</span> (count &gt; num_physpages)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>area = <span class="hljs-built_in">get_vm_area</span>((count &lt;&lt; PAGE_SHIFT), flags);<br><span class="hljs-keyword">if</span> (!area)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">map_vm_area</span>(area, prot, &amp;pages)) &#123;<br><span class="hljs-built_in">vunmap</span>(area-&gt;addr);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> area-&gt;addr;<br>&#125;<br><span class="hljs-comment">//显然map_vm_area是核心</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将线性地址和页框对应起来</span><br><span class="hljs-comment"> * area-指向内存区的vm_struct描述符的指针</span><br><span class="hljs-comment"> * prot-已分配页框的保护位，它总是被置为0x63，对应着present,accessed,read/write及dirty.</span><br><span class="hljs-comment"> * pages-指向一个指针数组的变量的地址。该指针数组的指针指向页描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">map_vm_area</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_struct *area, <span class="hljs-type">pgprot_t</span> prot, <span class="hljs-keyword">struct</span> page ***pages)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先将内存区的开始和末尾的线性地址分配给局部变量address和end</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) area-&gt;addr;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end = address + (area-&gt;size-PAGE_SIZE);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> next;<br><span class="hljs-type">pgd_t</span> *pgd;<br><span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用pgd_offset_k来获得主内核页全局目录中的目录项。该目录项对应于内存区起始线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 更新根目录在swapper_pg_dir主内核页全局目录中的常规页表集合，</span><br><span class="hljs-comment"> * 这个页全局目录由主内存描述符的pgd字段所指向，而主内存描述符存放于init_mm遍历</span><br><span class="hljs-comment">     */</span><br>pgd = <span class="hljs-built_in">pgd_offset_k</span>(address);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得内核页表自旋锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_lock</span>(&amp;init_mm.page_table_lock);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此循环为每个页框建立页表项。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-built_in">pgd_index</span>(address); i &lt;= <span class="hljs-built_in">pgd_index</span>(end<span class="hljs-number">-1</span>); i++) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用pud_alloc来为新内存区创建一个页上级目录。并把它的物理地址写入内核页全局目录的合适表项。</span><br><span class="hljs-comment"> * 建立了PGD和PUD的联系(addr对应部分)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">pud_t</span> *pud = <span class="hljs-built_in">pud_alloc</span>(&amp;init_mm, pgd, address);<br><span class="hljs-keyword">if</span> (!pud) &#123;<br>err = -ENOMEM;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * next是本PUD项映射范围的结束地址</span><br><span class="hljs-comment">         */</span><br>next = (address + PGDIR_SIZE) &amp; PGDIR_MASK;<br><span class="hljs-keyword">if</span> (next &lt; address || next &gt; end)<br>next = end;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * map_area_pud函数为页上级目录所指向的所有页表建立对应关系。</span><br><span class="hljs-comment"> * 建立PUD以下映射关系</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">map_area_pud</span>(pud, address, next, prot, pages)) &#123;<br>err = -ENOMEM;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>address = next;<br>pgd++;<br>&#125;<br><br><span class="hljs-built_in">spin_unlock</span>(&amp;init_mm.page_table_lock);<br><span class="hljs-built_in">flush_cache_vmap</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) area-&gt;addr, end);<br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="释放非连续内存区">释放非连续内存区</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">kfree</span>(addr);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放由kmalloc接口分配的内存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kfree</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *objp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">kmem_cache_t</span> *c;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br><span class="hljs-keyword">if</span> (!objp)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">local_irq_save</span>(flags);<br><span class="hljs-built_in">kfree_debugcheck</span>(objp);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过((kmem_cache_t *)(pg)-&gt;lru.next)，可确定合适的高速缓存描述符。</span><br><span class="hljs-comment"> */</span><br>c = <span class="hljs-built_in">GET_PAGE_CACHE</span>(<span class="hljs-built_in">virt_to_page</span>(objp));<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __cache_free释放高速缓存中的对象。</span><br><span class="hljs-comment"> */</span><br>__cache_free(c, (<span class="hljs-type">void</span>*)objp);<br><span class="hljs-built_in">local_irq_restore</span>(flags);<br>&#125;<br></code></pre></td></tr></table></figure><p>vmap对应的是vunmap: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放vmap创建的内存区。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vunmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">BUG_ON</span>(<span class="hljs-built_in">in_interrupt</span>());<br>__vunmap(addr, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 被vfree或者vunmap调用，来释放非连续分配的内存区。</span><br><span class="hljs-comment"> * addr-要释放的内存区的起始地址。</span><br><span class="hljs-comment"> * deallocate_pages-如果被映射的页框需要释放到分区页框分配器，就置位(当vfree调用本函数时)。否则不置位(被vunmap调用时)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> __vunmap(<span class="hljs-type">void</span> *addr, <span class="hljs-type">int</span> deallocate_pages)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_struct</span> *area;<br><br><span class="hljs-keyword">if</span> (!addr)<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span> ((PAGE_SIZE<span class="hljs-number">-1</span>) &amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)addr) &#123;<br><span class="hljs-built_in">printk</span>(KERN_ERR <span class="hljs-string">&quot;Trying to vfree() bad address (%p)\n&quot;</span>, addr);<br><span class="hljs-built_in">WARN_ON</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用remove_vm_area得到vm_struct描述符的地址。</span><br><span class="hljs-comment"> * 并清除非连续内存区中的线性地址对应的内核的页表项。</span><br><span class="hljs-comment"> */</span><br>area = <span class="hljs-built_in">remove_vm_area</span>(addr);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!area)) &#123;<br><span class="hljs-built_in">printk</span>(KERN_ERR <span class="hljs-string">&quot;Trying to vfree() nonexistent vm area (%p)\n&quot;</span>,<br>addr);<br><span class="hljs-built_in">WARN_ON</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果deallocate_pages被置位，扫描指向页描述符的area-&gt;nr_pages</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (deallocate_pages) &#123;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; area-&gt;nr_pages; i++) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对每一个数组元素，调用__free_page函数释放页框到分区页框分配器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!area-&gt;pages[i]))<br><span class="hljs-built_in">BUG</span>();<br>__free_page(area-&gt;pages[i]);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放area-&gt;pages数组本身。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (area-&gt;nr_pages &gt; PAGE_SIZE/<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> page *))<br><span class="hljs-built_in">vfree</span>(area-&gt;pages);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">kfree</span>(area-&gt;pages);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放vm_struct描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">kfree</span>(area);<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>释放永远要比分配简单。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux-kernel</tag>
      
      <tag>ulk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核学习——内存管理之内存区管理</title>
    <link href="/2017/10/24/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/"/>
    <url>/2017/10/24/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>阅读内存区管理之前，需要先掌握页框管理机制。优先阅读《Linux内核学习——内存管理之页框管理》。</p><span id="more"></span><h1 id="linux内存管理内存区管理">Linux内存管理——内存区管理</h1><p>buddy system以pageframe作为单位，这适合大块内存的请求，对于小请求来说，如果每次对几十字节的请求都分配一个pageframe显然是极大的浪费。Linux当然需要一套机制来管理每个页框的详细内存分配。</p><h2 id="slab-allocator-design">Slab Allocator Design</h2><p>源于Solaris2.4的一种设计，ULK给的定义非常晕，实际上只需要一张图即可搞清楚设计的架构。详细的情况需要看源码。</p><p><img src="20171024_1.jpg" /></p><p>cache和slab的关系： <img src="20171024_2.jpg" /></p><p>每个cache都包含三个slabs列表，这是一段连续的内存块。存在3种slab：full：完全分配的slab partial：部分分配的slabfree:空slab，对象没被分配</p><p>slab列表中的每个slab都是一个连续的内存块，它们被划分成一个个分类的对象。slab是slab分配器操作的最小分配单位，通常情况，一个slab被分配成多个对象。</p><p>深入探索三个列表的工作机理前，先看看它们的描述符结构定义。</p><h3 id="cache描述符">Cache描述符</h3><p><code>kmem_cache_s</code>就是cache的描述符结构： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 高速缓存描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">kmem_cache_s</span> &#123;<br><span class="hljs-comment">/* 1) per-cpu data, touched during every alloc/free */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 每CPU指针数组，指向包含空闲对象的本地高速缓存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span>*array[NR_CPUS];<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 要转移进本地高速缓存或从本地高速缓存中转移出的大批对象的数量。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>batchcount;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 本地高速缓存中空闲对象的最大数目。这个参数可调。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>limit;<br><span class="hljs-comment">/* 2) touched by every alloc &amp; free from the backend */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 包含三个链表，为什么要单独放到一个描述符中呢?</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">kmem_list3</span>lists;<br><span class="hljs-comment">/* NUMA: kmem_3list_t*nodelists[MAX_NUMNODES] */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 高速缓存中包含的对象的大小。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>objsize;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 描述高速缓存永久属性的一组标志。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<span class="hljs-comment">/* constant flags */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在一个单独slab中的对象的个数。高速缓存中的所有slab具有相同的大小。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>num;<span class="hljs-comment">/* # of objs per slab */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 整个slab高速缓存中空闲对象的上限。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>free_limit; <span class="hljs-comment">/* upper limit of objects in the lists */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 高速缓存自旋锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">spinlock_t</span>spinlock;<br><br><span class="hljs-comment">/* 3) cache_grow/shrink */</span><br><span class="hljs-comment">/* order of pgs per slab (2^n) */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个单独slab中包含的连续页框数目的对数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>gfporder;<br><br><span class="hljs-comment">/* force GFP flags, e.g. GFP_DMA */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分配页框时传递给伙伴系统函数的一组标志。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>gfpflags;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * slab使用的颜色个数。用于slab着色。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">size_t</span>colour;<span class="hljs-comment">/* cache colouring range */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * slab中的基本对齐偏移。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>colour_off;<span class="hljs-comment">/* colour offset */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 下一个被分配的slab使用的颜色。就是对齐因子。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>colour_next;<span class="hljs-comment">/* cache colouring */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向包含slab描述符的普通slab高速缓存。如果使用了内部slab描述符，则这个字段为NULL。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">kmem_cache_t</span>*slabp_cache;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单个slab的大小。</span><br><span class="hljs-comment"> * slab_size = slab描述符大小 + 所有对象描述符大小 + pading</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>slab_size;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 高速缓存动态属性标志。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>dflags;<span class="hljs-comment">/* dynamic flags */</span><br><br><span class="hljs-comment">/* constructor func */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 高速缓存相关的构造方法的指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">void</span> (*ctor)(<span class="hljs-type">void</span> *, <span class="hljs-type">kmem_cache_t</span> *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><br><span class="hljs-comment">/* de-constructor func */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 高速缓存相关的析构方法的指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">void</span> (*dtor)(<span class="hljs-type">void</span> *, <span class="hljs-type">kmem_cache_t</span> *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><br><span class="hljs-comment">/* 4) cache creation/removal */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 高速缓存名称。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 高速缓存链表。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>next;<br><br><span class="hljs-comment">/* 5) statistics */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> STATS</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 统计信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>num_active;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>num_allocations;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>high_mark;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>grown;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>reaped;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> errors;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>max_freeable;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>node_allocs;<br><span class="hljs-type">atomic_t</span>allochit;<br><span class="hljs-type">atomic_t</span>allocmiss;<br><span class="hljs-type">atomic_t</span>freehit;<br><span class="hljs-type">atomic_t</span>freemiss;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调试信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span>dbghead;<br><span class="hljs-type">int</span>reallen;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>通过next成员组成kmem_cache链，链的作用是配合查找best-fit大小的缓存。高速缓存描述符指针数组array展开： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 空闲对象的本地高速缓存描述符（注意：是描述符而不是本地高速缓存本身，本地高速缓存在描述符后面）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向本地高速缓存中可使用对象的指针的个数。</span><br><span class="hljs-comment"> * 它同时也作为高速缓存中第一个空槽的下标。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> avail;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 本地高速缓存的大小，也就是本地高速缓存中指针的最大个数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> limit;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 本地高速缓存重新填充或者腾空时使用的块大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> batchcount;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果最近被使用过，则置为1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> touched;<br>&#125;;<br></code></pre></td></tr></table></figure>lists就是三个slab链表，分别是不包含空闲对象的slab描述符链，只包含空闲对象的slab描述符链和包含空闲和费空闲对象的slab描述符链：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * slab高速缓存描述符内嵌结构</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">kmem_list3</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 空闲和非空闲对象的slab描述符双向循环链表。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>slabs_partial;<span class="hljs-comment">/* partial list first, better asm code */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不包含空闲对象的slab描述符双向循环链表。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>slabs_full;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 只包含空闲对象的slab描述符双向循环链表。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>slabs_free;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>free_objects;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * slab分配器的页回收算法使用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span>free_touched;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * slab分配器的页回收算法使用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>next_reap;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所有CPU共享的一个本地高速缓存的指针。它使得将空闲对象从一个本地高速缓存移动到另外一个高速缓存的任务更容易。</span><br><span class="hljs-comment"> * 它的初始大小是batchcount字段的8倍。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span>*shared;<br>&#125;;<br></code></pre></td></tr></table></figure>free链的slab是进行回收的主要备选对象。通过此过程，slab使用的内存被返回给OS。</p><p>对象都是在slab中进行分配释放的，单个slab可以在slab列表之间移动。比如当一个slab中所有对象都被用完时，就从partial链移动到full链；当一个slab完全被分配并且有对象被释放后，就从full链移动到partial链。在看完slab描述符后，会有一张图用于梳理工作逻辑与结构关系。</p><h3 id="slab描述符">slab描述符</h3><p>高速缓存中的每个slab都由自己的类型为slab的描述符： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * slab描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * slab高速缓存描述符的三个双向循环链表中的一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>list;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * slab中第一个对象的偏移。</span><br><span class="hljs-comment"> * 同一个高速缓存的不同slab有不同的coloroff值。这样可以避免硬件缓存行的不利影响。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>colouroff;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * slab中第一个对象的地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span>*s_mem;<span class="hljs-comment">/* including colour offset */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当前正在使用的slab中的对象个数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>inuse;<span class="hljs-comment">/* num of objs active in slab */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * slab中下一个空闲对象的下标。如果没有剩下空闲对象则为BUFCT_END</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">kmem_bufctl_t</span>free;<br>&#125;;<br></code></pre></td></tr></table></figure>slab描述符可以放在两个地方： -放在slab外部，位于cache_sizes指向的一个不适合ISADMA的普通高速缓存中。此时高速缓存描述符的flags字段中<code>CFLGS_OFF_SLAB</code>置1。-放在slab内部，位于分配给slab的第一个页框的起始位置。当对象小于512MB，或者当内部碎片为slab描述符和对象描述符在slab中留下足够空间时，slab描述符放在内部。</p><p>ULK上cache描述符与slab描述符的关联： <img src="20171024_3.jpg" /></p><p>三种slab链的工作机理： <img src="20171024_4.jpg" /></p><p>slab的内部结构平坦视图： <img src="20171024_5.jpg" /></p><p>关于着色相关，后面再详述。</p><h3 id="普通和专用高速缓存">普通和专用高速缓存</h3><p>高速缓存的两种类型。普通只由slab分配器用于自己的目的，专用则由内核其余部分使用。</p><p>普通高速缓存： 1.第一个高速缓存是kmem_cache，包含由内核使用的其余高速缓存的高速缓存描述符。cache_cache变量包含第一个高速缓存的描述符。2.另外一些高速缓存包含用作普通用途的内存区。内存区大小的范围一般包括13个几何分布的内存区。一个叫做malloc_sizes的表分别指向26个高速缓存描述符，相关的内存区大小为32，64，128，256，512，1024，2048，4096，8192，16384，32768，65536，131072字节。对每种大小，都有两个高速缓存：一个适用于ISADMA分配，一个用于常规分配。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第一个普通高速缓存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">kmem_cache_t</span> cache_cache = &#123;<br>.lists= <span class="hljs-built_in">LIST3_INIT</span>(cache_cache.lists),<br>.batchcount= <span class="hljs-number">1</span>,<br>.limit= BOOT_CPUCACHE_ENTRIES,<br>.objsize= <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_cache_t</span>),<br>.flags= SLAB_NO_REAP,<br>.spinlock= SPIN_LOCK_UNLOCKED,<br>.name= <span class="hljs-string">&quot;kmem_cache&quot;</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>.reallen= <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_cache_t</span>),<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向26个高速缓存描述符的表。</span><br><span class="hljs-comment"> * 与其相关的内存区大小为32,64,128,256,512,1024,4096,8192,32768,131072个字节。</span><br><span class="hljs-comment"> * 对于每种大小，都有两个高速缓存：一个适用于ISA DMA分配，一个适用于常规分配。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cache_sizes</span> malloc_sizes[] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CACHE(x) &#123; .cs_size = (x) &#125;,</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kmalloc_sizes.h&gt;</span></span><br>&#123; <span class="hljs-number">0</span>, &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> CACHE</span><br>&#125;;<br><br><span class="hljs-comment">/* Size description struct for general caches. */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cache_sizes</span> &#123;<br><span class="hljs-type">size_t</span> cs_size;<br><span class="hljs-type">kmem_cache_t</span>*cs_cachep;<br><span class="hljs-type">kmem_cache_t</span>*cs_dmacachep;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>普通高速缓存的初始化建立： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 建立普通高速缓存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> __init <span class="hljs-title">kmem_cache_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">size_t</span> left_over;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cache_sizes</span> *sizes;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cache_names</span> *names;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Fragmentation resistance on low memory - only use bigger</span><br><span class="hljs-comment"> * page orders on machines with more than 32MB of memory.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (num_physpages &gt; (<span class="hljs-number">32</span> &lt;&lt; <span class="hljs-number">20</span>) &gt;&gt; PAGE_SHIFT)<br>slab_break_gfp_order = BREAK_GFP_ORDER_HI;<br><br><br><span class="hljs-comment">/* Bootstrap is tricky, because several objects are allocated</span><br><span class="hljs-comment"> * from caches that do not exist yet:</span><br><span class="hljs-comment"> * 1) initialize the cache_cache cache: it contains the kmem_cache_t</span><br><span class="hljs-comment"> *    structures of all caches, except cache_cache itself: cache_cache</span><br><span class="hljs-comment"> *    is statically allocated.</span><br><span class="hljs-comment"> *    Initially an __init data area is used for the head array, it&#x27;s</span><br><span class="hljs-comment"> *    replaced with a kmalloc allocated array at the end of the bootstrap.</span><br><span class="hljs-comment"> * 2) Create the first kmalloc cache.</span><br><span class="hljs-comment"> *    The kmem_cache_t for the new cache is allocated normally. An __init</span><br><span class="hljs-comment"> *    data area is used for the head array.</span><br><span class="hljs-comment"> * 3) Create the remaining kmalloc caches, with minimally sized head arrays.</span><br><span class="hljs-comment"> * 4) Replace the __init data head arrays for cache_cache and the first</span><br><span class="hljs-comment"> *    kmalloc cache with kmalloc allocated arrays.</span><br><span class="hljs-comment"> * 5) Resize the head arrays of the kmalloc caches to their final sizes.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* 1) create the cache_cache */</span><br><span class="hljs-built_in">init_MUTEX</span>(&amp;cache_chain_sem);<br><span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;cache_chain);<br><span class="hljs-built_in">list_add</span>(&amp;cache_cache.next, &amp;cache_chain);<br>cache_cache.colour_off = <span class="hljs-built_in">cache_line_size</span>();<br>cache_cache.array[<span class="hljs-built_in">smp_processor_id</span>()] = &amp;initarray_cache.cache;<br><br>cache_cache.objsize = <span class="hljs-built_in">ALIGN</span>(cache_cache.objsize, <span class="hljs-built_in">cache_line_size</span>());<br><br><span class="hljs-built_in">cache_estimate</span>(<span class="hljs-number">0</span>, cache_cache.objsize, <span class="hljs-built_in">cache_line_size</span>(), <span class="hljs-number">0</span>,<br>&amp;left_over, &amp;cache_cache.num);<br><span class="hljs-keyword">if</span> (!cache_cache.num)<br><span class="hljs-built_in">BUG</span>();<br><br>cache_cache.colour = left_over/cache_cache.colour_off;<br>cache_cache.colour_next = <span class="hljs-number">0</span>;<br>cache_cache.slab_size = <span class="hljs-built_in">ALIGN</span>(cache_cache.num*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_bufctl_t</span>) +<br><span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> slab), <span class="hljs-built_in">cache_line_size</span>());<br><br><span class="hljs-comment">/* 2+3) create the kmalloc caches */</span><br>sizes = malloc_sizes;<br>names = cache_names;<br><br><span class="hljs-keyword">while</span> (sizes-&gt;cs_size) &#123;<br><span class="hljs-comment">/* For performance, all the general caches are L1 aligned.</span><br><span class="hljs-comment"> * This should be particularly beneficial on SMP boxes, as it</span><br><span class="hljs-comment"> * eliminates &quot;false sharing&quot;.</span><br><span class="hljs-comment"> * Note for systems short on memory removing the alignment will</span><br><span class="hljs-comment"> * allow tighter packing of the smaller caches. */</span><br>sizes-&gt;cs_cachep = <span class="hljs-built_in">kmem_cache_create</span>(names-&gt;name,<br>sizes-&gt;cs_size, ARCH_KMALLOC_MINALIGN,<br>(ARCH_KMALLOC_FLAGS | SLAB_PANIC), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">/* Inc off-slab bufctl limit until the ceiling is hit. */</span><br><span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">OFF_SLAB</span>(sizes-&gt;cs_cachep))) &#123;<br>offslab_limit = sizes-&gt;cs_size-<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> slab);<br>offslab_limit /= <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_bufctl_t</span>);<br>&#125;<br><br>sizes-&gt;cs_dmacachep = <span class="hljs-built_in">kmem_cache_create</span>(names-&gt;name_dma,<br>sizes-&gt;cs_size, ARCH_KMALLOC_MINALIGN,<br>(ARCH_KMALLOC_FLAGS | SLAB_CACHE_DMA | SLAB_PANIC),<br><span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>sizes++;<br>names++;<br>&#125;<br><span class="hljs-comment">/* 4) Replace the bootstrap head arrays */</span><br>&#123;<br><span class="hljs-type">void</span> * ptr;<br><br>ptr = <span class="hljs-built_in">kmalloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> arraycache_init), GFP_KERNEL);<br><span class="hljs-built_in">local_irq_disable</span>();<br><span class="hljs-built_in">BUG_ON</span>(<span class="hljs-built_in">ac_data</span>(&amp;cache_cache) != &amp;initarray_cache.cache);<br><span class="hljs-built_in">memcpy</span>(ptr, <span class="hljs-built_in">ac_data</span>(&amp;cache_cache), <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> arraycache_init));<br>cache_cache.array[<span class="hljs-built_in">smp_processor_id</span>()] = ptr;<br><span class="hljs-built_in">local_irq_enable</span>();<br><br>ptr = <span class="hljs-built_in">kmalloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> arraycache_init), GFP_KERNEL);<br><span class="hljs-built_in">local_irq_disable</span>();<br><span class="hljs-built_in">BUG_ON</span>(<span class="hljs-built_in">ac_data</span>(malloc_sizes[<span class="hljs-number">0</span>].cs_cachep) != &amp;initarray_generic.cache);<br><span class="hljs-built_in">memcpy</span>(ptr, <span class="hljs-built_in">ac_data</span>(malloc_sizes[<span class="hljs-number">0</span>].cs_cachep),<br><span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> arraycache_init));<br>malloc_sizes[<span class="hljs-number">0</span>].cs_cachep-&gt;array[<span class="hljs-built_in">smp_processor_id</span>()] = ptr;<br><span class="hljs-built_in">local_irq_enable</span>();<br>&#125;<br><br><span class="hljs-comment">/* 5) resize the head arrays to their final sizes */</span><br>&#123;<br><span class="hljs-type">kmem_cache_t</span> *cachep;<br><span class="hljs-built_in">down</span>(&amp;cache_chain_sem);<br><span class="hljs-built_in">list_for_each_entry</span>(cachep, &amp;cache_chain, next)<br><span class="hljs-built_in">enable_cpucache</span>(cachep);<br><span class="hljs-built_in">up</span>(&amp;cache_chain_sem);<br>&#125;<br><br><span class="hljs-comment">/* Done! */</span><br>g_cpucache_up = FULL;<br><br><span class="hljs-comment">/* Register a cpu startup notifier callback</span><br><span class="hljs-comment"> * that initializes ac_data for all new cpus</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">register_cpu_notifier</span>(&amp;cpucache_notifier);<br><br><br><span class="hljs-comment">/* The reap timers are started later, with a module init call:</span><br><span class="hljs-comment"> * That part of the kernel is not yet operational.</span><br><span class="hljs-comment"> */</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>专用高速缓存创建： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 建立专用高速缓存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">kmem_cache_t</span> *</span><br><span class="hljs-function"><span class="hljs-title">kmem_cache_create</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> align,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span>*, <span class="hljs-type">kmem_cache_t</span> *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span> (*dtor)(<span class="hljs-type">void</span>*, <span class="hljs-type">kmem_cache_t</span> *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>))</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">size_t</span> left_over, slab_size, ralign;<br><span class="hljs-type">kmem_cache_t</span> *cachep = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Sanity checks... these are all serious usage bugs.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((!name) ||<br><span class="hljs-built_in">in_interrupt</span>() ||<br>(size &lt; BYTES_PER_WORD) ||<br>(size &gt; (<span class="hljs-number">1</span>&lt;&lt;MAX_OBJ_ORDER)*PAGE_SIZE) ||<br>(dtor &amp;&amp; !ctor)) &#123;<br><span class="hljs-built_in">printk</span>(KERN_ERR <span class="hljs-string">&quot;%s: Early error in slab %s\n&quot;</span>,<br>__FUNCTION__, name);<br><span class="hljs-built_in">BUG</span>();<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br><span class="hljs-built_in">WARN_ON</span>(<span class="hljs-built_in">strchr</span>(name, <span class="hljs-string">&#x27; &#x27;</span>));<span class="hljs-comment">/* It confuses parsers */</span><br><span class="hljs-keyword">if</span> ((flags &amp; SLAB_DEBUG_INITIAL) &amp;&amp; !ctor) &#123;<br><span class="hljs-comment">/* No constructor, but inital state check requested */</span><br><span class="hljs-built_in">printk</span>(KERN_ERR <span class="hljs-string">&quot;%s: No con, but init state check &quot;</span><br><span class="hljs-string">&quot;requested - %s\n&quot;</span>, __FUNCTION__, name);<br>flags &amp;= ~SLAB_DEBUG_INITIAL;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FORCED_DEBUG</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Enable redzoning and last user accounting, except for caches with</span><br><span class="hljs-comment"> * large objects, if the increased size would increase the object size</span><br><span class="hljs-comment"> * above the next power of two: caches with object sizes just above a</span><br><span class="hljs-comment"> * power of two have a significant amount of internal fragmentation.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据参数确定高速缓存的最佳方法(是内部还是外部slab描述符。)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((size &lt; <span class="hljs-number">4096</span> || <span class="hljs-built_in">fls</span>(size<span class="hljs-number">-1</span>) == <span class="hljs-built_in">fls</span>(size<span class="hljs-number">-1</span>+<span class="hljs-number">3</span>*BYTES_PER_WORD)))<br>flags |= SLAB_RED_ZONE|SLAB_STORE_USER;<br><span class="hljs-keyword">if</span> (!(flags &amp; SLAB_DESTROY_BY_RCU))<br>flags |= SLAB_POISON;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">if</span> (flags &amp; SLAB_DESTROY_BY_RCU)<br><span class="hljs-built_in">BUG_ON</span>(flags &amp; SLAB_POISON);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">if</span> (flags &amp; SLAB_DESTROY_BY_RCU)<br><span class="hljs-built_in">BUG_ON</span>(dtor);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Always checks flags, a caller might be expecting debug</span><br><span class="hljs-comment"> * support which isn&#x27;t available.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (flags &amp; ~CREATE_MASK)<br><span class="hljs-built_in">BUG</span>();<br><br><span class="hljs-comment">/* Check that size is in terms of words.  This is needed to avoid</span><br><span class="hljs-comment"> * unaligned accesses for some archs when redzoning is used, and makes</span><br><span class="hljs-comment"> * sure any on-slab bufctl&#x27;s are also correctly aligned.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (size &amp; (BYTES_PER_WORD<span class="hljs-number">-1</span>)) &#123;<br>size += (BYTES_PER_WORD<span class="hljs-number">-1</span>);<br>size &amp;= ~(BYTES_PER_WORD<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-comment">/* calculate out the final buffer alignment: */</span><br><span class="hljs-comment">/* 1) arch recommendation: can be overridden for debug */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 需要考虑硬件缓存行。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (flags &amp; SLAB_HWCACHE_ALIGN) &#123;<br><span class="hljs-comment">/* Default alignment: as specified by the arch code.</span><br><span class="hljs-comment"> * Except if an object is really small, then squeeze multiple</span><br><span class="hljs-comment"> * objects into one cacheline.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果高速缓存对象的大小大于高速缓存行ralign的一半，</span><br><span class="hljs-comment"> * 就在RAM中根据L1_CACHE_BYTES的倍数对齐对象。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * lf: 很好理解，大于cacheline，一半，就按照整个cacheline对其; 小于一半，一个cacheline至少可以放两个，以cacheline的一半对其</span><br><span class="hljs-comment"> */</span><br>ralign = <span class="hljs-built_in">cache_line_size</span>();<br><span class="hljs-keyword">while</span> (size &lt;= ralign/<span class="hljs-number">2</span>)<br>ralign /= <span class="hljs-number">2</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ralign = BYTES_PER_WORD;<br>&#125;<br><span class="hljs-comment">/* 2) arch mandated alignment: disables debug if necessary */</span><br><span class="hljs-keyword">if</span> (ralign &lt; ARCH_SLAB_MINALIGN) &#123;<br>ralign = ARCH_SLAB_MINALIGN;<br><span class="hljs-keyword">if</span> (ralign &gt; BYTES_PER_WORD)<br>flags &amp;= ~(SLAB_RED_ZONE|SLAB_STORE_USER);<br>&#125;<br><span class="hljs-comment">/* 3) caller mandated alignment: disables debug if necessary */</span><br><span class="hljs-keyword">if</span> (ralign &lt; align) &#123;<br>ralign = align;<br><span class="hljs-keyword">if</span> (ralign &gt; BYTES_PER_WORD)<br>flags &amp;= ~(SLAB_RED_ZONE|SLAB_STORE_USER);<br>&#125;<br><span class="hljs-comment">/* 4) Store it. Note that the debug code below can reduce</span><br><span class="hljs-comment"> *    the alignment to BYTES_PER_WORD.</span><br><span class="hljs-comment"> */</span><br>align = ralign;<br><br><span class="hljs-comment">/* Get cache&#x27;s description obj. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从cache_cache普通高速缓存中为新的高速缓存分配一个高速缓存描述符。</span><br><span class="hljs-comment"> * 并把这个描述符插入到高速缓存描述符的cache_chain链表中。</span><br><span class="hljs-comment"> */</span><br>cachep = (<span class="hljs-type">kmem_cache_t</span> *) <span class="hljs-built_in">kmem_cache_alloc</span>(&amp;cache_cache, SLAB_KERNEL);<br><span class="hljs-keyword">if</span> (!cachep)<br><span class="hljs-keyword">goto</span> opps;<br><span class="hljs-built_in">memset</span>(cachep, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_cache_t</span>));<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>cachep-&gt;reallen = size;<br><br><span class="hljs-keyword">if</span> (flags &amp; SLAB_RED_ZONE) &#123;<br><span class="hljs-comment">/* redzoning only works with word aligned caches */</span><br>align = BYTES_PER_WORD;<br><br><span class="hljs-comment">/* add space for red zone words */</span><br>cachep-&gt;dbghead += BYTES_PER_WORD;<br>size += <span class="hljs-number">2</span>*BYTES_PER_WORD;<br>&#125;<br><span class="hljs-keyword">if</span> (flags &amp; SLAB_STORE_USER) &#123;<br><span class="hljs-comment">/* user store requires word alignment and</span><br><span class="hljs-comment"> * one word storage behind the end of the real</span><br><span class="hljs-comment"> * object.</span><br><span class="hljs-comment"> */</span><br>align = BYTES_PER_WORD;<br>size += BYTES_PER_WORD;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FORCED_DEBUG &amp;&amp; defined(CONFIG_DEBUG_PAGEALLOC)</span><br><span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">128</span> &amp;&amp; cachep-&gt;reallen &gt; <span class="hljs-built_in">cache_line_size</span>() &amp;&amp; size &lt; PAGE_SIZE) &#123;<br>cachep-&gt;dbghead += PAGE_SIZE - size;<br>size = PAGE_SIZE;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/* Determine if the slab management is &#x27;on&#x27; or &#x27;off&#x27; slab. */</span><br><span class="hljs-keyword">if</span> (size &gt;= (PAGE_SIZE&gt;&gt;<span class="hljs-number">3</span>))<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Size is large, assume best to place the slab management obj</span><br><span class="hljs-comment"> * off-slab (should allow better packing of objs).</span><br><span class="hljs-comment"> */</span><br>flags |= CFLGS_OFF_SLAB;<br><br>size = <span class="hljs-built_in">ALIGN</span>(size, align);<br><br><span class="hljs-keyword">if</span> ((flags &amp; SLAB_RECLAIM_ACCOUNT) &amp;&amp; size &lt;= PAGE_SIZE) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * A VFS-reclaimable slab tends to have most allocations</span><br><span class="hljs-comment"> * as GFP_NOFS and we really don&#x27;t want to have to be allocating</span><br><span class="hljs-comment"> * higher-order pages when we are unable to shrink dcache.</span><br><span class="hljs-comment"> */</span><br>cachep-&gt;gfporder = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">cache_estimate</span>(cachep-&gt;gfporder, size, align, flags,<br>&amp;left_over, &amp;cachep-&gt;num);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Calculate size (in pages) of slabs, and the num of objs per</span><br><span class="hljs-comment"> * slab.  This could be made much more intelligent.  For now,</span><br><span class="hljs-comment"> * try to avoid using high page-orders for slabs.  When the</span><br><span class="hljs-comment"> * gfp() funcs are more friendly towards high-order requests,</span><br><span class="hljs-comment"> * this should be changed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> break_flag = <span class="hljs-number">0</span>;<br>cal_wastage:<br><span class="hljs-built_in">cache_estimate</span>(cachep-&gt;gfporder, size, align, flags,<br>&amp;left_over, &amp;cachep-&gt;num);<br><span class="hljs-keyword">if</span> (break_flag)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span> (cachep-&gt;gfporder &gt;= MAX_GFP_ORDER)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span> (!cachep-&gt;num)<br><span class="hljs-keyword">goto</span> next;<br><span class="hljs-keyword">if</span> (flags &amp; CFLGS_OFF_SLAB &amp;&amp;<br>cachep-&gt;num &gt; offslab_limit) &#123;<br><span class="hljs-comment">/* This num of objs will cause problems. */</span><br>cachep-&gt;gfporder--;<br>break_flag++;<br><span class="hljs-keyword">goto</span> cal_wastage;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Large num of objs is good, but v. large slabs are</span><br><span class="hljs-comment"> * currently bad for the gfp()s.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (cachep-&gt;gfporder &gt;= slab_break_gfp_order)<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">if</span> ((left_over*<span class="hljs-number">8</span>) &lt;= (PAGE_SIZE&lt;&lt;cachep-&gt;gfporder))<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">/* Acceptable internal fragmentation. */</span><br>next:<br>cachep-&gt;gfporder++;<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (!cachep-&gt;num) &#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;kmem_cache_create: couldn&#x27;t create cache %s.\n&quot;</span>, name);<br><span class="hljs-built_in">kmem_cache_free</span>(&amp;cache_cache, cachep);<br>cachep = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">goto</span> opps;<br>&#125;<br>slab_size = <span class="hljs-built_in">ALIGN</span>(cachep-&gt;num*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_bufctl_t</span>)<br>+ <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> slab), align);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If the slab has been placed off-slab, and we have enough space then</span><br><span class="hljs-comment"> * move it on-slab. This is at the expense of any extra colouring.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (flags &amp; CFLGS_OFF_SLAB &amp;&amp; left_over &gt;= slab_size) &#123;<br>flags &amp;= ~CFLGS_OFF_SLAB;<br>left_over -= slab_size;<br>&#125;<br><br><span class="hljs-keyword">if</span> (flags &amp; CFLGS_OFF_SLAB) &#123;<br><span class="hljs-comment">/* really off slab. No need for manual alignment */</span><br>slab_size = cachep-&gt;num*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">kmem_bufctl_t</span>)+<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> slab);<br>&#125;<br><br>    <span class="hljs-comment">/*colour_off中记录的aln*/</span><br>cachep-&gt;colour_off = <span class="hljs-built_in">cache_line_size</span>();<br><span class="hljs-comment">/* Offset must be a multiple of the alignment. */</span><br><span class="hljs-keyword">if</span> (cachep-&gt;colour_off &lt; align)<br>cachep-&gt;colour_off = align;<br>    <span class="hljs-comment">/*可用颜色的个数是free/aln*/</span><br>cachep-&gt;colour = left_over/cachep-&gt;colour_off;<br>cachep-&gt;slab_size = slab_size;<br>cachep-&gt;flags = flags;<br>cachep-&gt;gfpflags = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (flags &amp; SLAB_CACHE_DMA)<br>cachep-&gt;gfpflags |= GFP_DMA;<br><span class="hljs-built_in">spin_lock_init</span>(&amp;cachep-&gt;spinlock);<br>cachep-&gt;objsize = size;<br><span class="hljs-comment">/* NUMA */</span><br><span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;cachep-&gt;lists.slabs_full);<br><span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;cachep-&gt;lists.slabs_partial);<br><span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;cachep-&gt;lists.slabs_free);<br><br><span class="hljs-keyword">if</span> (flags &amp; CFLGS_OFF_SLAB)<br>cachep-&gt;slabp_cache = <span class="hljs-built_in">kmem_find_general_cachep</span>(slab_size,<span class="hljs-number">0</span>);<br>cachep-&gt;ctor = ctor;<br>cachep-&gt;dtor = dtor;<br>cachep-&gt;name = name;<br><br><span class="hljs-comment">/* Don&#x27;t let CPUs to come and go */</span><br><span class="hljs-built_in">lock_cpu_hotplug</span>();<br><br><span class="hljs-keyword">if</span> (g_cpucache_up == FULL) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 初始化每CPU本地高速缓存</span><br><span class="hljs-comment">         */</span><br><span class="hljs-built_in">enable_cpucache</span>(cachep);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (g_cpucache_up == NONE) &#123;<br><span class="hljs-comment">/* Note: the first kmem_cache_create must create</span><br><span class="hljs-comment"> * the cache that&#x27;s used by kmalloc(24), otherwise</span><br><span class="hljs-comment"> * the creation of further caches will BUG().</span><br><span class="hljs-comment"> */</span><br>cachep-&gt;array[<span class="hljs-built_in">smp_processor_id</span>()] = &amp;initarray_generic.cache;<br>g_cpucache_up = PARTIAL;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cachep-&gt;array[<span class="hljs-built_in">smp_processor_id</span>()] = <span class="hljs-built_in">kmalloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> arraycache_init),GFP_KERNEL);<br>&#125;<br><span class="hljs-built_in">BUG_ON</span>(!<span class="hljs-built_in">ac_data</span>(cachep));<br><span class="hljs-built_in">ac_data</span>(cachep)-&gt;avail = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">ac_data</span>(cachep)-&gt;limit = BOOT_CPUCACHE_ENTRIES;<br><span class="hljs-built_in">ac_data</span>(cachep)-&gt;batchcount = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">ac_data</span>(cachep)-&gt;touched = <span class="hljs-number">0</span>;<br>cachep-&gt;batchcount = <span class="hljs-number">1</span>;<br>cachep-&gt;limit = BOOT_CPUCACHE_ENTRIES;<br>cachep-&gt;free_limit = (<span class="hljs-number">1</span>+<span class="hljs-built_in">num_online_cpus</span>())*cachep-&gt;batchcount<br>+ cachep-&gt;num;<br>&#125; <br><br>cachep-&gt;lists.next_reap = jiffies + REAPTIMEOUT_LIST3 +<br>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)cachep)%REAPTIMEOUT_LIST3;<br><br><span class="hljs-comment">/* Need the semaphore to access the chain. */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 将新分配的高速缓存描述符挂接到cache_chain中</span><br><span class="hljs-comment">     */</span><br><span class="hljs-built_in">down</span>(&amp;cache_chain_sem);<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> *p;<br><span class="hljs-type">mm_segment_t</span> old_fs;<br><br>old_fs = <span class="hljs-built_in">get_fs</span>();<br><span class="hljs-built_in">set_fs</span>(KERNEL_DS);<br><span class="hljs-built_in">list_for_each</span>(p, &amp;cache_chain) &#123;<br><span class="hljs-type">kmem_cache_t</span> *pc = <span class="hljs-built_in">list_entry</span>(p, <span class="hljs-type">kmem_cache_t</span>, next);<br><span class="hljs-type">char</span> tmp;<br><span class="hljs-comment">/* This happens when the module gets unloaded and doesn&#x27;t</span><br><span class="hljs-comment">   destroy its slab cache and noone else reuses the vmalloc</span><br><span class="hljs-comment">   area of the module. Print a warning. */</span><br><span class="hljs-keyword">if</span> (__get_user(tmp,pc-&gt;name)) &#123; <br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;SLAB: cache with size %d has lost its name\n&quot;</span>, <br>pc-&gt;objsize); <br><span class="hljs-keyword">continue</span>; <br>&#125; <br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(pc-&gt;name,name)) &#123; <br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;kmem_cache_create: duplicate cache %s\n&quot;</span>,name); <br><span class="hljs-built_in">up</span>(&amp;cache_chain_sem); <br><span class="hljs-built_in">unlock_cpu_hotplug</span>();<br><span class="hljs-built_in">BUG</span>(); <br>&#125;<br>&#125;<br><span class="hljs-built_in">set_fs</span>(old_fs);<br>&#125;<br><br><span class="hljs-comment">/* cache setup completed, link it into the list */</span><br><span class="hljs-built_in">list_add</span>(&amp;cachep-&gt;next, &amp;cache_chain);<br><span class="hljs-built_in">up</span>(&amp;cache_chain_sem);<br><span class="hljs-built_in">unlock_cpu_hotplug</span>();<br>opps:<br><span class="hljs-keyword">if</span> (!cachep &amp;&amp; (flags &amp; SLAB_PANIC))<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;kmem_cache_create(): failed to create slab `%s&#x27;\n&quot;</span>,<br>name);<br><span class="hljs-keyword">return</span> cachep;<br>&#125;<br></code></pre></td></tr></table></figure>根据参数确定处理新高速缓存的最佳方法，然后从普通高速缓存cache_cache中分配一个新的高速缓存描述符。然后入链到cache_chain。</p><p>撤销高速缓存： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 撤销一个高速缓存并将它从cache_chain链表上删除</span><br><span class="hljs-comment"> * 主要用于模块中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kmem_cache_destroy</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> * cachep)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-keyword">if</span> (!cachep || <span class="hljs-built_in">in_interrupt</span>())<br><span class="hljs-built_in">BUG</span>();<br><br><span class="hljs-comment">/* Don&#x27;t let CPUs to come and go */</span><br><span class="hljs-built_in">lock_cpu_hotplug</span>();<br><br><span class="hljs-comment">/* Find the cache in the chain of caches. */</span><br><span class="hljs-built_in">down</span>(&amp;cache_chain_sem);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * the chain is never empty, cache_cache is never destroyed</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">list_del</span>(&amp;cachep-&gt;next);<br><span class="hljs-built_in">up</span>(&amp;cache_chain_sem);<br><br><span class="hljs-keyword">if</span> (__cache_shrink(cachep)) &#123;<br><span class="hljs-built_in">slab_error</span>(cachep, <span class="hljs-string">&quot;Can&#x27;t free all objects&quot;</span>);<br><span class="hljs-built_in">down</span>(&amp;cache_chain_sem);<br><span class="hljs-built_in">list_add</span>(&amp;cachep-&gt;next,&amp;cache_chain);<br><span class="hljs-built_in">up</span>(&amp;cache_chain_sem);<br><span class="hljs-built_in">unlock_cpu_hotplug</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(cachep-&gt;flags &amp; SLAB_DESTROY_BY_RCU))<br><span class="hljs-built_in">synchronize_kernel</span>();<br><br><span class="hljs-comment">/* no cpu_online check required here since we clear the percpu</span><br><span class="hljs-comment"> * array on cpu offline and set this to NULL.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NR_CPUS; i++)<br><span class="hljs-built_in">kfree</span>(cachep-&gt;array[i]);<br><br><span class="hljs-comment">/* NUMA: free the list3 structures */</span><br><span class="hljs-built_in">kfree</span>(cachep-&gt;lists.shared);<br>cachep-&gt;lists.shared = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">kmem_cache_free</span>(&amp;cache_cache, cachep);<br><br><span class="hljs-built_in">unlock_cpu_hotplug</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>撤销kmem_cache时，要确保先撤销掉其上所有的slab。<code>__cache_shrink()</code>负责这一工作，实际上就是反复的<code>slab_destroy()</code>:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __cache_shrink(<span class="hljs-type">kmem_cache_t</span> *cachep)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span> *slabp;<br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-built_in">drain_cpu_caches</span>(cachep);<br><br><span class="hljs-built_in">check_irq_on</span>();<br><span class="hljs-built_in">spin_lock_irq</span>(&amp;cachep-&gt;spinlock);<br><br><span class="hljs-keyword">for</span>(;;) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> *p;<br><br>p = cachep-&gt;lists.slabs_free.prev;<br><span class="hljs-keyword">if</span> (p == &amp;cachep-&gt;lists.slabs_free)<br><span class="hljs-keyword">break</span>;<br><br>slabp = <span class="hljs-built_in">list_entry</span>(cachep-&gt;lists.slabs_free.prev, <span class="hljs-keyword">struct</span> slab, list);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br><span class="hljs-keyword">if</span> (slabp-&gt;inuse)<br><span class="hljs-built_in">BUG</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">list_del</span>(&amp;slabp-&gt;list);<br><br>cachep-&gt;lists.free_objects -= cachep-&gt;num;<br><span class="hljs-built_in">spin_unlock_irq</span>(&amp;cachep-&gt;spinlock);<br><span class="hljs-built_in">slab_destroy</span>(cachep, slabp);<br><span class="hljs-built_in">spin_lock_irq</span>(&amp;cachep-&gt;spinlock);<br>&#125;<br>ret = !<span class="hljs-built_in">list_empty</span>(&amp;cachep-&gt;lists.slabs_full) ||<br>!<span class="hljs-built_in">list_empty</span>(&amp;cachep-&gt;lists.slabs_partial);<br><span class="hljs-built_in">spin_unlock_irq</span>(&amp;cachep-&gt;spinlock);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="slab分配器与zoned-page-frame分配器的接口">slab分配器与zoned pageframe分配器的接口</h2><p>slab分配器创建新slab时，它依赖zoned pageframe分配器以获得一组空闲连续页框。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * slab分配器调用此接口从页框分配器中获得一组连续的空闲页框。</span><br><span class="hljs-comment"> * cachep-需要额外页框的高速缓存的高速缓存描述符。请求页框的个数由cachep-&gt;gfporder中的order决定。</span><br><span class="hljs-comment"> * flags-说明如何请求页框。这组标志与存放在高速缓存描述符的gfpflags字段中专用高速缓存分配标志相结合。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">kmem_getpages</span><span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> nodeid)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page;<br><span class="hljs-type">void</span> *addr;<br><span class="hljs-type">int</span> i;<br><br>flags |= cachep-&gt;gfpflags;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(nodeid == <span class="hljs-number">-1</span>)) &#123;<br>page = <span class="hljs-built_in">alloc_pages</span>(flags, cachep-&gt;gfporder);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>page = <span class="hljs-built_in">alloc_pages_node</span>(nodeid, flags, cachep-&gt;gfporder);<br>&#125;<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>addr = <span class="hljs-built_in">page_address</span>(page);<br><br>i = (<span class="hljs-number">1</span> &lt;&lt; cachep-&gt;gfporder);<br><span class="hljs-keyword">if</span> (cachep-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)<br><span class="hljs-built_in">atomic_add</span>(i, &amp;slab_reclaim_pages);<br><span class="hljs-built_in">add_page_state</span>(nr_slab, i);<br><span class="hljs-keyword">while</span> (i--) &#123;<br><span class="hljs-built_in">SetPageSlab</span>(page);<br>page++;<br>&#125;<br><span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure>熟悉的<code>alloc_pages_node</code>，再看释放操作： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放分配给slab的页框。</span><br><span class="hljs-comment"> * addr-从该地址开始释放页框。</span><br><span class="hljs-comment"> * cachep-slab是由cachep标识的高速缓存中的slab.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">kmem_freepages</span><span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">void</span> *addr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> i = (<span class="hljs-number">1</span>&lt;&lt;cachep-&gt;gfporder);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page = <span class="hljs-built_in">virt_to_page</span>(addr);<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_freed = i;<br><br><span class="hljs-keyword">while</span> (i--) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">TestClearPageSlab</span>(page))<br><span class="hljs-built_in">BUG</span>();<br>page++;<br>&#125;<br><span class="hljs-built_in">sub_page_state</span>(nr_slab, nr_freed);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果当前进程正在执行回存回收。就适当增加reclaimed_slab字段。</span><br><span class="hljs-comment"> * 于是刚被释放的页就能通过回收算法被记录下来。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (current-&gt;reclaim_state)<br>current-&gt;reclaim_state-&gt;reclaimed_slab += nr_freed;<br><span class="hljs-built_in">free_pages</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)addr, cachep-&gt;gfporder);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果SLAB_RECLAIM_ACCOUNT被置位，slab_reclaim_pages则被适当的减少。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (cachep-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT) <br><span class="hljs-built_in">atomic_sub</span>(<span class="hljs-number">1</span>&lt;&lt;cachep-&gt;gfporder, &amp;slab_reclaim_pages);<br>&#125;<br></code></pre></td></tr></table></figure>依然是熟悉的<code>free_pages</code>。</p><h2 id="slab分配与释放">slab分配与释放</h2><h3 id="分配">分配</h3><p>kmem_cache一开始没有任何slab，三条链都是空的。只有当收到分配新对象的请求或者当前不包含任何空闲对象时才会分配slab。</p><p>slab分配器通过<code>cache_grow()</code>给kmem_cache分配新的slab：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 给高速缓存分配一个新的slab。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">cache_grow</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> * cachep, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> nodeid)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span>*slabp;<br><span class="hljs-type">void</span>*objp;<br><span class="hljs-type">size_t</span> offset;<br><span class="hljs-type">int</span> local_flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ctor_flags;<br><br><span class="hljs-comment">/* Be lazy and only check for valid flags here,</span><br><span class="hljs-comment">  * keeping it out of the critical path in kmem_cache_alloc().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (flags &amp; ~(SLAB_DMA|SLAB_LEVEL_MASK|SLAB_NO_GROW))<br><span class="hljs-built_in">BUG</span>();<br><span class="hljs-keyword">if</span> (flags &amp; SLAB_NO_GROW)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>ctor_flags = SLAB_CTOR_CONSTRUCTOR;<br>local_flags = (flags &amp; SLAB_LEVEL_MASK);<br><span class="hljs-keyword">if</span> (!(local_flags &amp; __GFP_WAIT))<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Not allowed to sleep.  Need to tell a constructor about</span><br><span class="hljs-comment"> * this - it might need to know...</span><br><span class="hljs-comment"> */</span><br>ctor_flags |= SLAB_CTOR_ATOMIC;<br><br><span class="hljs-comment">/* About to mess with non-constant members - lock. */</span><br><span class="hljs-built_in">check_irq_off</span>();<br><span class="hljs-built_in">spin_lock</span>(&amp;cachep-&gt;spinlock);<br><br><span class="hljs-comment">/* Get colour for the slab, and cal the next value. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 更新高速缓存描述符的当前颜色值。并根据当前颜色值计算数据区的偏移。</span><br><span class="hljs-comment"> * 这样可以平等的在slab间分布颜色值。</span><br><span class="hljs-comment"> * offset就是 aln * col,  colour_off字段记录的aln，colour_next记录的col</span><br><span class="hljs-comment"> */</span><br>offset = cachep-&gt;colour_next;<br>cachep-&gt;colour_next++;<br><span class="hljs-keyword">if</span> (cachep-&gt;colour_next &gt;= cachep-&gt;colour)<br>cachep-&gt;colour_next = <span class="hljs-number">0</span>;<br>offset *= cachep-&gt;colour_off;<br><br><span class="hljs-built_in">spin_unlock</span>(&amp;cachep-&gt;spinlock);<br><br><span class="hljs-keyword">if</span> (local_flags &amp; __GFP_WAIT)<br><span class="hljs-built_in">local_irq_enable</span>();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The test for missing atomic flag is performed here, rather than</span><br><span class="hljs-comment"> * the more obvious place, simply to reduce the critical path length</span><br><span class="hljs-comment"> * in kmem_cache_alloc(). If a caller is seriously mis-behaving they</span><br><span class="hljs-comment"> * will eventually be caught here (where it matters).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">kmem_flagcheck</span>(cachep, flags);<br><br><br><span class="hljs-comment">/* Get mem for the objs. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用kmem_getpages从分区页框分配器获得一组页框来存放一个单独的slab</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(objp = <span class="hljs-built_in">kmem_getpages</span>(cachep, flags, nodeid)))<br><span class="hljs-keyword">goto</span> failed;<br><br><span class="hljs-comment">/* Get slab management. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得一个新的slab描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(slabp = <span class="hljs-built_in">alloc_slabmgmt</span>(cachep, objp, offset, local_flags)))<br><span class="hljs-keyword">goto</span> opps1;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * set_slab_attr扫描分配给新slab的页框的所有页描述符</span><br><span class="hljs-comment"> * 并将高速缓存描述符和slab描述符的地址分别赋给页描述符中lru字段的next和prev字段</span><br><span class="hljs-comment"> * 这是不会出错的，因为只有当页框空闲时，伙伴系统的函数才会使用lru字段，而只要涉及伙伴系统，slab分配器函数处理的页框就不空闲。</span><br><span class="hljs-comment"> * 注意：这个字段因为也会被页框回收算法使用，所以包含了这些隐含的约定，总会让人困惑，也许会带来一些意外的后果。</span><br><span class="hljs-comment"> * 总之，从这里可以看出linux不好、甚至是坏的一面。除了linus，还有多少人能够改linux??</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">set_slab_attr</span>(cachep, slabp, objp);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cache_init_objs将构造方法（如果有）应用到新的slab包含的所有对象上。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">cache_init_objs</span>(cachep, slabp, ctor_flags);<br><br><span class="hljs-keyword">if</span> (local_flags &amp; __GFP_WAIT)<br><span class="hljs-built_in">local_irq_disable</span>();<br><span class="hljs-built_in">check_irq_off</span>();<br><span class="hljs-built_in">spin_lock</span>(&amp;cachep-&gt;spinlock);<br><br><span class="hljs-comment">/* Make slab active. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将新得到的slab描述符slabp添加到高速缓存描述符cachep的全空slab链表的末端。并更新空闲对象计数器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">list_add_tail</span>(&amp;slabp-&gt;list, &amp;(<span class="hljs-built_in">list3_data</span>(cachep)-&gt;slabs_free));<br><span class="hljs-built_in">STATS_INC_GROWN</span>(cachep);<br><span class="hljs-built_in">list3_data</span>(cachep)-&gt;free_objects += cachep-&gt;num;<br><span class="hljs-built_in">spin_unlock</span>(&amp;cachep-&gt;spinlock);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>opps1:<br><span class="hljs-built_in">kmem_freepages</span>(cachep, objp);<br>failed:<br><span class="hljs-keyword">if</span> (local_flags &amp; __GFP_WAIT)<br><span class="hljs-built_in">local_irq_disable</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>暂时不关心着色，显示通过<code>kmem_getpages</code>拿到一组页框。然后通过<code>alloc_slabmgmt</code>获得新的slab描述符：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得一个新的slab描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span>* <span class="hljs-built_in">alloc_slabmgmt</span> (<span class="hljs-type">kmem_cache_t</span> *cachep,<br><span class="hljs-type">void</span> *objp, <span class="hljs-type">int</span> colour_off, <span class="hljs-type">int</span> local_flags)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span> *slabp;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果CFLGS_OFF_SLAB标志被置位，那么样从高速缓存描述符的slabp_cache字段指向的普通高速缓存中分配这个新的描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">OFF_SLAB</span>(cachep)) &#123;<br><span class="hljs-comment">/* Slab management obj is off-slab. */</span><br>slabp = <span class="hljs-built_in">kmem_cache_alloc</span>(cachep-&gt;slabp_cache, local_flags);<br><span class="hljs-keyword">if</span> (!slabp)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 否则，从slab的第一个页框中分配这个slab描述符</span><br><span class="hljs-comment"> */</span><br>slabp = objp+colour_off;<br>colour_off += cachep-&gt;slab_size; <span class="hljs-comment">/*slab_size字段记录的就是dsize*/</span><br>&#125;<br>slabp-&gt;inuse = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/*将col*aln + dsize存放到colouroff中，aln就是高速缓存描述符的colour_off字段*/</span><br>slabp-&gt;colouroff = colour_off;<br>slabp-&gt;s_mem = objp+colour_off;<br><br><span class="hljs-keyword">return</span> slabp;<br>&#125;<br></code></pre></td></tr></table></figure>CFLGS_OFF_SLAB表示从内部还是外部存放slab描述符。内部对应else分支，在第一个页框中分配slab描述符，外部则对应if分支，在cachep-&gt;slabp_cache指向的普通高速缓存中分配slab描述符。</p><p>分配新slab描述符后，扫描分配给新slab的页框的所有页描述符，将kmem_cache和slab描述符的地址赋给页描述符的lru字段的next和prev。lru在buddysystem和slab系统中都有用到，实际上这种设计虽然省了空间，但却称为逻辑的困扰项。</p><p>此后的<code>cache_init_objs</code>对新slab的所有对象应用构造方法，然后把新的slab描述符链到free链的尾端，更新对应的字段。</p><h3 id="释放">释放</h3><p>当slab高速缓存中空闲对象太多或周期性调用的定时器函数确定有可以被释放的slab时，才会进行slab的撤销：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当以下两个条件满足时:</span><br><span class="hljs-comment"> *     Slab高速缓存中有太多的空闲对象。</span><br><span class="hljs-comment"> *     被定时器周期性的检测到，有完全未使用的slab能够被释放。</span><br><span class="hljs-comment"> * 撤销一个slab。并释放相应的页框到分区页框分配器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">slab_destroy</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-keyword">struct</span> slab *slabp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">void</span> *addr = slabp-&gt;s_mem - slabp-&gt;colouroff;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cachep-&gt;num; i++) &#123;<br><span class="hljs-type">void</span> *objp = slabp-&gt;s_mem + cachep-&gt;objsize * i;<br><br><span class="hljs-keyword">if</span> (cachep-&gt;flags &amp; SLAB_POISON) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_PAGEALLOC</span><br><span class="hljs-keyword">if</span> ((cachep-&gt;objsize%PAGE_SIZE)==<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">OFF_SLAB</span>(cachep))<br><span class="hljs-built_in">kernel_map_pages</span>(<span class="hljs-built_in">virt_to_page</span>(objp), cachep-&gt;objsize/PAGE_SIZE,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">check_poison_obj</span>(cachep, objp);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-built_in">check_poison_obj</span>(cachep, objp);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><span class="hljs-keyword">if</span> (cachep-&gt;flags &amp; SLAB_RED_ZONE) &#123;<br><span class="hljs-keyword">if</span> (*<span class="hljs-built_in">dbg_redzone1</span>(cachep, objp) != RED_INACTIVE)<br><span class="hljs-built_in">slab_error</span>(cachep, <span class="hljs-string">&quot;start of a freed object &quot;</span><br><span class="hljs-string">&quot;was overwritten&quot;</span>);<br><span class="hljs-keyword">if</span> (*<span class="hljs-built_in">dbg_redzone2</span>(cachep, objp) != RED_INACTIVE)<br><span class="hljs-built_in">slab_error</span>(cachep, <span class="hljs-string">&quot;end of a freed object &quot;</span><br><span class="hljs-string">&quot;was overwritten&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (cachep-&gt;dtor &amp;&amp; !(cachep-&gt;flags &amp; SLAB_POISON))<br>(cachep-&gt;dtor)(objp+<span class="hljs-built_in">obj_dbghead</span>(cachep), cachep, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果高速缓存为它的对象定义了析构方法，就遍历slab中的所有对象。</span><br><span class="hljs-comment"> * 使用析构函数释放slab中的所有对象。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (cachep-&gt;dtor) &#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cachep-&gt;num; i++) &#123;<br><span class="hljs-type">void</span>* objp = slabp-&gt;s_mem+cachep-&gt;objsize*i;<br>(cachep-&gt;dtor)(objp, cachep, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果使用了SLAB_DESTROY_BY_RCU标志来创建slab高速缓存，就应该使用call_rcu</span><br><span class="hljs-comment"> * 来注册一个回调，以延期释放slab。回调函数会调用kmem_freepages和kmem_cache_free</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(cachep-&gt;flags &amp; SLAB_DESTROY_BY_RCU)) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab_rcu</span> *slab_rcu;<br><br>slab_rcu = (<span class="hljs-keyword">struct</span> slab_rcu *) slabp;<br>slab_rcu-&gt;cachep = cachep;<br>slab_rcu-&gt;addr = addr;<br><span class="hljs-built_in">call_rcu</span>(&amp;slab_rcu-&gt;head, kmem_rcu_free);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用kmem_freepages，将slab使用的所有连续页框返回给伙伴系统。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">kmem_freepages</span>(cachep, addr);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果slab描述符存放在slab的外面，那么就从slab描述符的高速缓存释放slab描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">OFF_SLAB</span>(cachep))<br><span class="hljs-built_in">kmem_cache_free</span>(cachep-&gt;slabp_cache, slabp);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> 先进行析构dtor，然后释放slab给buddy system。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放分配给slab的页框。</span><br><span class="hljs-comment"> * addr-从该地址开始释放页框。</span><br><span class="hljs-comment"> * cachep-slab是由cachep标识的高速缓存中的slab.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">kmem_freepages</span><span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">void</span> *addr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> i = (<span class="hljs-number">1</span>&lt;&lt;cachep-&gt;gfporder);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page = <span class="hljs-built_in">virt_to_page</span>(addr);<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_freed = i;<br><br><span class="hljs-keyword">while</span> (i--) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">TestClearPageSlab</span>(page))<br><span class="hljs-built_in">BUG</span>();<br>page++;<br>&#125;<br><span class="hljs-built_in">sub_page_state</span>(nr_slab, nr_freed);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果当前进程正在执行回存回收。就适当增加reclaimed_slab字段。</span><br><span class="hljs-comment"> * 于是刚被释放的页就能通过回收算法被记录下来。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (current-&gt;reclaim_state)<br>current-&gt;reclaim_state-&gt;reclaimed_slab += nr_freed;<br><span class="hljs-built_in">free_pages</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)addr, cachep-&gt;gfporder);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果SLAB_RECLAIM_ACCOUNT被置位，slab_reclaim_pages则被适当的减少。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (cachep-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT) <br><span class="hljs-built_in">atomic_sub</span>(<span class="hljs-number">1</span>&lt;&lt;cachep-&gt;gfporder, &amp;slab_reclaim_pages);<br>&#125;<br></code></pre></td></tr></table></figure> 最终通过<code>free_pages()</code>释放。</p><p>且另一方面，如果slab描述符存放在slab外部，也需要从专门放slab描述符的高速缓存中释放该slab描述符：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放一个曾经由slab分配器分配给某个内核函数的对象</span><br><span class="hljs-comment"> * cachep-高速缓存描述符的地址。</span><br><span class="hljs-comment"> * objp-要释放的对象的地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmem_cache_free</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">void</span> *objp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br><span class="hljs-built_in">local_irq_save</span>(flags);<br>__cache_free(cachep, objp);<br><span class="hljs-built_in">local_irq_restore</span>(flags);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __cache_free (<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">void</span>* objp)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *ac = <span class="hljs-built_in">ac_data</span>(cachep);<br><br><span class="hljs-built_in">check_irq_off</span>();<br>objp = <span class="hljs-built_in">cache_free_debugcheck</span>(cachep, objp, __builtin_return_address(<span class="hljs-number">0</span>));<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先检查本地高速缓存是否有空间给指向一个空闲对象的额外指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(ac-&gt;avail &lt; ac-&gt;limit)) &#123;<br><span class="hljs-built_in">STATS_INC_FREEHIT</span>(cachep);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 本地高速缓存有空闲指针，则该指针被加到本地高速缓存后返回。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">ac_entry</span>(ac)[ac-&gt;avail++] = objp;<br><span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">STATS_INC_FREEMISS</span>(cachep);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用cache_flusharray，清空本地高速缓存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">cache_flusharray</span>(cachep, ac);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 然后将指针加到本地高速缓存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">ac_entry</span>(ac)[ac-&gt;avail++] = objp;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清空本地高速缓存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">cache_flusharray</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span>* cachep, <span class="hljs-keyword">struct</span> array_cache *ac)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> batchcount;<br><br>batchcount = ac-&gt;batchcount;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br><span class="hljs-built_in">BUG_ON</span>(!batchcount || batchcount &gt; ac-&gt;avail);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">check_irq_off</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得自旋锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_lock</span>(&amp;cachep-&gt;spinlock);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果包含一个共享本地高速缓存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (cachep-&gt;lists.shared) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *shared_array = cachep-&gt;lists.shared;<br><span class="hljs-type">int</span> max = shared_array-&gt;limit-shared_array-&gt;avail;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该共享缓存还没有满</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (max) &#123;<br><span class="hljs-keyword">if</span> (batchcount &gt; max)<br>batchcount = max;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将batchcount个指针放到共享高速缓存中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">memcpy</span>(&amp;<span class="hljs-built_in">ac_entry</span>(shared_array)[shared_array-&gt;avail],<br>&amp;<span class="hljs-built_in">ac_entry</span>(ac)[<span class="hljs-number">0</span>],<br><span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*)*batchcount);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 上移batchcount个指针来重新填充共享本地高速缓存</span><br><span class="hljs-comment"> */</span><br>shared_array-&gt;avail += batchcount;<br><span class="hljs-keyword">goto</span> free_done;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将当前包含在本地高速缓存中的ac-&gt;batchcount个对象归还给slab分配器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">free_block</span>(cachep, &amp;<span class="hljs-built_in">ac_entry</span>(ac)[<span class="hljs-number">0</span>], batchcount);<br>free_done:<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> STATS</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> *p;<br><br>p = <span class="hljs-built_in">list3_data</span>(cachep)-&gt;slabs_free.next;<br><span class="hljs-keyword">while</span> (p != &amp;(<span class="hljs-built_in">list3_data</span>(cachep)-&gt;slabs_free)) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span> *slabp;<br><br>slabp = <span class="hljs-built_in">list_entry</span>(p, <span class="hljs-keyword">struct</span> slab, list);<br><span class="hljs-built_in">BUG_ON</span>(slabp-&gt;inuse);<br><br>i++;<br>p = p-&gt;next;<br>&#125;<br><span class="hljs-built_in">STATS_SET_FREEABLE</span>(cachep, i);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_unlock</span>(&amp;cachep-&gt;spinlock);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过减去被移到共享本地高速缓存或被释放到slab分配器的对象的个数来更新本地高速缓存描述的avail字段</span><br><span class="hljs-comment"> */</span><br>ac-&gt;avail -= batchcount;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 移动本地高速缓存数组起始处的那个本地高速缓存中的所有指针。</span><br><span class="hljs-comment"> * 因为已经把第一个对象指针从本地高速缓存上删除，因此剩余的指针必须上移。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">memmove</span>(&amp;<span class="hljs-built_in">ac_entry</span>(ac)[<span class="hljs-number">0</span>], &amp;<span class="hljs-built_in">ac_entry</span>(ac)[batchcount],<br><span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*)*ac-&gt;avail);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>如果cachep-&gt;flags中指定了<code>SLAB_DESTROY_BY_RCU</code>，就注册<code>kmem_rcu_free</code>回调，延期释放slab<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * rcu原语中，写者调用call_rcu来释放数据结构的旧副本。</span><br><span class="hljs-comment"> * 当所有CPU都经过静止状态(quiescent state)后，</span><br><span class="hljs-comment"> * call_rcu接受rcu_head描述符（通常嵌在要释放在数据结构中）和将要调用的回调函数的地址作为参数。</span><br><span class="hljs-comment"> * 一旦回调函数被执行，它通常释放数据结构的旧副本。</span><br><span class="hljs-comment"> * call_rcu把回调函数和其参数的地址存放在rcu_head，然后把描述符插入到回调函数的每CPU链表中。</span><br><span class="hljs-comment"> * 内核每经过一个时钟滴答，就周期性的检查本地CPU是否经过了一个静止状态。</span><br><span class="hljs-comment"> * 如果经过了，本地tasklet(rcu_tasklet)就执行链表中的回调函数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> fastcall <span class="hljs-title">call_rcu</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rcu_head *head,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span> (*func)(<span class="hljs-keyword">struct</span> rcu_head *rcu))</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rcu_data</span> *rdp;<br><br>head-&gt;func = func;<br>head-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">local_irq_save</span>(flags);<br>rdp = &amp;__get_cpu_var(rcu_data);<br>*rdp-&gt;nxttail = head;<br>rdp-&gt;nxttail = &amp;head-&gt;next;<br><span class="hljs-built_in">local_irq_restore</span>(flags);<br>&#125;<br><br><span class="hljs-comment">//注册的回调函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">kmem_rcu_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rcu_head *head)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab_rcu</span> *slab_rcu = (<span class="hljs-keyword">struct</span> slab_rcu *) head;<br><span class="hljs-type">kmem_cache_t</span> *cachep = slab_rcu-&gt;cachep;<br><br><span class="hljs-built_in">kmem_freepages</span>(cachep, slab_rcu-&gt;addr);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">OFF_SLAB</span>(cachep))<br><span class="hljs-built_in">kmem_cache_free</span>(cachep-&gt;slabp_cache, slab_rcu);<br>&#125;<br></code></pre></td></tr></table></figure>rcu的机制暂时不关心，但延迟的<code>kmem_rcu_free</code>函数依然调用的是<code>kmem_freepages</code>挂<code>kmem_cache_free</code>。一样的套路。</p><h2 id="object">Object</h2><h3 id="对象描述符">对象描述符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 高速缓存对象描述符。将slab中的空闲对象链接起来。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">kmem_bufctl_t</span>;<br></code></pre></td></tr></table></figure><p>kmem_bufctl_t实际上就是个uint16，只有当object空闲时才有意义，表示下一个空闲对象在slab中的下标。通过这一描述符形成了隐式链表，最后一个空闲对象用BUFCTL_END(0xffff)标记<code>#define BUFCTL_END   (((kmem_bufctl_t)(~0U))-0)</code>。</p><p>因为slab描述符有内部或外部之分，而object描述符跟着slab描述符走（注意这里说的是描述符，而不是object或是slab，object始终在slab内），所以object描述符也有内外之分。-外部的object描述符由外部的slab描述符所在的普通高速缓存中的slabp_cache字段指向，它是一个数组。- 内部的object描述符就位于所有对象之前。</p><p><img src="20171024_6.jpg" /></p><h3 id="对象对齐">对象对齐</h3><p>object在内存中是对齐的，起始物理地址是一个给定常量的倍数，通常是2的倍数。该常量称为对齐因子。</p><p>slab分配器允许的最大对齐因子为4096，即页框大小。</p><p>80x86指定32位大小来对齐对象，因为当内存单元的物理地址对齐尺寸和内存总线宽度一致时，内存的读写会非常快。slab分配器为了对齐，难免会产生额外的内存碎片，但瑕不掩瑜，这代价是值得的。</p><h3 id="slab着色">slab着色</h3><p>回看这张图： <img src="20171024_5.jpg" /></p><p>每个slab的首部都有一个着色区，不为对象使用。着色区的大小使slab中每个对象的起始地址都按高速缓存中缓存行(cacheline)大小进行对齐。slab是一组页框，因此slab肯定是按高速缓存行对齐的，但是slab的object大小是不确定的，设置着色区的目的就是将lab中第一个对象的起始地址往后推到与缓冲行对齐的位置。因为一个缓冲区中有多个slab，因此应该把每个缓冲区中的各个slab着色区的大小尽量安排成不同的大小，这就可以使得在不同slab中，出于同一相对位置的对象，让它们在高速缓存中的起始地址相互错开，以改善高速缓存的存取效率（如果不错开，可能同缓存区的两个slab上，同相对位置的两个对象会来来回回在高速缓存行与RAM之间传送，高速缓存行无法发挥效率）。</p><p>每个slab上最后也有一片废料区，是对着色区大小的补偿，大小取决于着色区的大小，以及slab与其每个对象的相对大小。该区域和着色区的综合对于同一个对象的各个slab来说是个constant。</p><p>每个对象的大小基本上是所需数据结构的大小，只有当数据结构大小不与高速缓存中的缓冲行对齐时，才增加若干字节使其对齐。所以，一个slab上的所有对象的起始地址都必然是按高速缓冲中的缓冲行对齐的。</p><p>也就是说，着色区保证了第一个对象的对齐，而对象大小的对齐保证了后续所有对象的对齐。</p><h3 id="空闲slab对象的本地缓存">空闲slab对象的本地缓存</h3><p>多处理的slab分配器实现不同于原始的Solaris2.4。为了减少处理器之间对自旋锁的竞争并更好的利用硬件缓存，slab分配器的每个高速缓存都包含一个每CPU数据结构。该结构由一个指向被释放对象的小指针数组组成。slab对象的大多数分配和释放只影响本地数组，只有在本地数组下溢或上溢时才涉及slab数据结构。</p><p>这就是kmem_cache的array_cache，前面已经展开看到过。这一设计非常类似“每CPU页框高速缓存”。</p><h3 id="分配slab对象">分配slab对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得新的slab对象</span><br><span class="hljs-comment"> * cachep-指向高速缓存描述符。新空闲对象必须从该高速缓存描述符获得。</span><br><span class="hljs-comment"> * flag-表示传递给分区页框分配器函数的标志。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">kmem_cache_alloc</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> __cache_alloc(cachep, flags);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> * __cache_alloc (<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">int</span> flags)<br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> save_flags;<br><span class="hljs-type">void</span>* objp;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *ac;<br><br><span class="hljs-built_in">cache_alloc_debugcheck_before</span>(cachep, flags);<br><br><span class="hljs-built_in">local_irq_save</span>(save_flags);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先试图从本地高速缓存获得一个空闲对象。</span><br><span class="hljs-comment"> */</span><br>ac = <span class="hljs-built_in">ac_data</span>(cachep);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果本地高速缓存有空闲对象，那么avail字段就包含最后被释放的对象的项在本地高速缓存中的下标。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(ac-&gt;avail)) &#123;<br><span class="hljs-built_in">STATS_INC_ALLOCHIT</span>(cachep);<br>ac-&gt;touched = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 因为本地高速缓存数组正好存放在ac描述符的后面。</span><br><span class="hljs-comment"> * 所以(void**)(ac+1)[--ac-&gt;avail]获得空闲对象的地址，并递减ac-&gt;avail的值。</span><br><span class="hljs-comment"> */</span><br>objp = <span class="hljs-built_in">ac_entry</span>(ac)[--ac-&gt;avail];<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* 本地高速缓存中没有空闲对象。 */</span>  <span class="hljs-comment">/*ac-&gt;avail == 0*/</span><br><span class="hljs-built_in">STATS_INC_ALLOCMISS</span>(cachep);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cache_alloc_refill重新填充本地高速缓存并获得一个空闲对象。</span><br><span class="hljs-comment"> */</span><br>objp = <span class="hljs-built_in">cache_alloc_refill</span>(cachep, flags);<br>&#125;<br><span class="hljs-built_in">local_irq_restore</span>(save_flags);<br>objp = <span class="hljs-built_in">cache_alloc_debugcheck_after</span>(cachep, flags, objp, __builtin_return_address(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">return</span> objp;<br>&#125;<br><br><span class="hljs-comment">//本地高速缓存派上了用场</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *<span class="hljs-built_in">ac_data</span>(<span class="hljs-type">kmem_cache_t</span> *cachep)<br>&#123;<br><span class="hljs-keyword">return</span> cachep-&gt;array[<span class="hljs-built_in">smp_processor_id</span>()];<br>&#125;<br></code></pre></td></tr></table></figure><p>如果本地高速缓存有空闲对象，则递减ac-&gt;avail值即可，avail包含指向最后被释放的对象的项在本地高速缓存中的下标。if分支的逻辑很简单。</p><p>如果没有的话，进入else，就需要通过cache_alloc_refill：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重新填充本地高速缓存并获得一个空闲对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">cache_alloc_refill</span><span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span>* cachep, <span class="hljs-type">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> batchcount;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">kmem_list3</span> *l3;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *ac;<br><br><span class="hljs-built_in">check_irq_off</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ac = cachep-&gt;array[smp_processor_id()];</span><br><span class="hljs-comment"> * 将本地高速缓存描述符的地址存放在ac局部变量中。</span><br><span class="hljs-comment"> */</span><br>ac = <span class="hljs-built_in">ac_data</span>(cachep);<br>retry:<br>batchcount = ac-&gt;batchcount;<br><span class="hljs-keyword">if</span> (!ac-&gt;touched &amp;&amp; batchcount &gt; BATCHREFILL_LIMIT) &#123;<br><span class="hljs-comment">/* if there was little recent activity on this</span><br><span class="hljs-comment"> * cache, then perform only a partial refill.</span><br><span class="hljs-comment"> * Otherwise we could generate refill bouncing.</span><br><span class="hljs-comment"> */</span><br>batchcount = BATCHREFILL_LIMIT;<br>&#125;<br>l3 = <span class="hljs-built_in">list3_data</span>(cachep);<br><br><span class="hljs-built_in">BUG_ON</span>(ac-&gt;avail &gt; <span class="hljs-number">0</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取spinlock</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_lock</span>(&amp;cachep-&gt;spinlock);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果slab高速缓存包含共享本地高速缓存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (l3-&gt;shared) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *shared_array = l3-&gt;shared;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 并且该共享本地高速缓存包含一些空闲对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (shared_array-&gt;avail) &#123;<br><span class="hljs-keyword">if</span> (batchcount &gt; shared_array-&gt;avail)<br>batchcount = shared_array-&gt;avail;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从共享本地高速缓存中上移batchcount个指针来重新填充CPU的本地高速缓存</span><br><span class="hljs-comment"> */</span><br>shared_array-&gt;avail -= batchcount;<br>ac-&gt;avail = batchcount;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 共享本地高速缓存，从后向前使用，avail指向最后面</span><br><span class="hljs-comment">             * 这里shared_array-&gt;avail在前面经过&quot;shared_array-&gt;avail -= batchcount;&quot;的处理指向了前面，</span><br><span class="hljs-comment">             * 所以这里直接用memcpy进行从前向后的拷贝</span><br><span class="hljs-comment">             */</span><br><span class="hljs-built_in">memcpy</span>(<span class="hljs-built_in">ac_entry</span>(ac), &amp;<span class="hljs-built_in">ac_entry</span>(shared_array)[shared_array-&gt;avail],<br><span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*)*batchcount);<br>shared_array-&gt;touched = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">goto</span> alloc_done;<br>&#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 函数试图填充本地高速缓存，填充值为高速缓存的slab中包含的多达ac-&gt;batchcount个空闲对象的指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">while</span> (batchcount &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> *entry;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span> *slabp;<br><span class="hljs-comment">/* Get slab alloc is to come from. */</span><br>entry = l3-&gt;slabs_partial.next;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查看高速缓存描述符的slabs_partial和slabs_free链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (entry == &amp;l3-&gt;slabs_partial) &#123; <span class="hljs-comment">/*partial用完了*/</span><br>l3-&gt;free_touched = <span class="hljs-number">1</span>;<br>entry = l3-&gt;slabs_free.next;<br><span class="hljs-keyword">if</span> (entry == &amp;l3-&gt;slabs_free) <span class="hljs-comment">/*free用完了*/</span><br><span class="hljs-keyword">goto</span> must_grow;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得slab描述符的地址slabp，该slab描述符的相应slab或者部分被填充或者为空。</span><br><span class="hljs-comment"> */</span><br>slabp = <span class="hljs-built_in">list_entry</span>(entry, <span class="hljs-keyword">struct</span> slab, list);<br><span class="hljs-built_in">check_slabp</span>(cachep, slabp);<br><span class="hljs-built_in">check_spinlock_acquired</span>(cachep);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对于slab中的每个空闲对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">while</span> (slabp-&gt;inuse &lt; cachep-&gt;num &amp;&amp; batchcount--) &#123;<br><span class="hljs-type">kmem_bufctl_t</span> next;<br><span class="hljs-built_in">STATS_INC_ALLOCED</span>(cachep);<br><span class="hljs-built_in">STATS_INC_ACTIVE</span>(cachep);<br><span class="hljs-built_in">STATS_SET_HIGH</span>(cachep);<br><br><span class="hljs-comment">/* get obj pointer */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将对象地址插入本地高速缓存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">ac_entry</span>(ac)[ac-&gt;avail++] = slabp-&gt;s_mem + slabp-&gt;free*cachep-&gt;objsize;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 函数增加slab描述符的inuse字段</span><br><span class="hljs-comment"> */</span><br>slabp-&gt;inuse++;<br>next = <span class="hljs-built_in">slab_bufctl</span>(slabp)[slabp-&gt;free];<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br><span class="hljs-built_in">slab_bufctl</span>(slabp)[slabp-&gt;free] = BUFCTL_FREE;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 更新free字段，使得它指向slab中下一个空闲对象的下标。</span><br><span class="hljs-comment"> */</span><br>       slabp-&gt;free = next;<br>&#125;<br><span class="hljs-built_in">check_slabp</span>(cachep, slabp);<br><br><span class="hljs-comment">/* move slabp to correct slabp list: */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果有必要，将清空的slab插入到适当的链表上，可以是slabs_full链表，也可以是slabs_partial链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">list_del</span>(&amp;slabp-&gt;list);<br><span class="hljs-keyword">if</span> (slabp-&gt;free == BUFCTL_END)<br><span class="hljs-built_in">list_add</span>(&amp;slabp-&gt;list, &amp;l3-&gt;slabs_full);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">list_add</span>(&amp;slabp-&gt;list, &amp;l3-&gt;slabs_partial);<br>&#125;<br><br>must_grow:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 被加到本地高速缓存的指针个数被存放在ac-&gt;avail字段。</span><br><span class="hljs-comment"> * 函数递减同样数量的free_objects来说明这些对象不再空闲</span><br><span class="hljs-comment"> */</span><br>l3-&gt;free_objects -= ac-&gt;avail;<br>alloc_done:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放spinlock</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_unlock</span>(&amp;cachep-&gt;spinlock);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有发生任何高速缓存再填充的情况</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!ac-&gt;avail)) &#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用cache_grow获得一个新的slab，从而获得了新的空闲对象</span><br><span class="hljs-comment"> */</span><br>x = <span class="hljs-built_in">cache_grow</span>(cachep, flags, <span class="hljs-number">-1</span>);<br><br><span class="hljs-comment">// cache_grow can reenable interrupts, then ac could change.</span><br>ac = <span class="hljs-built_in">ac_data</span>(cachep);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cache_grow失败了，返回NULL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!x &amp;&amp; ac-&gt;avail == <span class="hljs-number">0</span>)<span class="hljs-comment">// no objects in sight? abort</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cache_grow成功了，返回再试。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!ac-&gt;avail)<span class="hljs-comment">// objects refilled by interrupt?</span><br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果ac-&gt;avail&gt;0(一些高速缓存再填充的情况发生了)</span><br><span class="hljs-comment"> */</span><br>ac-&gt;touched = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回最后插入到本地高速缓存的空闲对象指针</span><br><span class="hljs-comment"> * 本地高速缓存(非共享)，从后像前使用，avail指向最后面</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">ac_entry</span>(ac)[--ac-&gt;avail];<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="释放slab对象">释放slab对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放一个曾经由slab分配器分配给某个内核函数的对象</span><br><span class="hljs-comment"> * cachep-高速缓存描述符的地址。</span><br><span class="hljs-comment"> * objp-要释放的对象的地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmem_cache_free</span> <span class="hljs-params">(<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">void</span> *objp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br><span class="hljs-built_in">local_irq_save</span>(flags);<br>__cache_free(cachep, objp);<br><span class="hljs-built_in">local_irq_restore</span>(flags);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __cache_free (<span class="hljs-type">kmem_cache_t</span> *cachep, <span class="hljs-type">void</span>* objp)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">array_cache</span> *ac = <span class="hljs-built_in">ac_data</span>(cachep);<br><br><span class="hljs-built_in">check_irq_off</span>();<br>objp = <span class="hljs-built_in">cache_free_debugcheck</span>(cachep, objp, __builtin_return_address(<span class="hljs-number">0</span>));<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先检查本地高速缓存是否有空间给指向一个空闲对象的额外指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(ac-&gt;avail &lt; ac-&gt;limit)) &#123;<br><span class="hljs-built_in">STATS_INC_FREEHIT</span>(cachep);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 本地高速缓存有空闲指针，则该指针被加到本地高速缓存后返回。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">ac_entry</span>(ac)[ac-&gt;avail++] = objp;<br><span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">STATS_INC_FREEMISS</span>(cachep);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用cache_flusharray，清空本地高速缓存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">cache_flusharray</span>(cachep, ac);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 然后将指针加到本地高速缓存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">ac_entry</span>(ac)[ac-&gt;avail++] = objp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>较之alloc简单一些，同样的道理，alloc是多对一，而free是一对一。free时当发现本地高速缓存已满，就先清一波，再将本次的对象放进去。</p><h3 id="通用对象">通用对象</h3><p>如果对存储区的请求不频繁，就可以用一组普通高速缓存来处理，普通高速缓存中的对象具有几何分布的大小，范围是32-131072字节。</p><p><code>kmalloc</code>用于获取这种对象： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得普通高速缓存中的对象。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title">kmalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (__builtin_constant_p(size)) &#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 找size对应的几何分布大小值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CACHE(x) \</span><br><span class="hljs-meta"><span class="hljs-keyword">if</span> (size &lt;= x) \</span><br><span class="hljs-meta">goto found; \</span><br><span class="hljs-meta"><span class="hljs-keyword">else</span> \</span><br><span class="hljs-meta">i++;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kmalloc_sizes.h&quot;</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 运行到此，说明要分配的对象太大，不能分配这么大的对象。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> CACHE</span><br>&#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> __you_cannot_kmalloc_that_much(<span class="hljs-type">void</span>);<br>__you_cannot_kmalloc_that_much();<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 请求分配的size对应的高速缓存描述符索引号为i</span><br><span class="hljs-comment"> * 根据GFP_DMA，在不同的高速缓存描述符中分配对象。</span><br><span class="hljs-comment"> */</span><br>found:<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">kmem_cache_alloc</span>((flags &amp; GFP_DMA) ?<br>malloc_sizes[i].cs_dmacachep :<br>malloc_sizes[i].cs_cachep, flags);<br>&#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 主要走这里，只有内置的常量分配才会走上面</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">return</span> __kmalloc(size, flags);<br>&#125;<br><br><span class="hljs-type">void</span> * __kmalloc (<span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> flags)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cache_sizes</span> *csizep = malloc_sizes;<br><br><span class="hljs-comment">/* 在malloc_sizes表中为size匹配最近的2的幂数大小的内存 */</span><br><span class="hljs-keyword">for</span> (; csizep-&gt;cs_size; csizep++) &#123;<br><span class="hljs-keyword">if</span> (size &gt; csizep-&gt;cs_size)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br><span class="hljs-comment">/* This happens if someone tries to call</span><br><span class="hljs-comment"> * kmem_cache_create(), or kmalloc(), before</span><br><span class="hljs-comment"> * the generic caches are initialized.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">BUG_ON</span>(csizep-&gt;cs_cachep == <span class="hljs-literal">NULL</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* 最终落实到__cache_alloc，GFP_DMA标志在这里处理，决定用csizep对应的dmacache还是级常规cache */</span><br><span class="hljs-keyword">return</span> __cache_alloc(flags &amp; GFP_DMA ?<br> csizep-&gt;cs_dmacachep : csizep-&gt;cs_cachep, flags);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 对应kfree:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放由kmalloc接口分配的内存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kfree</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *objp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">kmem_cache_t</span> *c;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br><span class="hljs-keyword">if</span> (!objp)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">local_irq_save</span>(flags);<br><span class="hljs-built_in">kfree_debugcheck</span>(objp);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过((kmem_cache_t *)(pg)-&gt;lru.next)，可确定合适的高速缓存描述符。</span><br><span class="hljs-comment"> */</span><br>c = <span class="hljs-built_in">GET_PAGE_CACHE</span>(<span class="hljs-built_in">virt_to_page</span>(objp));<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __cache_free释放高速缓存中的对象。</span><br><span class="hljs-comment"> */</span><br>__cache_free(c, (<span class="hljs-type">void</span>*)objp);<br><span class="hljs-built_in">local_irq_restore</span>(flags);<br>&#125;<br></code></pre></td></tr></table></figure>这个就很简单了，拿到内存区所在的第一个页框描述符的<code>lru.next</code>字段，就可以确定合适的高速缓存描述符。最终落实到<code>__cache_free</code>释放。</p><h2 id="内存池-mempool_t">内存池 mempool_t</h2><p>动态内存最后的储备，内核手头保留的应急罐头。它和保留页框池显然是两回事。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存池描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mempool_s</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用来保护对象字段的自旋锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">spinlock_t</span> lock;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存池中元素的最大个数。内存池元素的初始个数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> min_nr;<span class="hljs-comment">/* nr of elements at *elements */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当前内存池中元素的个数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> curr_nr;<span class="hljs-comment">/* Current nr of elements at *elements */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向一个数组的指针，该数组由指向保留元素的指针组成。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> **elements;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 池的拥有者可获得的私有数据。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> *pool_data;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分配一个元素的方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">mempool_alloc_t</span> *alloc;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放一个元素的方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">mempool_free_t</span> *free;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当内存池为空时使用的等待队列。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">wait_queue_head_t</span> wait;<br>&#125; <span class="hljs-type">mempool_t</span>;<br></code></pre></td></tr></table></figure> ### 创建内存池 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建一个新内存池</span><br><span class="hljs-comment"> * min_nr-内存元素的个数。</span><br><span class="hljs-comment"> * alloc_fn,free_fn-分配和释放内存的方法地址。</span><br><span class="hljs-comment"> * pool_data-私有数据。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">mempool_t</span> * <span class="hljs-title">mempool_create</span><span class="hljs-params">(<span class="hljs-type">int</span> min_nr, <span class="hljs-type">mempool_alloc_t</span> *alloc_fn,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">mempool_free_t</span> *free_fn, <span class="hljs-type">void</span> *pool_data)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">mempool_t</span> *pool;<br><br>pool = <span class="hljs-built_in">kmalloc</span>(<span class="hljs-built_in">sizeof</span>(*pool), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!pool)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">memset</span>(pool, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(*pool));<br>pool-&gt;elements = <span class="hljs-built_in">kmalloc</span>(min_nr * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!pool-&gt;elements) &#123;<br><span class="hljs-built_in">kfree</span>(pool);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-built_in">spin_lock_init</span>(&amp;pool-&gt;lock);<br>pool-&gt;min_nr = min_nr;<br>pool-&gt;pool_data = pool_data;<br><span class="hljs-built_in">init_waitqueue_head</span>(&amp;pool-&gt;wait);<br>pool-&gt;alloc = alloc_fn;<br>pool-&gt;free = free_fn;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * First pre-allocate the guaranteed number of buffers.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">while</span> (pool-&gt;curr_nr &lt; pool-&gt;min_nr) &#123;<br><span class="hljs-type">void</span> *element;<br><br>element = pool-&gt;<span class="hljs-built_in">alloc</span>(GFP_KERNEL, pool-&gt;pool_data);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!element)) &#123;<br><span class="hljs-built_in">free_pool</span>(pool);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-built_in">add_element</span>(pool, element);<br>&#125;<br><span class="hljs-keyword">return</span> pool;<br>&#125;<br></code></pre></td></tr></table></figure> ### 分配元素<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从内存池中分配一个元素</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">mempool_alloc</span><span class="hljs-params">(<span class="hljs-type">mempool_t</span> *pool, <span class="hljs-type">int</span> gfp_mask)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">void</span> *element;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-built_in">DEFINE_WAIT</span>(wait);<br><span class="hljs-type">int</span> gfp_nowait = gfp_mask &amp; ~(__GFP_WAIT | __GFP_IO);<br><br><span class="hljs-built_in">might_sleep_if</span>(gfp_mask &amp; __GFP_WAIT);<br>repeat_alloc:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先试图通过调用alloc函数从基本内存分配器分配一个内存元素。</span><br><span class="hljs-comment"> */</span><br>element = pool-&gt;<span class="hljs-built_in">alloc</span>(gfp_nowait|__GFP_NOWARN, pool-&gt;pool_data);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果从基本内存分配器中分配成功，就返回获得的内存元素而不涉及到内存池。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(element != <span class="hljs-literal">NULL</span>))<br><span class="hljs-keyword">return</span> element;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If the pool is less than 50% full and we can perform effective</span><br><span class="hljs-comment"> * page reclaim then try harder to allocate an element.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">mb</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从基本内存池中分配元素失败，从内存池中分配。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果内存池中的对象太少，并且允许阻塞，就试图从基本内存分配器分配。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((gfp_mask &amp; __GFP_FS) &amp;&amp; (gfp_mask != gfp_nowait) &amp;&amp;<br>(pool-&gt;curr_nr &lt;= pool-&gt;min_nr/<span class="hljs-number">2</span>)) &#123;<br>element = pool-&gt;<span class="hljs-built_in">alloc</span>(gfp_mask, pool-&gt;pool_data);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(element != <span class="hljs-literal">NULL</span>))<br><span class="hljs-keyword">return</span> element;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Kick the VM at this point.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">wakeup_bdflush</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 运行到此，就真的需要从内存池中取得元素了。</span><br><span class="hljs-comment"> * 要么是从基本内存池中分配失败，要么是内存池中的元素还比较多。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_lock_irqsave</span>(&amp;pool-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(pool-&gt;curr_nr)) &#123;<br>element = <span class="hljs-built_in">remove_element</span>(pool);<br><span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;pool-&gt;lock, flags);<br><span class="hljs-keyword">return</span> element;<br>&#125;<br><span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;pool-&gt;lock, flags);<br><br><span class="hljs-comment">/* We must not sleep in the GFP_ATOMIC case */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存池中的对象也用完了。又不允许等待，那就返回NULL吧。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(gfp_mask &amp; __GFP_WAIT))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存池中的元素用完了，但是允许等待，由于前面已经唤醒了守护进程。</span><br><span class="hljs-comment"> * 现在需要的是让守护线程运行起来，调度一次。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">prepare_to_wait</span>(&amp;pool-&gt;wait, &amp;wait, TASK_UNINTERRUPTIBLE);<br><span class="hljs-built_in">mb</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在真正调度出去前，再次判断一下curr_nr，是否有其他进程在开中断后释放了元素。</span><br><span class="hljs-comment"> * 注意前面调用了mb()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!pool-&gt;curr_nr)<br><span class="hljs-built_in">io_schedule</span>();<br><span class="hljs-built_in">finish_wait</span>(&amp;pool-&gt;wait, &amp;wait);<br><br><span class="hljs-keyword">goto</span> repeat_alloc;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="释放元素">释放元素：</h3><p>mempool回收元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放一个元素到内存池。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mempool_free</span><span class="hljs-params">(<span class="hljs-type">void</span> *element, <span class="hljs-type">mempool_t</span> *pool)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br><span class="hljs-built_in">mb</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果内存池未满，就将元素加入到内存池。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (pool-&gt;curr_nr &lt; pool-&gt;min_nr) &#123;<br><span class="hljs-built_in">spin_lock_irqsave</span>(&amp;pool-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (pool-&gt;curr_nr &lt; pool-&gt;min_nr) &#123;<br><span class="hljs-built_in">add_element</span>(pool, element);<br><span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;pool-&gt;lock, flags);<br><span class="hljs-built_in">wake_up</span>(&amp;pool-&gt;wait);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;pool-&gt;lock, flags);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 否则释放到基本内存分配器中。</span><br><span class="hljs-comment"> */</span><br>pool-&gt;<span class="hljs-built_in">free</span>(element, pool-&gt;pool_data);<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux-kernel</tag>
      
      <tag>ulk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核学习——内存管理之页框管理</title>
    <link href="/2017/10/20/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%A1%B5%E6%A1%86%E7%AE%A1%E7%90%86/"/>
    <url>/2017/10/20/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%A1%B5%E6%A1%86%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Linux内存管理非常复杂，从物理内存的分门别类，到内核用户态进程的索取，可以说是包罗万象。这一篇学习页框管理机制的设计以及透过源码了解一些技术细节。</p><span id="more"></span><h1 id="linux内存管理页框管理">Linux内存管理——页框管理</h1><p>在“内存寻址”一节中，我们知道了描述一个物理页的单位叫页框(pageframe)。页框的尺寸大小和硬件和Linux系统配置有关。对Intel来说，Linux采用4KB页框尺寸作为标准内存分配单元。</p><blockquote><ol type="1"><li>开启PAE的情况下，为2MB。</li><li>如果开启了大页，那么页框尺寸为4MB。</li></ol></blockquote><p>页框之所以选择4KB大小，ULK给出了两方面原因：</p><ol type="1"><li>分页系统造成的缺页异常很好解释，要么是页存在但process不被允许访问，要么是页不存在。如果不存在，内存分配器需要找一个free4KB页框给process。（这样一来管理虚拟地址空间的分页系统的4KB单位与页框大小一致，处理起来也就省事。此外，关于缺页异常实际上也没这里描摹的那么简单，ULK这里的说法是高度抽象的。）</li><li>尽管4K和4M都是磁盘块尺寸的倍数，但内存和磁盘间往往传递小块更为的高效。（这是考虑到页的换入换出机制，磁盘IO比内存寻址慢的多，页越大那么单次执行换页操作就越耗时，这不难理解。）</li></ol><p>物理内存可以分成静态+动态两部分，其中静态部分永久保留，用于硬件和Linux内核代码/静态数据结构。动态内存部分则是Linux系统RT所使用和管理。</p><p>物理内存的动静态布局大致如此：</p><p><img src="20171020_1.jpg" /></p><h2 id="内存模型">内存模型</h2><p>动态内存是如何管理的呢？这将牵扯到各个层面的管理模块，每个模块都足够复杂。在探索之前，我们先来搞清楚Linux在设计上如何抽象动态内存。</p><h3 id="平坦模式">平坦模式</h3><p>所谓平坦模式，是指物理地址空间连续没有空洞。这是最为理想化的模型，管理也简单。虚拟地址空间位于线性映射区域的页与物理地址空间的页帧一一对应，利用内核的某种映射机制来相互转换。</p><h3 id="非连续模式">非连续模式</h3><p>cpu访问物理内存，地址空间往往有着空洞。这种模式本质上是平坦模式的扩展，它相当于用空洞做间隔，把物理内存拆分成多个平坦空间，而虚拟地址空间就多了一个索引转换层，每个内存页需要去索引属于哪一块物理内存区。</p><blockquote><p>为什么设计上要自找麻烦呢？用平坦模式不好吗？当然是因为外因造成的，比如NUMA架构（详见下文）。</p></blockquote><h3 id="稀疏模式">稀疏模式</h3><p>这种模式就比较新潮了，是内核发展到现代所演变出来的一种模式。平坦模式是把物理页全部抽象成一片连续的地址空间，所有页page都在<code>mem_maps[]</code>中，而因为NUMA架构，物理内存空间不再连续，原本的单一<code>mem_maps[]</code>变成了<code>mem_maps[][]</code>，多了一个维度来索引某一块物理连续内存空间。而稀疏模式则在此基础上，引入了section的概念，每个section内部内存连续，而mem_map的page数组依附于section而不再依附于node(<code>struct pglist_data</code>)。</p><p>由于我们分析2.6.x内核，所以只会涉及到平坦和非连续模式，着重探索平坦模式，NUMA架构只是做一些介绍。</p><h2 id="物理内存的三个层次">物理内存的三个层次</h2><p>宏观上的设计大抵如此，但如果不了解微观上的各相关结构意义与耦合关系，读内核代码势必云里雾里。物理内存的管理上，有三个最为基础的数据结构：<code>struct page</code>,<code>struct pg_data_t</code>和<code>struct zone</code> 。</p><h3 id="page">page</h3><p>内核记录了每个页框的状态：属于哪个进程；属于内核代码或数据结构；空闲等等。页框的状态保存在页描述符，其类型为<code>struct page</code>。内核把所有的页描述符都存在全局<code>mem_map</code>数组（通常存放在ZONE_NORMAL首部）。page是最为基本的存储单元，可以看成是字节数组，标准大小为4KB。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Each physical page in the system has a struct page associated with</span><br><span class="hljs-comment"> * it to keep track of whatever it is we are using the page for at the</span><br><span class="hljs-comment"> * moment. Note that we have no way to track which tasks are using</span><br><span class="hljs-comment"> * a page.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> &#123;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一组标志，也对页框所在的管理区进行编号</span><br><span class="hljs-comment"> * 在不支持NUMA的机器上，flags中字段中管理索引占两位，节点索引占一位。</span><br><span class="hljs-comment"> * 在支持NUMA的32位机器上，flags中管理索引占用两位。节点数目占6位。</span><br><span class="hljs-comment"> * 在支持NUMA的64位机器上，64位的flags字段中，管理区索引占用两位，节点数目占用10位。</span><br><span class="hljs-comment"> * page_flags_t实际上是个无符号整型数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">page_flags_t</span> flags;<span class="hljs-comment">/* Atomic flags, some possibly</span><br><span class="hljs-comment"> * updated asynchronously */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 页框的引用计数。当小于0表示没有人使用。</span><br><span class="hljs-comment"> * Page_count返回_count+1表示正在使用的人数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">atomic_t</span> _count;<span class="hljs-comment">/* Usage count, see below. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 页框中的页表项数目（没有则为-1）</span><br><span class="hljs-comment"> *-1:表示没有页表项引用该页框。</span><br><span class="hljs-comment"> *0:表明页是非共享的。</span><br><span class="hljs-comment"> *&gt;0:表示而是共享的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">atomic_t</span> _mapcount;<span class="hljs-comment">/* Count of ptes mapped in mms,</span><br><span class="hljs-comment"> * to show when page is mapped</span><br><span class="hljs-comment"> * &amp; limit reverse map searches.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 可用于正在使用页的内核成分（如在缓冲页的情况下，它是一个缓冲器头指针。）</span><br><span class="hljs-comment"> * 如果页是空闲的，则该字段由伙伴系统使用。</span><br><span class="hljs-comment"> * 当用于伙伴系统时，如果该页是一个2^k的空闲页块的第一个页，那么它的值就是k.</span><br><span class="hljs-comment"> * 这样，伙伴系统可以查找相邻的伙伴，以确定是否可以将空闲块合并成2^(k+1)大小的空闲块。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<span class="hljs-comment">/* Mapping-private opaque data:</span><br><span class="hljs-comment"> * usually used for buffer_heads</span><br><span class="hljs-comment"> * if PagePrivate set; used for</span><br><span class="hljs-comment"> * swp_entry_t if PageSwapCache</span><br><span class="hljs-comment"> * When page is free, this indicates</span><br><span class="hljs-comment"> * order in the buddy system.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当页被插入页高速缓存时使用或者当页属于匿名页时使用）。</span><br><span class="hljs-comment"> * 如果mapping字段为空，则该页属于交换高速缓存(swap cache)。</span><br><span class="hljs-comment"> *如果mapping字段不为空，且最低位为1，表示该页为匿名页。同时该字段中存放的是指向anon_vma描述符的指针。</span><br><span class="hljs-comment"> *如果mapping字段不为空，且最低位为0，表示该页为映射页。同时该字段指向对应文件的address_space对象。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *<span class="hljs-title">mapping</span>;</span><span class="hljs-comment">/* If low bit clear, points to</span><br><span class="hljs-comment"> * inode address_space, or NULL.</span><br><span class="hljs-comment"> * If page mapped as anonymous</span><br><span class="hljs-comment"> * memory, low bit is set, and</span><br><span class="hljs-comment"> * it points to anon_vma object:</span><br><span class="hljs-comment"> * see PAGE_MAPPING_ANON below.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 作为不同的含义被几种内核成分使用。</span><br><span class="hljs-comment"> * 在页磁盘映象或匿名区中表示存放在页框中的数据的位置。</span><br><span class="hljs-comment"> * 或者它存放在一个换出页标志符。</span><br><span class="hljs-comment"> * 表示所有者的地址空间中以页大小为单位的偏移量，</span><br><span class="hljs-comment"> * 也就是磁盘映像中页中数据的位置</span><br><span class="hljs-comment"> * page-&gt;index是区域内的页索引或是页的线性地址除以PAGE_SIZE</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * liufeng: </span><br><span class="hljs-comment"> * 不是页内偏移量，而是该页面相对于文件起始位置，以页面为大小的偏移量</span><br><span class="hljs-comment"> * 如果减去vma-&gt;vm_pgoff，就表示该页面的虚拟地址相对于vma起始地址，以页面为大小的偏移量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">pgoff_t</span> index;<span class="hljs-comment">/* Our offset within mapping. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 包含页的最近最少使用的双向链表的指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">lru</span>;</span><span class="hljs-comment">/* Pageout list, eg. active_list</span><br><span class="hljs-comment"> * protected by zone-&gt;lru_lock !</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * On machines where all RAM is mapped into kernel address space,</span><br><span class="hljs-comment"> * we can simply calculate the virtual address. On machines with</span><br><span class="hljs-comment"> * highmem some memory is mapped into kernel virtual memory</span><br><span class="hljs-comment"> * dynamically, so we need a place to store that address.</span><br><span class="hljs-comment"> * Note that this field could be 16 bits on x86 ... ;)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Architectures with slow multiplication can define</span><br><span class="hljs-comment"> * WANT_PAGE_VIRTUAL in asm/page.h</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果进行了内存映射，就是内核虚拟地址。对存在高端内存的系统来说有意义。</span><br><span class="hljs-comment"> * 否则是NULL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> *virtual;<span class="hljs-comment">/* Kernel virtual address (NULL if</span><br><span class="hljs-comment">   not kmapped, ie. highmem) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* WANT_PAGE_VIRTUAL */</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>每个页框都有一个page描述符，内部的各个字段与耦合的各个模块有关，比如buddysystem，lrupageout链等。另外也可以看出内核设计上对空间的取用近乎苛刻，虽然不似WRK中充斥着大量的union语法（较新的内核4.x版本已经用union重写了，为了增强可读性），但同一个成员在不同的场景下其代表意义不同，并非单一职责。</p><p>此外，在Linux内核中，有个非常重要的全局指针变量<code>mem_map</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存映射数组。管理区描述符的zone_mem_map指向它的一个元素。</span><br><span class="hljs-comment"> * 用于伙伴系统。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">mem_map</span>;</span><br></code></pre></td></tr></table></figure><p>实际上是个flexible数组。</p><p>flags字段非常重要，取值非常多且意义深远：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">page_buf_flags_e</span> &#123;</span><span class="hljs-comment">/* pb_flags values */</span><br>PBF_READ = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>),<span class="hljs-comment">/* buffer intended for reading from device */</span><br>PBF_WRITE = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>),<span class="hljs-comment">/* buffer intended for writing to device   */</span><br>PBF_MAPPED = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>),  <span class="hljs-comment">/* buffer mapped (pb_addr valid)           */</span><br>PBF_PARTIAL = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>), <span class="hljs-comment">/* buffer partially read                   */</span><br>PBF_ASYNC = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>),   <span class="hljs-comment">/* initiator will not wait for completion  */</span><br>PBF_NONE = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>),    <span class="hljs-comment">/* buffer not read at all                  */</span><br>PBF_DELWRI = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>),  <span class="hljs-comment">/* buffer has dirty pages                  */</span><br>PBF_STALE = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>),<span class="hljs-comment">/* buffer has been staled, do not find it  */</span><br>PBF_FS_MANAGED = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>),  <span class="hljs-comment">/* filesystem controls freeing memory  */</span><br>PBF_FS_DATAIOD = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">9</span>),  <span class="hljs-comment">/* schedule IO completion on fs datad  */</span><br>PBF_FORCEIO = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>),    <span class="hljs-comment">/* ignore any cache state   */</span><br>PBF_FLUSH = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">11</span>),    <span class="hljs-comment">/* flush disk write cache   */</span><br>PBF_READ_AHEAD = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">12</span>), <span class="hljs-comment">/* asynchronous read-ahead   */</span><br><br><span class="hljs-comment">/* flags used only as arguments to access routines */</span><br>PBF_LOCK = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>),       <span class="hljs-comment">/* lock requested   */</span><br>PBF_TRYLOCK = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">15</span>),    <span class="hljs-comment">/* lock requested, but do not wait   */</span><br>PBF_DONT_BLOCK = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>), <span class="hljs-comment">/* do not block in current thread   */</span><br><br><span class="hljs-comment">/* flags used only internally */</span><br>_PBF_PAGE_CACHE = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">17</span>),<span class="hljs-comment">/* backed by pagecache   */</span><br>_PBF_KMEM_ALLOC = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">18</span>),<span class="hljs-comment">/* backed by kmem_alloc()   */</span><br>_PBF_RUN_QUEUES = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">19</span>),<span class="hljs-comment">/* run block device task queue   */</span><br>&#125; <span class="hljs-type">page_buf_flags_t</span>;<br></code></pre></td></tr></table></figure><p>参考ULK的释义： <img src="20171020_2.jpg" /></p><p>flags包含了各个耦合模块上相对的意义，设计上也可以看得出来其枚举值是可以叠加而不交叉的。关于它们的意义，具体读到相关代码时再做阐述。</p><h3 id="node">node</h3><p>如果所有内存都是均质的，那么物理地址整个都是平坦的，一气呵成也就不需要进行分类，但现实中往往不是所有的内存都是均质的，不同架构寻址内存的不同空间速度是不同的（Alpha,mips,etc.）。所以内存的使用布局就很有讲究，2.6支持NUMA，物理内存被瓜分成多个nodes。不同的node中的page同一CPU访问速度是相同的。所以一个node就表示一种物理内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The pg_data_t structure is used in machines with CONFIG_DISCONTIGMEM</span><br><span class="hljs-comment"> * (mostly NUMA machines?) to denote a higher-level memory zone than the</span><br><span class="hljs-comment"> * zone denotes.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * On NUMA machines, each NUMA node would have a pg_data_t to describe</span><br><span class="hljs-comment"> * it&#x27;s memory layout.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Memory statistics and page replacement data structures are maintained on a</span><br><span class="hljs-comment"> * per-zone basis.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bootmem_data</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存管理结点描述符。每个描述符中的物理内存，对CPU来说，访问是一致的。</span><br><span class="hljs-comment"> * 但是每个管理结点又包含了不同的管理区。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pglist_data</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 节点管理区描述符数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">zone</span> node_zones[MAX_NR_ZONES];<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 页分配器使用的zonelist数据结构的数组。</span><br><span class="hljs-comment"> * 实际上这个东西对NUMA来说意义非凡，它可以承载备用节点，在当前节点没有空间时使用备用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">zonelist</span> node_zonelists[GFP_ZONETYPES];<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 节点中管理区的个数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> nr_zones;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 节点中页描述符的数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *node_mem_map;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用在内核初始化阶段</span><br><span class="hljs-comment"> * 内存管理子系统初始化前，内核页需要使用内存</span><br><span class="hljs-comment"> * 此结构用于这个阶段的内存管理，内核使用自举内存分配器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bootmem_data</span> *bdata;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 节点中第一个页框的下标。</span><br><span class="hljs-comment"> * 系统中所有的页帧是依次编号的，每个页帧的号码都是全局唯一的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_start_pfn;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存结点的大小，不包含空洞（以页为单位）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_present_pages; <span class="hljs-comment">/* total number of physical pages */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 节点的大小，包括空洞</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_spanned_pages; <span class="hljs-comment">/* total size of physical page</span><br><span class="hljs-comment">     range, including holes */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 节点标识符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> node_id;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存节点链表的下一项。该字段构成node单链表。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pglist_data</span> *pgdat_next;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kswapd页换出守护进程使用的等待队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">wait_queue_head_t</span> kswapd_wait;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指针指向kswapd内核线程的进程描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> *kswapd;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kswapd将要创建的空闲块大小取对数的值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> kswapd_max_order;<br>&#125; <span class="hljs-type">pg_data_t</span>;<br></code></pre></td></tr></table></figure><p>每个node又可以分成多个zones，每个node有个类型为<code>pg_data_t</code>的描述符，所有node描述符都存储在单一链，第一个元素由<code>pgdat_list</code>变量所指向。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内核将物理内存分为几个结点。</span><br><span class="hljs-comment"> * 每个结点上的内存，对当前CPU来说，其访问时间是相等的。</span><br><span class="hljs-comment"> * pgdat_list是这些结点的单向列表。</span><br><span class="hljs-comment"> * 对x86来说，不支持NUMA，所以这个链表只有一个结点。这个结点保存在contig_page_data中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> *<span class="hljs-title">pgdat_list</span>;</span><br></code></pre></td></tr></table></figure><p>对于x86这种不支持NUMA的架构，node实际上只有一个，它在全局数组变量<code>contig_page_data</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 支持NUMA。</span><br><span class="hljs-comment"> * 对IBM来说，虽然并不真正需要NUMA支持，但是：即使NUMA的支持没有编译进内核，LINUX还是使用结点管理NUMA。</span><br><span class="hljs-comment"> * 不过，这是一个单独的结点。它包含了系统中所有的物理内存。</span><br><span class="hljs-comment"> * 这个元素由contig_page_data表示。它包含在一个只有一个结点的链表中，这个链表被pgdat_list指向。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> <span class="hljs-title">contig_page_data</span> =</span> &#123; .bdata = &amp;contig_bootmem_data &#125;;<br></code></pre></td></tr></table></figure><p>此外，<code>mem_map</code>在<code>node_alloc_mem_map</code>中被赋值，指向了<code>contig_page_data.node_mem_map</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __init <span class="hljs-title function_">node_alloc_mem_map</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pglist_data *pgdat)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br><br>size = (pgdat-&gt;node_spanned_pages + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> page);<br>pgdat-&gt;node_mem_map = alloc_bootmem_node(pgdat, size);<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_DISCONTIGMEM</span><br>mem_map = contig_page_data.node_mem_map;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>NUMA架构比UMA架构复杂得多，整个系统的内存由<code>node_data</code>这个<code>pg_data_t</code>数组管理，而UMA只有一个简单的<code>contig_page_data</code>。</p><p>可以用<code>NODE_DATA(node_id)</code>来查找编号为<code>node_id</code>的节点，对于UMA架构，node只有一个，所以该宏总是返回全局的<code>contig_page_data</code>。</p><p>本文只讨论UMA架构，在UMA系统中,内存就相当于一个只使用一个NUMA节点来管理整个系统的内存。而内存管理的其他地方则认为他们就是在处理一个(伪)NUMA系统。</p><h3 id="zone">zone</h3><p>理想架构中，页框作为内存存储单元可以存储内核和用户数据，磁盘数据缓存等等。任何页数据都可以存在任何页框中，没有任何限制。然而真实的架构有着硬件限制。</p><p>Linux内核必须处理80x86架构的两个硬件限制： 1.旧ISA总线的DMA处理器有一个严格的限制：它们只能寻址RAM的前16MB空间。 2.现代32位计算机有很多RAM，CPU不能直接访问所有的物理内存，因为线性地址空间太小了。(内核线性地址只有3G到4G这1GB，而RAM当前比这大得多，设计成一对一肯定是不行的，所以映射机制是个复杂的大杂烩。)</p><p>为了应付这两个限制，Linux在80x86UMA架构中分割物理内存node成3个zones。 - ZONE_DMA -包含低16MB的内存页框，用于兼容旧ISA总线DMA处理器 - ZONE_NORMAL -包含16MB到896MB的内存页框 - ZONE_HIGHMEM - 包含高于896MB的内存页框</p><p>ZONE_DMA给旧ISA总线设备用。ZONE_DMA和ZONE_NORMAL包含内存的常规页框，通过线性映射到4GB的线性地址空间，它们可以被内核直接使用。ZONE_HIGHMEM包含不能够直接访问的内存页框。此外，因为x64虚拟地址空间的膨胀，ZONE_HIGHMENzone在64bit机器上总是空的（没有存在的必要）。</p><p>不同的硬件架构node分成的zone类别也有所不同，但大体上来讲都有两个非常重要的zone，一个是直接线性映射的NORMAL区，比如x86上的16M到896M这一部分偏移量的物理内存可以直接映射到3G+16M到3G+896M的虚拟线性地址上。而HIGHMEM则比较复杂，它被各种机制安排到剩余的128MB（1024MB-896MB）（不同架构可能不一样）线性空间上（也就是靠近4G的最后128MB），这些机制我们过后再探索。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存管理区描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">zone</span> &#123;<br><span class="hljs-comment">/* Fields commonly accessed by the page allocator */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 管理区中空闲页的数目</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>free_pages;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Pages_min-管理区中保留页的数目</span><br><span class="hljs-comment"> * Page_low-回收页框使用的下界。同时也被管理区分配器为作为阈值使用。</span><br><span class="hljs-comment"> * pages_high-回收页框使用的上界，同时也被管理区分配器作为阈值使用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>pages_min, pages_low, pages_high;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We don&#x27;t know if the memory that we&#x27;re going to allocate will be freeable</span><br><span class="hljs-comment"> * or/and it will be released eventually, so to avoid totally wasting several</span><br><span class="hljs-comment"> * GB of ram we must reserve some of the lower zone memory (otherwise we risk</span><br><span class="hljs-comment"> * to run OOM on the lower zones despite there&#x27;s tons of freeable ram</span><br><span class="hljs-comment"> * on the higher zones). This array is recalculated at runtime if the</span><br><span class="hljs-comment"> * sysctl_lowmem_reserve_ratio sysctl changes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为内存不足保留的页框，分别为各种内存域指定了若干页</span><br><span class="hljs-comment"> * 用于一些无论如何都不能失败的关键性内存分配</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>lowmem_reserve[MAX_NR_ZONES];<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于实现单一页框的特殊高速缓存。</span><br><span class="hljs-comment"> * 每内存管理区对每CPU都有一个。包含热高速缓存和冷高速缓存。</span><br><span class="hljs-comment"> * 内核使用这些列表来保存可用于满足实现的“新鲜”页。</span><br><span class="hljs-comment"> * 有些页帧很可能在CPU高速缓存中，因此可以快速访问，称之为热。</span><br><span class="hljs-comment"> * 未缓存的页帧称之为冷的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pageset</span>pageset[NR_CPUS];<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * free areas of different sizes</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保护该描述符的自旋锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">spinlock_t</span>lock;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 标识出管理区中的空闲页框块。</span><br><span class="hljs-comment"> * 包含11个元素，被伙伴系统使用。分别对应大小的1,2,4,8,16,32,128,256,512,1024连续空闲块的链表。</span><br><span class="hljs-comment"> * 第k个元素标识所有大小为2^k的空闲块。free_list字段指向双向循环链表的头。</span><br><span class="hljs-comment"> * free_list是free_area的内部结构，是个双向环回链表节点。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">free_area</span>free_area[MAX_ORDER];<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 为了cache line对齐加的pad</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">ZONE_PADDING</span>(_pad1_)<br><br><span class="hljs-comment">/* Fields commonly accessed by the page reclaim scanner */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 活动以及非活动链表使用的自旋锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">spinlock_t</span>lru_lock;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 管理区中的活动页链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>active_list;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 管理区中的非活动页链表。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>inactive_list;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 回收内存时需要扫描的活动页数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>nr_scan_active;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 回收内存时需要扫描的非活动页数目</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>nr_scan_inactive;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 管理区的活动链表上的页数目。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>nr_active;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 管理区的非活动链表上的页数目。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>nr_inactive;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 管理区内回收页框时使用的计数器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>pages_scanned;   <span class="hljs-comment">/* since last reclaim */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在管理区中填满不可回收页时此标志被置位</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span>all_unreclaimable; <span class="hljs-comment">/* All pages pinned */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * prev_priority holds the scanning priority for this zone.  It is</span><br><span class="hljs-comment"> * defined as the scanning priority at which we achieved our reclaim</span><br><span class="hljs-comment"> * target at the previous try_to_free_pages() or balance_pgdat()</span><br><span class="hljs-comment"> * invokation.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * We use prev_priority as a measure of how much stress page reclaim is</span><br><span class="hljs-comment"> * under - it drives the swappiness decision: whether to unmap mapped</span><br><span class="hljs-comment"> * pages.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * temp_priority is used to remember the scanning priority at which</span><br><span class="hljs-comment"> * this zone was successfully refilled to free_pages == pages_high.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Access to both these fields is quite racy even on uniprocessor.  But</span><br><span class="hljs-comment"> * it is expected to average out OK.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 临时管理区的优先级。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> temp_priority;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 管理区优先级，范围在12和0之间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> prev_priority;<br><br><br><span class="hljs-built_in">ZONE_PADDING</span>(_pad2_)<br><span class="hljs-comment">/* Rarely used or read-mostly fields */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * wait_table-- the array holding the hash table</span><br><span class="hljs-comment"> * wait_table_size-- the size of the hash table array</span><br><span class="hljs-comment"> * wait_table_bits-- wait_table_size == (1 &lt;&lt; wait_table_bits)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The purpose of all these is to keep track of the people</span><br><span class="hljs-comment"> * waiting for a page to become available and make them</span><br><span class="hljs-comment"> * runnable again when possible. The trouble is that this</span><br><span class="hljs-comment"> * consumes a lot of space, especially when so few things</span><br><span class="hljs-comment"> * wait on pages at a given time. So instead of using</span><br><span class="hljs-comment"> * per-page waitqueues, we use a waitqueue hash table.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The bucket discipline is to sleep on the same queue when</span><br><span class="hljs-comment"> * colliding and wake all in that wait queue when removing.</span><br><span class="hljs-comment"> * When something wakes, it must check to be sure its page is</span><br><span class="hljs-comment"> * truly available, a la thundering herd. The cost of a</span><br><span class="hljs-comment"> * collision is great, but given the expected load of the</span><br><span class="hljs-comment"> * table, they should be so rare as to be outweighed by the</span><br><span class="hljs-comment"> * benefits from the saved space.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * __wait_on_page_locked() and unlock_page() in mm/filemap.c, are the</span><br><span class="hljs-comment"> * primary users of these fields, and in mm/page_alloc.c</span><br><span class="hljs-comment"> * free_area_init_core() performs the initialization of them.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程等待队列的散列表。这些进程正在等待管理区中的某页。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">wait_queue_head_t</span>* wait_table;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待队列散列表的大小。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>wait_table_size;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待队列散列表数组的大小。值为2^order</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>wait_table_bits;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Discontig memory support fields.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存节点。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pglist_data</span>*zone_pgdat;<br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 指向管理区的第一个页描述符的指针。这个指针是数组mem_map的一个元素。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span>*zone_mem_map;<br><span class="hljs-comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 管理区的第一个页框的下标。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>zone_start_pfn;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以页为单位的管理区的总大小，包含空洞。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>spanned_pages;<span class="hljs-comment">/* total size, including holes */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以页为单位的管理区的总大小，不包含空洞。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>present_pages;<span class="hljs-comment">/* amount of memory (excluding holes) */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * rarely used fields:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指针指向管理区的传统名称：DMA、NORMAL、HighMem</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span>*name;<br>&#125; ____cacheline_maxaligned_in_smp;<br></code></pre></td></tr></table></figure><blockquote><p>由于 <code>struct zone</code> 结构经常被访问到,因此这个数据结构要求以 <code>L1 Cache</code> 对齐. 另外, 这里的<code>ZONE_PADDING( )</code> 让 <code>zone-&gt;lock</code> 和<code>zone_lru_lock</code> 这两个很热门的锁可以分布在不同的<code>Cahe Line</code> 中. 一个内存 <code>node</code> 节点最多也就几个<code>zone</code>, 因此 <code>zone</code> 数据结构不需要像<code>struct page</code> 一样关心数据结构的大小, 因此这里的<code>ZONE_PADDING( )</code> 可以理解为用空间换取时间(性能).在内存管理开发过程中, 内核开发者逐渐发现有一些自选锁竞争会非常厉害,很难获取. 像 <code>zone-&gt;lock</code> 和<code>zone-&gt;lru_lock</code> 这两个锁有时需要同时获取锁.因此保证他们使用不同的 <code>Cache Line</code>是内核常用的一种优化技巧.</p></blockquote><p>回过头看page，page中有到node和zone的链接，为了省空间，并没有设定单独的指针指向，而是编码成索引放在flags字段的高位(2.4.18前，page是有个指向zone的指针的，但page那么多，每个都浪费一个指针大小，浪费的内存还是相当可观的，对于linux这种性能癖，当然优化掉了)。源码中可以看到flags的标志数目是有限的，flags字段的高位可以用于编码特定node和zone号（对32位非NUMA，zone索引2位，node索引1位。（因为zone有3个而node只有1个））。</p><p>page_zone()接收一个page地址作为参数，读取flags中的最高位，通过查看zone_table来确定zone的地址：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收一个页描述符的地址作为它的参数，它读取页描述符的flags字段的高位，并通过zone_table数组来确定相应管理区描述符的地址</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zone</span> *<span class="hljs-built_in">page_zone</span>(<span class="hljs-keyword">struct</span> page *page)<br>&#123;<br><span class="hljs-keyword">return</span> zone_table[page-&gt;flags &gt;&gt; NODEZONE_SHIFT];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODEZONE_SHIFT (sizeof(page_flags_t)*8 - MAX_NODES_SHIFT - MAX_ZONES_SHIFT)</span><br><br><span class="hljs-comment">/* There are currently 3 zones: DMA, Normal &amp; Highmem, thus we need 2 bits */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ZONES_SHIFT2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_DISCONTIGMEM</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pglist_data</span> contig_page_data;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_DATA(nid)(&amp;contig_page_data)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_MEM_MAP(nid)mem_map</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NODES_SHIFT1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pfn_to_nid(pfn)(0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* CONFIG_DISCONTIGMEM */</span></span><br><span class="hljs-comment">//只关心non-NUMA</span><br></code></pre></td></tr></table></figure>内核调用内存分配函数时，必须指明请求page所在的zone。内核一般指明它想用的zone。内核使用<code>zonelist</code>数组指明首选的zone：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * One allocation request operates on a zonelist. A zonelist</span><br><span class="hljs-comment"> * is a list of zones, the first one is the &#x27;goal&#x27; of the</span><br><span class="hljs-comment"> * allocation, the other zones are fallback zones, in decreasing</span><br><span class="hljs-comment"> * priority.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Right now a zonelist takes up less than a cacheline. We never</span><br><span class="hljs-comment"> * modify it apart from boot-up, and only a few indices are used,</span><br><span class="hljs-comment"> * so despite the zonelist table being relatively big, the cache</span><br><span class="hljs-comment"> * footprint of this construct is very small.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">zonelist</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">zone</span> *zones[MAX_NUMNODES * MAX_NR_ZONES + <span class="hljs-number">1</span>]; <span class="hljs-comment">// NULL delimited</span><br>&#125;;<br></code></pre></td></tr></table></figure></p><p>可以看到<code>zonelist</code>不过是zone的一个集成，聚合了所有node的所有zone，它的内部究竟如何布局，具体分配时又如何使用等到阅读内存分配代码时再一探究竟。</p><h2 id="保留的页框池">保留的页框池</h2><p>一方面内存有时会不够用，一些操作会被阻塞到有其他内存free。另一方面内核的某些操作是非常不想阻塞的，所以折中的办法就是留一个保留区。保留内存的数量由<code>min_free_kbytes</code>决定，单位为KB。这个值可以动态修改，通过sysctl系统调用或者直接写/proc文件系统下的内核变量。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内核保留内存池大小。</span><br><span class="hljs-comment"> * 一般等于sqrt(16*内核直接映射内存大小)</span><br><span class="hljs-comment"> * 但是不能小于128也不能大于65536</span><br><span class="hljs-comment"> * 管理员可以通过写入/proc/sys/vm/min_free_kbytes来改变这个值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> min_free_kbytes = <span class="hljs-number">1024</span>;<br></code></pre></td></tr></table></figure></p><p>zone的<code>pages_min</code>存储管理区内保留页框的数目。连同<code>pages_low</code>，<code>pages_high</code>在页框回收算法中会用到。</p><h2 id="zoned-page-frame分配器">Zoned Page Frame分配器</h2><p>zoned pageframe分配器是一个内核子系统，处理一组连续的页框分配请求。</p><p><strong>概要：</strong>分配器接收分配和释放请求。分配时，组件搜索包含连续pageframes的zone来满足请求。在每个zone内，page frames由组件"buddysystem"控制。为了得到更高的性能，少量的pageframes放在缓存中以满足多次对单个页面的分配请求。</p><h3 id="分配接口">分配接口</h3><p>分配页框可以使用6个不同的函数和宏，直接对照源码最易理解。</p><p>note：以下源码取非NUMA配置。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分配2^order个连续的页框。它返回第一个所分配页框描述符的地址或者返回NULL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> alloc_pages(gfp_mask, order) \</span><br><span class="hljs-meta">alloc_pages_node(numa_node_id(), gfp_mask, order)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于获得一个单独页框的宏</span><br><span class="hljs-comment"> * 它返回所分配页框描述符的地址，如果失败，则返回NULL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)</span><br><br><span class="hljs-comment">/* 可以看出alloc_page就是alloc_pages的特例 */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 类似于alloc_pages，但是它返回第一个所分配页的线性地址。</span><br><span class="hljs-comment"> */</span><br>fastcall <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __get_free_pages(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gfp_mask, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> * page;<br>page = <span class="hljs-built_in">alloc_pages</span>(gfp_mask, order);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 实际上是page-&gt;virtual</span><br><span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) <span class="hljs-built_in">page_address</span>(page);<br>&#125;<br><br><span class="hljs-comment">/* 可以看到__get_free_pages内部也是调用了alloc_pages，只是返回的page由page_address转成了线性地址 */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于获得一个单独页框的宏。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __get_free_page(gfp_mask) \</span><br><span class="hljs-meta">__get_free_pages((gfp_mask),0)</span><br><span class="hljs-comment">/* __get_free_page亦是__get_free_pages的特例 */</span><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于获取填满0的页框。</span><br><span class="hljs-comment"> * 返回的是页框对应的虚拟地址VA</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">fastcall <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">get_zeroed_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gfp_mask)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> * page;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * get_zeroed_page() returns a 32-bit address, which cannot represent</span><br><span class="hljs-comment"> * a highmem page</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">BUG_ON</span>(gfp_mask &amp; __GFP_HIGHMEM);<br><br>page = <span class="hljs-built_in">alloc_pages</span>(gfp_mask | __GFP_ZERO, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) <span class="hljs-built_in">page_address</span>(page);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 显然也是alloc_pages的特例，给定了__GFP_ZERO标志 */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于获得适用于dma的页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __get_dma_pages(gfp_mask, order) \</span><br><span class="hljs-meta">__get_free_pages((gfp_mask) | GFP_DMA,(order))</span><br><br><span class="hljs-comment">/* 又是个特例，给定了GFP_DMA标志 */</span><br></code></pre></td></tr></table></figure></p><p>可以看出这一族alloc函数都是对<code>alloc_pages</code>的包装，做了些善后工作，传递了不同的参数。</p><p>所以最后的谜底就在于<code>alloc_pages</code>中的<code>alloc_pages_node</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *<span class="hljs-built_in">alloc_pages_node</span>(<span class="hljs-type">int</span> nid, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gfp_mask,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(order &gt;= MAX_ORDER))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> __alloc_pages(gfp_mask, order,<br><span class="hljs-built_in">NODE_DATA</span>(nid)-&gt;node_zonelists + (gfp_mask &amp; GFP_ZONEMASK));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>alloc_pages_node</code>只是做心智健全检查，实际工作交给了<code>__alloc_pages</code>，注意参数中<code>zonelist</code>是通过<code>NODE_DATA(nid)</code>取出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> *<span class="hljs-title">node_data</span>[];</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_DATA(nid)(node_data[nid])</span><br></code></pre></td></tr></table></figure><p>转去看看<code>__alloc_pages</code>这个内存区PF分配器的总入口函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 请求分配一组连续页框，它是管理区分配器的核心</span><br><span class="hljs-comment"> * gfp_mask：在内存分配请求中指定的标志</span><br><span class="hljs-comment"> * order：   连续分配的页框数量的对数(实际分配的是2^order个连续的页框)</span><br><span class="hljs-comment"> * zonelist: zonelist数据结构的指针。该结构按优先次序描述了适于内存分配的内存管理区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> * <span class="hljs-title">fastcall</span></span><br><span class="hljs-class">__<span class="hljs-title">alloc_pages</span>(<span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">gfp_mask</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> *<span class="hljs-title">zonelist</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> wait = gfp_mask &amp; __GFP_WAIT;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> **<span class="hljs-title">zones</span>, *<span class="hljs-title">z</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reclaim_state</span> <span class="hljs-title">reclaim_state</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">p</span> =</span> current;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> classzone_idx;<br><span class="hljs-type">int</span> do_retry;<br><span class="hljs-type">int</span> can_try_harder;<br><span class="hljs-type">int</span> did_some_progress;<br><br>might_sleep_if(wait);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The caller may dip into page reserves a bit more if the caller</span><br><span class="hljs-comment"> * cannot run direct reclaim, or is the caller has realtime scheduling</span><br><span class="hljs-comment"> * policy</span><br><span class="hljs-comment"> */</span><br>can_try_harder = (unlikely(rt_task(p)) &amp;&amp; !in_interrupt()) || !wait;<br><br>zones = zonelist-&gt;zones;  <span class="hljs-comment">/* the list of zones suitable for gfp_mask */</span><br><br><span class="hljs-keyword">if</span> (unlikely(zones[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>)) &#123;<br><span class="hljs-comment">/* Should this ever happen?? */</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>classzone_idx = zone_idx(zones[<span class="hljs-number">0</span>]);<br><br> restart:<br><span class="hljs-comment">/* Go through the zonelist once, looking for a zone with enough free */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 扫描包含在zonelist数据结构中的每个内存管理区</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * 这里可以看到对zonelist的扫描顺序，是按索引从前向后的。</span><br><span class="hljs-comment">   * 那么zonelist是如何布局的呢？如何为不同zone区分高低贵贱呢？</span><br><span class="hljs-comment">   * 对于UMA架构比较简单，因为只有单一node，在build_zonelists中可以一探究竟</span><br><span class="hljs-comment">   * 简单归纳来说，HIGHMEM最廉价、NORMAL次之，DMA最昂贵。</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (z = zones[i]) != <span class="hljs-literal">NULL</span>; i++) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对于每个内存管理区，该函数将空闲页框的个数与一个阀值进行比较</span><br><span class="hljs-comment"> * 该值取决于内存分配标志、当前进程的类型及管理区被函数检查的次数。</span><br><span class="hljs-comment"> * 实际上，如果空闲内存不足，那么每个内存管理区一般会被检查几次。</span><br><span class="hljs-comment"> * 每一次在所请求的空闲内存最低量的基础上使用更低的值进行扫描。</span><br><span class="hljs-comment"> * 因此，这段循环代码会被复制几次，而变化很小。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * zone_watermark_ok辅助函数接收几个参数，它们决定内存管理区中空闲页框个数的阀值min。</span><br><span class="hljs-comment"> * 这是对内存管理区的第一次扫描，在第一次扫描中，阀值设置为z-&gt;pages_low</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!zone_watermark_ok(z, order, z-&gt;pages_low,<br>       classzone_idx, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 这个函数就是关键的分配函数，它杂糅了伙伴系统分配策略 + 本地CPU高速缓存</span><br><span class="hljs-comment"> */</span><br>page = buffered_rmqueue(z, order, gfp_mask);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一般来说，应当在上一次扫描时得到内存。</span><br><span class="hljs-comment"> * 运行到此，表示内存已经紧张了（xie.baoyou注：没有连续的页框可供分配了）</span><br><span class="hljs-comment"> * 就唤醒kswapd内核线程来异步的开始回收页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (z = zones[i]) != <span class="hljs-literal">NULL</span>; i++)<br>wakeup_kswapd(z, order);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Go through the zonelist again. Let __GFP_HIGH and allocations</span><br><span class="hljs-comment"> * coming from realtime tasks to go deeper into reserves</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 执行对内存管理区的第二次扫描，将值z-&gt;pages_min作为阀值传入。这个值已经在上一步的基础上降低了（pages_low一般是pages_min的5/4，pages_high一般是pages_min的3/2）。</span><br><span class="hljs-comment"> * 当然，实际的min值还是要由can_try_harder和gfp_high确定。z-&gt;pages_min仅仅是一个参考值而已。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (z = zones[i]) != <span class="hljs-literal">NULL</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (!zone_watermark_ok(z, order, z-&gt;pages_min,<br>       classzone_idx, can_try_harder,<br>       gfp_mask &amp; __GFP_HIGH))<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 第二次扫描后，可能因为阈值的降低也可能因为异步的kswapd内核线程回收了页框</span><br><span class="hljs-comment"> * 此时已经可以满足分配需求了</span><br><span class="hljs-comment"> */</span><br>page = buffered_rmqueue(z, order, gfp_mask);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br>&#125;<br><br><span class="hljs-comment">/* This allocation should allow future memory freeing. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 上一步都还没有获得内存，系统内存肯定是不足了。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果产生内存分配的内核控制路径不是一个中断处理程序或者可延迟函数，</span><br><span class="hljs-comment"> * 并且它试图回收页框（PF_MEMALLOC，TIF_MEMDIE标志被置位）,那么才对内存管理区进行第三次扫描。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (((p-&gt;flags &amp; PF_MEMALLOC) || unlikely(test_thread_flag(TIF_MEMDIE))) &amp;&amp; !in_interrupt()) &#123;<br><span class="hljs-comment">/* go through the zonelist yet again, ignoring mins */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (z = zones[i]) != <span class="hljs-literal">NULL</span>; i++) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 本次扫描就不调用zone_watermark_ok，它忽略阀值，这样才能从预留的页中分配页。</span><br><span class="hljs-comment"> * 允许这样做，因为是这个进程想要归还页框，那就暂借一点给它吧（呵呵，舍不得孩子套不到狼）。</span><br><span class="hljs-comment"> */</span><br>page = buffered_rmqueue(z, order, gfp_mask);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 老天保佑，不要运行到这里来，实在是没有内存了。</span><br><span class="hljs-comment"> * 不论是高端内存区还是普通内存区、还是DMA内存区，甚至这些管理区中保留的内存都没有了。</span><br><span class="hljs-comment"> * 意味着我们的家底都完了。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">goto</span> nopage;<br>&#125;<br><br><span class="hljs-comment">/* Atomic allocations - we can&#x27;t balance anything */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果gfp_mask的__GFP_WAIT标志没有被置位，函数就返回NULL。你又不能等，实在没辙。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!wait)<br><span class="hljs-keyword">goto</span> nopage;<br><br>rebalance:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果当前进程能够被阻塞，调用cond_resched检查是否有其他进程需要CPU</span><br><span class="hljs-comment"> */</span><br>cond_resched();<br><br><span class="hljs-comment">/* We now go into synchronous reclaim */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置PF_MEMALLOC标志来表示进程已经准备好执行内存回收。</span><br><span class="hljs-comment"> */</span><br>p-&gt;flags |= PF_MEMALLOC;<br>reclaim_state.reclaimed_slab = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将reclaim_state数据结构指针存入reclaim_state。这个结构只包含一个字段reclaimed_slab，初始值为0</span><br><span class="hljs-comment"> */</span><br>p-&gt;reclaim_state = &amp;reclaim_state;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用try_to_free_pages寻找一些页框来回收。</span><br><span class="hljs-comment"> * 这个函数可能会阻塞当前进程。一旦返回，就重设PF_MEMALLOC，并再次调用cond_resched</span><br><span class="hljs-comment"> */</span><br>did_some_progress = try_to_free_pages(zones, gfp_mask, order);<br><br>p-&gt;reclaim_state = <span class="hljs-literal">NULL</span>;<br>p-&gt;flags &amp;= ~PF_MEMALLOC;<br><br>cond_resched();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果已经回收了一些页框，那么执行第二遍扫描类似的操作。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (likely(did_some_progress)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Go through the zonelist yet one more time, keep</span><br><span class="hljs-comment"> * very high watermark here, this is only to catch</span><br><span class="hljs-comment"> * a parallel oom killing, we must fail if we&#x27;re still</span><br><span class="hljs-comment"> * under heavy pressure.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (z = zones[i]) != <span class="hljs-literal">NULL</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (!zone_watermark_ok(z, order, z-&gt;pages_min,<br>       classzone_idx, can_try_harder,<br>       gfp_mask &amp; __GFP_HIGH))<br><span class="hljs-keyword">continue</span>;<br><br>page = buffered_rmqueue(z, order, gfp_mask);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((gfp_mask &amp; __GFP_FS) &amp;&amp; !(gfp_mask &amp; __GFP_NORETRY)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Go through the zonelist yet one more time, keep</span><br><span class="hljs-comment"> * very high watermark here, this is only to catch</span><br><span class="hljs-comment"> * a parallel oom killing, we must fail if we&#x27;re still</span><br><span class="hljs-comment"> * under heavy pressure.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有释放任何页框，说明内核遇到很大麻烦了。因为内存少又不能释放页框。</span><br><span class="hljs-comment"> * 如果允许杀死进程：__GFP_FS被置位并且__GFP_NORETRY标志为0。</span><br><span class="hljs-comment"> * 那就开始准备杀死进程吧。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 再扫描一次内存管理区。</span><br><span class="hljs-comment"> * 这样做有点莫名其妙，既然申请少一点的内存都不行，为什么还要传入z-&gt;pages_high？？它看起来更不会成功。</span><br><span class="hljs-comment"> * 其实这样做还是有道理的：实际上，只有另一个内核控制路径已经杀死一个进程来回收它的内存后，这步才会成功。</span><br><span class="hljs-comment"> * 因此，这步避免了两个（而不是一个）无辜的进程被杀死。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (z = zones[i]) != <span class="hljs-literal">NULL</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (!zone_watermark_ok(z, order, z-&gt;pages_high,<br>       classzone_idx, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br><span class="hljs-keyword">continue</span>;<br><br>page = buffered_rmqueue(z, order, gfp_mask);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 还是不行，就杀死一些进程再试吧。</span><br><span class="hljs-comment"> */</span><br>out_of_memory(gfp_mask);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * let&#x27;s go on</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">goto</span> restart;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Don&#x27;t let big-order allocations loop unless the caller explicitly</span><br><span class="hljs-comment"> * requests that.  Wait for some write requests to complete then retry.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * In this implementation, __GFP_REPEAT means __GFP_NOFAIL for order</span><br><span class="hljs-comment"> * &lt;= 3, but that may not be true in other implementations.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果内存分配请求不能被满足，那么函数决定是否应当继续扫描内存管理区。</span><br><span class="hljs-comment"> * 如果__GFP_NORETRY被清除，并且内存分配请求跨越了多达8个页框或者__GFP_REPEAT被置位，或者__GFP_NOFAIL被置位。</span><br><span class="hljs-comment"> */</span><br>do_retry = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (!(gfp_mask &amp; __GFP_NORETRY)) &#123;<br><span class="hljs-keyword">if</span> ((order &lt;= <span class="hljs-number">3</span>) || (gfp_mask &amp; __GFP_REPEAT))<br>do_retry = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (gfp_mask &amp; __GFP_NOFAIL)<br>do_retry = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 要重试，就调用blk_congestion_wait 使进程休眠一会。再跳到rebalance 重试。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (do_retry) &#123;<br>blk_congestion_wait(WRITE, HZ/<span class="hljs-number">50</span>);<br><span class="hljs-keyword">goto</span> rebalance;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 既然不用重试，那就执行到nopage 返回NULL 了。</span><br><span class="hljs-comment"> */</span><br>nopage:<br><span class="hljs-keyword">if</span> (!(gfp_mask &amp; __GFP_NOWARN) &amp;&amp; printk_ratelimit()) &#123;<br>printk(KERN_WARNING <span class="hljs-string">&quot;%s: page allocation failure.&quot;</span><br><span class="hljs-string">&quot; order:%d, mode:0x%x\n&quot;</span>,<br>p-&gt;comm, order, gfp_mask);<br>dump_stack();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>got_pg:<br>zone_statistics(zonelist, z);<br><span class="hljs-keyword">return</span> page;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Return 1 if free pages are above &#x27;mark&#x27;. This takes into account the order</span><br><span class="hljs-comment"> * of the allocation.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * zone_watermark_ok辅助函数接收几个参数，它们决定内存管理区中空闲页框个数的阀值min。</span><br><span class="hljs-comment"> * 特别的，如果满足下列两个条件，则该函数返回1：</span><br><span class="hljs-comment"> *     1、除了被分配的页框外，在内存管理区中至少还有min个空闲页框，不包括为内存不足保留的页框（zone的lowmem_reserve字段）。</span><br><span class="hljs-comment"> *     2、除了被分配的页框外，这里在order至少为k的块中，起码还有min/2^k个空闲页框。其中对每个k，取值在1和order之间。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 作为参数传递的基本值可以是内存管理区界值pages_min,pages_low,pages_high中的任意一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">zone_watermark_ok</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *z, <span class="hljs-type">int</span> order, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mark,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> classzone_idx, <span class="hljs-type">int</span> can_try_harder, <span class="hljs-type">int</span> gfp_high)</span><br>&#123;<br><span class="hljs-comment">/* free_pages my go negative - that&#x27;s OK */</span><br><span class="hljs-type">long</span> min = mark, free_pages = z-&gt;free_pages - (<span class="hljs-number">1</span> &lt;&lt; order) + <span class="hljs-number">1</span>; <span class="hljs-comment">/*free_pages是除了要分配的页框(1&lt;&lt;order)后剩余的空闲页面*/</span><br><span class="hljs-type">int</span> o;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果gfp_high标志被置位。则base除2。</span><br><span class="hljs-comment"> * 注意这里不是：min /= 2;</span><br><span class="hljs-comment"> * 一般来说，如果gfp_mask的__GFP_HIGH标志被置位，那么这个标志就会为1</span><br><span class="hljs-comment"> * 换句话说，就是指从高端内存中分配。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (gfp_high)<br>min -= min / <span class="hljs-number">2</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果作为参数传递的can_try_harder标志被置位，这个值再减少1/4</span><br><span class="hljs-comment"> * can_try_harder=1一般是当：gfp_mask中的__GFP_WAIT标志被置位，或者当前进程是一个实时进程并且在进程上下文中已经完成了内存分配。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (can_try_harder)<br>min -= min / <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 除了被分配的页框外，在内存管理区中至少还有min个空闲页框，不包括为内存不足保留的页框（zone的lowmem_reserve字段）。</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">if</span> (free_pages &lt;= min + z-&gt;lowmem_reserve[classzone_idx])<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 除了被分配的页框外，这里在order至少为k的块中，起码还有min/2^k个空闲页框。其中对每个k，取值在1和order之间。</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">for</span> (o = <span class="hljs-number">0</span>; o &lt; order; o++) &#123;<br><span class="hljs-comment">/* At the next order, this order&#x27;s pages become unavailable */</span><br>free_pages -= z-&gt;free_area[o].nr_free &lt;&lt; o;<br><br><span class="hljs-comment">/* Require fewer higher order pages to be free */</span><br>min &gt;&gt;= <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (free_pages &lt;= min)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到整个zone的扫描策略非常复杂，但无论哪种情形，一旦满足了分配水位需求，就会调用</p><p><code>buffered_rmqueue</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回第一个被分配的页框的页描述符。如果内存管理区没有所请求大小的一组连续页框，则返回NULL。</span><br><span class="hljs-comment"> * 在指定的内存管理区中分配页框。它使用每CPU页框高速缓存来处理单一页框请求。</span><br><span class="hljs-comment"> * zone:内存管理区描述符的地址。</span><br><span class="hljs-comment"> * order：请求分配的内存大小的对数,0表示分配一个页框。</span><br><span class="hljs-comment"> * gfp_flags:分配标志，如果gfp_flags中的__GFP_COLD标志被置位，那么页框应当从冷高速缓存中获取，否则应当从热高速缓存中获取（只对单一页框请求有意义。）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<br><span class="hljs-title function_">buffered_rmqueue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">int</span> order, <span class="hljs-type">int</span> gfp_flags)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> cold = !!(gfp_flags &amp; __GFP_COLD);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果order!=0，则每CPU页框高速缓存就不能被使用。</span><br><span class="hljs-comment"> * 因为高速缓存仅限于单页分配，这是固有的设计，就是为了加速单页请求分配的效率。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (order == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pages</span> *<span class="hljs-title">pcp</span>;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查由__GFP_COLD标志所标识的内存管理区本地CPU高速缓存是否需要被补充。</span><br><span class="hljs-comment"> * 其count字段小于或者等于low</span><br><span class="hljs-comment"> */</span><br>pcp = &amp;zone-&gt;pageset[get_cpu()].pcp[cold];<br>local_irq_save(flags);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当前缓存中的页框数低于low，需要从伙伴系统中补充页框。</span><br><span class="hljs-comment"> * 调用rmqueue_bulk函数从伙伴系统中分配batch个单一页框</span><br><span class="hljs-comment"> * rmqueue_bulk反复调用__rmqueue，直到缓存的页框达到low。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (pcp-&gt;count &lt;= pcp-&gt;low)<br>pcp-&gt;count += rmqueue_bulk(zone, <span class="hljs-number">0</span>,<br>pcp-&gt;batch, &amp;pcp-&gt;<span class="hljs-built_in">list</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果count为正，函数从高速缓存链表中获得一个页框。</span><br><span class="hljs-comment"> * count减1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (pcp-&gt;count) &#123;<br>page = list_entry(pcp-&gt;<span class="hljs-built_in">list</span>.next, <span class="hljs-keyword">struct</span> page, lru);<br>list_del(&amp;page-&gt;lru);<br>pcp-&gt;count--;<br>&#125;<br>local_irq_restore(flags);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有和get_cpu配对使用呢？</span><br><span class="hljs-comment"> * 这就是内核，外层一定调用了get_cpu。这种代码看起来头疼。</span><br><span class="hljs-comment"> */</span><br>put_cpu();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存请求没有得到满足，或者是因为请求跨越了几个连续页框，或者是因为被选中的页框高速缓存为空。</span><br><span class="hljs-comment"> * 调用__rmqueue函数(因为已经保护了，直接调用__rmqueue即可)从伙伴系统中分配所请求的页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (page == <span class="hljs-literal">NULL</span>) &#123;<br>spin_lock_irqsave(&amp;zone-&gt;lock, flags);<br>page = __rmqueue(zone, order);<br>spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果内存请求得到满足，函数就初始化（第一个）页框的页描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (page != <span class="hljs-literal">NULL</span>) &#123;<br>BUG_ON(bad_range(zone, page));<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将第一个页清除一些标志，将private字段置0，并将页框引用计数器置1。</span><br><span class="hljs-comment"> */</span><br>mod_page_state_zone(zone, pgalloc, <span class="hljs-number">1</span> &lt;&lt; order);<br>prep_new_page(page, order);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果__GFP_ZERO标志被置位，则将被分配的区域填充0。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (gfp_flags &amp; __GFP_ZERO)<br>prep_zero_page(page, order, gfp_flags);<br><br><span class="hljs-keyword">if</span> (order &amp;&amp; (gfp_flags &amp; __GFP_COMP))<br>prep_compound_page(page, order);<br>&#125;<br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了每CPU页框高速缓存的分配以外，重点就是<code>__rmqueue</code>这个函数，该函数实际上就是通往伙伴系统的分配接口。另一方面，每CPU页框高速缓存在分配时也会检查当前预存量的水位，如果不足也会调用相应的到伙伴系统的接口去批量申请页框。</p><p>关于伙伴系统的<code>__rmqueue</code>，我们过后再深入分析。</p><p>####Appendix</p><p><code>gfp_mask</code>flags:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * GFP bitmasks..</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Zone modifiers in GFP_ZONEMASK (see linux/mmzone.h - low two bits) */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所请求的页框必须处于ZONE_DMA管理区。等价于GFP_DMA</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_DMA0x01</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所请求的页框处于ZONE_HIGHMEM管理区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_HIGHMEM0x02</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Action modifiers - doesn&#x27;t change the zoning</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * __GFP_REPEAT: Try hard to allocate the memory, but the allocation attempt</span><br><span class="hljs-comment"> * _might_ fail.  This depends upon the particular VM implementation.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * __GFP_NOFAIL: The VM implementation _must_ retry infinitely: the caller</span><br><span class="hljs-comment"> * cannot handle allocation failures.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * __GFP_NORETRY: The VM implementation must not retry indefinitely.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 允许内核对等待空闲页框的当前进程进行阻塞</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_WAIT0x10<span class="hljs-comment">/* Can wait and reschedule? */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 允许内核访问保留的页框池</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_HIGH0x20<span class="hljs-comment">/* Should access emergency pools? */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 允许内核在低端内存上执行IO传输以释放页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_IO0x40<span class="hljs-comment">/* Can start physical IO? */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果清0,则不允许内核执行依赖于文件系统的操作。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_FS0x80<span class="hljs-comment">/* Can call down to low-level FS? */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所请求的页可能为&quot;冷&quot;的。即不在高速缓存中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_COLD0x100<span class="hljs-comment">/* Cache-cold page required */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一次内存分配失败将不会产生警告信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_NOWARN0x200<span class="hljs-comment">/* Suppress page allocation failure warning */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内核重试内存分配直到成功。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_REPEAT0x400<span class="hljs-comment">/* Retry the allocation.  Might fail */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 与__GFP_REPEAT相同</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_NOFAIL0x800<span class="hljs-comment">/* Retry for ever.  Cannot fail */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一次内存分配失败后不再重试。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_NORETRY0x1000<span class="hljs-comment">/* Do not retry.  Might fail */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Slab分配器不允许增大slab高速缓存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_NO_GROW0x2000<span class="hljs-comment">/* Slab internal usage */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 属于扩展页的页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_COMP0x4000<span class="hljs-comment">/* Add compound page metadata */</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 任何返回的页框必须被填满0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GFP_ZERO0x8000<span class="hljs-comment">/* Return zeroed page on success */</span></span><br></code></pre></td></tr></table></figure><p>###释放接口</p><p>再看释放：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先检查page指向的页描述符。</span><br><span class="hljs-comment"> * 如果该页框未被保留，就把描述符的count字段减1</span><br><span class="hljs-comment"> * 如果count变为0,就假定从与page对应的页框开始的2^order个连续页框不再被使用。</span><br><span class="hljs-comment"> * 这种情况下，该函数释放页框。</span><br><span class="hljs-comment"> */</span><br>fastcall <span class="hljs-type">void</span> __free_pages(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * 如果是保留的页框或者引用计数-1不为0，则不用释放页框。</span><br><span class="hljs-comment">   * 前者是因为保留页框本来就不用释放（通过flags的PG_reserved位标识），</span><br><span class="hljs-comment">   * 后者是因为当前尚有进程引用该页框（比如经典的父子进程）</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PageReserved</span>(page) &amp;&amp; <span class="hljs-built_in">put_page_testzero</span>(page)) &#123;<br><span class="hljs-keyword">if</span> (order == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">free_hot_page</span>(page);<br><span class="hljs-keyword">else</span><br>__free_pages_ok(page, order);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 类似于__free_pages，但是它接收的参数为要释放的第一个页框的线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">fastcall <span class="hljs-type">void</span> <span class="hljs-title">free_pages</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (addr != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">BUG_ON</span>(!<span class="hljs-built_in">virt_addr_valid</span>((<span class="hljs-type">void</span> *)addr));<br>__free_pages(<span class="hljs-built_in">virt_to_page</span>((<span class="hljs-type">void</span> *)addr), order);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* 和alloc相反，此时用virt_to_page来从线性地址到page进行转换，本质上调用依然是__free_pages */</span><br><br><span class="hljs-comment">/* 衍生出的另两个order为0的特例 */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放page指向的页框</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __free_page(page) __free_pages((page), 0)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放线性地址addr对应的页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> free_page(addr) free_pages((addr),0)</span><br></code></pre></td></tr></table></figure><p>所以还是看__free_pages，对于order为0的情况，最终cold参数为0进入free_hot_cold_page中：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> fastcall <span class="hljs-title">free_hot_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// cold为0，表示是热高速缓存</span><br><span class="hljs-built_in">free_hot_cold_page</span>(page, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放单个页框到页框高速缓存。</span><br><span class="hljs-comment"> * page-要释放的页框描述符地址。</span><br><span class="hljs-comment"> * cold-释放到热高速缓存还是冷高速缓存中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> fastcall <span class="hljs-title">free_hot_cold_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">int</span> cold)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * page_zone从page-&gt;flag中，获得page所在的内存管理区描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">zone</span> *zone = <span class="hljs-built_in">page_zone</span>(page);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pages</span> *pcp;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br><span class="hljs-built_in">arch_free_page</span>(page, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">kernel_map_pages</span>(page, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">inc_page_state</span>(pgfree);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">PageAnon</span>(page))<br>page-&gt;mapping = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">free_pages_check</span>(__FUNCTION__, page);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 冷高速缓存还是热高速缓存??</span><br><span class="hljs-comment"> */</span><br>pcp = &amp;zone-&gt;pageset[<span class="hljs-built_in">get_cpu</span>()].pcp[cold];<br><span class="hljs-built_in">local_irq_save</span>(flags);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果缓存的页框太多，就清除一些。</span><br><span class="hljs-comment"> * 调用free_pages_bulk将这些页框释放给伙伴系统。</span><br><span class="hljs-comment"> * 当然，需要更新一下count计数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (pcp-&gt;count &gt;= pcp-&gt;high)<br>pcp-&gt;count -= <span class="hljs-built_in">free_pages_bulk</span>(zone, pcp-&gt;batch, &amp;pcp-&gt;list, <span class="hljs-number">0</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将释放的页框加到高速缓存链表上。并增加count字段。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">list_add</span>(&amp;page-&gt;lru, &amp;pcp-&gt;list);<br>pcp-&gt;count++;<br><span class="hljs-built_in">local_irq_restore</span>(flags);<br><span class="hljs-built_in">put_cpu</span>();<br>&#125;<br></code></pre></td></tr></table></figure>对order为0也就是单页释放的情况，和分配时策略相同，都是最终释放到每CPU页框高速缓存。此外，释放时也会做相反的判断，如果当前预留量过多了，就还给伙伴系统一些。而释放给伙伴系统的核心在于<code>free_pages_bulk</code>，这涉及到伙伴系统的策略，过后再研究。</p><blockquote><p>到这里，透过代码也就不难看出，每CPU页框高速缓存的管理类似zone，也有自己的阈值，判断水位高低的策略，这与zone分配器的扫描策略十分相似。</p><p>更多详细可以展开每CPU页框高速缓存的结构体与内部函数，这里限于篇幅不展开了。</p></blockquote><p>对于order不为0的，核心也是<code>free_page_bulk</code>，说白了还是释放给伙伴系统：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> __free_pages_ok(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br><span class="hljs-built_in">LIST_HEAD</span>(list);<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-built_in">arch_free_page</span>(page, order);<br><br><span class="hljs-built_in">mod_page_state</span>(pgfree, <span class="hljs-number">1</span> &lt;&lt; order);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><br><span class="hljs-keyword">if</span> (order &gt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span> ; i &lt; (<span class="hljs-number">1</span> &lt;&lt; order) ; ++i)<br>__put_page(page + i);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> ; i &lt; (<span class="hljs-number">1</span> &lt;&lt; order) ; ++i)<br><span class="hljs-built_in">free_pages_check</span>(__FUNCTION__, page + i);<br><span class="hljs-built_in">list_add</span>(&amp;page-&gt;lru, &amp;list);<br><span class="hljs-built_in">kernel_map_pages</span>(page, <span class="hljs-number">1</span>&lt;&lt;order, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">free_pages_bulk</span>(<span class="hljs-built_in">page_zone</span>(page), <span class="hljs-number">1</span>, &amp;list, order);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="appendix">Appendix</h4><p><code>virt_to_page</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将内核逻辑地址转换为相应的page结构指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> virt_to_page(kaddr)pfn_to_page(__pa(kaddr) &gt;&gt; PAGE_SHIFT)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __pa(x)((unsigned long)(x)-PAGE_OFFSET)<span class="hljs-comment">//PAGE_OFFSET = 0xC0000000</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pfn_to_page(pfn)(mem_map + (pfn))<span class="hljs-comment">//由页框号+mem_map得到描述符page， mem_map就是存放page的数组，根据number索引</span></span><br></code></pre></td></tr></table></figure><h2 id="zone_highmem内核映射">ZONE_HIGHMEM内核映射</h2><p>high_memory变量存放HIGHMEM起始地址，设置为896M。896MB边界以上的pageframe无法直接映射在内核线性地址空间，因此内核无法直接访问。因此，<code>__get_free_pages</code>等函数对此情形并不适用（32位的系统中，因为<code>__get_free_pages()</code>无法返回一个不存在的线性地址（会溢出0xFFFFFFFF）转而返回NULL，会造成pageframe的丢失）。</p><p>为了32位系统内核可以使用HIGHMEM，做了一种映射的机制。约定如下： 1.只用<code>alloc_pages</code>,<code>alloc_page</code>分配HIGHMEM的内存页框，虽然线性地址不存在，但是页描述符page的线性地址存在，这个东西在一开始就分配到NON-HIGHMEM区了。2.内核线性地址空间的最后128MB的一部分用于映射HIGHMEM的页框。线性地址对页框是一对多的，映射是暂时性的（如果都是永久的，那肯定不够用）。</p><p>当内核想访问高于896M的物理地址内存时，会从0xF8000000~0xFFFFFFFF空间范围内找一段相应大小空闲的地址空间，暂借一会儿，用毕归还。这就相当于坑位就那么多，大家轮着用。</p><p>内核有3种机制映射高端内存的页框：永久内核映射、临时内核映射和非连续内存分配。目前只关心前两种。</p><blockquote><p>实际上896M只是个上限值，不一定真的会分配这么多给NORMAL，毕竟有时候物理内存没有这么大，这个值会根据真实物理内存大小动态计算出来。</p></blockquote><p>内核1GB线性地址空间划分如图：</p><p><img src="20171020_4.jpg" /></p><ul><li>PAGE_OFFSET ~ high_memory: 16~896MB直接映射</li><li>VMALLOC_START ~ VMALLOC_END: 非连续内存分配</li><li>KMAP_BASE ~ FIXADDR_START: 永久内核映射</li><li>FIXADDR_START ~4GB:固定映射线性地址空间（FIX_KMAP区域为临时内核映射）</li></ul><h3 id="永久内核映射">永久内核映射</h3><p>在2.6内核上, 这个地址范围是4G-8M到4G-4M之间.这个空间起叫”内核永久映射空间”或者”永久内核映射空间”,这个空间和其它空间使用同样的页目录表，对于内核来说，就是<code>swapper_pg_dir</code>，对普通进程来说，通过 CR3寄存器指向。通常情况下，这个空间是 4M大小，因此仅仅需要一个页表即可，内核通过来 <code>pkmap_page_table</code>寻找这个页表。通过 <code>kmap()</code>，可以把一个 page映射到这个空间来。由于这个空间是 4M 大小，最多能同时映射1024 个page。因此，对于不使用的的page，及应该时从这个空间释放掉（也就是解除映射关系），通过<code>kunmap()</code>，可以把一个page 对应的线性地址从这个空间释放出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于建立永久内核映射的页表。</span><br><span class="hljs-comment"> * 这样，内核可以长期映射高端内存到内核地址空间中。</span><br><span class="hljs-comment"> * 页表中的表项数由LAST_PKMAP宏产生，取决于是否打开PAE，它的值可能是512或者1024，</span><br><span class="hljs-comment"> * 这样可能映射2MB或4MB的永久内核映射。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">pte_t</span> * pkmap_page_table;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Pkmap_count数组包含LAST_PKMAP个计数器，pkmap_page_table页表中每一项都有一个。</span><br><span class="hljs-comment"> * 它记录了永久内核映射使用了哪些页表项。</span><br><span class="hljs-comment"> * 它的值可能为：</span><br><span class="hljs-comment"> *0：对应的页表项没有映射任何高端内存页框，并且是可用的。</span><br><span class="hljs-comment"> *1：对应页表项没有映射任何高端内存，但是它仍然不可用。因为自从它最后一次使用以来，相应的TLB表还没有被刷新。</span><br><span class="hljs-comment"> *&gt;1：相应的页表项映射了一个高端内存页框。并且正好有n-1个内核正在使用这个页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> pkmap_count[LAST_PKMAP];<br></code></pre></td></tr></table></figure><p>映射起始地址从PKMAP_BASE开始: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 永久内核映射的线性地址起始处。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PKMAP_BASE ( (FIXADDR_BOOT_START - PAGE_SIZE*(LAST_PKMAP + 1)) &amp; PMD_MASK )</span><br></code></pre></td></tr></table></figure></p><p>内核使用<code>page_address_htable</code>散列表记录高端内存页框和线性地址的关系：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 本散列表记录了高端内存页框与永久内核映射映射包含的线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">page_address_slot</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> lh;<span class="hljs-comment">/* List of page_address_maps */</span><br><span class="hljs-type">spinlock_t</span> lock;<span class="hljs-comment">/* Protect this bucket&#x27;s list */</span><br>&#125; ____cacheline_aligned_in_smp page_address_htable[<span class="hljs-number">1</span>&lt;&lt;PA_HASH_ORDER];<br></code></pre></td></tr></table></figure>典型的list_head嵌入链表结构。实际上每个节点是<code>page_address_map</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Describes one page-&gt;virtual association</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page_address_map</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page;<br><span class="hljs-type">void</span> *<span class="hljs-keyword">virtual</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> list;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>####Appendix</p><p><code>page_address</code>函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * page_address返回页框对应的线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">page_address</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-type">void</span> *ret;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page_address_slot</span> *pas;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果页框不在高端内存中(PG_highmem标志为0)，则线性地址总是存在的。</span><br><span class="hljs-comment"> * 并且通过计算页框下标，然后将其转换成物理地址，最后根据物理地址得到线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PageHighMem</span>(page))<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 本句等价于__va((unsigned long)(page - mem_map) &lt;&lt; 12)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">lowmem_page_address</span>(page);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 否则页框在高端内存中(PG_highmem标志为1)，则到page_address_htable散列表中查找。</span><br><span class="hljs-comment"> */</span><br>pas = <span class="hljs-built_in">page_slot</span>(page);<br>ret = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">spin_lock_irqsave</span>(&amp;pas-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">list_empty</span>(&amp;pas-&gt;lh)) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page_address_map</span> *pam;<br><br><span class="hljs-built_in">list_for_each_entry</span>(pam, &amp;pas-&gt;lh, list) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在page_address_htable中找到，返回对应的物理地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (pam-&gt;page == page) &#123;<br>ret = pam-&gt;<span class="hljs-keyword">virtual</span>;<br><span class="hljs-keyword">goto</span> done;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有在page_address_htable中找到，返回默认值NULL。</span><br><span class="hljs-comment"> */</span><br>done:<br><span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;pas-&gt;lock, flags);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>kmap/kunmap</code>: 一目了然的设计 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 建立永久内核映射。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">kmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kmap是允许睡眠的，意思是说不能在中断和可延迟函数中调用。</span><br><span class="hljs-comment"> * 如果试图在中断中调用，那么might_sleep会触发异常。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">might_sleep</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果页框不属于高端内存，则调用page_address直接返回线性地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PageHighMem</span>(page))<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">page_address</span>(page);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 否则调用kmap_high真正建立永久内核映射。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">kmap_high</span>(page);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为高端内存建立永久内核映射。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> fastcall *<span class="hljs-title">kmap_high</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vaddr;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For highmem pages, we can&#x27;t trust &quot;virtual&quot; until</span><br><span class="hljs-comment"> * after we have the lock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * We cannot call this from interrupts, as it may block</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个函数不会在中断中调用，也不能在中断中调用。</span><br><span class="hljs-comment"> * 所以，在这里只需要获取自旋锁就行了。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_lock</span>(&amp;kmap_lock);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * page_address有检查页框是否被映射的作用。</span><br><span class="hljs-comment"> */</span><br>vaddr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">page_address</span>(page);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有被映射，就调用map_new_virtual把页框的物理地址插入到pkmap_page_table的一个项中。</span><br><span class="hljs-comment"> * 并在page_address_htable散列表中加入一个元素。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!vaddr)<br>vaddr = <span class="hljs-built_in">map_new_virtual</span>(page);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使页框的线性地址所对应的计数器加1.</span><br><span class="hljs-comment"> */</span><br>pkmap_count[<span class="hljs-built_in">PKMAP_NR</span>(vaddr)]++;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初次映射时,map_new_virtual中会将计数置为1,上一句再加1.</span><br><span class="hljs-comment"> * 多次映射时,计数值会再加1.</span><br><span class="hljs-comment"> * 总之,计数值决不会小于2.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (pkmap_count[<span class="hljs-built_in">PKMAP_NR</span>(vaddr)] &lt; <span class="hljs-number">2</span>)<br><span class="hljs-built_in">BUG</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放自旋锁.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">spin_unlock</span>(&amp;kmap_lock);<br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*) vaddr;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为建立永久内核映射建立初始映射.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">map_new_virtual</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vaddr;<br><span class="hljs-type">int</span> count;<br><br>start:<br>count = LAST_PKMAP;<br><span class="hljs-comment">/* Find an empty entry */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扫描pkmap_count中的所有计数器值,直到找到一个空值.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从上次结束的地方开始搜索.</span><br><span class="hljs-comment"> */</span><br>last_pkmap_nr = (last_pkmap_nr + <span class="hljs-number">1</span>) &amp; LAST_PKMAP_MASK;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 搜索到最后一位了.在从0开始搜索前,刷新计数为1的项.</span><br><span class="hljs-comment"> * 当计数值为1表示页表项可用,但是对应的TLB还没有刷新.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!last_pkmap_nr) &#123;<br><span class="hljs-built_in">flush_all_zero_pkmaps</span>();<br>count = LAST_PKMAP;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 找到计数为0的页表项,表示该页空闲且可用.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!pkmap_count[last_pkmap_nr])<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">/* Found a usable entry */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * count是允许的搜索次数.如果还允许继续搜索下一个页表项.则继续,否则表示没有空闲项,退出.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (--count)<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Sleep for somebody else to unmap their entries</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 运行到这里,表示没有找到空闲页表项.先睡眠一下.</span><br><span class="hljs-comment"> * 等待其他线程释放页表项,然后唤醒本线程.</span><br><span class="hljs-comment"> */</span><br>&#123;<br><span class="hljs-built_in">DECLARE_WAITQUEUE</span>(wait, current);<br><br>__set_current_state(TASK_UNINTERRUPTIBLE);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将当前线程挂到pkmap_map_wait等待队列上.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">add_wait_queue</span>(&amp;pkmap_map_wait, &amp;wait);<br><span class="hljs-built_in">spin_unlock</span>(&amp;kmap_lock);<br><span class="hljs-built_in">schedule</span>();<br><span class="hljs-built_in">remove_wait_queue</span>(&amp;pkmap_map_wait, &amp;wait);<br><span class="hljs-built_in">spin_lock</span>(&amp;kmap_lock);<br><br><span class="hljs-comment">/* Somebody else might have mapped it while we slept */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在当前线程等待的过程中,其他线程可能已经将页面进行了映射.</span><br><span class="hljs-comment"> * 检测一下,如果已经映射了,就退出.</span><br><span class="hljs-comment"> * 注意,这里没有对kmap_lock进行解锁操作.关于kmap_lock锁的操作,需要结合kmap_high来分析.</span><br><span class="hljs-comment"> * 总的原则是:进入本函数时保证关锁,然后在本句前面关锁,本句后面解锁.</span><br><span class="hljs-comment"> * 在函数返回后,锁仍然是关的.则外层解锁.</span><br><span class="hljs-comment"> * 即使在本函数中循环也是这样.</span><br><span class="hljs-comment"> * 内核就是这么乱,看久了就习惯了.不过你目前可能必须得学着适应这种代码.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">page_address</span>(page))<br><span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">page_address</span>(page);<br><br><span class="hljs-comment">/* Re-start */</span><br><span class="hljs-keyword">goto</span> start;<br>&#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不管何种路径运行到这里来,kmap_lock都是锁着的.</span><br><span class="hljs-comment"> * 并且last_pkmap_nr对应的是一个空闲且可用的表项.</span><br><span class="hljs-comment"> */</span><br>vaddr = <span class="hljs-built_in">PKMAP_ADDR</span>(last_pkmap_nr);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置页表属性,建立虚拟地址和物理地址之间的映射.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">set_pte</span>(&amp;(pkmap_page_table[last_pkmap_nr]), <span class="hljs-built_in">mk_pte</span>(page, kmap_prot));<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1表示相应的项可用,但是TLB需要刷新.</span><br><span class="hljs-comment"> * 但是我们这里明明建立了映射,为什么还是可用的呢,其他地方不会将占用么?</span><br><span class="hljs-comment"> * 其实不用担心,因为返回kmap_high后,kmap_high函数会将它再加1.</span><br><span class="hljs-comment"> */</span><br>pkmap_count[last_pkmap_nr] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">set_page_address</span>(page, (<span class="hljs-type">void</span> *)vaddr);<br><br><span class="hljs-keyword">return</span> vaddr;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 撤销先前由kmap建立的永久内核映射</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kunmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kmap和kunmap都不允许在中断中使用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">in_interrupt</span>())<br><span class="hljs-built_in">BUG</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果对应页根本就不是高端内存，当然就没有进行内核映射，也就不用调用本函数了。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PageHighMem</span>(page))<br><span class="hljs-keyword">return</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kunmap_high真正执行unmap过程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">kunmap_high</span>(page);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解除高端内存的永久内核映射</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> fastcall <span class="hljs-title">kunmap_high</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vaddr;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr;<br><span class="hljs-type">int</span> need_wakeup;<br><br><span class="hljs-built_in">spin_lock</span>(&amp;kmap_lock);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 得到物理页对应的虚拟地址。</span><br><span class="hljs-comment"> */</span><br>vaddr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">page_address</span>(page);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * vaddr会==0，可能是内存越界等严重故障了吧。</span><br><span class="hljs-comment"> * BUG一下</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!vaddr)<br><span class="hljs-built_in">BUG</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据虚拟地址，找到页表项在pkmap_count中的序号。</span><br><span class="hljs-comment"> */</span><br>nr = <span class="hljs-built_in">PKMAP_NR</span>(vaddr);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * A count must never go down to zero</span><br><span class="hljs-comment"> * without a TLB flush!</span><br><span class="hljs-comment"> */</span><br>need_wakeup = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">switch</span> (--pkmap_count[nr]) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br><span class="hljs-built_in">BUG</span>();<span class="hljs-comment">/* 一定是逻辑错误了，多次调用了unmap */</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Avoid an unnecessary wake_up() function call.</span><br><span class="hljs-comment"> * The common case is pkmap_count[] == 1, but</span><br><span class="hljs-comment"> * no waiters.</span><br><span class="hljs-comment"> * The tasks queued in the wait-queue are guarded</span><br><span class="hljs-comment"> * by both the lock in the wait-queue-head and by</span><br><span class="hljs-comment"> * the kmap_lock.  As the kmap_lock is held here,</span><br><span class="hljs-comment"> * no need for the wait-queue-head&#x27;s lock.  Simply</span><br><span class="hljs-comment"> * test if the queue is empty.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 页表项可用了。need_wakeup会唤醒等待队列上阻塞的线程。</span><br><span class="hljs-comment"> */</span><br>need_wakeup = <span class="hljs-built_in">waitqueue_active</span>(&amp;pkmap_map_wait);<br>&#125;<br><span class="hljs-built_in">spin_unlock</span>(&amp;kmap_lock);<br><br><span class="hljs-comment">/* do wake-up, if needed, race-free outside of the spin lock */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 有等待线程，唤醒它。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (need_wakeup)<br><span class="hljs-built_in">wake_up</span>(&amp;pkmap_map_wait);<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="临时内核映射">临时内核映射</h3><p>内核在 FIXADDR_START 到 FIXADDR_TOP之间保留了一些线性空间用于特殊需求。这个空间称为”固定映射空间”在这个空间中，有一部分用于高端内存的临时映射。临时内核映射可以用在中断处理程序和可延迟函数内部，它们从不阻塞当前进程。</p><p>这块空间具有如下特点：</p><ol type="1"><li>每个 CPU 占用一块空间</li><li>在每个 CPU 占用的那块空间中，又分为多个小空间，每个小空间大小是 1 个page，每个小空间用于一个目的，这些目的定义在 kmap_types.h 中的<code>km_type</code> 中。</li></ol><p>任一页框都可以通过一个窗口映射到内核地址空间，这些窗口非常少。</p><p>每个CPU有自己的13个窗口集合： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_HIGHMEM</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> D(n) __KM_FENCE_##n ,</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> D(n)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 系统为每个CPU预留了13个临时内核映射页表项。这是它们在线性地址表中的下标。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">km_type</span> &#123;<br><span class="hljs-built_in">D</span>(<span class="hljs-number">0</span>)KM_BOUNCE_READ,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">1</span>)KM_SKB_SUNRPC_DATA,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">2</span>)KM_SKB_DATA_SOFTIRQ,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">3</span>)KM_USER0,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">4</span>)KM_USER1,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">5</span>)KM_BIO_SRC_IRQ,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">6</span>)KM_BIO_DST_IRQ,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">7</span>)KM_PTE0,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">8</span>)KM_PTE1,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">9</span>)KM_IRQ0,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">10</span>)KM_IRQ1,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">11</span>)KM_SOFTIRQ0,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">12</span>)KM_SOFTIRQ1,<br><span class="hljs-built_in">D</span>(<span class="hljs-number">13</span>)KM_TYPE_NR<br>&#125;;<br></code></pre></td></tr></table></figure>同一窗口永不会被两个不同的控制路径同时使用。km_type的每个符号都只能由一种内核成分使用，并以此而命名。KM_TYPE_NR不是线性地址，而是CPU产生可用窗口的个数。</p><p>这些符号都只是线性地址的一个下标: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">fixed_addresses</span> &#123;<br>FIX_HOLE,<br>FIX_VSYSCALL,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_LOCAL_APIC</span><br>FIX_APIC_BASE,<span class="hljs-comment">/* local (CPU) APIC) -- required for SMP or not */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_IO_APIC</span><br>FIX_IO_APIC_BASE_0,<br>FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + MAX_IO_APICS<span class="hljs-number">-1</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_VISWS_APIC</span><br>FIX_CO_CPU,<span class="hljs-comment">/* Cobalt timer */</span><br>FIX_CO_APIC,<span class="hljs-comment">/* Cobalt APIC Redirection Table */</span> <br>FIX_LI_PCIA,<span class="hljs-comment">/* Lithium PCI Bridge A */</span><br>FIX_LI_PCIB,<span class="hljs-comment">/* Lithium PCI Bridge B */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_F00F_BUG</span><br>FIX_F00F_IDT,<span class="hljs-comment">/* Virtual mapping for IDT */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_CYCLONE_TIMER</span><br>FIX_CYCLONE_TIMER, <span class="hljs-comment">/*cyclone timer register*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIGHMEM</span><br>FIX_KMAP_BEGIN,<span class="hljs-comment">/* reserved pte&#x27;s for temporary kernel mappings */</span><br>FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)<span class="hljs-number">-1</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ACPI_BOOT</span><br>FIX_ACPI_BEGIN,<br>FIX_ACPI_END = FIX_ACPI_BEGIN + FIX_ACPI_PAGES - <span class="hljs-number">1</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PCI_MMCONFIG</span><br>FIX_PCIE_MCFG,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>__end_of_permanent_fixed_addresses,<br><span class="hljs-comment">/* temporary boot-time mappings, used before ioremap() is functional */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NR_FIX_BTMAPS16</span><br>FIX_BTMAP_END = __end_of_permanent_fixed_addresses,<br>FIX_BTMAP_BEGIN = FIX_BTMAP_END + NR_FIX_BTMAPS - <span class="hljs-number">1</span>,<br>FIX_WP_TEST,<br>__end_of_fixed_addresses<br>&#125;;<br><br></code></pre></td></tr></table></figure>所以每个CPU都有KM_TYPE_NR个固定的映射线性地址。</p><p>当要进行一次临时映射的时候，需要指定映射的目的，根据映射目的，可以找到对应的小空间，然后把这个空间的地址作为映射地址。这意味着一次临时映射会导致以前的映射被覆盖。通过<code>kmap_atomic()</code>可实现临时映射:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 建立临时内核映射</span><br><span class="hljs-comment"> * type和CPU共同确定用哪个固定映射的线性地址映射请求页。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">kmap_atomic</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-keyword">enum</span> km_type type)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">fixed_addresses</span> idx;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vaddr;<br><br><span class="hljs-comment">/* even !CONFIG_PREEMPT needs this, for in_atomic in do_page_fault */</span><br><span class="hljs-built_in">inc_preempt_count</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果被映射的页不属于高端内存，当然用不着映射。直接返回线性地址就行了。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PageHighMem</span>(page))<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">page_address</span>(page);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过type和CPU确定线性地址。</span><br><span class="hljs-comment"> */</span><br>idx = type + KM_TYPE_NR*<span class="hljs-built_in">smp_processor_id</span>();<br>vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_HIGHMEM</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">pte_none</span>(*(kmap_pte-idx)))<br><span class="hljs-built_in">BUG</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将线性地址与页表项建立映射。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">set_pte</span>(kmap_pte-idx, <span class="hljs-built_in">mk_pte</span>(page, kmap_prot));<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当然，最后必须刷新一下TLB。然后才能返回线性地址。</span><br><span class="hljs-comment"> */</span><br>__flush_tlb_one(vaddr);<br><br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*) vaddr;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __fix_to_virt(x)(FIXADDR_TOP - ((x) &lt;&lt; PAGE_SHIFT))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIXADDR_TOP((unsigned long)__FIXADDR_TOP)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __FIXADDR_TOP0xfffff000</span><br></code></pre></td></tr></table></figure><p>撤销<code>kunmap_atomic</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 撤销内核临时映射</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kunmap_atomic</span><span class="hljs-params">(<span class="hljs-type">void</span> *kvaddr, <span class="hljs-keyword">enum</span> km_type type)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_HIGHMEM</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vaddr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) kvaddr &amp; PAGE_MASK;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">fixed_addresses</span> idx = type + KM_TYPE_NR*<span class="hljs-built_in">smp_processor_id</span>();<br><br><span class="hljs-keyword">if</span> (vaddr &lt; FIXADDR_START) &#123; <span class="hljs-comment">// FIXME</span><br><span class="hljs-built_in">dec_preempt_count</span>();<br><span class="hljs-built_in">preempt_check_resched</span>();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (vaddr != __fix_to_virt(FIX_KMAP_BEGIN+idx))<br><span class="hljs-built_in">BUG</span>();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * force other mappings to Oops if they&#x27;ll try to access</span><br><span class="hljs-comment"> * this pte without first remap it</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 取消映射并刷新TLB</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">pte_clear</span>(kmap_pte-idx);<br>__flush_tlb_one(vaddr);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 允许抢占，并检查调度点。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">dec_preempt_count</span>();<br><span class="hljs-built_in">preempt_check_resched</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>高端内存是物理内存的概念，无论何种映射，最终它映射到的是内核线性地址空间，和用户进程没有什么关系，不要混淆。</p><h2 id="buddy-system伙伴系统algorithm">BuddySystem（伙伴系统）Algorithm</h2><p>内存管理的经典问题：碎片化 两种解决方案： -非连续空闲页框映射到连续的线性地址 -定制一套体系处理空闲连续页框块，分配与回收</p><p>出于种种原因，Linux内核使用第二种方案（详见ULK，实际上一言以蔽之——第二种方案更契合Linux）。这个方案就是buddysystem。空闲页框分组为11个双向循环链表，每个链表存储大小为1,2,4,8,16,32,64,128,256,512,1024个连续的页框，形成块。每个块的第一个页框的首地址都是该块大小的整数倍。</p><p>涉及的数据结构主要是两个，前面提到的所有page数组mem_map以及free_area。关于mem_map，前面初始化的代码中可以看到它是整个node的page集合。而对于每个zone的page，都是node的page也就是mem_map的子集。zone的zone_mem_map成员就是在mem_map中的起始成员。另一方面，zone的free_area数组存储了这11个链(MAX_ORDER=11)。看一下free_area结构：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">free_area</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>free_list;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>nr_free;<br>&#125;;<br></code></pre></td></tr></table></figure>经典的list_head双向循环链表，该链表包含每个空闲页框块(2^k)的起始页框的page。指向链表中相邻元素的指针存放在page的lru字段中（lru在页非空闲时用于其它目的）。nr_free表示空闲块的个数。page中的private存放了块的order（private在非空闲时也用于其它目的）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span>&#123;<br>...<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 可用于正在使用页的内核成分（如在缓冲页的情况下，它是一个缓冲器头指针。）</span><br><span class="hljs-comment"> * 如果页是空闲的，则该字段由伙伴系统使用。</span><br><span class="hljs-comment"> * 当用于伙伴系统时，如果该页是一个2^k的空闲页块的第一个页，那么它的值就是k.</span><br><span class="hljs-comment"> * 这样，伙伴系统可以查找相邻的伙伴，以确定是否可以将空闲块合并成2^(k+1)大小的空闲块。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-keyword">private</span>;<span class="hljs-comment">/* Mapping-private opaque data:</span><br><span class="hljs-comment"> * usually used for buffer_heads</span><br><span class="hljs-comment"> * if PagePrivate set; used for</span><br><span class="hljs-comment"> * swp_entry_t if PageSwapCache</span><br><span class="hljs-comment"> * When page is free, this indicates</span><br><span class="hljs-comment"> * order in the buddy system.</span><br><span class="hljs-comment"> */</span><br>...<br>&#125;;<br></code></pre></td></tr></table></figure></p><h3 id="alloc">alloc</h3><p><code>__rmqueue()</code>负责在zone中找空闲块，顺着上次看到的<code>__alloc_pages</code>看下去，<code>__alloc_pages()=&gt;buffered_rmqueue()=&gt;__rmqueue()</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在管理区中找到一个空闲块。</span><br><span class="hljs-comment"> * 它需要两个参数：管理区描述符的地址和order。Order表示请求的空闲页块大小的对数值。</span><br><span class="hljs-comment"> * 如果页框被成功分配，则返回第一个被分配的页框的页描述符。否则返回NULL。</span><br><span class="hljs-comment"> * 本函数假设调用者已经禁止和本地中断并获得了自旋锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *__rmqueue(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">free_area</span> * area;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> current_order;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从所请求的order开始，扫描每个可用块链表进行循环搜索。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;<br>area = zone-&gt;free_area + current_order;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对应的空闲块链表为空，在更大的空闲块链表中进行循环搜索。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">list_empty</span>(&amp;area-&gt;free_list))<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 运行到此，说明有合适的空闲块。</span><br><span class="hljs-comment"> */</span><br>page = <span class="hljs-built_in">list_entry</span>(area-&gt;free_list.next, <span class="hljs-keyword">struct</span> page, lru);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先在空闲块链表中删除第一个页框描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">list_del</span>(&amp;page-&gt;lru);<br><span class="hljs-built_in">rmv_page_order</span>(page);<br>area-&gt;nr_free--;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 并减少空闲管理区的空闲页数量。</span><br><span class="hljs-comment"> */</span><br>zone-&gt;free_pages -= <span class="hljs-number">1UL</span> &lt;&lt; order;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果2^order空闲块链表中没有合适的空闲块，那么就是从更大的空闲链表中分配的。</span><br><span class="hljs-comment"> * 将剩余的空闲块分散到合适的链表中去。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">expand</span>(zone, page, order, current_order, area);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 直到循环结束都没有找到合适的空闲块，就返回NULL。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 由此也可以看到buddysystem的策略算法。优先在等尺寸链上找，如果找不到则采用类似glibc的“smallfirst，bestfit”策略，在更大的链上找，并进行切割。切割手法也很简单,简单来说，如果切割1024给256，那么切割后前512链到k=9的链，剩下的256链到k=8的链（都是基于pageframe对齐的，所以切割比glibc容易管理得多）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *<br><span class="hljs-built_in">expand</span>(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-keyword">struct</span> page *page,<br> <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-keyword">struct</span> free_area *area)<br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size = <span class="hljs-number">1</span> &lt;&lt; high;<br><br><span class="hljs-keyword">while</span> (high &gt; low) &#123;<br>area--;<br>high--;<br>size &gt;&gt;= <span class="hljs-number">1</span>;<br><span class="hljs-built_in">BUG_ON</span>(<span class="hljs-built_in">bad_range</span>(zone, &amp;page[size]));<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 后半部分(page[size])加入free_area-&gt;free_list中，并设定order</span><br><span class="hljs-comment">         * 前半部分(page)，继续进行分裂或者返回</span><br><span class="hljs-comment">         */</span><br><span class="hljs-built_in">list_add</span>(&amp;page[size].lru, &amp;area-&gt;free_list);<br>area-&gt;nr_free++;<br><span class="hljs-built_in">set_page_order</span>(&amp;page[size], high);<br>&#125;<br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="free">free</h3><p>释放使用<code>__free_pages_bulk()</code>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 按照伙伴系统的策略释放页框。</span><br><span class="hljs-comment"> * page-被释放块中所包含的第一个页框描述符的地址。</span><br><span class="hljs-comment"> * zone-管理区描述符的地址。</span><br><span class="hljs-comment"> * order-块大小的对数。</span><br><span class="hljs-comment"> * base-纯粹由于效率的原因而引入。其实可以从其他三个参数计算得出。</span><br><span class="hljs-comment"> * 该函数假定调用者已经禁止本地中断并获得了自旋锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __free_pages_bulk (<span class="hljs-keyword">struct</span> page *page, <span class="hljs-keyword">struct</span> page *base,<br><span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * page_idx包含块中第一个页框的下标。</span><br><span class="hljs-comment"> * 这是相对于管理区中的第一个页框而言的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_idx;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *coalesced;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * order_size用于增加管理区中空闲页框的计数器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> order_size = <span class="hljs-number">1</span> &lt;&lt; order;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(order))<br><span class="hljs-built_in">destroy_compound_page</span>(page, order);<br><br>page_idx = page - base;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 大小为2^k的块，它的线性地址都是2^k * 2 ^ 12的整数倍。</span><br><span class="hljs-comment"> * 相应的，它在管理区的偏移应该是2^k倍。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">BUG_ON</span>(page_idx &amp; (order_size - <span class="hljs-number">1</span>));<br><span class="hljs-built_in">BUG_ON</span>(<span class="hljs-built_in">bad_range</span>(zone, page));<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 增加管理区的空闲页数</span><br><span class="hljs-comment"> */</span><br>zone-&gt;free_pages += order_size;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 最多循环10 - order次。每次都将一个块和它的伙伴进行合并。</span><br><span class="hljs-comment"> * 每次从最小的块开始，向上合并。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">while</span> (order &lt; MAX_ORDER<span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">free_area</span> *area;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *buddy;<br><span class="hljs-type">int</span> buddy_idx;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 最小块的下标。它是要合并的块的伙伴。</span><br><span class="hljs-comment"> * 注意异或操作的用法，是如何用来寻找伙伴的。</span><br><span class="hljs-comment"> * 相当于在page_idx加上或者减去1 &lt;&lt; order的距离就是buddy_idx</span><br><span class="hljs-comment"> */</span><br>buddy_idx = (page_idx ^ (<span class="hljs-number">1</span> &lt;&lt; order));<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过伙伴的下标找到页描述符的地址。</span><br><span class="hljs-comment"> */</span><br>buddy = base + buddy_idx;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">bad_range</span>(zone, buddy))<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断伙伴块是否是大小为order的空闲页框的第一个页。</span><br><span class="hljs-comment"> * 首先，伙伴的第一个页必须是空闲的(_count == -1)</span><br><span class="hljs-comment"> * 同时，必须属于动态内存(PG_reserved被清0,PG_reserved为1表示留给内核或者没有使用)</span><br><span class="hljs-comment"> * 最后，其private字段必须是order</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">page_is_buddy</span>(buddy, order))<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 运行到这里，说明伙伴块可以与当前块合并。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Move the buddy up one level. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 伙伴将被合并，将它从现有链表中取下。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">list_del</span>(&amp;buddy-&gt;lru);<br>area = zone-&gt;free_area + order;<br>area-&gt;nr_free--;<br><span class="hljs-built_in">rmv_page_order</span>(buddy);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 计算parent_idx</span><br><span class="hljs-comment">         */</span><br>page_idx &amp;= buddy_idx;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将合并了的块再与它的伙伴进行合并。</span><br><span class="hljs-comment"> */</span><br>order++;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 伙伴不能与当前块合并。</span><br><span class="hljs-comment"> * 将块插入适当的链表，并以块大小的order更新第一个页框的private字段。</span><br><span class="hljs-comment"> */</span><br>coalesced = base + page_idx;<br><span class="hljs-built_in">set_page_order</span>(coalesced, order);<br><span class="hljs-built_in">list_add</span>(&amp;coalesced-&gt;lru, &amp;zone-&gt;free_area[order].free_list);<br>zone-&gt;free_area[order].nr_free++;<br>&#125;<br></code></pre></td></tr></table></figure> 理解了buddysystem的策略，代码也就一目了然了。调用链：<code>__free_pages()=&gt;__free_pages_ok()=&gt;free_pages_bulk()=&gt;__free_pages_bulk()</code>。</p><h2 id="cpu页框高速缓存">CPU页框高速缓存</h2><p>内核经常请求或释放单个页框（对应order=0的情况），为了提升性能，内存管理区定义了一个每CPU页框高速缓存用于包含一些预先分配的页框。我们先前在ZonedPage Frame分配器中的分配和释放操作代码中已经看过了。Linux为每个内存管理区和每CPU提供了两个高速缓存：热高速和冷高速。两种类型针对不同的请求而设计。</p><p>zone的<code>pageset</code>成员保存了两个高速缓存： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 管理区每CPU页框高速缓存描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pageset</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 热高速缓存和冷高速缓存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pages</span> pcp[<span class="hljs-number">2</span>];<span class="hljs-comment">/* 0: hot.  1: cold */</span><br>&#125; ____cacheline_aligned_in_smp;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存管理区页框高速缓存描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pages</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 高速缓存中的页框个数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> count;<span class="hljs-comment">/* number of pages in the list */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 下界，低于此就需要补充高速缓存。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> low;<span class="hljs-comment">/* low watermark, refill needed */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 上界，高于此则向伙伴系统释放页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> high;<span class="hljs-comment">/* high watermark, emptying needed */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当需要增加或者减少高速缓存页框时，操作的页框个数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> batch;<span class="hljs-comment">/* chunk size for buddy add/remove */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 高速缓存中包含的页框描述符链表。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> list;<span class="hljs-comment">/* the list of pages */</span><br>&#125;;<br></code></pre></td></tr></table></figure></p><h3 id="alloc-1">alloc</h3><p>回顾一下处理<code>order==0</code>时使用CPU页框高速缓存分配的场景：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回第一个被分配的页框的页描述符。如果内存管理区没有所请求大小的一组连续页框，则返回NULL。</span><br><span class="hljs-comment"> * 在指定的内存管理区中分配页框。它使用每CPU页框高速缓存来处理单一页框请求。</span><br><span class="hljs-comment"> * zone:内存管理区描述符的地址。</span><br><span class="hljs-comment"> * order：请求分配的内存大小的对数,0表示分配一个页框。</span><br><span class="hljs-comment"> * gfp_flags:分配标志，如果gfp_flags中的__GFP_COLD标志被置位，那么页框应当从冷高速缓存中获取，否则应当从热高速缓存中获取（只对单一页框请求有意义。）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *<br><span class="hljs-built_in">buffered_rmqueue</span>(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">int</span> order, <span class="hljs-type">int</span> gfp_flags)<br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> cold = !!(gfp_flags &amp; __GFP_COLD);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果order!=0，则每CPU页框高速缓存就不能被使用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (order == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pages</span> *pcp;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查由__GFP_COLD标志所标识的内存管理区本地CPU高速缓存是否需要被补充。</span><br><span class="hljs-comment"> * 其count字段小于或者等于low</span><br><span class="hljs-comment"> */</span><br>pcp = &amp;zone-&gt;pageset[<span class="hljs-built_in">get_cpu</span>()].pcp[cold];<br><span class="hljs-built_in">local_irq_save</span>(flags);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当前缓存中的页框数低于low，需要从伙伴系统中补充页框。</span><br><span class="hljs-comment"> * 调用rmqueue_bulk函数从伙伴系统中分配batch个单一页框</span><br><span class="hljs-comment"> * rmqueue_bulk反复调用__rmqueue，直到缓存的页框达到low。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (pcp-&gt;count &lt;= pcp-&gt;low)<br>pcp-&gt;count += <span class="hljs-built_in">rmqueue_bulk</span>(zone, <span class="hljs-number">0</span>,<br>pcp-&gt;batch, &amp;pcp-&gt;list);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果count为正，函数从高速缓存链表中获得一个页框。</span><br><span class="hljs-comment"> * count减1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* 这就是分配的核心了，直接操作就行了，哪那么多__rmqueue，所以快 */</span><br><span class="hljs-keyword">if</span> (pcp-&gt;count) &#123;<br>page = <span class="hljs-built_in">list_entry</span>(pcp-&gt;list.next, <span class="hljs-keyword">struct</span> page, lru);<br><span class="hljs-built_in">list_del</span>(&amp;page-&gt;lru);<br>pcp-&gt;count--;<br>&#125;<br><span class="hljs-built_in">local_irq_restore</span>(flags);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有和get_cpu配对使用呢？</span><br><span class="hljs-comment"> * 这就是内核，外层一定调用了get_cpu。这种代码看起来头疼。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">put_cpu</span>();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内存请求没有得到满足，或者是因为请求跨越了几个连续页框，或者是因为被选中的页框高速缓存为空。</span><br><span class="hljs-comment"> * 调用__rmqueue函数(因为已经保护了，直接调用__rmqueue即可)从伙伴系统中分配所请求的页框。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (page == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">spin_lock_irqsave</span>(&amp;zone-&gt;lock, flags);<br>page = __rmqueue(zone, order);<br><span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;zone-&gt;lock, flags);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果内存请求得到满足，函数就初始化（第一个）页框的页描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (page != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">BUG_ON</span>(<span class="hljs-built_in">bad_range</span>(zone, page));<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将第一个页清除一些标志，将private字段置0，并将页框引用计数器置1。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">mod_page_state_zone</span>(zone, pgalloc, <span class="hljs-number">1</span> &lt;&lt; order);<br><span class="hljs-built_in">prep_new_page</span>(page, order);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果__GFP_ZERO标志被置位，则将被分配的区域填充0。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (gfp_flags &amp; __GFP_ZERO)<br><span class="hljs-built_in">prep_zero_page</span>(page, order, gfp_flags);<br><br><span class="hljs-keyword">if</span> (order &amp;&amp; (gfp_flags &amp; __GFP_COMP))<br><span class="hljs-built_in">prep_compound_page</span>(page, order);<br>&#125;<br><span class="hljs-keyword">return</span> page;<br>&#125;<br><br><span class="hljs-comment">//展开看补充页框的操作，实际上也是通过__rmqueue操作的，通过拿到的page-&gt;lru链到传入的pcp-&gt;list：</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">rmqueue_bulk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count, <span class="hljs-keyword">struct</span> list_head *list)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> allocated = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">page</span> *page;<br><br><span class="hljs-built_in">spin_lock_irqsave</span>(&amp;zone-&gt;lock, flags);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>page = __rmqueue(zone, order);<br><span class="hljs-keyword">if</span> (page == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">break</span>;<br>allocated++;<br><span class="hljs-built_in">list_add_tail</span>(&amp;page-&gt;lru, list);<br>&#125;<br><span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;zone-&gt;lock, flags);<br><span class="hljs-keyword">return</span> allocated;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="free-1">free</h3><p>再回顾一下free：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先检查page指向的页描述符。</span><br><span class="hljs-comment"> * 如果该页框未被保留，就把描述符的count字段减1</span><br><span class="hljs-comment"> * 如果count变为0,就假定从与page对应的页框开始的2^order个连续页框不再被使用。</span><br><span class="hljs-comment"> * 这种情况下，该函数释放页框。</span><br><span class="hljs-comment"> */</span><br>fastcall <span class="hljs-type">void</span> __free_pages(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PageReserved</span>(page) &amp;&amp; <span class="hljs-built_in">put_page_testzero</span>(page)) &#123;<br><span class="hljs-keyword">if</span> (order == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">free_hot_page</span>(page);<br><span class="hljs-keyword">else</span><br>__free_pages_ok(page, order);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>暂时只关心先对于<code>order==0</code>的情况处理(即高速缓存)：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> fastcall <span class="hljs-title">free_hot_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">free_hot_cold_page</span>(page, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> fastcall <span class="hljs-title">free_cold_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">free_hot_cold_page</span>(page, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">/* 这两个都是封装 */</span><br><span class="hljs-comment">/* core api */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放单个页框到页框高速缓存。</span><br><span class="hljs-comment"> * page-要释放的页框描述符地址。</span><br><span class="hljs-comment"> * cold-释放到热高速缓存还是冷高速缓存中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> fastcall <span class="hljs-title">free_hot_cold_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">int</span> cold)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * page_zone从page-&gt;flag中，获得page所在的内存管理区描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">zone</span> *zone = <span class="hljs-built_in">page_zone</span>(page);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">per_cpu_pages</span> *pcp;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br><span class="hljs-built_in">arch_free_page</span>(page, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">kernel_map_pages</span>(page, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">inc_page_state</span>(pgfree);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">PageAnon</span>(page))<br>page-&gt;mapping = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">free_pages_check</span>(__FUNCTION__, page);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 冷高速缓存还是热高速缓存??</span><br><span class="hljs-comment"> */</span><br>pcp = &amp;zone-&gt;pageset[<span class="hljs-built_in">get_cpu</span>()].pcp[cold];<br><span class="hljs-built_in">local_irq_save</span>(flags);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果缓存的页框太多，就清除一些。</span><br><span class="hljs-comment"> * 调用free_pages_bulk将这些页框释放给伙伴系统。</span><br><span class="hljs-comment"> * 当然，需要更新一下count计数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (pcp-&gt;count &gt;= pcp-&gt;high)<br>pcp-&gt;count -= <span class="hljs-built_in">free_pages_bulk</span>(zone, pcp-&gt;batch, &amp;pcp-&gt;list, <span class="hljs-number">0</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将释放的页框加到高速缓存链表上。并增加count字段。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">list_add</span>(&amp;page-&gt;lru, &amp;pcp-&gt;list);<br>pcp-&gt;count++;<br><span class="hljs-built_in">local_irq_restore</span>(flags);<br><span class="hljs-built_in">put_cpu</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="总结">总结</h2><p>到此，关于页框的管理策略，从zoned alloc/free system到((per CPUcache)+buddysystem)，一系列的算法已经了然于胸。物理内存的层层架构、支配与回收也就这么回事儿。</p><p>ULK的这张图很透彻： <img src="20171020_3.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux-kernel</tag>
      
      <tag>ulk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核学习——Linux进程的创建与撤销</title>
    <link href="/2017/08/27/Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%92%A4%E9%94%80/"/>
    <url>/2017/08/27/Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%92%A4%E9%94%80/</url>
    
    <content type="html"><![CDATA[<p>Linux的进程除了PID为0的第一个进程以外，所有的其他进程都是复制出来的，这和Windows凭空捏造不太一样。另一方面，Linux进程在复制时也有很多细节处理的设计，旨在更高效、更简洁。近来在研究Linux进程活动的整个生命周期，而本文仅仅对进程的出生与死亡进行了概略性描述，毕竟一个进程的前世今生绝不是一两篇文章可以hold住的。</p><span id="more"></span><h1 id="linux进程的创建与撤销">Linux进程的创建与撤销</h1><p>Linux进程的创建有三个函数。fork,vfork和clone。不要把exec系列的函数和这三个函数混为一谈，exec系列函数常用于三者之后，用于创建一个新的程序运行环境。</p><h2 id="clone-fork-vfork">clone(), fork(), vfork()</h2><p>Linux既然有各种各样的机制，那么复制也有着多种手法。这也就对应了这三种创建进程的系统调用。</p><p>这三个函数实际上都是C库的封装，内部分别调用了sys_clone, sys_fork,sys_vfork三个系统调用。这三个系统调用又统一调用了do_fork函数，只是携带的参数和标志不同，从而在do_fork中有选择的完成某些任务。</p><p>便于理解，先大体来谈谈三者的区别： - fork -子进程复制父进程的所有资源 - clone - 轻量级进程使用clone - vfork -子进程和父进程共享数据段，子进程每次都优先于父进程执行(这很有意义，后面你会看到)</p><h3 id="fork">fork()</h3><p>既然Linux的进程是复制的，那么大多数人的第一想法一定是子进程复制整个父进程的资源。诸如最简单的fork，是否只要在调用时完全的深度拷贝即可？实际上深度拷贝所有的资源是没有必要的，Linux指定了3个机制，用于提升性能：-COW，即写时复制。这一技术的引用就使得父子进程可以在一开始的时候共享物理页（一开始是相同的），当二者其一想要写该物理页时，再真正的copy出页的内容到新分配的物理页，然后进行修改。-轻量级进程允许父子进程共享内核的大部分数据结构（页表（用户态地址空间）、打开文件表和信号处理），所以如同在《Linux进程概述》中所说，它更像一个线程。-vfork()系统调用创建的进程能共享父进程的内存地址空间。为了防止父进程重写子进程所需要的数据，阻塞父进程的执行，直到子进程推出或执行一个新的程序为止。</p><p><font color="red">无论是哪一种机制，其根本的思想是一致的：能省则省，延迟拷贝。</font></p><p>对于fork来说，进程A调用fork创建一个子进程B时，B和A拥有相同的物理页面，为了节约内存和提速，fork()会把A和B的物理页面设置成只读。此后，A或B想要执行写操作时，都会产生页面出错异常(page_faultint14)中断，此时CPU执行异常处理函数do_wp_page()解决该异常。do_wp_page()实际上非常简单，无非就是取消共享，为写进程复制一个新的物理页面（此时才真正进行了开辟和复制），设置权限。异常返回后，继续执行写操作。</p><h3 id="vfork">vfork()</h3><p>比起fork()的延迟懒惰处理，vfork()更加粗暴。内核在复制子进程时，连子进程自身的虚拟地址空间都不创建了，干脆使用了父进程的虚拟空间。既然虚拟空间都霸占了，物理页面也当然共享了（这意味着修改子进程的变量值也会影响父进程）。于是，vfork为了防止父进程overwrite，设计上会把父进程先挂起，子进程exit或execve时父进程才会被唤起。vfork创建的子进程不应该用return或exit()，但可以用_exit()退出（参考manvfork，exit是_exit()或_exitgroup()的封装，结束子进程，他不会修改函数栈，所以我在测试中exit()没有出错，这应该是一种严格的说法，当然vfork不接exec，要么脑子有坑，要么想干坏事。至于exit()封装的额外操作还有待研究）。</p><blockquote><p>vfork的子进程如果return就意味着父进程return（共享内存、栈），这看起来没问题，但是接下来父进程再次return就崩了，系统表示很困惑。（return后会自动接exit()，而此时栈已经被破坏了，有些系统会无限循环，再次调用main()，有些直接就segmentationfault）。</p></blockquote><p>那么问题来了，我要这vfork有何用？实际上，vfork只是一个中间步骤，vfork的存在是为了exec的调用。exec是重新开辟空间，那么如果没有vfork，就只得用笨重的fork，而因为下一步想要exec，所以fork的复制过程就毫无意义。</p><h3 id="clone">clone()</h3><p>clone是给轻量级进程的，但clone本身的设计很强大，他可以有选择性的让子进程继承资源。</p><p>clone结构：<code>int clone(int (fn)(void ), void *child_stack, int flags, void *arg, ...);</code></p><p>fn是函数指针，指向程序的指针，函数返回时子进程终止并返回一个退出码；child_stack是子进程堆栈；flags表示从父进程继承哪些资源；arg为传递给子进程的参数。</p><p>flags取值是一组宏，几个常见的标志： - CLONE_VM -共享内存描述符和所有的页表 - CLONE_FS -共享根目录和当前工作目录所在的表，以及用于屏蔽新文件初始许可权的位掩码值- CLONE_FILES - 共享打开文件表 - CLONE_SIGHAND -共享信号处理程序的表、阻塞信号表和挂起信号表。如果标记为true，必须设置CLONE_VM- CLONE_PTRACE - 如果父进程被跟踪，那么子进程也被跟踪。 - CLONE_VFORK -vfork()系统调用时设置 - CLONE_PARENT -设置子进程的父进程为调用进程的父进程 - CLONE_THREAD -把子进程插入到父进程的同一线程组中，使子进程共享父进程信号描述符。因此子进程的tgid和group_leader字段也被设置。如果该标记为true，必须设置CLONE_SIGHAND- CLONE_NEWNS -当clone需要自己的命名空间时设置这个标志。CLONE_NEWNS和CLONE_FS互斥。 -CLONE_PID - 子进程创建时PID和父进程一致</p><p>clone()是libc定义的封装函数，clone()系统调用的服务例程是sys_clone()，它没有fn和arg参数（clone()把fn指针放在了子进程堆栈的某个位置，arg在fn下面），clone()返回后，取出的地址就是fn，参数就是arg，顺理成章执行fn(arg)。</p><h3 id="系统调用服务例程">系统调用服务例程</h3><p>实际上我在看glibc2.19时发现整个流程非常的复杂，有兴趣的可以自己跟一下。但无论如何，我只需要知道，最终的系统调用对应的服务例程是sys_fork等函数就够了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">asmlinkage <span class="hljs-type">int</span> <span class="hljs-title">sys_fork</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs regs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">do_fork</span>(SIGCHLD, regs.esp, &amp;regs, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-function">asmlinkage <span class="hljs-type">int</span> <span class="hljs-title">sys_clone</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs regs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> clone_flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> newsp;<br><span class="hljs-type">int</span> __user *parent_tidptr, *child_tidptr;<br><br>clone_flags = regs.ebx;<br>newsp = regs.ecx;<br>parent_tidptr = (<span class="hljs-type">int</span> __user *)regs.edx;<br>child_tidptr = (<span class="hljs-type">int</span> __user *)regs.edi;<br><span class="hljs-keyword">if</span> (!newsp)<br>newsp = regs.esp;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">do_fork</span>(clone_flags, newsp, &amp;regs, <span class="hljs-number">0</span>, parent_tidptr, child_tidptr);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This is trivial, and on the face of it looks like it</span><br><span class="hljs-comment"> * could equally well be done in user mode.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Not so, for quite unobvious reasons - register pressure.</span><br><span class="hljs-comment"> * In user mode vfork() cannot have a stack frame, and if</span><br><span class="hljs-comment"> * done by calling the &quot;clone()&quot; system call directly, you</span><br><span class="hljs-comment"> * do not have enough call-clobbered registers to hold all</span><br><span class="hljs-comment"> * the information you need.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">asmlinkage <span class="hljs-type">int</span> <span class="hljs-title">sys_vfork</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs regs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">do_fork</span>(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.esp, &amp;regs, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到vfork和fork最终也都是通过do_fork()进行的，只是提前给定了clone_flags。do_fork()处理的事情： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 负责处理clone,fork,vfork系统调用。</span><br><span class="hljs-comment"> * clone_flags-与clone的flag参数相同</span><br><span class="hljs-comment"> * stack_start-与clone的child_stack相同</span><br><span class="hljs-comment"> * regs-指向通用寄存器的值。是在从用户态切换到内核态时被保存到内核态堆栈中的。</span><br><span class="hljs-comment"> * stack_size-未使用,总是为0</span><br><span class="hljs-comment"> * parent_tidptr,child_tidptr-clone中对应参数ptid,ctid相同</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">do_fork</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> clone_flags,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_start,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">struct</span> pt_regs *regs,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_size,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">int</span> __user *parent_tidptr,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">int</span> __user *child_tidptr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> *p;<br><span class="hljs-type">int</span> trace = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过查找pidmap_array位图,为子进程分配新的pid参数.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">long</span> pid = <span class="hljs-built_in">alloc_pidmap</span>();<br><br><span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EAGAIN;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果父进程正在被跟踪,就检查debugger程序是否想跟踪子进程.并且子进程不是内核进程(CLONE_UNTRACED未设置)</span><br><span class="hljs-comment"> * 那么就设置CLONE_PTRACE标志.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(current-&gt;ptrace)) &#123;<br>trace = fork_traceflag (clone_flags);<br><span class="hljs-keyword">if</span> (trace)<br>clone_flags |= CLONE_PTRACE;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * copy_process复制进程描述符.如果所有必须的资源都是可用的,该函数返回刚创建的task_struct描述符的地址.</span><br><span class="hljs-comment"> * 这是创建进程的关键步骤.</span><br><span class="hljs-comment"> */</span><br>p = <span class="hljs-built_in">copy_process</span>(clone_flags, stack_start, regs, stack_size, parent_tidptr, child_tidptr, pid);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Do this prior waking up the new thread - the thread pointer</span><br><span class="hljs-comment"> * might get invalid after that point, if the thread exits quickly.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IS_ERR</span>(p)) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">completion</span> vfork;<br><br><span class="hljs-keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;<br>p-&gt;vfork_done = &amp;vfork;<br><span class="hljs-built_in">init_completion</span>(&amp;vfork);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果设置了CLONE_STOPPED,或者必须跟踪子进程.</span><br><span class="hljs-comment"> * 就设置子进程为TASK_STOPPED状态,并发送SIGSTOP信号挂起它.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((p-&gt;ptrace &amp; PT_PTRACED) || (clone_flags &amp; CLONE_STOPPED)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We&#x27;ll start up with an immediate SIGSTOP.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">sigaddset</span>(&amp;p-&gt;pending.signal, SIGSTOP);<br><span class="hljs-built_in">set_tsk_thread_flag</span>(p, TIF_SIGPENDING);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 没有设置CLONE_STOPPED,就调用wake_up_new_task</span><br><span class="hljs-comment"> * 它调整父进程和子进程的调度参数.</span><br><span class="hljs-comment"> * 如果父子进程运行在同一个CPU上,并且不能共享同一组页表(CLONE_VM标志被清0).那么,就把子进程插入父进程运行队列.</span><br><span class="hljs-comment"> * 并且子进程插在父进程之前.这样做的目的是:如果子进程在创建之后执行新程序,就可以避免写时复制机制执行不必要时页面复制.</span><br><span class="hljs-comment"> * 否则,如果运行在不同的CPU上,或者父子进程共享同一组页表.就把子进程插入父进程运行队列的队尾.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(clone_flags &amp; CLONE_STOPPED))<br><span class="hljs-built_in">wake_up_new_task</span>(p, clone_flags);<br><span class="hljs-keyword">else</span><span class="hljs-comment">/*如果CLONE_STOPPED标志被设置，就把子进程设置为TASK_STOPPED状态。*/</span><br>p-&gt;state = TASK_STOPPED;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果进程正被跟踪,则把子进程的PID插入到父进程的ptrace_message,并调用ptrace_notify</span><br><span class="hljs-comment"> * ptrace_notify使当前进程停止运行,并向当前进程的父进程发送SIGCHLD信号.子进程的祖父进程是跟踪父进程的debugger进程.</span><br><span class="hljs-comment"> * dubugger进程可以通过ptrace_message获得被创建子进程的PID.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span> (trace)) &#123;<br>current-&gt;ptrace_message = pid;<br><span class="hljs-built_in">ptrace_notify</span> ((trace &lt;&lt; <span class="hljs-number">8</span>) | SIGTRAP);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果设置了CLONE_VFORK,就把父进程插入等待队列,并挂起父进程直到子进程结束或者执行了新的程序.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;<br><span class="hljs-built_in">wait_for_completion</span>(&amp;vfork);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span> (current-&gt;ptrace &amp; PT_TRACE_VFORK_DONE))<br><span class="hljs-built_in">ptrace_notify</span> ((PTRACE_EVENT_VFORK_DONE &lt;&lt; <span class="hljs-number">8</span>) | SIGTRAP);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">free_pidmap</span>(pid);<br>pid = <span class="hljs-built_in">PTR_ERR</span>(p);<br>&#125;<br><span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure>可以看到，实际上fork，clone和vfork的区别，仅仅是在do_fork中根据clone_flags来筛选的。对应不同的flags，实现效果和此前谈到的机制相同。</p><h3 id="copy_process">copy_process()</h3><p>这个函数创建了进程描述符以及子进程执行所要的所有其他数据结构。它的参数与do_fork()相同，外加子进程的PID。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建进程描述符以及子进程执行所需要的所有其他数据结构</span><br><span class="hljs-comment"> * 它的参数与do_fork相同。外加子进程的PID。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">task_t</span> *<span class="hljs-title">copy_process</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> clone_flags,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_start,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">struct</span> pt_regs *regs,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_size,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">int</span> __user *parent_tidptr,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">int</span> __user *child_tidptr,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">int</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> retval;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> *p = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查clone_flags所传标志的一致性。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果CLONE_NEWNS和CLONE_FS标志都被设置，返回错误</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((clone_flags &amp; (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">ERR_PTR</span>(-EINVAL);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Thread groups must share signals as well, and detached threads</span><br><span class="hljs-comment"> * can only be started up within the thread group.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * CLONE_THREAD标志被设置，并且CLONE_SIGHAND没有设置。</span><br><span class="hljs-comment"> * (同一线程组中的轻量级进程必须共享信号)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((clone_flags &amp; CLONE_THREAD) &amp;&amp; !(clone_flags &amp; CLONE_SIGHAND))<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">ERR_PTR</span>(-EINVAL);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Shared signal handlers imply shared VM. By way of the above,</span><br><span class="hljs-comment"> * thread groups also imply shared VM. Blocking this case allows</span><br><span class="hljs-comment"> * for various simplifications in other code.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * CLONE_SIGHAND被设置，但是CLONE_VM没有设置。</span><br><span class="hljs-comment"> * (共享信号处理程序的轻量级进程也必须共享内存描述符)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((clone_flags &amp; CLONE_SIGHAND) &amp;&amp; !(clone_flags &amp; CLONE_VM))<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">ERR_PTR</span>(-EINVAL);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过调用security_task_create以及稍后调用security_task_alloc执行所有附加的安全检查。</span><br><span class="hljs-comment"> * LINUX2.6提供扩展安全性的钩子函数，与传统unix相比，它具有更加强壮的安全模型。</span><br><span class="hljs-comment"> */</span><br>retval = <span class="hljs-built_in">security_task_create</span>(clone_flags);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> fork_out;<br><br>retval = -ENOMEM;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用dup_task_struct为子进程获取进程描述符。</span><br><span class="hljs-comment"> */</span><br>p = <span class="hljs-built_in">dup_task_struct</span>(current);<br><span class="hljs-keyword">if</span> (!p)<br><span class="hljs-keyword">goto</span> fork_out;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查存放在current-&gt;sigal-&gt;rlim[RLIMIT_NPROC].rlim_cur中的限制值，是否小于或者等于用户所拥有的进程数。</span><br><span class="hljs-comment"> * 如果是，则返回错误码。当然，有root权限除外。</span><br><span class="hljs-comment"> * p-&gt;user表示进程的拥有者，p-&gt;user-&gt;processes表示进程拥有者当前进程数</span><br><span class="hljs-comment"> * xie.baoyou注：此处比较是用&gt;=而不是&gt;</span><br><span class="hljs-comment"> */</span><br>retval = -EAGAIN;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">atomic_read</span>(&amp;p-&gt;user-&gt;processes) &gt;=<br>p-&gt;signal-&gt;rlim[RLIMIT_NPROC].rlim_cur) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当然，用户有root权限就另当别论了</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">capable</span>(CAP_SYS_ADMIN) &amp;&amp; !<span class="hljs-built_in">capable</span>(CAP_SYS_RESOURCE) &amp;&amp;<br>p-&gt;user != &amp;root_user)<br><span class="hljs-keyword">goto</span> bad_fork_free;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递增user结构的使用计数器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">atomic_inc</span>(&amp;p-&gt;user-&gt;__count);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 增加用户拥有的进程计数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">atomic_inc</span>(&amp;p-&gt;user-&gt;processes);<br><span class="hljs-built_in">get_group_info</span>(p-&gt;group_info);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If multiple threads are within copy_process(), then this check</span><br><span class="hljs-comment"> * triggers too late. This doesn&#x27;t hurt, the check is only there</span><br><span class="hljs-comment"> * to stop root fork bombs.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查系统中的进程数量（nr_threads）是否超过max_threads</span><br><span class="hljs-comment"> * max_threads的缺省值是由系统内存容量决定的。总的原则是：所有的thread_info描述符和内核栈所占用的空间</span><br><span class="hljs-comment"> * 不能超过物理内存的1/8。不过，系统管理可以通过写/proc/sys/kernel/thread-max文件来改变这个值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (nr_threads &gt;= max_threads)<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_count;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果新进程的执行域和可招待格式的内核函数都包含在内核中模块中，</span><br><span class="hljs-comment"> * 就递增它们的使用计数器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">try_module_get</span>(p-&gt;thread_info-&gt;exec_domain-&gt;<span class="hljs-keyword">module</span>))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_count;<br><br><span class="hljs-keyword">if</span> (p-&gt;binfmt &amp;&amp; !<span class="hljs-built_in">try_module_get</span>(p-&gt;binfmt-&gt;<span class="hljs-keyword">module</span>))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_put_domain;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置几个与进程状态相关的关键字段。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * did_exec是进程发出的execve系统调用的次数，初始为0</span><br><span class="hljs-comment"> */</span><br>p-&gt;did_exec = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 更新从父进程复制到tsk_flags字段中的一些标志。</span><br><span class="hljs-comment"> * 首先清除PF_SUPERPRIV。该标志表示进程是否使用了某种超级用户权限。</span><br><span class="hljs-comment"> * 然后设置PF_FORKNOEXEC标志。它表示子进程还没有发出execve系统调用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">copy_flags</span>(clone_flags, p);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保存新进程的pid值。</span><br><span class="hljs-comment"> */</span><br>p-&gt;pid = pid;<br>retval = -EFAULT;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果CLONE_PARENT_SETTID标志被设置，就将子进程的PID复制到参数parent_tidptr指向的用户态变量中。</span><br><span class="hljs-comment"> * xie.baoyou:想想我们常常调用的pid = fork()语句吧。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">put_user</span>(p-&gt;pid, parent_tidptr))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup;<br><br>p-&gt;proc_dentry = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化子进程描述符中的list_head数据结构和自旋锁。</span><br><span class="hljs-comment"> * 并为挂起信号，定时器及时间统计表相关的几个字段赋初值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;children);<br><span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;sibling);<br>p-&gt;vfork_done = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">spin_lock_init</span>(&amp;p-&gt;alloc_lock);<br><span class="hljs-built_in">spin_lock_init</span>(&amp;p-&gt;proc_lock);<br><br><span class="hljs-built_in">clear_tsk_thread_flag</span>(p, TIF_SIGPENDING);<br><span class="hljs-built_in">init_sigpending</span>(&amp;p-&gt;pending);<br><br>p-&gt;it_real_value = <span class="hljs-number">0</span>;<br>p-&gt;it_real_incr = <span class="hljs-number">0</span>;<br>p-&gt;it_virt_value = cputime_zero;<br>p-&gt;it_virt_incr = cputime_zero;<br>p-&gt;it_prof_value = cputime_zero;<br>p-&gt;it_prof_incr = cputime_zero;<br><span class="hljs-built_in">init_timer</span>(&amp;p-&gt;real_timer);<br>p-&gt;real_timer.data = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) p;<br><br>p-&gt;utime = cputime_zero;<br>p-&gt;stime = cputime_zero;<br>p-&gt;rchar = <span class="hljs-number">0</span>;<span class="hljs-comment">/* I/O counter: bytes read */</span><br>p-&gt;wchar = <span class="hljs-number">0</span>;<span class="hljs-comment">/* I/O counter: bytes written */</span><br>p-&gt;syscr = <span class="hljs-number">0</span>;<span class="hljs-comment">/* I/O counter: read syscalls */</span><br>p-&gt;syscw = <span class="hljs-number">0</span>;<span class="hljs-comment">/* I/O counter: write syscalls */</span><br><span class="hljs-built_in">acct_clear_integrals</span>(p);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把大内核锁计数器初始化为-1</span><br><span class="hljs-comment"> */</span><br>p-&gt;lock_depth = <span class="hljs-number">-1</span>;<span class="hljs-comment">/* -1 = no lock */</span><br><span class="hljs-built_in">do_posix_clock_monotonic_gettime</span>(&amp;p-&gt;start_time);<br>p-&gt;security = <span class="hljs-literal">NULL</span>;<br>p-&gt;io_context = <span class="hljs-literal">NULL</span>;<br>p-&gt;io_wait = <span class="hljs-literal">NULL</span>;<br>p-&gt;audit_context = <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br> p-&gt;mempolicy = <span class="hljs-built_in">mpol_copy</span>(p-&gt;mempolicy);<br> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IS_ERR</span>(p-&gt;mempolicy)) &#123;<br> retval = <span class="hljs-built_in">PTR_ERR</span>(p-&gt;mempolicy);<br> p-&gt;mempolicy = <span class="hljs-literal">NULL</span>;<br> <span class="hljs-keyword">goto</span> bad_fork_cleanup;<br> &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>p-&gt;tgid = p-&gt;pid;<br><span class="hljs-keyword">if</span> (clone_flags &amp; CLONE_THREAD)<br>p-&gt;tgid = current-&gt;tgid;<br><br><span class="hljs-keyword">if</span> ((retval = <span class="hljs-built_in">security_task_alloc</span>(p)))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_policy;<br><span class="hljs-keyword">if</span> ((retval = <span class="hljs-built_in">audit_alloc</span>(p)))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_security;<br><span class="hljs-comment">/* copy all the process information */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * copy_semundo，copy_files，copy_fs，copy_sighand，copy_signal</span><br><span class="hljs-comment"> * copy_mm，copy_keys，copy_namespace创建新的数据结构，并把父进程相应数据结构的值复制到新数据结构中。</span><br><span class="hljs-comment"> * 除非clone_flags参数指出它们有不同的值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((retval = <span class="hljs-built_in">copy_semundo</span>(clone_flags, p)))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_audit;<br><span class="hljs-keyword">if</span> ((retval = <span class="hljs-built_in">copy_files</span>(clone_flags, p)))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_semundo;<br><span class="hljs-keyword">if</span> ((retval = <span class="hljs-built_in">copy_fs</span>(clone_flags, p)))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_files;<br><span class="hljs-keyword">if</span> ((retval = <span class="hljs-built_in">copy_sighand</span>(clone_flags, p)))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_fs;<br><span class="hljs-keyword">if</span> ((retval = <span class="hljs-built_in">copy_signal</span>(clone_flags, p)))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_sighand;<br><span class="hljs-keyword">if</span> ((retval = <span class="hljs-built_in">copy_mm</span>(clone_flags, p)))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_signal;<br><span class="hljs-keyword">if</span> ((retval = <span class="hljs-built_in">copy_keys</span>(clone_flags, p)))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_mm;<br><span class="hljs-keyword">if</span> ((retval = <span class="hljs-built_in">copy_namespace</span>(clone_flags, p)))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_keys;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用copy_thread，用发出clone系统调用时CPU寄存器的值（它们保存在父进程的内核栈中）</span><br><span class="hljs-comment"> * 来初始化子进程的内核栈。不过，copy_thread把eax寄存器对应字段的值（这是fork和clone系统调用在子进程中的返回值）</span><br><span class="hljs-comment"> * 强行置为0。子进程描述符的thread.esp字段初始化为子进程内核栈的基地址。ret_from_fork的地址存放在thread.eip中。</span><br><span class="hljs-comment"> * 如果父进程使用IO权限位图。则子进程获取该位图的一个拷贝。</span><br><span class="hljs-comment"> * 最后，如果CLONE_SETTLS标志被置位，则子进程获取由CLONE系统调用的参数tls指向的用户态数据结构所表示的TLS段。</span><br><span class="hljs-comment"> */</span><br>retval = <span class="hljs-built_in">copy_thread</span>(<span class="hljs-number">0</span>, clone_flags, stack_start, stack_size, p, regs);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_namespace;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果clone_flags参数的值被置为CLONE_CHILD_SETTID或CLONE_CHILD_CLEARTID</span><br><span class="hljs-comment"> * 就把child_tidptr参数的值分别复制到set_child_tid或clear_child_tid字段。</span><br><span class="hljs-comment"> * 这些标志说明：必须改变子进程用户态地址空间的dhild_tidptr所指向的变量的值</span><br><span class="hljs-comment"> * 不过实际的写操作要稍后再执行。</span><br><span class="hljs-comment"> */</span><br>p-&gt;set_child_tid = (clone_flags &amp; CLONE_CHILD_SETTID) ? child_tidptr : <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Clear TID on mm_release()?</span><br><span class="hljs-comment"> */</span><br>p-&gt;clear_child_tid = (clone_flags &amp; CLONE_CHILD_CLEARTID) ? child_tidptr: <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Syscall tracing should be turned off in the child regardless</span><br><span class="hljs-comment"> * of CLONE_PTRACE.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清除TIF_SYSCALL_TRACE标志。使ret_from_fork函数不会把系统调用结束的消息通知给调试进程。</span><br><span class="hljs-comment"> * 也不应该通知给调试进程，因为子进程并没有调用fork.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">clear_tsk_thread_flag</span>(p, TIF_SYSCALL_TRACE);<br><br><span class="hljs-comment">/* Our parent execution domain becomes current domain</span><br><span class="hljs-comment">   These must match for thread signalling to apply */</span><br>   <br>p-&gt;parent_exec_id = p-&gt;self_exec_id;<br><br><span class="hljs-comment">/* ok, now we should be set up.. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用clone_flags参数低位的信号数据编码统建始化tsk_exit_signal字段。</span><br><span class="hljs-comment"> * 如CLONE_THREAD标志被置位，就把exit_signal字段初始化为-1。</span><br><span class="hljs-comment"> * 这样做是因为：当创建线程时，即使被创建的线程死亡，都不应该给领头进程的父进程发送信号。</span><br><span class="hljs-comment"> * 而应该是领头进程死亡后，才向其领头进程的父进程发送信号。</span><br><span class="hljs-comment"> */</span><br>p-&gt;exit_signal = (clone_flags &amp; CLONE_THREAD) ? <span class="hljs-number">-1</span> : (clone_flags &amp; CSIGNAL);<br>p-&gt;pdeath_signal = <span class="hljs-number">0</span>;<br>p-&gt;exit_state = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* Perform scheduler related setup */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用sched_fork完成对新进程调度程序数据结构的初始化。</span><br><span class="hljs-comment"> * 该函数把新进程的状态置为TASK_RUNNING，并把thread_info结构的preempt_count字段设置为1，</span><br><span class="hljs-comment"> * 从而禁止抢占。</span><br><span class="hljs-comment"> * 此外，为了保证公平调度，父子进程共享父进程的时间片。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">sched_fork</span>(p);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Ok, make it visible to the rest of the system.</span><br><span class="hljs-comment"> * We dont wake it up yet.</span><br><span class="hljs-comment"> */</span><br>p-&gt;group_leader = p;<br><span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;ptrace_children);<br><span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;ptrace_list);<br><br><span class="hljs-comment">/* Need tasklist lock for parent etc handling! */</span><br><span class="hljs-built_in">write_lock_irq</span>(&amp;tasklist_lock);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The task hasn&#x27;t been attached yet, so cpus_allowed mask cannot</span><br><span class="hljs-comment"> * have changed. The cpus_allowed mask of the parent may have</span><br><span class="hljs-comment"> * changed after it was copied first time, and it may then move to</span><br><span class="hljs-comment"> * another CPU - so we re-copy it here and set the child&#x27;s CPU to</span><br><span class="hljs-comment"> * the parent&#x27;s CPU. This avoids alot of nasty races.</span><br><span class="hljs-comment"> */</span><br>p-&gt;cpus_allowed = current-&gt;cpus_allowed;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化子线程的cpu字段。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">set_task_cpu</span>(p, <span class="hljs-built_in">smp_processor_id</span>());<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Check for pending SIGKILL! The new thread should not be allowed</span><br><span class="hljs-comment"> * to slip out of an OOM kill. (or normal SIGKILL.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">sigismember</span>(&amp;current-&gt;pending.signal, SIGKILL)) &#123;<br><span class="hljs-built_in">write_unlock_irq</span>(&amp;tasklist_lock);<br>retval = -EINTR;<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_namespace;<br>&#125;<br><br><span class="hljs-comment">/* CLONE_PARENT re-uses the old parent */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化表示亲子关系的字段，如果CLONE_PARENT或者CLONE_THREAD被设置了</span><br><span class="hljs-comment"> * 就用current-&gt;real_parent初始化，否则，当前进程就是初创建进程的父进程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD))<br>p-&gt;real_parent = current-&gt;real_parent;<br><span class="hljs-keyword">else</span><br>p-&gt;real_parent = current;<br>p-&gt;parent = p-&gt;real_parent;<br><br><span class="hljs-keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;<br><span class="hljs-built_in">spin_lock</span>(&amp;current-&gt;sighand-&gt;siglock);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Important: if an exit-all has been started then</span><br><span class="hljs-comment"> * do not create this new thread - the whole thread</span><br><span class="hljs-comment"> * group is supposed to exit anyway.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (current-&gt;signal-&gt;flags &amp; SIGNAL_GROUP_EXIT) &#123;<br><span class="hljs-built_in">spin_unlock</span>(&amp;current-&gt;sighand-&gt;siglock);<br><span class="hljs-built_in">write_unlock_irq</span>(&amp;tasklist_lock);<br>retval = -EAGAIN;<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_namespace;<br>&#125;<br>p-&gt;group_leader = current-&gt;group_leader;<br><br><span class="hljs-keyword">if</span> (current-&gt;signal-&gt;group_stop_count &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * There is an all-stop in progress for the group.</span><br><span class="hljs-comment"> * We ourselves will stop as soon as we check signals.</span><br><span class="hljs-comment"> * Make the new thread part of that group stop too.</span><br><span class="hljs-comment"> */</span><br>current-&gt;signal-&gt;group_stop_count++;<br><span class="hljs-built_in">set_tsk_thread_flag</span>(p, TIF_SIGPENDING);<br>&#125;<br><br><span class="hljs-built_in">spin_unlock</span>(&amp;current-&gt;sighand-&gt;siglock);<br>&#125;<br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 把新进程加入到进程链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">SET_LINKS</span>(p);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * PT_PTRACED表示子进程必须被跟踪，就把current-&gt;parent赋给tsk-&gt;parent，并将子进程插入调试程序的跟踪链表中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(p-&gt;ptrace &amp; PT_PTRACED))<br>__ptrace_link(p, current-&gt;parent);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把新进程描述符的PID插入pidhash散列表中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">attach_pid</span>(p, PIDTYPE_PID, p-&gt;pid);<br><span class="hljs-built_in">attach_pid</span>(p, PIDTYPE_TGID, p-&gt;tgid);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果子进程是线程组的领头进程(CLONE_THREAD标志被清0)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">thread_group_leader</span>(p)) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将进程插入相应的散列表。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">attach_pid</span>(p, PIDTYPE_PGID, <span class="hljs-built_in">process_group</span>(p));<br><span class="hljs-built_in">attach_pid</span>(p, PIDTYPE_SID, p-&gt;signal-&gt;session);<br><span class="hljs-keyword">if</span> (p-&gt;pid)<br>__get_cpu_var(process_counts)++;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计数</span><br><span class="hljs-comment"> */</span><br>nr_threads++;<br>total_forks++;<br><span class="hljs-built_in">write_unlock_irq</span>(&amp;tasklist_lock);<br>retval = <span class="hljs-number">0</span>;<br><br>fork_out:<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">ERR_PTR</span>(retval);<br><span class="hljs-keyword">return</span> p;<br><br>bad_fork_cleanup_namespace:<br><span class="hljs-built_in">exit_namespace</span>(p);<br>bad_fork_cleanup_keys:<br><span class="hljs-built_in">exit_keys</span>(p);<br>bad_fork_cleanup_mm:<br><span class="hljs-keyword">if</span> (p-&gt;mm)<br><span class="hljs-built_in">mmput</span>(p-&gt;mm);<br>bad_fork_cleanup_signal:<br><span class="hljs-built_in">exit_signal</span>(p);<br>bad_fork_cleanup_sighand:<br><span class="hljs-built_in">exit_sighand</span>(p);<br>bad_fork_cleanup_fs:<br><span class="hljs-built_in">exit_fs</span>(p); <span class="hljs-comment">/* blocking */</span><br>bad_fork_cleanup_files:<br><span class="hljs-built_in">exit_files</span>(p); <span class="hljs-comment">/* blocking */</span><br>bad_fork_cleanup_semundo:<br><span class="hljs-built_in">exit_sem</span>(p);<br>bad_fork_cleanup_audit:<br><span class="hljs-built_in">audit_free</span>(p);<br>bad_fork_cleanup_security:<br><span class="hljs-built_in">security_task_free</span>(p);<br>bad_fork_cleanup_policy:<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br><span class="hljs-built_in">mpol_free</span>(p-&gt;mempolicy);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>bad_fork_cleanup:<br><span class="hljs-keyword">if</span> (p-&gt;binfmt)<br><span class="hljs-built_in">module_put</span>(p-&gt;binfmt-&gt;<span class="hljs-keyword">module</span>);<br>bad_fork_cleanup_put_domain:<br><span class="hljs-built_in">module_put</span>(p-&gt;thread_info-&gt;exec_domain-&gt;<span class="hljs-keyword">module</span>);<br>bad_fork_cleanup_count:<br><span class="hljs-built_in">put_group_info</span>(p-&gt;group_info);<br><span class="hljs-built_in">atomic_dec</span>(&amp;p-&gt;user-&gt;processes);<br><span class="hljs-built_in">free_uid</span>(p-&gt;user);<br>bad_fork_free:<br><span class="hljs-built_in">free_task</span>(p);<br><span class="hljs-keyword">goto</span> fork_out;<br>&#125;<br></code></pre></td></tr></table></figure><p>做完do_fork后，我们的子进程整装待发，等待CPU调度。后续进程调度时，调度程序会把进程描述符thread字段的值装入几个CPU寄存器（thread.esp装入esp寄存器，ret_from_fork()地址装入eip寄存器）。关于此，可以参考《Linux进程切换》一文，这一处理刚好和_switch_to的设计一致。</p><h2 id="内核线程">内核线程</h2><p>Linux还有一组内核线程，它们只运行在内核态，因此也就不必受用户态上下文的拖累。内核线程只使用大于PAGE_OFFSET的内核地址空间。</p><p>创建内核线程使用kernel_thread()，实际上本质依然是do_fork():<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建一个新的内核线程</span><br><span class="hljs-comment"> * fn-要执行的内核函数的地址。</span><br><span class="hljs-comment"> * arg-要传递给函数的参数</span><br><span class="hljs-comment"> * flags-一组clone标志</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kernel_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fn)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> * arg, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pt_regs</span> regs;<br><br><span class="hljs-built_in">memset</span>(&amp;regs, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(regs));<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内核栈地址，为其赋初值。</span><br><span class="hljs-comment"> * do_fork将从这里取值来为新线程初始化CPU。</span><br><span class="hljs-comment"> */</span><br>regs.ebx = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fn;<br>regs.edx = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) arg;<br><br>regs.xds = __USER_DS;<br>regs.xes = __USER_DS;<br>regs.orig_eax = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把eip设置成kernel_thread_helper，这样，新线程将执行fn函数。如果函数结束，将执行do_exit</span><br><span class="hljs-comment"> * fn的返回值作为do_exit的参数。</span><br><span class="hljs-comment"> */</span><br>regs.eip = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) kernel_thread_helper;<br>regs.xcs = __KERNEL_CS;<br>regs.eflags = X86_EFLAGS_IF | X86_EFLAGS_SF | X86_EFLAGS_PF | <span class="hljs-number">0x2</span>;<br><br><span class="hljs-comment">/* Ok, create the new process.. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * CLONE_VM避免复制调用进程的页表。由于新的内核线程无论如何都不会访问用户态地址空间。</span><br><span class="hljs-comment"> * 所以复制只会造成时间和空间的浪费。</span><br><span class="hljs-comment"> * CLONE_UNTRACED标志保证内核线程不会被跟踪，即使调用进程被跟踪。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">do_fork</span>(flags | CLONE_VM | CLONE_UNTRACED, <span class="hljs-number">0</span>, &amp;regs, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure>不管你怎么折腾，说白了还是进程，是进程就得do_fork，设计用途不一致罢了。</p><h2 id="进程0">进程0</h2><p>一直在折腾clone，但总归有第一个进程，那就是进程0——idle或叫swapper。这是个Linux开天辟地时捏出来的内核线程。他使用的数据结构是静态分配的，换句话说，其他所有进程的数据结构都是动态分配的。- init_task变量中存放进程描述符，INIT_TASK宏初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程0的描述符, 也是进程链表的头</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> init_task = <span class="hljs-built_in">INIT_TASK</span>(init_task);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化进程0的任务描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_TASK(tsk)\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">.state= 0,\</span><br><span class="hljs-meta">.thread_info= &amp;init_thread_info,\</span><br><span class="hljs-meta">.usage= ATOMIC_INIT(2),\</span><br><span class="hljs-meta">.flags= 0,\</span><br><span class="hljs-meta">.lock_depth= -1,\</span><br><span class="hljs-meta">.prio= MAX_PRIO-20,\</span><br><span class="hljs-meta">.static_prio= MAX_PRIO-20,\</span><br><span class="hljs-meta">.policy= SCHED_NORMAL,\</span><br><span class="hljs-meta">.cpus_allowed= CPU_MASK_ALL,\</span><br><span class="hljs-meta">.mm= NULL,\</span><br><span class="hljs-meta">.active_mm= &amp;init_mm,\</span><br><span class="hljs-meta">.run_list= LIST_HEAD_INIT(tsk.run_list),\</span><br><span class="hljs-meta">.time_slice= HZ,\</span><br><span class="hljs-meta">.tasks= LIST_HEAD_INIT(tsk.tasks),\</span><br><span class="hljs-meta">.ptrace_children= LIST_HEAD_INIT(tsk.ptrace_children),\</span><br><span class="hljs-meta">.ptrace_list= LIST_HEAD_INIT(tsk.ptrace_list),\</span><br><span class="hljs-meta">.real_parent= &amp;tsk,\</span><br><span class="hljs-meta">.parent= &amp;tsk,\</span><br><span class="hljs-meta">.children= LIST_HEAD_INIT(tsk.children),\</span><br><span class="hljs-meta">.sibling= LIST_HEAD_INIT(tsk.sibling),\</span><br><span class="hljs-meta">.group_leader= &amp;tsk,\</span><br><span class="hljs-meta">.real_timer= &#123;\</span><br><span class="hljs-meta">.function= it_real_fn\</span><br><span class="hljs-meta">&#125;,\</span><br><span class="hljs-meta">.group_info= &amp;init_groups,\</span><br><span class="hljs-meta">.cap_effective= CAP_INIT_EFF_SET,\</span><br><span class="hljs-meta">.cap_inheritable = CAP_INIT_INH_SET,\</span><br><span class="hljs-meta">.cap_permitted= CAP_FULL_SET,\</span><br><span class="hljs-meta">.keep_capabilities = 0,\</span><br><span class="hljs-meta">.user= INIT_USER,\</span><br><span class="hljs-meta">.comm= <span class="hljs-string">&quot;swapper&quot;</span>,\</span><br><span class="hljs-meta">.thread= INIT_THREAD,\</span><br><span class="hljs-meta">.fs= &amp;init_fs,\</span><br><span class="hljs-meta">.files= &amp;init_files,\</span><br><span class="hljs-meta">.signal= &amp;init_signals,\</span><br><span class="hljs-meta">.sighand= &amp;init_sighand,\</span><br><span class="hljs-meta">.pending= &#123;\</span><br><span class="hljs-meta">.list = LIST_HEAD_INIT(tsk.pending.list),\</span><br><span class="hljs-meta">.signal = &#123;&#123;0&#125;&#125;&#125;,\</span><br><span class="hljs-meta">.blocked= &#123;&#123;0&#125;&#125;,\</span><br><span class="hljs-meta">.alloc_lock= SPIN_LOCK_UNLOCKED,\</span><br><span class="hljs-meta">.proc_lock= SPIN_LOCK_UNLOCKED,\</span><br><span class="hljs-meta">.switch_lock= SPIN_LOCK_UNLOCKED,\</span><br><span class="hljs-meta">.journal_info= NULL,\</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure> -init_thread_union中存放thread_info描述符和内核堆栈，INIT_THREAD_INFO宏完成初始化。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> init_thread_info(init_thread_union.thread_info)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_THREAD_INFO(tsk)\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">.task= &amp;tsk,\</span><br><span class="hljs-meta">.exec_domain= &amp;default_exec_domain,\</span><br><span class="hljs-meta">.flags= 0,\</span><br><span class="hljs-meta">.cpu= 0,\</span><br><span class="hljs-meta">.preempt_count= 1,\</span><br><span class="hljs-meta">.addr_limit= KERNEL_DS,\</span><br><span class="hljs-meta">.restart_block = &#123;\</span><br><span class="hljs-meta">.fn = do_no_restart_syscall,\</span><br><span class="hljs-meta">&#125;,\</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure> - 由进程描述符指向的下列表，也有对应宏初始化： - init_mmINIT_MM - init_fs INIT_FS - init_files INIT_FILES - init_signalsINIT_SIGNALS - init_sighand INIT_SIGHAND -主内核页全局目录放在swapper_pg_dir中。</p><p>start_kernel()初始化内核需要的所有数据结构，激活中断，创建另一个叫进程l的内核线程（一般叫init进程）：<code>kernel_thread(init, NULL, CLONE_FS|CLONE_SIGHAND);</code>新创建内核线程的PID为1，并与进程0共享每进程所有的内核数据结构。此外，当调度程序选择到它时，init进程开始执行init()函数。</p><p>创建init进程后，进程0执行cpu_idle()函数，该函数本质上是在开中断的情况下重复执行hlt汇编语言指令。只有当没有其他进程处于TASK_RUNNING状态时，调度程序才选择进程0。</p><h2 id="进程1">进程1</h2><p>0创建的内核线程执行init()，init()完成内核初始化。init()调用execve()系统调用装入可执行程序init。然后init内核线程变为一个普通进程，且拥有自己的每进程内核数据结构。系统关闭之前，init进程一直存活，因为它创建和监控在OS外层执行的所有进程的活动。</p><p>linux还有很多其他内核线程，到具体模块时再看。</p><h2 id="撤销进程">撤销进程</h2><p>进程终止时，必须通知内核释放进程的资源，包括内存、打开文件以及其他零碎的东西，比如信号量。进程终止一般通过调用exit()库函数，该函数释放C函数库所分配的资源，执行编程者所注册的每个函数，并结束从系统回收进程的那个系统调用。exit()可以显示的插入，C编译程序总是把exit()插入到main()的最后一条语句之后。</p><p>exit_group()和exit()都可以终止进程，前者终止的是整个线程组。do_group_exit()内核函数实现了这个系统调用，它对应C库的exit()。后者终止某一个线程，而不管线程所属线程组中的所有其他线程。do_exit()是实现这个系统调用的内核函数，它对应Linux线程库的pthread_exit()。</p><blockquote><p>注意区分C库的exit()和系统调用exit()。</p></blockquote><p>exit()的处理： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">asmlinkage <span class="hljs-type">long</span> <span class="hljs-title">sys_exit</span><span class="hljs-params">(<span class="hljs-type">int</span> error_code)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">do_exit</span>((error_code&amp;<span class="hljs-number">0xff</span>)&lt;&lt;<span class="hljs-number">8</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所有进程的终止都是本函数处理的。</span><br><span class="hljs-comment"> * 它从内核数据结构中删除对终止进程的大部分引用（注：不是全部，进程描述符就不是）</span><br><span class="hljs-comment"> * 它接受进程的终止代码作为参数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">fastcall NORET_TYPE <span class="hljs-type">void</span> <span class="hljs-title">do_exit</span><span class="hljs-params">(<span class="hljs-type">long</span> code)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> *tsk = current;<br><span class="hljs-type">int</span> group_dead;<br><br><span class="hljs-built_in">profile_task_exit</span>(tsk);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(<span class="hljs-built_in">in_interrupt</span>()))<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Aiee, killing interrupt handler!&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!tsk-&gt;pid))<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Attempted to kill the idle task!&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(tsk-&gt;pid == <span class="hljs-number">1</span>))<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Attempted to kill init!&quot;</span>);<br><span class="hljs-keyword">if</span> (tsk-&gt;io_context)<br><span class="hljs-built_in">exit_io_context</span>();<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(current-&gt;ptrace &amp; PT_TRACE_EXIT)) &#123;<br>current-&gt;ptrace_message = code;<br><span class="hljs-built_in">ptrace_notify</span>((PTRACE_EVENT_EXIT &lt;&lt; <span class="hljs-number">8</span>) | SIGTRAP);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * PF_EXITING表示进程的状态：正在被删除。</span><br><span class="hljs-comment"> */</span><br>tsk-&gt;flags |= PF_EXITING;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从动态定时器队列中删除进程描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">del_timer_sync</span>(&amp;tsk-&gt;real_timer);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(<span class="hljs-built_in">in_atomic</span>()))<br><span class="hljs-built_in">printk</span>(KERN_INFO <span class="hljs-string">&quot;note: %s[%d] exited with preempt_count %d\n&quot;</span>,<br>current-&gt;comm, current-&gt;pid,<br><span class="hljs-built_in">preempt_count</span>());<br><br><span class="hljs-built_in">acct_update_integrals</span>();<br><span class="hljs-built_in">update_mem_hiwater</span>();<br>group_dead = <span class="hljs-built_in">atomic_dec_and_test</span>(&amp;tsk-&gt;signal-&gt;live);<br><span class="hljs-keyword">if</span> (group_dead)<br><span class="hljs-built_in">acct_process</span>(code);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * exit_mm从进程描述符中分离出分页相关的描述符。</span><br><span class="hljs-comment"> * 如果没有其他进程共享这些数据结构，就删除这些数据结构。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">exit_mm</span>(tsk);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * exit_sem从进程描述符中分离出信号量相关的描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">exit_sem</span>(tsk);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __exit_files从进程描述符中分离出文件系统相关的描述符</span><br><span class="hljs-comment"> */</span><br>__exit_files(tsk);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __exit_fs从进程描述符中分离出打开文件描述符相关的描述符</span><br><span class="hljs-comment"> */</span><br>__exit_fs(tsk);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * exit_namespace从进程描述符中分离出命名空间相关的描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">exit_namespace</span>(tsk);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * exit_thread从进程描述符中分离出IO权限位图相关的描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">exit_thread</span>();<br><span class="hljs-built_in">exit_keys</span>(tsk);<br><br><span class="hljs-keyword">if</span> (group_dead &amp;&amp; tsk-&gt;signal-&gt;leader)<br><span class="hljs-built_in">disassociate_ctty</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果实现了被杀死进程的执行域和可执行格式的内核函数在内核模块中</span><br><span class="hljs-comment"> * 就递减它们的值。</span><br><span class="hljs-comment"> * 注：这应该是为了防止意外的卸载模块。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">module_put</span>(tsk-&gt;thread_info-&gt;exec_domain-&gt;<span class="hljs-keyword">module</span>);<br><span class="hljs-keyword">if</span> (tsk-&gt;binfmt)<br><span class="hljs-built_in">module_put</span>(tsk-&gt;binfmt-&gt;<span class="hljs-keyword">module</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置退出代码</span><br><span class="hljs-comment"> */</span><br>tsk-&gt;exit_code = code;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * exit_notify执行比较复杂的操作，更新了很多内核数据结构</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">exit_notify</span>(tsk);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br><span class="hljs-built_in">mpol_free</span>(tsk-&gt;mempolicy);<br>tsk-&gt;mempolicy = <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-built_in">BUG_ON</span>(!(current-&gt;flags &amp; PF_DEAD));<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 完了，让其他线程运行吧</span><br><span class="hljs-comment"> * 因为schedule会忽略处于EXIT_ZOMBIE状态的进程，所以进程现在是不会再运行了。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">schedule</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当然，谁还会让死掉的进程继续运行，说明内核一定是错了</span><br><span class="hljs-comment"> * 注：难道schedule被谁改了，没有判断EXIT_ZOMBIE？？？</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">BUG</span>();<br><span class="hljs-comment">/* Avoid &quot;noreturn function does return&quot;.  */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 仅仅为了防止编译器报警告信息而已，仅此而已。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (;;) ;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>再看exit_group(): <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">asmlinkage <span class="hljs-type">void</span> <span class="hljs-title">sys_exit_group</span><span class="hljs-params">(<span class="hljs-type">int</span> error_code)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">do_group_exit</span>((error_code &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">8</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 杀死属于current线程组的所有进程.它接受进程终止代码作为参数.</span><br><span class="hljs-comment"> * 这个参数可能是系统调用exit_group()指定的一个值,也可能是内核提供的一个错误代号.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">NORET_TYPE <span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">do_group_exit</span><span class="hljs-params">(<span class="hljs-type">int</span> exit_code)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">BUG_ON</span>(exit_code &amp; <span class="hljs-number">0x80</span>); <span class="hljs-comment">/* core dumps don&#x27;t get here */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查进程的SIGNAL_GROUP_EXIT,如果不为0,说明内核已经开始为线程组执行退出的过程.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (current-&gt;signal-&gt;flags &amp; SIGNAL_GROUP_EXIT)<br>exit_code = current-&gt;signal-&gt;group_exit_code;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">thread_group_empty</span>(current)) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置进程的SIGNAL_GROUP_EXIT标志,并把终止代号放在sig-&gt;group_exit_code</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> signal_struct *<span class="hljs-type">const</span> sig = current-&gt;signal;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sighand_struct</span> *<span class="hljs-type">const</span> sighand = current-&gt;sighand;<br><span class="hljs-built_in">read_lock</span>(&amp;tasklist_lock);<br><span class="hljs-built_in">spin_lock_irq</span>(&amp;sighand-&gt;siglock);<br><span class="hljs-keyword">if</span> (sig-&gt;flags &amp; SIGNAL_GROUP_EXIT)<br><span class="hljs-comment">/* Another thread got here before we took the lock.  */</span><br>exit_code = sig-&gt;group_exit_code;<br><span class="hljs-keyword">else</span> &#123;<br>sig-&gt;flags = SIGNAL_GROUP_EXIT;<br>sig-&gt;group_exit_code = exit_code;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * zap_other_threads杀死线程组中的其他线程.</span><br><span class="hljs-comment"> * 它扫描PIDTYPE_TGID类型的散列表中的每个PID链表,向表中其他进程发送SIGKILL信号.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">zap_other_threads</span>(current);<br>&#125;<br><span class="hljs-built_in">spin_unlock_irq</span>(&amp;sighand-&gt;siglock);<br><span class="hljs-built_in">read_unlock</span>(&amp;tasklist_lock);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 杀死当前进程,此过程不再返回.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">do_exit</span>(exit_code);<br><span class="hljs-comment">/* NOTREACHED */</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="进程删除">进程删除</h2><p>Linux的子进程可以通过查询内核获取父进程的PID，或者它的子进程的执行状态。考虑到这一设计的完整性，Linux不允许内核在进程终止后直接丢弃包含在进程描述符字段中的数据，而是当父进程发出了与被终止的进程相关的wait()系列系统调用后，才可以这样做。这就是引入僵死状态的原因（参考《Linux进程概述》）。</p><p>如果父进程死在子进程前，那么所有孤儿都交给init。init在用wait()系列系统调用检查到其终止时，撤销僵死的进程。</p><p>负责干活的是release_task()函数，他从僵死进程的描述符中分离出最后的数据结构；对僵死进程的处理有两种可能的方式：如果父进程不需要接收子进程的信号，就调用do_exit()；如果已经给父进程发了新号，就调用wait4()或waitpid()系统调用。后者中函数还会回收进程描述符所占用的内存空间，而前者中内存的回收由进程调度程序完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 释放进程描述符。如果进程已经是僵死状态，就会回收它占用的RAM。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release_task</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct * p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> zap_leader;<br><span class="hljs-type">task_t</span> *leader;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dentry</span> *proc_dentry;<br><br>repeat: <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递减进程拥有者的进程个数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">atomic_dec</span>(&amp;p-&gt;user-&gt;processes);<br><span class="hljs-built_in">spin_lock</span>(&amp;p-&gt;proc_lock);<br>proc_dentry = <span class="hljs-built_in">proc_pid_unhash</span>(p);<br><span class="hljs-built_in">write_lock_irq</span>(&amp;tasklist_lock);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果进程正被跟踪，函数将它从调试程序的ptrace_children链表中删除，并让该进程重新属于初始的父进程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(p-&gt;ptrace))<br>__ptrace_unlink(p);<br><span class="hljs-built_in">BUG_ON</span>(!<span class="hljs-built_in">list_empty</span>(&amp;p-&gt;ptrace_list) || !<span class="hljs-built_in">list_empty</span>(&amp;p-&gt;ptrace_children));<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除所有的挂起信号并释放进程的signal_struct描述符。</span><br><span class="hljs-comment"> * 如果该描述符不再被其他的轻量级进程使用，函数进一步删除这个数据结构。</span><br><span class="hljs-comment"> * 它还会调用exit_itimers，删除所有POSIX时间间隔定时器。</span><br><span class="hljs-comment"> */</span><br>__exit_signal(p);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除信号处理函数。</span><br><span class="hljs-comment"> */</span><br>__exit_sighand(p);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __unhash_process将进程从各种hash表中摘除。它执行:</span><br><span class="hljs-comment"> *    变量nr_threads减1</span><br><span class="hljs-comment"> *    两次调用detach_pid，分别从PIDTYPE_PID和PIDTYPE_TGID类型的PID散列表中删除进程描述符。</span><br><span class="hljs-comment"> *    如果进程是线程组的领头进程，那么再调用两次detach_pid，从PIDTYPE_PGID和PIDTYPE_SID类型的散列表中删除进程描述符。</span><br><span class="hljs-comment"> *    用宏REMOVE_LINKS从进程链表中解除进程描述符的链接。</span><br><span class="hljs-comment"> */</span><br>__unhash_process(p);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we are the last non-leader member of the thread</span><br><span class="hljs-comment"> * group, and the leader is zombie, then notify the</span><br><span class="hljs-comment"> * group leader&#x27;s parent process. (if it wants notification.)</span><br><span class="hljs-comment"> */</span><br>zap_leader = <span class="hljs-number">0</span>;<br>leader = p-&gt;group_leader;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果进程不是线程组的领头进程，领头进程处于僵死状态，并且进程是线程组的最后一个成员。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (leader != p &amp;&amp; <span class="hljs-built_in">thread_group_empty</span>(leader) &amp;&amp; leader-&gt;exit_state == EXIT_ZOMBIE) &#123;<br><span class="hljs-built_in">BUG_ON</span>(leader-&gt;exit_signal == <span class="hljs-number">-1</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 向领头进程的父进程发送一个信号，通知它:进程已经死亡。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">do_notify_parent</span>(leader, leader-&gt;exit_signal);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we were the last child thread and the leader has</span><br><span class="hljs-comment"> * exited already, and the leader&#x27;s parent ignores SIGCHLD,</span><br><span class="hljs-comment"> * then we are the one who should release the leader.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * do_notify_parent() will have marked it self-reaping in</span><br><span class="hljs-comment"> * that case.</span><br><span class="hljs-comment"> */</span><br>zap_leader = (leader-&gt;exit_signal == <span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * sched_exit函数调整父进程的时间片。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">sched_exit</span>(p);<br><span class="hljs-built_in">write_unlock_irq</span>(&amp;tasklist_lock);<br><span class="hljs-built_in">spin_unlock</span>(&amp;p-&gt;proc_lock);<br><span class="hljs-built_in">proc_pid_flush</span>(proc_dentry);<br><span class="hljs-built_in">release_thread</span>(p);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递减进程描述符的使用计数器。如果计数器变成0,则终止所有残留的对进程的引用。</span><br><span class="hljs-comment"> *     递减进程所有者的user_struct数据结构的使用计数器。如果计数为0，就释放该结构。</span><br><span class="hljs-comment"> *     释放进程描述符以及thread_info描述符和内核态堆栈所占用的内存区域。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">put_task_struct</span>(p);<br><br>p = leader;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(zap_leader))<br><span class="hljs-keyword">goto</span> repeat;<br>&#125;<br></code></pre></td></tr></table></figure><p>进程终止的处理函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所有进程的终止都是本函数处理的。</span><br><span class="hljs-comment"> * 它从内核数据结构中删除对终止进程的大部分引用（注：不是全部，进程描述符就不是）</span><br><span class="hljs-comment"> * 它接受进程的终止代码作为参数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">fastcall NORET_TYPE <span class="hljs-type">void</span> <span class="hljs-title">do_exit</span><span class="hljs-params">(<span class="hljs-type">long</span> code)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> *tsk = current;<br><span class="hljs-type">int</span> group_dead;<br><br><span class="hljs-built_in">profile_task_exit</span>(tsk);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(<span class="hljs-built_in">in_interrupt</span>()))<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Aiee, killing interrupt handler!&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!tsk-&gt;pid))<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Attempted to kill the idle task!&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(tsk-&gt;pid == <span class="hljs-number">1</span>))<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Attempted to kill init!&quot;</span>);<br><span class="hljs-keyword">if</span> (tsk-&gt;io_context)<br><span class="hljs-built_in">exit_io_context</span>();<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(current-&gt;ptrace &amp; PT_TRACE_EXIT)) &#123;<br>current-&gt;ptrace_message = code;<br><span class="hljs-built_in">ptrace_notify</span>((PTRACE_EVENT_EXIT &lt;&lt; <span class="hljs-number">8</span>) | SIGTRAP);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * PF_EXITING表示进程的状态：正在被删除。</span><br><span class="hljs-comment"> */</span><br>tsk-&gt;flags |= PF_EXITING;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从动态定时器队列中删除进程描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">del_timer_sync</span>(&amp;tsk-&gt;real_timer);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(<span class="hljs-built_in">in_atomic</span>()))<br><span class="hljs-built_in">printk</span>(KERN_INFO <span class="hljs-string">&quot;note: %s[%d] exited with preempt_count %d\n&quot;</span>,<br>current-&gt;comm, current-&gt;pid,<br><span class="hljs-built_in">preempt_count</span>());<br><br><span class="hljs-built_in">acct_update_integrals</span>();<br><span class="hljs-built_in">update_mem_hiwater</span>();<br>group_dead = <span class="hljs-built_in">atomic_dec_and_test</span>(&amp;tsk-&gt;signal-&gt;live);<br><span class="hljs-keyword">if</span> (group_dead)<br><span class="hljs-built_in">acct_process</span>(code);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * exit_mm从进程描述符中分离出分页相关的描述符。</span><br><span class="hljs-comment"> * 如果没有其他进程共享这些数据结构，就删除这些数据结构。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">exit_mm</span>(tsk);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * exit_sem从进程描述符中分离出信号量相关的描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">exit_sem</span>(tsk);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __exit_files从进程描述符中分离出文件系统相关的描述符</span><br><span class="hljs-comment"> */</span><br>__exit_files(tsk);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __exit_fs从进程描述符中分离出打开文件描述符相关的描述符</span><br><span class="hljs-comment"> */</span><br>__exit_fs(tsk);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * exit_namespace从进程描述符中分离出命名空间相关的描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">exit_namespace</span>(tsk);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * exit_thread从进程描述符中分离出IO权限位图相关的描述符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">exit_thread</span>();<br><span class="hljs-built_in">exit_keys</span>(tsk);<br><br><span class="hljs-keyword">if</span> (group_dead &amp;&amp; tsk-&gt;signal-&gt;leader)<br><span class="hljs-built_in">disassociate_ctty</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果实现了被杀死进程的执行域和可执行格式的内核函数在内核模块中</span><br><span class="hljs-comment"> * 就递减它们的值。</span><br><span class="hljs-comment"> * 注：这应该是为了防止意外的卸载模块。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">module_put</span>(tsk-&gt;thread_info-&gt;exec_domain-&gt;<span class="hljs-keyword">module</span>);<br><span class="hljs-keyword">if</span> (tsk-&gt;binfmt)<br><span class="hljs-built_in">module_put</span>(tsk-&gt;binfmt-&gt;<span class="hljs-keyword">module</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置退出代码</span><br><span class="hljs-comment"> */</span><br>tsk-&gt;exit_code = code;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * exit_notify执行比较复杂的操作，更新了很多内核数据结构</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">exit_notify</span>(tsk);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br><span class="hljs-built_in">mpol_free</span>(tsk-&gt;mempolicy);<br>tsk-&gt;mempolicy = <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-built_in">BUG_ON</span>(!(current-&gt;flags &amp; PF_DEAD));<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 完了，让其他线程运行吧</span><br><span class="hljs-comment"> * 因为schedule会忽略处于EXIT_ZOMBIE状态的进程，所以进程现在是不会再运行了。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">schedule</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当然，谁还会让死掉的进程继续运行，说明内核一定是错了</span><br><span class="hljs-comment"> * 注：难道schedule被谁改了，没有判断EXIT_ZOMBIE？？？</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">BUG</span>();<br><span class="hljs-comment">/* Avoid &quot;noreturn function does return&quot;.  */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 仅仅为了防止编译器报警告信息而已，仅此而已。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (;;) ;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="参考文献">参考文献</h2><ul><li><ahref="http://www.lenky.info/archives/2013/01/2195">gcc中的weak和alias</a></li><li><ahref="http://blog.csdn.net/gatieme/article/details/51417488">Linux中fork，vfork和clone详解</a></li><li><ahref="http://blog.csdn.net/drdairen/article/details/51896141">Linux系统调用：exit()与_exit()函数详解</a></li><li>《深入理解Linux内核》</li><li><a href="https://github.com/sohu2000000/ULK">ULK Chinesecomments</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux-kernel</tag>
      
      <tag>ulk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核学习——Linux进程切换</title>
    <link href="/2017/08/26/Linux%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/"/>
    <url>/2017/08/26/Linux%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>Linux内核的进程切换可谓精彩绝伦，遗憾的是，ULK对此的介绍不够详尽，而毛批中也是一带而过，所以一时云里雾里。本文是我参考了大量资料，反复研磨后对Linux内核中进程切换的一点理解。</p><span id="more"></span><h1 id="linux内核学习linux进程切换">Linux内核学习——Linux进程切换</h1><p>对于Linux这种分时操作系统来说，内核必须有能力挂起CPU正在运行的进程，以复杂的策略调度另外一个进程。这就是进程切换。在Linux中，这也常被称为任务切换或上下文切换。</p><blockquote><p>Linux的进程和任务是一回事，按我的理解，一般内核进程叫任务，用户进程叫进程。</p></blockquote><p>每个进程有自己的地址空间，相互隔离，而CPU是共享的。于是，进程切换时，CPU寄存器的L/S(LoadandSave)大法需要内核来谨慎的完成。进一步说，折腾寄存器的这组数据叫硬件上下文，它是进程可执行上下文的一个子集。硬件上下文的一部分放在TSS段，剩余部分放在内核态堆栈。</p><p><font color="red">进程切换只发生在内核态!</font></p><h2 id="任务状态段">任务状态段</h2><p>TSS段在我另一篇文章中简单提到过(Linux内存寻址)，它用来存放硬件上下文。尽管Linux根本不使用硬件上下文切换，但还是强制它为系统中每个不同CPU创建一个TSS，原因有二：-x86的一个CPU从用户态切换到内核态时，它就从TSS中获取内核态堆栈的地址(中断和异常中的sysenter-&gt;系统调用)。-用户态进程试图通过in或out指令访问一个I/O端口时，CPU需要访问存在TSS的I/O许可权位图以检查该进程是否有访问端口的权利。</p><p>TSS的结构定义成tss_struct：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 描述TSS的格式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tss_struct</span> &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>back_link,__blh;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>esp0;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>ss0,__ss0h;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>esp1;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>ss1,__ss1h;<span class="hljs-comment">/* ss1 is used to cache MSR_IA32_SYSENTER_CS */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>esp2;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>ss2,__ss2h;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>__cr3;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>eip;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>eflags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>eax,ecx,edx,ebx;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>esp;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>ebp;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>esi;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>edi;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>es, __esh;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>cs, __csh;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>ss, __ssh;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>ds, __dsh;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>fs, __fsh;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>gs, __gsh;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>ldt, __ldth;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>trace, io_bitmap_base;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The extra 1 is there because the CPU will access an</span><br><span class="hljs-comment"> * additional byte beyond the end of the IO permission</span><br><span class="hljs-comment"> * bitmap. The extra byte must be all 1 bits, and must</span><br><span class="hljs-comment"> * be within the limit.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>io_bitmap[IO_BITMAP_LONGS + <span class="hljs-number">1</span>];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Cache the current maximum and the last task that used the bitmap:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> io_bitmap_max;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_struct</span> *io_bitmap_owner;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * pads the TSS to be cacheline-aligned (size is 0x100)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __cacheline_filler[<span class="hljs-number">35</span>];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * .. and then another 0x100 bytes for emergency kernel stack</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack[<span class="hljs-number">64</span>];<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure><p>每次进程切换时，内核更新TSS的某些字段以便相应CPU控制单元可以安全检索到它需要的信息。因此，TSS反映了CPU上当前进程的特权级，但对于没有运行的进程来说，并未保留TSS（TSS跟随CPU而不是进程，这和intel的初衷不同）。</p><p>每个TSS有自己的8字节任务状态段描述符(TSSD)，放在GDT中，CPU的tr寄存器包含相应TSS的TSSD，同时包含两个隐藏的非编程字段：TSSD的Base和Limit域。关于这些的设计，可以参考我之前写的“Linux内存寻址”。</p><p>所以，Linux的TSS跟着CPU走，那么进程切换时，进程的硬件上下文就必须保存在别处。于是，Linux的每个进程描述符包含一个类型为thread_struct的thread字段，只要进程被换出，就把硬件上下文存于此。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程被切换出去后，内核把它的硬件上下文保存在这个结构中。</span><br><span class="hljs-comment"> * 它包含大部分CPU寄存器，但是不包含eax、ebx这样的通用寄存器,他们的值保留在内核堆栈中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_struct</span> &#123;<br><span class="hljs-comment">/* cached TLS descriptors. */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">desc_struct</span> tls_array[GDT_ENTRY_TLS_ENTRIES];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>esp0;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>sysenter_cs;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>eip;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>esp;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>fs;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>gs;<br><span class="hljs-comment">/* Hardware debugging registers */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>debugreg[<span class="hljs-number">8</span>];  <span class="hljs-comment">/* %%db0-7 debug registers */</span><br><span class="hljs-comment">/* fault info */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>cr2, trap_no, error_code;<br><span class="hljs-comment">/* floating point info */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为支持选择性装入FPU、MMX和XMM寄存器，引入此结构。</span><br><span class="hljs-comment"> * 当切换进程时，将进程的这些寄存器保存在i387结构中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">i387_union</span>i387;<br><span class="hljs-comment">/* virtual 86 mode info */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm86_struct</span> __user * vm86_info;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>screen_bitmap;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>v86flags, v86mask, saved_esp0;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>saved_fs, saved_gs;<br><span class="hljs-comment">/* IO permissions */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*io_bitmap_ptr;<br><span class="hljs-comment">/* max allowed port in the bitmap, in bytes: */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>io_bitmap_max;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_THREAD  &#123;\</span><br><span class="hljs-meta">.vm86_info = NULL,\</span><br><span class="hljs-meta">.sysenter_cs = __KERNEL_CS,\</span><br><span class="hljs-meta">.io_bitmap_ptr = NULL,\</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到诸如eip，esp，fs，gs等寄存器放在了这里，但是一些通用的eax等寄存器却不在这里（他们在内核堆栈）。</p><h2 id="进程切换的入口">进程切换的入口</h2><p>进程切换只可能发生在schedule()函数中，这个函数涉及了复杂的调度策略，在选出一个合适的待换入进程后，执行进程切换。本节，我们只关心进程切换。</p><p>进程切换本质上由两步组成：切换页全局目录以安装一个新的地址空间；切换内核态堆栈和硬件上下文。</p><p>忽略调度策略，schedule()对进程切换的处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp">switch_tasks:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 运行到这里，开始进行进程切换了。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (next == rq-&gt;idle)<br><span class="hljs-built_in">schedstat_inc</span>(rq, sched_goidle);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * prefetch提示CPU控制单元把next的进程描述符的第一部分字段的内容装入硬件高速缓存。</span><br><span class="hljs-comment"> * 这改善了schedule的性能。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">prefetch</span>(next);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清除TIF_NEED_RESCHED标志。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">clear_tsk_need_resched</span>(prev);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 记录CPU正在经历静止状态。主要与RCU相关。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">rcu_qsctr_inc</span>(<span class="hljs-built_in">task_cpu</span>(prev));<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 减少prev的平均睡眠时间</span><br><span class="hljs-comment"> */</span><br>prev-&gt;sleep_avg -= run_time;<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)prev-&gt;sleep_avg &lt;= <span class="hljs-number">0</span>)<br>prev-&gt;sleep_avg = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 更新进程的时间戳</span><br><span class="hljs-comment"> */</span><br>prev-&gt;timestamp = prev-&gt;last_ran = now;<br><br><span class="hljs-built_in">sched_info_switch</span>(prev, next);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(prev != next)) &#123;<span class="hljs-comment">/* prev和next不同，需要切换 */</span><br>next-&gt;timestamp = now;<br>rq-&gt;nr_switches++;<br>rq-&gt;curr = next;<br>++*switch_count;<br><br><span class="hljs-built_in">prepare_arch_switch</span>(rq, next);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * context_switch执行真正的进程切换</span><br><span class="hljs-comment"> */</span><br>prev = <span class="hljs-built_in">context_switch</span>(rq, prev, next);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当进程再次被切换进来后，以下代码被接着运行。</span><br><span class="hljs-comment"> * 但是此时prev并不指向当前进程，而是指代码从哪一个进程切换到本进程。</span><br><span class="hljs-comment"> * 由于此时已经进行了进程空间的切换，寄存器中缓存的变量等都不再有效，所以用barrier产生一个优化屏障。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">barrier</span>();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对前一个进程进行一些收尾工作，比如减少它的mm_struct,task_struct的引用计数等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">finish_task_switch</span>(prev);<br>&#125; <span class="hljs-keyword">else</span><span class="hljs-comment">/* 如果prev和next是同一个进程，就不做进程切换。当prev仍然是当前活动集合中的最高优先级进程时，这是有可能发生的。 */</span><br><span class="hljs-built_in">spin_unlock_irq</span>(&amp;rq-&gt;lock);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在前几句中(context_switch之后)，prev代表的是从哪个进程切换到本进程。</span><br><span class="hljs-comment"> * 在继续进行调度之前(因此在context_switch中开了中断，可能刚切回本进程就来了中断，并需要重新调度)，将prev设置成当前进程。</span><br><span class="hljs-comment"> */</span><br>prev = current;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重新获得大内核锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(<span class="hljs-built_in">reacquire_kernel_lock</span>(prev) &lt; <span class="hljs-number">0</span>))<br><span class="hljs-keyword">goto</span> need_resched_nonpreemptible;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 打开抢占，并检查是否需要重新调度。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">preempt_enable_no_resched</span>();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 同时检查其他进程是否设置了当前进程的TIF_NEED_RESCHED标志，</span><br><span class="hljs-comment"> * 如果是，则整个schedule()函数重新开始执行，否则函数结束</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(<span class="hljs-built_in">test_thread_flag</span>(TIF_NEED_RESCHED)))<br><span class="hljs-keyword">goto</span> need_resched;<br></code></pre></td></tr></table></figure><p>此时prev和next指向换出和换入的进程，进入context_switch函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * context_switch - switch to the new MM and the new</span><br><span class="hljs-comment"> * thread&#x27;s register state.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 建立next的地址空间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-type">task_t</span> * <span class="hljs-title">context_switch</span><span class="hljs-params">(<span class="hljs-type">runqueue_t</span> *rq, <span class="hljs-type">task_t</span> *prev, <span class="hljs-type">task_t</span> *next)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *mm = next-&gt;mm;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *oldmm = prev-&gt;active_mm;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果是切换到一个内核线程，新进程就使用pre的地址空间，避免了TLB的切换</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!mm)) &#123;<br>next-&gt;active_mm = oldmm;<br><span class="hljs-built_in">atomic_inc</span>(&amp;oldmm-&gt;mm_count);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 作为更进一步的优化措施，如果新进程是内核线程，就将进程设置为懒惰TLB模式</span><br><span class="hljs-comment"> * xie.baoyou注：请想一下，如果内核线程切换出去后，可能又会回到上一个进程，此时就根本不需要切换地址空间。</span><br><span class="hljs-comment"> * 皆大欢喜，大家都省事了，这叫“懒人有懒福”</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">enter_lazy_tlb</span>(oldmm, next);<br>&#125; <span class="hljs-keyword">else</span><span class="hljs-comment">/* 否则就需要切换内地址空间。 */</span><br>switch_mm(oldmm, mm, next);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果上一个线程是内核线程或正在退出的进程，就把prev内存描述符的指针保存到运行队列的prev_mm中。</span><br><span class="hljs-comment"> * 并清空rq-&gt;prev_mm</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!prev-&gt;mm)) &#123;<br>prev-&gt;active_mm = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">WARN_ON</span>(rq-&gt;prev_mm);<br>rq-&gt;prev_mm = oldmm;<br>&#125;<br><br><span class="hljs-comment">/* Here we just switch the register state and the stack. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 终于可以真正的切换了。</span><br><span class="hljs-comment"> */</span><br>switch_to(prev, next, prev);<br><br><span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="晦涩的switch_to">晦涩的switch_to</h2><p>这个switch_to是个宏，它很有意思，因为除了prev和next外，还有个last参数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程切换时，切换内核态堆栈和硬件上下文。</span><br><span class="hljs-comment"> * prev-被替换的进程</span><br><span class="hljs-comment"> * next-新进程</span><br><span class="hljs-comment"> * last-在任何进程切换中，到三个进程而不是两个。假设内核决定暂停A而激活B，那么在schedule函数中，prev指向A而next指向B。</span><br><span class="hljs-comment"> *      当切换回A后，就必须暂停另外一个进程C。而LAST则指向C进程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> switch_to(prev,next,last) do &#123;\</span><br><span class="hljs-meta">unsigned long esi,edi;\</span><br><span class="hljs-meta"><span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="hljs-meta"> * 在真正执行汇编代码前，已经将prev存入eax，next存入edx中了。</span></span><br><span class="hljs-comment"><span class="hljs-meta"> */</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保存eflags和ebp到内核栈中。必须保存是因为编译器认为在switch_to结束前，</span><br><span class="hljs-comment"> * 它们的值应当保持不变。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;pushfl\n\t&quot;</span>\</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-string">&quot;pushl %%ebp\n\t&quot;</span>\</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      * 把esp的内容保存到prev-&gt;thread.esp中</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      * 这样该字段指向prev内核栈的栈顶。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      */</span></span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-string">&quot;movl %%esp,%0\n\t&quot;</span><span class="hljs-comment">/* save ESP */</span>\</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      * 将next-&gt;thread.esp装入到esp.</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      * 此时，内核开始在next的栈上进行操作。这条指令实际上完成了从prev到next的切换。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      * 由于进程描述符的地址和内核栈的地址紧挨着，所以改变内核栈意味着改变当前进程。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      */</span></span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-string">&quot;movl %5,%%esp\n\t&quot;</span><span class="hljs-comment">/* restore ESP */</span>\</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      * 将标记为1f的地址存入prev-&gt;thread.eip.</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      * 当被替换的进程重新恢复执行时，进程执行被标记为1f的那条指令。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      */</span></span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-string">&quot;movl $1f,%1\n\t&quot;</span><span class="hljs-comment">/* save EIP */</span>\</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      * 将next-&gt;thread.eip的值保存到next的内核栈中。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      * 这样，_switch_to调用ret返回时，就会跳转到next-&gt;thread.eip执行。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      * 这个地址一般情况下就会是1f.</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      */</span></span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-string">&quot;pushl %6\n\t&quot;</span><span class="hljs-comment">/* restore EIP */</span>\</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      * 注意，这里不是用call，是jmp，这样，上一条语句中压入的eip地址就可以执行了。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      */</span></span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-string">&quot;jmp __switch_to\n&quot;</span>\</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      * 到这里，进程A再次获得CPU。它从栈中弹出ebp和eflags。</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">      */</span></span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-string">&quot;1:\t&quot;</span>\</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-string">&quot;popl %%ebp\n\t&quot;</span>\</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-string">&quot;popfl&quot;</span>\</span></span><br><span class="hljs-params"><span class="hljs-function">     :<span class="hljs-string">&quot;=m&quot;</span> (prev-&gt;thread.esp),<span class="hljs-string">&quot;=m&quot;</span> (prev-&gt;thread.eip),\</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-comment">/* last被作为输出参数，它的值会由eax赋给它。 */</span></span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-string">&quot;=a&quot;</span> (last),<span class="hljs-string">&quot;=S&quot;</span> (esi),<span class="hljs-string">&quot;=D&quot;</span> (edi)\</span></span><br><span class="hljs-params"><span class="hljs-function">     :<span class="hljs-string">&quot;m&quot;</span> (next-&gt;thread.esp),<span class="hljs-string">&quot;m&quot;</span> (next-&gt;thread.eip),\</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-string">&quot;2&quot;</span> (prev), <span class="hljs-string">&quot;d&quot;</span> (next))</span></span>;\<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></p><p>这个宏是用AT&amp;T汇编语法写的，不是很好理解，虽然上述代码根据ULK的描述，已一一按桩插入，但我们还是展开成最终反汇编码说明。</p><blockquote><p>AT&amp;T汇编语法的基础知识，可以参考毛批的第一章。</p></blockquote><ol type="1"><li>eax和edx分别保存prev和next: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">movl prev, %eax<br>movl next, %edx<br></code></pre></td></tr></table></figure></li><li>eflags和ebp保存到prev的内核堆栈： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">pushfl<br>pushl %ebp<br></code></pre></td></tr></table></figure></li><li>把esp的内容保存到prev-&gt;thread.esp中使得该字段指向prev内核堆栈栈顶：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">movl %esp, 484(%eax)<br></code></pre></td></tr></table></figure>484(%eax)表示内存单元地址为eax+484，也就是prev-&gt;thread.esp。</li><li>把next-&gt;thread.esp装入esp。esp指向了next的内核栈，就代表此时内核切换到了next的内核栈。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">movl 484(%edx), %esp<br></code></pre></td></tr></table></figure></li><li>把标记为1的地址放入prev-&gt;thread.eip，这表示替换的进程再次恢复执行时，restore出eip，从1处继续执行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">movl $1f, 480(%eax)<br></code></pre></td></tr></table></figure> 480(%eax)就是prev-&gt;thread.eip</li><li>对称的，把next-&gt;thread.eip的值（大概率就是上一次压入的1的地址，如果它未被换出过，那情况要复杂一些）压入next内核栈：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">pushl 480(%edx)<br></code></pre></td></tr></table></figure></li><li>跳到__switch_to() C函数： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">jmp __switch_to<br></code></pre></td></tr></table></figure></li><li>从__switch_to回来后，实际上已经变成了next进程，而__switch_to实际上内部是通过ret返回的，那么返回地址也就刚好是push的next-&gt;thread.eip。玩安全的想必非常熟悉，这是经典的push+jmp+ret伪造call指令。于是，next执行从1标签开始的指令，进行restore，而此时因为堆栈早已换成next自己的，所以pop出来的也就是上一次被换出时保存的ebp和eflags。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">1:<br>popl %ebp<br>popfl<br></code></pre></td></tr></table></figure></li><li>拷贝eax的内容到switch_to的第三个参数last标记的内存区域中：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">movl %eax, last<br></code></pre></td></tr></table></figure>prev和next是进程堆栈中的两个局部变量，那么对于两个进程来说，我们把prev标志的称为A，next标志的称为B。A的进程堆栈中有着prev和next，在切换前夕，prev是A，next是B。当跳到__switch_to后，ret回来，此时就是进程B的堆栈，而B的堆栈中同样有上一次的prev和next，B的prev应该是B本身，而B的next应该是上一次B切换到C时的C。而我们设计上，希望从A切换到B时，不仅能够保证A的prev和next正确，还要保证切换到B后，B的prev也是正确的。如果只是单纯的A-&gt;B-&gt;A在不会有问题，他们的prev和next都是正确的，但是如果A-&gt;B，C-&gt;A就会有问题:（注意，这里换入的进程的prev还没有被eax重置，这一忽略曾让我怀疑人生）</li></ol><p><img src="20170826_1.jpg" /></p><p>由于A此前在切换到B时，堆栈上prev和next保存的分别是A和B，那么如果我们从C到A时，A的prev依然是A，这就有问题了。A的prev明明应该是C才对（这就是前面说的我们不仅要保证换出的C的prev和next正确，换入的A的prev也应该正确，至于A的next，whocare?等它再次切换时自己就处理好了）。本质上来讲，这其实就是堆栈切换后，局部变量因为他的含义需要相应调整的故事。所以switch_to宏多引入了一个last变量，last实际上就是prev，__switch_to返回值eax实际上就是A的prev，因为执行__switch_to时prev变量指向的还是A的prev，而ret回去后，prev变量就是B的堆栈上的prev。因此，借由__switch_to前传递A的prev，ret后再返回这个A的prev值给B，用于覆盖B的prev，那么B的prev由谁覆盖？答案就是last，eax值返回给last，用last覆盖B的prev，从而保持了prev的字面意义。</p><p>如果说prev和next是变化的状态量，随着进程切换而改变意义，那么这个一开始和prev一致的last就是个过程量，用于切换后以A的prev正确的重置B的prev。prev和next是输入型变量，last是输出型变量，用于指明切换后被覆盖的地址。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">movl %eax, last<br></code></pre></td></tr></table></figure></p><p>这一过程非常的复杂，我自己也是研究了好久才弄明白，但是当我捋清了整个流程，便惊叹于内核设计的绝伦精妙。</p><p>我在网上淘金时，挖到了描述这一过程不错的图例：</p><p><img src="20170826_2.jpg" /> <img src="20170826_3.jpg" /></p><h2 id="switch_to函数">__switch_to函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __switch_to函数执行大多数进程切换的工作。</span><br><span class="hljs-comment"> * 进程切换的工作开始于switch_to宏，但是它的主要工作还是由__switch_to完成。</span><br><span class="hljs-comment"> * 这个函数是寄存器传参的函数。在switch_to宏中，参数已经保存在eax和edx中了.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> fastcall * __switch_to(<span class="hljs-keyword">struct</span> task_struct *prev_p, <span class="hljs-keyword">struct</span> task_struct *next_p)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_struct</span> *prev = &amp;prev_p-&gt;thread,<br> *next = &amp;next_p-&gt;thread;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过读取current_thread_info()-&gt;cpu,获得当前进程在哪个CPU上运行.</span><br><span class="hljs-comment"> * 因为在schedule函数中已经调用了禁用抢占,所以这里可以直接使用smp_processor_id()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> cpu = <span class="hljs-built_in">smp_processor_id</span>();<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tss_struct</span> *tss = &amp;<span class="hljs-built_in">per_cpu</span>(init_tss, cpu);<br><br><span class="hljs-comment">/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __unlazy_fpu宏有选择的保存FPU\MMX\XMM寄存器的内容.</span><br><span class="hljs-comment"> * 它可能会延后保存这些寄存器的内容.</span><br><span class="hljs-comment"> */</span><br>__unlazy_fpu(prev_p);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Reload esp0, LDT and the page table pointer:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把next_p-&gt;thread.esp0装入本地CPU的TSS的esp0字段.</span><br><span class="hljs-comment"> * 任何由sysenter汇编指令产生的从用户态到内核态的特权级转换将把这个地址复制到esp寄存器.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">load_esp0</span>(tss, next);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Load the per-thread Thread-Local Storage descriptor.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将next_p进程使用的线程局部存储(TLS)段装入本地CPU的全局描述符表.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">load_TLS</span>(next, cpu);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Save away %fs and %gs. No need to save %es and %ds, as</span><br><span class="hljs-comment"> * those are always kernel segments while inside the kernel.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把fs和gs段寄存器的内容分别存放在prev_p-&gt;thread.fs和prev_p-&gt;thread.gs中.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movl %%fs,%0&quot;</span>:<span class="hljs-string">&quot;=m&quot;</span> (*(<span class="hljs-type">int</span> *)&amp;prev-&gt;fs))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movl %%gs,%0&quot;</span>:<span class="hljs-string">&quot;=m&quot;</span> (*(<span class="hljs-type">int</span> *)&amp;prev-&gt;gs))</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Restore %fs and %gs if needed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不管是prev还是next,只要他们使用了fs和gs,那么,都需要将next中的fs,gs更新到段寄存器.</span><br><span class="hljs-comment"> * 即使next并不使用fs,但是只要prev使用了,也需要更新.这样可以防止next通过fs,gs访问prev的数据.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(prev-&gt;fs | prev-&gt;gs | next-&gt;fs | next-&gt;gs)) &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * loadsegment可能会装载一个无效的段寄存器.CPU可能会产生一个异常.</span><br><span class="hljs-comment"> * 但是loadsegment会采用代码修正技术来处理这种情况.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">loadsegment</span>(fs, next-&gt;fs);<br><span class="hljs-built_in">loadsegment</span>(gs, next-&gt;gs);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Now maybe reload the debug registers</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用debugreg数组的内容dr0..dr7中的6个调试寄存器.这允许定义四个断点区域.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(next-&gt;debugreg[<span class="hljs-number">7</span>])) &#123;<br><span class="hljs-built_in">loaddebug</span>(next, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">loaddebug</span>(next, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">loaddebug</span>(next, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">loaddebug</span>(next, <span class="hljs-number">3</span>);<br><span class="hljs-comment">/* no 4 and 5 */</span><br><span class="hljs-built_in">loaddebug</span>(next, <span class="hljs-number">6</span>);<br><span class="hljs-built_in">loaddebug</span>(next, <span class="hljs-number">7</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果必要,更新TSS中的IO位图.当next或者prev有其自己的定制IO权限位图时必须这么做.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(prev-&gt;io_bitmap_ptr || next-&gt;io_bitmap_ptr))<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * handle_io_bitmap并不立即更新位图,而是采用一种懒模式的方法.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">handle_io_bitmap</span>(next, tss);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * return产生的汇编指令是movl %edi, %eax,ret.</span><br><span class="hljs-comment"> * 这里有保护eax和返回地址的问题.请仔细理解.</span><br><span class="hljs-comment"> * 除了需要理解switch_to宏中的jmp指令外,对于没有产生切换,而是第一次开始执行的进程.</span><br><span class="hljs-comment"> * 它并不会跳回switch_to,而是找到ret_from_fork函数的超始地址.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> prev_p;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，进程切换中硬件上下文的实质性工作都是在这里处理的，而__switch_to返回值就是传入的prev_p，也就是switch_to中的prev局部变量，这个变量在执行jmp__switch_to之前代表着A的prev。</p><p>值得一提的是，__switch_to的函数参数不是通过栈传递的，而是指定了eax和edx寄存器，__switch_to什么都没有做，只是在对应Makefile中写上了<code>KBUILD_CFLAGS += -msoft-float -mregparm=3 -freg-struct-return</code>，-mregparm=3表示默认使用3个寄存器传参。</p><p><font color="red">一言以蔽之，进程切换的关键操作无非就是切换地址空间、切换内核堆栈、切换内核控制流程以及必要寄存器的现场保护与还原。</font></p><h2 id="参考文献">参考文献</h2><ul><li><ahref="http://home.ustc.edu.cn/~hchunhui/linux_sched.html">x86体系结构下Linux-2.6.26的进程调度和切换</a></li><li><a href="http://blog.csdn.net/titer1/article/details/45289159">linux进程调度switch_to宏浅析+系统执行过程总结</a></li><li><ahref="http://www.cnblogs.com/visayafan/archive/2011/12/10/2283660.html">【内核】进程切换switch_to 与 __switch_to</a></li><li>《深入理解Linux内核》</li><li>《Linux内核源代码情景分析(上)》</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux-kernel</tag>
      
      <tag>ulk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核学习——Linux进程概述</title>
    <link href="/2017/08/22/Linux%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
    <url>/2017/08/22/Linux%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>近年来陆陆续续对Linux内核各模块做些研究，本文是对Linux内核中进程基本概念的一点研究。主要参考ULK以及毛批，结合自己的一些深入的理解，以及从源代码中翻箱倒柜获取的心得。</p><span id="more"></span><h1 id="linux内核学习linux进程概述">Linux内核学习——Linux进程概述</h1><h2 id="活在os理论中的进程与线程">活在OS理论中的进程与线程</h2><p>进程与线程是OS理论中的基本概念。在理论中，进程通常被定义成一个正在运行的程序的实例。举个例子，你在Windows系统上运行一个notepad.exe，这个notepad.exe就会被拉到RAM中映射成一个应用程序，这个应用程序就是进程。同理，在Linux下，使用vim编辑某个文件，vim也被拉到了RAM中映射出一个进程。</p><p>进程由两部分组成： - OS管理进程的内核对象。 - 自己的地址空间</p><p>线程和进程很相似，同样由两部分组成： - 一个是线程的内核对象 -自己专有的资源（如线程堆栈地址空间）</p><h2 id="linux的进程轻量级进程与线程">Linux的进程、轻量级进程与线程</h2><p>然而，理论毕竟是理论，各种OS真正在实现时，其抽象体与具象体的设计往往并不一致。</p><p>拿我比较熟悉的Windows来说，Windows中进程是一个相对抽象的概念，进程本身是不干活的，进程包含了一个(主线程)或多个线程，这些线程实际上才是干活的主体对象。一个进程只是定义了内核对象（用于管理，状态标志等）和一片自己的地址空间(每个程序都告诉自己有4G的线性地址，其中高2G内核领空共用)。每个线程也有他自己的内核对象，以及它所属进程的地址空间中的一部分（主要是线程堆栈）。用Windows话来说，进程是不活泼的，从不执行任何东西，只是线程的容器。线程是活泼的，同属于一个进程的所有线程共享这片地址空间，但每个线程又有它自己的一亩三分地，这就使得同组线程的交互极为简单，而不同组线程又被相对隔离。</p><p>而Linux则大相径庭，Linux中进程和线程的概念有那么一点混淆不清，不似Windows般泾渭分明。纵观Linux源代码，各路Author常把进程称为task或thread（实际上叫Process更合适），各种结构的命名上可见一斑。</p><p>但无论你如何命名，如何设计，从内核观点来看，进程的目的就在于担当分配系统资源（CPU分片、地址空间）的实体。Linux中除了第一个pid为0的进程，所有的进程都是复制出来的。父子进程虽然可以共享程序代码页，但有自己独立的数据拷贝。子进程自身内存单元的修改对父进程是不可见的，反之亦然。</p><blockquote><p>这和Windows的进程设计完全不同，Windows是可以由OS通过CreateProcess捏出一个无父无母的进程，Linux的每个进程却都是克隆出来的，Linux从未提供一个类似CreateProcess的方法来凭空捏一个进程，唯有通过fork(),clone()或vfork()复制。</p></blockquote><p>Linux内核没有线程，POSIX兼容的pthread库在早期的Linux上，其多个执行流的创建、处理、调度整个都是在用户态进行的。因此，pthread引入的所谓多线程应用程序从内核角度来看，只是一个普通进程。</p><p>然而，Linux还是拗不过潮流，这种老式的设计在很多情况下的表现不尽人意。ULK的例子尤为生动，假设一个象棋程序使用两个线程：线程A负责GUI，等待人类棋手移动并显示计算机的移动；线程B思考下一手棋。尽管A等待人类选手时，B应当继续运行，把时间利用起来。但是，如果象棋程序是一个单独进程，A就不能简单的发出等待用户行为的阻塞系统调用，否则B也会阻塞。相反，A需要利用复杂的非阻塞技术确保进程仍然是可运行的（轮询，自旋）。</p><p>现代Linux对此妥协，对比Windows的设计来说，前者引入了一个不伦不类的概念：轻量级进程(lightweightprocess)。用于对多线程提供更好的支持。两个轻量级进程基本上可以共享一些资源，比如地址空间、打开的文件等。只要其中一个修改共享资源，那么另一个就立即查看这种修改。当然，两个线程访问共享资源时需要同步处理。</p><p>于是处理多线程时，可以把轻量级进程和每个线程关联起来。线程之间可以简单地共享同一内存地址空间、打开文件集等。每个线程也就由内核独立调度，不再出现一个发出阻塞系统调用，其他宕机的情况。</p><p>归根结底，Linux的基本单元是进程。</p><h2 id="进程描述符">进程描述符</h2><p>有进程就得有管理的媒介。进程描述符用于提供内核进程的优先级、运行状态、地址空间等信息。Linux的进程描述符是<code>task_struct</code>结构，该字段极为庞大复杂，包含了进程相关的所有信息。</p><p><img src="20170822_1.jpg" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程状态。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> state;<span class="hljs-comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程的基本信息。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_info</span> *thread_info;<br><span class="hljs-type">atomic_t</span> usage;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<span class="hljs-comment">/* per process flags, defined below */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ptrace;<br><br><span class="hljs-type">int</span> lock_depth;<span class="hljs-comment">/* Lock depth */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进行的动态优先权和静态优先权</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> prio, static_prio;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程所在运行队列。每个优先级对应一个运行队列。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> run_list;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向当前运行队列的prio_array_t</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">prio_array_t</span> *array;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程的平均睡眠时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sleep_avg;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * timestamp-进程最近插入运行队列的时间。或涉及本进程的最近一次进程切换的时间</span><br><span class="hljs-comment"> * last_ran-最近一次替换本进程的进程切换时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> timestamp, last_ran;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程被唤醒时所使用的代码。</span><br><span class="hljs-comment"> *     0:进程处于TASK_RUNNING状态。</span><br><span class="hljs-comment"> *     1:进程处于TASK_INTERRUPTIBLE或者TASK_STOPPED状态，而且正在被系统调用服务例程或内核线程唤醒。</span><br><span class="hljs-comment"> *     2:进程处于TASK_INTERRUPTIBLE或者TASK_STOPPED状态，而且正在被ISR或者可延迟函数唤醒。</span><br><span class="hljs-comment"> *     -1:表示从UNINTERRUPTIBLE状态被唤醒</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> activated;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程的调度类型:sched_normal,sched_rr或者sched_fifo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> policy;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 能执行进程的CPU的位掩码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">cpumask_t</span> cpus_allowed;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * time_slice-在进程的时间片中，还剩余的时钟节拍数。</span><br><span class="hljs-comment"> * first_time_slice-如果进程肯定不会用完其时间片，就把该标志设置为1.</span><br><span class="hljs-comment"> *            xie.baoyou注:原文如此,应该是表示任务是否是第一次执行。这样，如果是第一次执行，并且在开始运行</span><br><span class="hljs-comment"> *                         的第一个时间片内就运行完毕，那么就将剩余的时间片还给父进程。主要是考虑到有进程</span><br><span class="hljs-comment"> *                         会大量的动态创建子进程时，而子进程会立即退出这种情况。如果不还给父进程时间片，会对这种进程不公平。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> time_slice, first_time_slice;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SCHEDSTATS</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sched_info</span> sched_info;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过此链表把所有进程链接到一个双向链表中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> tasks;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ptrace_list/ptrace_children forms the list of my children</span><br><span class="hljs-comment"> * that were stolen by a ptracer.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 链表的头。该链表包含所有被debugger程序跟踪的P的子进程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> ptrace_children;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向所跟踪进程其实际父进程链表的前一个下一个元素。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> ptrace_list;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * mm:指向内存区描述符的指针</span><br><span class="hljs-comment"> * mm字段指向进程所拥有的内存描述符，而active_mm字段指向进程运行时所使用的内存描述符</span><br><span class="hljs-comment"> * 对于普通进程而已，这两个字段存放相同的指针，但是，内核线程不拥有任何内存描述符，因此，他们的mm字段总是为NULL</span><br><span class="hljs-comment"> * 当内核线程得以运行时，他的active_mm字段被初始化为前一个运行进程的active_mm值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *mm, *active_mm;<br><br><span class="hljs-comment">/* task state */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">linux_binfmt</span> *binfmt;<br><span class="hljs-type">long</span> exit_state;<br><span class="hljs-type">int</span> exit_code, exit_signal;<br><span class="hljs-type">int</span> pdeath_signal;  <span class="hljs-comment">/*  The signal sent when the parent dies  */</span><br><span class="hljs-comment">/* ??? */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> personality;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程发出execve系统调用的次数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> did_exec:<span class="hljs-number">1</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程PID</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">pid_t</span> pid;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程组领头线程的PID。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">pid_t</span> tgid;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * pointers to (original) parent process, youngest child, younger sibling,</span><br><span class="hljs-comment"> * older sibling, respectively.  (p-&gt;father can be replaced with </span><br><span class="hljs-comment"> * p-&gt;parent-&gt;pid)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向创建进程的进程的描述符。</span><br><span class="hljs-comment"> * 如果进程的父进程不再存在，就指向进程1的描述符。</span><br><span class="hljs-comment"> * 因此，如果用户运行一个后台进程而且退出了shell，后台进程就会成为init的子进程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> *real_parent; <span class="hljs-comment">/* real parent process (when being debugged) */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向进程的当前父进程。这种进程的子进程终止时，必须向父进程发信号。</span><br><span class="hljs-comment"> * 它的值通常与real_parent一致。</span><br><span class="hljs-comment"> * 但偶尔也可以不同。例如：当另一个进程发出监控进程的ptrace系统调用请求时。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> *parent;<span class="hljs-comment">/* parent process */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * children/sibling forms the list of my children plus the</span><br><span class="hljs-comment"> * tasks I&#x27;m ptracing.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 链表头部。链表指向的所有元素都是进程创建的子进程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> children;<span class="hljs-comment">/* list of my children */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向兄弟进程链表的下一个元素或前一个元素的指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> sibling;<span class="hljs-comment">/* linkage in my parent&#x27;s children list */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * P所在进程组的领头进程的描述符指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> *group_leader;<span class="hljs-comment">/* threadgroup leader */</span><br><br><span class="hljs-comment">/* PID/PID hash table linkage. */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * PID散列表。通过这四个表，可以方便的查找同一线程组的其他线程，同一会话的其他进程等等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pid</span> pids[PIDTYPE_MAX];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">completion</span> *vfork_done;<span class="hljs-comment">/* for vfork() */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 子进程在用户态的地址。这些用户态地址的值将被设置或者清除。</span><br><span class="hljs-comment"> * 在do_fork时记录这些地址，稍后再设置或者清除它们的值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> __user *set_child_tid;<span class="hljs-comment">/* CLONE_CHILD_SETTID */</span><br><span class="hljs-type">int</span> __user *clear_child_tid;<span class="hljs-comment">/* CLONE_CHILD_CLEARTID */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程的实时优先级。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rt_priority;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以下三对值用于用户态的定时器。当定时器到期时，会向用户态进程发送信号。</span><br><span class="hljs-comment"> * 每一对值分别存放了两个信号之间以节拍为单位的间隔，及定时器的当前值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> it_real_value, it_real_incr;<br><span class="hljs-type">cputime_t</span> it_virt_value, it_virt_incr;<br><span class="hljs-type">cputime_t</span> it_prof_value, it_prof_incr;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 每个进程的动态定时器。用于实现ITIMER_REAL类型的间隔定时器。</span><br><span class="hljs-comment"> * 由settimer系统调用初始化。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timer_list</span> real_timer;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程在用户态和内核态下经过的节拍数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">cputime_t</span> utime, stime;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nvcsw, nivcsw; <span class="hljs-comment">/* context switch counts */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> start_time;<br><span class="hljs-comment">/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> min_flt, maj_flt;<br><span class="hljs-comment">/* process credentials */</span><br><span class="hljs-type">uid_t</span> uid,euid,suid,fsuid;<br><span class="hljs-type">gid_t</span> gid,egid,sgid,fsgid;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">group_info</span> *group_info;<br><span class="hljs-type">kernel_cap_t</span>   cap_effective, cap_inheritable, cap_permitted;<br><span class="hljs-type">unsigned</span> keep_capabilities:<span class="hljs-number">1</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">user_struct</span> *user;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEYS</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">key</span> *session_keyring;<span class="hljs-comment">/* keyring inherited over fork */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">key</span> *process_keyring;<span class="hljs-comment">/* keyring private to this process (CLONE_THREAD) */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">key</span> *thread_keyring;<span class="hljs-comment">/* keyring private to this thread */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">int</span> oomkilladj; <span class="hljs-comment">/* OOM kill score adjustment (bit shift). */</span><br><span class="hljs-type">char</span> comm[TASK_COMM_LEN];<br><span class="hljs-comment">/* file system info */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文件系统在查找路径时使用，避免符号链接查找深度过深，导致死循环。</span><br><span class="hljs-comment"> * link_count是__do_follow_link递归调用的层次。</span><br><span class="hljs-comment"> * total_link_count调用__do_follow_link的总次数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> link_count, total_link_count;<br><span class="hljs-comment">/* ipc stuff */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sysv_sem</span> sysvsem;<br><span class="hljs-comment">/* CPU-specific state of this task */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_struct</span> thread;<br><span class="hljs-comment">/* filesystem information */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 与文件系统相关的信息。如当前目录。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fs_struct</span> *fs;<br><span class="hljs-comment">/* open file information */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向文件描述符的指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">files_struct</span> *files;<br><span class="hljs-comment">/* namespace */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">namespace</span> *<span class="hljs-keyword">namespace</span>;<br><span class="hljs-comment">/* signal handlers */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向进程的信号描述符的指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">signal_struct</span> *signal;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向进程的信号处理程序描述符的指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sighand_struct</span> *sighand;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * blocked-被阻塞的信号的掩码</span><br><span class="hljs-comment"> * real_blocked-被阻塞信号的临时掩码（由rt_sigtimedwait系统调用使用）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">sigset_t</span> blocked, real_blocked;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 存放私有挂起信号的数据结构</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigpending</span> pending;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 信号处理程序备用堆栈的地址</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sas_ss_sp;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 信号处理程序备用堆栈的大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">size_t</span> sas_ss_size;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向一个函数的指针，设备驱动程序使用这个函数阻塞进程的某些信号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">int</span> (*notifier)(<span class="hljs-type">void</span> *priv);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向notifier函数可能使用的数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> *notifier_data;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 设备驱动程序通过notifier 函数所阻塞的信号的位掩码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">sigset_t</span> *notifier_mask;<br><br><span class="hljs-type">void</span> *security;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">audit_context</span> *audit_context;<br><br><span class="hljs-comment">/* Thread group tracking */</span><br>   u32 parent_exec_id;<br>   u32 self_exec_id;<br><span class="hljs-comment">/* Protection of (de-)allocation: mm, files, fs, tty, keyrings */</span><br><span class="hljs-type">spinlock_t</span> alloc_lock;<br><span class="hljs-comment">/* Protection of proc_dentry: nesting proc_lock, dcache_lock, write_lock_irq(&amp;tasklist_lock); */</span><br><span class="hljs-type">spinlock_t</span> proc_lock;<br><span class="hljs-comment">/* context-switch lock */</span><br><span class="hljs-type">spinlock_t</span> switch_lock;<br><br><span class="hljs-comment">/* journalling filesystem info */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当前活动日志操作处理的地址。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> *journal_info;<br><br><span class="hljs-comment">/* VM state */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">reclaim_state</span> *reclaim_state;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dentry</span> *proc_dentry;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">backing_dev_info</span> *backing_dev_info;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">io_context</span> *io_context;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ptrace_message;<br><span class="hljs-type">siginfo_t</span> *last_siginfo; <span class="hljs-comment">/* For ptrace use.  */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * current io wait handle: wait queue entry to use for io waits</span><br><span class="hljs-comment"> * If this thread is processing aio, this points at the waitqueue</span><br><span class="hljs-comment"> * inside the currently handled kiocb. It may be NULL (i.e. default</span><br><span class="hljs-comment"> * to a stack based synchronous wait) if its doing sync IO.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">wait_queue_t</span> *io_wait;<br><span class="hljs-comment">/* i/o counters(bytes read/written, #syscalls */</span><br>u64 rchar, wchar, syscr, syscw;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_BSD_PROCESS_ACCT)</span><br>u64 acct_rss_mem1;<span class="hljs-comment">/* accumulated rss usage */</span><br>u64 acct_vm_mem1;<span class="hljs-comment">/* accumulated virtual memory usage */</span><br><span class="hljs-type">clock_t</span> acct_stimexpd;<span class="hljs-comment">/* clock_t-converted stime since last update */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mempolicy</span> *mempolicy;<br><span class="hljs-type">short</span> il_next;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>包罗万象！</p><h3 id="进程状态">进程状态</h3><p>state描述进程状态，0表示正在运行或准备执行(runnable)，-1表示unrunnable，而大于0的情况都是stop态，此时要根据具体的值来判断其所处状态：</p><p>以下代码展示了各种状态值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程要么在CPU上执行，要么准备执行。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_RUNNING0</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 可中断的等待状态。</span><br><span class="hljs-comment"> * 进程被挂起，直到某个条件变为真。产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都是可以唤醒进程的条件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_INTERRUPTIBLE1</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不可中断的等待状态。</span><br><span class="hljs-comment"> * 这种情况很少，但是有时也有用：比如进程打开一个设备文件，其相应的驱动程序在探测硬件设备时，就是这种状态。</span><br><span class="hljs-comment"> * 在探测完成前，设备驱动程序如果被中断，那么硬件设备的状态可能会处于不可预知状态。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_UNINTERRUPTIBLE2</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 暂停状态。当收到SIGSTOP,SIGTSTP,SIGTTIN或者SIGTTOU信号后，会进入此状态。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_STOPPED4</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 被跟踪状态。当进程被另外一个进程监控时，任何信号都可以把这个置于该状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_TRACED8</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 僵死状态。进程的执行被终止，但是，父进程还没有调用完wait4和waitpid来返回有关</span><br><span class="hljs-comment"> * 死亡进程的信息。在此时，内核不能释放相关数据结构，因为父进程可能还需要它。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXIT_ZOMBIE16</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在父进程调用wait4后，删除前，为避免其他进程在同一进程上也执行wait4调用</span><br><span class="hljs-comment"> * 将其状态由EXIT_ZOMBIE转为EXIT_DEAD，即僵死撤销状态。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXIT_DEAD32</span><br></code></pre></td></tr></table></figure></p><p>state字段的值通常都是简单的赋值语句：<code>p-&gt;state = TASK_RUNNING</code></p><blockquote><p>虽然设计上可以看出每个状态都是一个二进制位，理论上可以置多位。但当前的Linux中，这些标志全部都是互斥的。</p></blockquote><p>每个进程都有也必须有自己的进程描述符（包括轻量级进程，因为它也能独立调度每个执行上下文）。进程和描述符间存在一一对应的关系，进程描述符指针指向这些地址，内核对进程的大部分引用都是通过进程描述符指针进行的。</p><h3 id="pid">PID</h3><p>Linux的每个进程都有一个PID，这个PID放在task_struct的pid中。pid循环使用，内核通过一个pidmap-array位图来管理PID的分配。Linux把不同的PID与系统中每个进程相关联。这种方式十分灵活，因为系统中每个执行上下文都可以被唯一地识别。</p><p>而因为考虑到多线程的支持，Linux引入线程组的表示。一个线程组中所有线程使用和该线程组领头线程相同的PID，也就是该组中第一个轻量级进程的PID，它放入task_struct的tgid字段。多线程应用程序的所有线程共享相同的PID。绝大多数进程都属于一个线程组，包含单一的成员；线程组的领头线程其tgid的值与pid的值相同。</p><blockquote><p>getpid()返回的是tgid值而不是gid值。某种视角来看，Linux多线程的支持概念中，线程和进程的地位刚好和Windows相反。</p></blockquote><h3 id="进程-进程描述符">进程&lt;-&gt;进程描述符</h3><p>进程是动态的，内核显然不能把进程描述符放在永久分配的静态内存区，而应该放在动态内存中。对每个进程来说，Linux把两个不同的数据结构紧凑地存放在一个单独为进程分配的存储区域内：内核态堆栈+thread_info。</p><p><img src="20170822_2.jpg" /></p><p>共同占据了8K也就是两页的内存，栈向上增长，thread_info有个task指针指向了进程描述符，进程描述符也通过thread_info指针指向这一结构，形成互相引用的关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内核栈与thread_info的联合体。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">thread_union</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_info</span> thread_info;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack[THREAD_SIZE/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>)];<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>考虑到效率因素，内核会让这8K占据连续的两个物理页框，第一个页框起始地址总是<code>1&lt;&lt;13</code>的倍数。另一方面因为连续页框会导致大量碎片，所以x86也提供了编译时的设置项，可以让内核栈和线程描述符跨越一个单独的页框。</p></blockquote><p>因为esp的关系，内核想要获取thread_info非常简单，current_thread_info()来完成这一简单的操作：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># AT&amp;T汇编产生的汇编指令</span><br><span class="hljs-attribute">movl</span> <span class="hljs-variable">$0</span>xffffe000, <span class="hljs-variable">$ecx</span><br>andl <span class="hljs-variable">$esp</span>, <span class="hljs-variable">$ecx</span><br>movl <span class="hljs-variable">$ecx</span>, p<br></code></pre></td></tr></table></figure><p>实际上就是简单的把esp的低13位归零，自然就对应着thread_union的起始地址，也正是thread_info。进一步拿到current则有:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> current get_current()</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> * <span class="hljs-built_in">get_current</span>(<span class="hljs-type">void</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">current_thread_info</span>()-&gt;task;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>栈存放进程描述符的优点在于多处理器上，每个处理器只需要通过检查栈就可以获得当前正确的进程。</p></blockquote><h3 id="双向链表">双向链表</h3><p>Linux内核有个通用的结构list_head，本身只是个双向循环链表。但Linux常常把它嵌入到某个struct中，间接实现struct的链式管理：</p><p><img src="20170822_3.jpg" /></p><p>注意next和prev指针指向的不是某个struct，而是struct中list_head的首地址（显然是为了泛用型设计）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Simple doubly linked list implementation.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Some of the internal functions (&quot;__xxx&quot;) are useful when</span><br><span class="hljs-comment"> * manipulating whole lists rather than single entries, as</span><br><span class="hljs-comment"> * sometimes we already know the next/prev entries and we can</span><br><span class="hljs-comment"> * generate better code by using them directly rather than</span><br><span class="hljs-comment"> * using the generic single-entry routines.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> *next, *prev;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建一个新的链表。是新链表头的占位符，并且是一个哑元素。</span><br><span class="hljs-comment"> * 同时初始化prev和next字段，让它们指向list_name变量本身。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_HEAD(name) \</span><br><span class="hljs-meta">struct list_head name = LIST_HEAD_INIT(name)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_LIST_HEAD(ptr) do &#123; \</span><br><span class="hljs-meta">(ptr)-&gt;next = (ptr); (ptr)-&gt;prev = (ptr); \</span><br><span class="hljs-meta">&#125; while (0)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Insert a new entry between two known consecutive entries.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This is only for internal list manipulation where we know</span><br><span class="hljs-comment"> * the prev/next entries already!</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __list_add(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-keyword">new</span>,<br>      <span class="hljs-keyword">struct</span> list_head *prev,<br>      <span class="hljs-keyword">struct</span> list_head *next)<br>&#123;<br>next-&gt;prev = <span class="hljs-keyword">new</span>;<br><span class="hljs-keyword">new</span>-&gt;next = next;<br><span class="hljs-keyword">new</span>-&gt;prev = prev;<br>prev-&gt;next = <span class="hljs-keyword">new</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_add - add a new entry</span><br><span class="hljs-comment"> * @new: new entry to be added</span><br><span class="hljs-comment"> * @head: list head to add it after</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Insert a new entry after the specified head.</span><br><span class="hljs-comment"> * This is good for implementing stacks.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把元素插入特定元素之后</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">list_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-keyword">new</span>, <span class="hljs-keyword">struct</span> list_head *head)</span></span><br><span class="hljs-function"></span>&#123;<br>__list_add(<span class="hljs-keyword">new</span>, head, head-&gt;next);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_add_tail - add a new entry</span><br><span class="hljs-comment"> * @new: new entry to be added</span><br><span class="hljs-comment"> * @head: list head to add it before</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Insert a new entry before the specified head.</span><br><span class="hljs-comment"> * This is useful for implementing queues.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把元素插到特定元素之前。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">list_add_tail</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-keyword">new</span>, <span class="hljs-keyword">struct</span> list_head *head)</span></span><br><span class="hljs-function"></span>&#123;<br>__list_add(<span class="hljs-keyword">new</span>, head-&gt;prev, head);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Insert a new entry between two known consecutive entries.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This is only for internal list manipulation where we know</span><br><span class="hljs-comment"> * the prev/next entries already!</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __list_add_rcu(<span class="hljs-keyword">struct</span> list_head * <span class="hljs-keyword">new</span>,<br><span class="hljs-keyword">struct</span> list_head * prev, <span class="hljs-keyword">struct</span> list_head * next)<br>&#123;<br><span class="hljs-keyword">new</span>-&gt;next = next;<br><span class="hljs-keyword">new</span>-&gt;prev = prev;<br><span class="hljs-built_in">smp_wmb</span>();<br>next-&gt;prev = <span class="hljs-keyword">new</span>;<br>prev-&gt;next = <span class="hljs-keyword">new</span>;<br>&#125;<br><br>...<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Delete a list entry by making the prev/next entries</span><br><span class="hljs-comment"> * point to each other.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This is only for internal list manipulation where we know</span><br><span class="hljs-comment"> * the prev/next entries already!</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __list_del(<span class="hljs-keyword">struct</span> list_head * prev, <span class="hljs-keyword">struct</span> list_head * next)<br>&#123;<br>next-&gt;prev = prev;<br>prev-&gt;next = next;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_del - deletes entry from list.</span><br><span class="hljs-comment"> * @entry: the element to delete from the list.</span><br><span class="hljs-comment"> * Note: list_empty on entry does not return true after this, the entry is</span><br><span class="hljs-comment"> * in an undefined state.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除特定元素</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">list_del</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_head *entry)</span></span><br><span class="hljs-function"></span>&#123;<br>__list_del(entry-&gt;prev, entry-&gt;next);<br>entry-&gt;next = LIST_POISON1;<br>entry-&gt;prev = LIST_POISON2;<br>&#125;<br><br>...<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_empty - tests whether a list is empty</span><br><span class="hljs-comment"> * @head: the list to test.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查指定的链表是否为空</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">list_empty</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_head *head)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> head-&gt;next == head;<br>&#125;<br><br>...<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_entry - get the struct for this entry</span><br><span class="hljs-comment"> * @ptr:the &amp;struct list_head pointer.</span><br><span class="hljs-comment"> * @type:the type of the struct this is embedded in.</span><br><span class="hljs-comment"> * @member:the name of the list_struct within the struct.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 返回链表所在结构</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_entry(ptr, type, member) \</span><br><span class="hljs-meta">container_of(ptr, type, member)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each-iterate over a list</span><br><span class="hljs-comment"> * @pos:the &amp;struct list_head to use as a loop counter.</span><br><span class="hljs-comment"> * @head:the head for your list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扫描指定的链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each(pos, head) \</span><br><span class="hljs-meta">for (pos = (head)-&gt;next; prefetch(pos-&gt;next), pos != (head); \</span><br><span class="hljs-meta">        pos = pos-&gt;next)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __list_for_each-iterate over a list</span><br><span class="hljs-comment"> * @pos:the &amp;struct list_head to use as a loop counter.</span><br><span class="hljs-comment"> * @head:the head for your list.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This variant differs from list_for_each() in that it&#x27;s the</span><br><span class="hljs-comment"> * simplest possible list iteration code, no prefetching is done.</span><br><span class="hljs-comment"> * Use this for code that knows the list to be very short (empty</span><br><span class="hljs-comment"> * or 1 entry) most of the time.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __list_for_each(pos, head) \</span><br><span class="hljs-meta">for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each_prev-iterate over a list backwards</span><br><span class="hljs-comment"> * @pos:the &amp;struct list_head to use as a loop counter.</span><br><span class="hljs-comment"> * @head:the head for your list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_prev(pos, head) \</span><br><span class="hljs-meta">for (pos = (head)-&gt;prev; prefetch(pos-&gt;prev), pos != (head); \</span><br><span class="hljs-meta">        pos = pos-&gt;prev)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each_safe-iterate over a list safe against removal of list entry</span><br><span class="hljs-comment"> * @pos:the &amp;struct list_head to use as a loop counter.</span><br><span class="hljs-comment"> * @n:another &amp;struct list_head to use as temporary storage</span><br><span class="hljs-comment"> * @head:the head for your list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_safe(pos, n, head) \</span><br><span class="hljs-meta">for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \</span><br><span class="hljs-meta">pos = n, n = pos-&gt;next)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each_entry-iterate over list of given type</span><br><span class="hljs-comment"> * @pos:the type * to use as a loop counter.</span><br><span class="hljs-comment"> * @head:the head for your list.</span><br><span class="hljs-comment"> * @member:the name of the list_struct within the struct.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 与list_for_each相似，但是返回每个链表结点所在结构</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_entry(pos, head, member)\</span><br><span class="hljs-meta">for (pos = list_entry((head)-&gt;next, typeof(*pos), member);\</span><br><span class="hljs-meta">     prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head); \</span><br><span class="hljs-meta">     pos = list_entry(pos-&gt;member.next, typeof(*pos), member))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each_entry_reverse - iterate backwards over list of given type.</span><br><span class="hljs-comment"> * @pos:the type * to use as a loop counter.</span><br><span class="hljs-comment"> * @head:the head for your list.</span><br><span class="hljs-comment"> * @member:the name of the list_struct within the struct.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_entry_reverse(pos, head, member)\</span><br><span class="hljs-meta">for (pos = list_entry((head)-&gt;prev, typeof(*pos), member);\</span><br><span class="hljs-meta">     prefetch(pos-&gt;member.prev), &amp;pos-&gt;member != (head); \</span><br><span class="hljs-meta">     pos = list_entry(pos-&gt;member.prev, typeof(*pos), member))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_prepare_entry - prepare a pos entry for use as a start point in</span><br><span class="hljs-comment"> *list_for_each_entry_continue</span><br><span class="hljs-comment"> * @pos:the type * to use as a start point</span><br><span class="hljs-comment"> * @head:the head of the list</span><br><span class="hljs-comment"> * @member:the name of the list_struct within the struct.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_prepare_entry(pos, head, member) \</span><br><span class="hljs-meta">((pos) ? : list_entry(head, typeof(*pos), member))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each_entry_continue -iterate over list of given type</span><br><span class="hljs-comment"> *continuing after existing point</span><br><span class="hljs-comment"> * @pos:the type * to use as a loop counter.</span><br><span class="hljs-comment"> * @head:the head for your list.</span><br><span class="hljs-comment"> * @member:the name of the list_struct within the struct.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_entry_continue(pos, head, member) \</span><br><span class="hljs-meta">for (pos = list_entry(pos-&gt;member.next, typeof(*pos), member);\</span><br><span class="hljs-meta">     prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head);\</span><br><span class="hljs-meta">     pos = list_entry(pos-&gt;member.next, typeof(*pos), member))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry</span><br><span class="hljs-comment"> * @pos:the type * to use as a loop counter.</span><br><span class="hljs-comment"> * @n:another type * to use as temporary storage</span><br><span class="hljs-comment"> * @head:the head for your list.</span><br><span class="hljs-comment"> * @member:the name of the list_struct within the struct.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_entry_safe(pos, n, head, member)\</span><br><span class="hljs-meta">for (pos = list_entry((head)-&gt;next, typeof(*pos), member),\</span><br><span class="hljs-meta">n = list_entry(pos-&gt;member.next, typeof(*pos), member);\</span><br><span class="hljs-meta">     &amp;pos-&gt;member != (head); \</span><br><span class="hljs-meta">     pos = n, n = list_entry(n-&gt;member.next, typeof(*n), member))</span><br></code></pre></td></tr></table></figure><p>篇幅太长，详细可以自己看<code>include/linux/List.h</code></p><h3 id="进程链表">进程链表</h3><p>进程链表是list_head的一个例子，进程链表把所有进程描述符链接起来。每个task_struct结构包含一个list_head类型的tasks字段，该字段的prev和next指向前后的task_struct元素（前面代码已给出）。</p><p>链表头是init_task描述符，就是0进程。init_task的prev指向链表最后插入的进程描述符的tasks。</p><h3 id="task_running态进程链表">TASK_RUNNING态进程链表</h3><p>CPU调度时，只需要考虑可运行进程(TASK_RUNNING态)即可。Linux2.6为此优化了数据结构，设计了多个优先级不等的可运行进程链表，通过task_struct中另外一个list_head字段run_list链入对应优先权为k的链中。每个CPU都有自己的运行队列（可运行进程链表集）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程优先级数组。每个CPU对应一个此结构。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">prio_array</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 链表中进程描述符的数量。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_active;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 优先权数组。当且仅当某个优先权的进程链表不为空时设置相应的位标志。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bitmap[BITMAP_SIZE];<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 140个优先权队列的头结点。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> queue[MAX_PRIO];<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">prio_array</span> <span class="hljs-type">prio_array_t</span>;<br></code></pre></td></tr></table></figure><h3 id="进程间的关系">进程间的关系</h3><p>进程描述符中有4个描述进程关系的字段： - real_parent<br />-指向创建了P的进程的描述符，如果P父进程不再存在，则指向1的描述符(init进程)- parent -指向P的当前父进程（这种进程的子进程终止时，必须向父进程发信号）。它的值通常与real_parent一致，但偶尔也可以不同，例如，当另一个进程发出监控P的ptrace()系统调用请求时- children - 链表头，链表中的所有元素都是P创建的子进程 - sibling -指向兄弟进程链表中的下一个元素或前一个元素指针，这些兄弟进程的父进程都是P</p><p>进程关系的示意图(一图胜千言呐!)：</p><p><img src="20170822_4.jpg" /></p><p>建立非亲属关系的进程描述符字段： - group_leader -P所在进程组的领头进程的描述符指针 - signal-&gt;pgrp -P所在进程组的领头进程的PID - tgid<br />- P所在线程组的领头进程的PID - signal-&gt;session -P的登录会话领头进程的PID - ptrace_children -链表的头，该链表包含所有被debugger程序跟踪的P的子进程 - ptrace_list -指向所跟踪进程其实际父进程链表的前一个和下一个元素（用于P被跟踪的时候）</p><h3 id="pidhash表及链表">pidhash表及链表</h3><p>内核必须能从进程PID导出对应的进程描述符指针，比如kill()系统调用（P1调用kill()，参数为P2的PID）。顺序扫描进程链表并逐一检查效率太低了，Linux实际上在布局进程描述符时，不仅采用了内嵌的双向链表，还有4个散列表。他们分别是：</p><table><thead><tr class="header"><th>Hash表类型</th><th>字段</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>PIDTYPE_PID</td><td>pid</td><td>进程的PID</td></tr><tr class="even"><td>PIDTYPE_TGID</td><td>tgid</td><td>进程组领头进程的PID</td></tr><tr class="odd"><td>PIDTYPE_PGID</td><td>pgrp</td><td>进程组领头进程的PID</td></tr><tr class="even"><td>PIDTYPE_SID</td><td>session</td><td>会话领头进程的PID</td></tr></tbody></table><p>4个散列表在内核初始化期间拿到空间，并把他们的地址存入pid_hash数组。</p><p>Linux内核的哈希对于冲突的处理采用桶式链处理：</p><p><img src="20170822_5.jpg" /></p><p>task_struct中structpid成员pids数组即为四个散列表，看看struct结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pid</span><br>&#123;<br><span class="hljs-comment">/* Try to keep pid_chain in the same cacheline as nr for find_pid */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * PID值。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> nr;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 链接散列表中下一个和前一个元素。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hlist_node</span> pid_chain;<br><span class="hljs-comment">/* list of pids with the same nr, only one of them is in the hash */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 每个PID的进程链表头。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> pid_list;<br>&#125;;<br></code></pre></td></tr></table></figure><p>所以，哈希的效果实现来看即如此：</p><p><img src="20170822_6.jpg" /></p><h3 id="非task_running态进程">非TASK_RUNNING态进程</h3><p>除了TASK_RUNNING态的进程组织成了链表，其他状态也有分别的处理： -TASK_STOPPED,EXIT_ZOMBIE,EXIT_DEAD都是散户，没有组织成链表，这几种状态的进程访问或者通过PID散列，或者通过父进程的子进程链表。-TASK_INTERRUPTIBLE，TASK_UNINTERRUPTIBLE状态被再细分成多个类，每一个对应一个特定的事件(event)。在这种情况下，进程状态不提供足够的信息来快速的追溯进程，所以有必要引入额外的进程链表。这被称作等待队列。</p><h3 id="等待队列">等待队列</h3><p>进程必须经常等待某些事件的发生，例如，等待一个磁盘操作的终止，系统资源的释放，等待固定的间隔。等待队列实现了在事件上的条件等待：希望等待特定事件的进程把自己放入合适的等待队列，并放弃控制权（阻塞）。因此，等待队列表示的是一组睡眠的进程，当其对应的事件置True时，内核唤醒它们。</p><p>等待队列也是双向链表，使用list_head子结构，每个队列都有一个等待队列头，结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待队列的头</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__wait_queue_head</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 由于等待队列可能由中断处理程序和内核函数修改，所以必须对双向链表进行保护，以免对其进行同时访问。</span><br><span class="hljs-comment"> * 其同步是由lock自旋锁达到的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">spinlock_t</span> lock;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待进程链表的头。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> task_list;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__wait_queue_head</span> <span class="hljs-type">wait_queue_head_t</span>;<br></code></pre></td></tr></table></figure><p>lock为同步所用自旋锁。</p><p>等待队列链表中元素类型为wait_queue_t:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__wait_queue</span> <span class="hljs-type">wait_queue_t</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待队列中的元素，每个元素代表一个睡眠的进程。</span><br><span class="hljs-comment"> * 该进程等待某一个事件的发生。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__wait_queue</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果flags为1,表示等待进程是互斥的。等待访问临界资源的进程就是典型的互斥进程。</span><br><span class="hljs-comment"> * 如果flags为0，表示等待进程是非互斥的。等待相关事件的进程是非互斥的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WQ_FLAG_EXCLUSIVE0x01</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 睡眠在队列上的进程描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> * task;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待队列中的睡眠进程以何种方式唤醒。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">wait_queue_func_t</span> func;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过此指针将睡眠进程链接起来。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> task_list;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个元素都是一个睡眠进程，等待某一事件发生；描述符地址在task字段，task_list包含的是指针，链接前后的等待相同事件的进程成员。</p><p>显然如果每次唤醒都是唤醒所有进程，则当多个进程申请互斥资源时，存在着废操作（雷鸣般兽群问题），此时仅唤醒一个即可。于是，互斥进程（等待队列元素的flags字段为1）由内核选择地唤醒，非互斥进程(flags为0)由内核在事件发生时唤醒。</p><h2 id="参考文献">参考文献</h2><ul><li>《深入理解Linux内核》</li><li>《Linux内核源代码情景分析(上)》</li><li>《Windows核心编程》</li><li><ahref="http://www.nowamagic.net/academy/detail/3008086">Linux内核中的hash与bucket</a></li><li><a href="https://github.com/sohu2000000/ULK">ULK Chinesecomments</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux-kernel</tag>
      
      <tag>ulk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核学习——内存寻址</title>
    <link href="/2017/08/18/Linux%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/"/>
    <url>/2017/08/18/Linux%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>近年来陆陆续续对Linux内核各模块做些研究，本文是对Linux内核中内存寻址的一点研究。主要参考ULK以及毛批，结合自己的一些深入的理解，以及从源代码中翻箱倒柜获取的心得。</p><span id="more"></span><h1 id="内存寻址">内存寻址</h1><p>对x86处理器来说，内存地址有三个形而上的概念：逻辑地址、线性地址以及物理地址。- 逻辑地址(logical address) -每个逻辑地址都由一个段(segment)和偏移量(offset或displacement)组成，偏移量是段起始到实际地址之间的距离。- 线性地址(linear address/virtual address) -32位无符号整数，范围从0x00000000到0xffffffff。 - 物理地址 -物理内存所用的真实地址，与CPU地址引脚发到内存总线的电信号相对应。物理地址是32位或36位（通过宏扩展）无符号整数。</p><p><img src="20170818_1.jpg" /></p><h2 id="逻辑地址">逻辑地址</h2><p>16位段选择符:32位段内RVA。</p><h3 id="段选择符">段选择符</h3><p><img src="20170818_2.jpg" /></p><p>段选择符存放在cs,ss,ds,es,fs,gs，他们都是16位的段寄存器。 - cs代码段寄存器 - ss 栈段寄存器 - ds 数据段寄存器 -es,fs,gs作一般用途，可指向任意数据段</p><p>cs寄存器含有一个两位的字段，用以指明CPU的当前特权级(Current PrivilegeLevel,CPL)。0表示最高优先级，3表示最低优先级。Linux只有0和3，这就是我们常说的内核态和用户态。</p><h3 id="段描述符">段描述符</h3><p>每个段由一个64位的段描述符(SegmentDescriptor)表示，描述段的特征。段描述符放在全局描述符表(GDT)或局部描述符表(LDT)中。GDT只有一个(多处理器的话每个CPU各有一个)，如果进程除了存放在GDT的段之外还需要创建附加段，就可以有自己的LDT。gdtr寄存器存放GDT的地址和大小，ldtr寄存器存放当前正在使用的LDT地址和大小。</p><p>这里引用ulk的图： <img src="20170818_3.jpg" /></p><ul><li>Base<ul><li>段起始线性地址</li></ul></li><li>G<ul><li>粒度标志：0表示段大小以字节为单位，1表示4K字节为单位。</li></ul></li><li>D or B<ul><li>第54位在代码段中称作D，而数据段中称作B。如果段RVA是32位则置1，16位则清0（Intel手册有描述，我对此暂不感兴趣）。</li></ul></li><li>AVL<ul><li>Linux忽略此位。</li></ul></li><li>Limit<ul><li>存放段中最后一个内存单元的偏移量，Limit和Base共同决定了段的位置和长度。如果G清0，则一个段大小在1个字节到1MB之间变化；如果G置1，则在4KB到4GB之间变化。&gt;因为LIMIT是20位，1字节为单位时，段大小就是1M，4K做单位，段大小就是4G。而BASE是32位所以基地址范围就是0~4G。</li></ul></li><li>S<ul><li>系统标志：0表示系统段，存储诸如LDT这种关键数据结构，1表示普通的代码段或数据段（栈段本质上是数据段）。</li></ul></li><li>Type<ul><li>段的类型特征和存取权限。这个值具体段描述符表具体分析。</li></ul></li><li>DPL(Descriptor Privilege Level)<ul><li>描述符特权级字段：用于限制对该段的存取。它表示为访问这个段而要求的CPU最小的优先级。故DPL设为0的段只能当CPL为0时（内核态）才可访问，而DPL设3的段对任何CPL的值都是可访问的。</li></ul></li><li>P<ul><li>Segment-Present标志：0表示段当前不在内存中。Linux总是把这个标志设为1，因为它从来不把整个段交换到磁盘上去。&gt;后面了解到，Linux实际上干脆没怎么鸟Intel的这种段式设计，而是直接在页式管理上做文章。段式管理仅仅只是个架子，所以这个P位也就始终是1了，即Linux管理的单元是页，而不是段。也就明白了为什么网络上的资料中，有些说是段页式管理，有些说是页式管理。</li></ul></li></ul><p>不够清楚？再从毛德操老师那儿盗个图：</p><p><img src="20170818_4.jpg" /></p><p>Linux广泛的使用了4种段描述符： - 代码段描述符 -S为1（非系统段），在GDT或LDT中出现。 - 数据段描述符 -S为1（非系统段），在GDT或LDT中出现。 - 任务状态段描述符 -代表一个任务状态段(Task State Segment,TSS)，该段用于保存处理器寄存器的内容。只在GDT中出现，根据相应的进程是否正在CPU上运行，其Type字段的值分别为11或9。S标志显然是0。&gt; 这个TSS暂时不甚清楚，读到进程切换时再看，先Mark。 -局部描述符表描述符(LDTD) -这个段描述符代表一个包含LDT的段，它在GDT中。相应Type字段值为2，S为0。</p><p><strong>逻辑地址16位段选择符+32位RVA组成，段选择符放在段寄存器中，段描述符放在对应的GDT或LDT中，GDT和LDT在内存中，LDT在内存的位置可以通过在GDT中找LDTD而得知。gdtr永远指向单一的GDT，ldtr则指向当前正在用的LDT，也正是因为ldtr的动态变化，LDT的内存地址才需要在GDT中查找</strong></p><h3 id="地址转换加速">地址转换加速</h3><p>x86通过附加的非编程寄存器，加速了逻辑地址到线性地址的转换。每一个非编程的寄存器含有64位的段描述符，由相应的段寄存器中的段选择符来指定。每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程CPU寄存器。此后对该段的逻辑地址转换只需要直接引用非编程寄存器中的段描述符即可。只有当段寄存器内容改变了，这时再重新装载段描述符到非编程寄存器。实际上，这就是个缓存的思想，出发点在于CPU访问寄存器速度远快于内存寻址。</p><h3 id="段选择符-段描述符">段选择符-&gt;段描述符</h3><p>两个概念清楚了，但却不了解段选择符如何找到段描述符。回过头来我们看看段选择符的字段：- Index - 指定了放在GDT或LDT中的相应段描述符的入口 - TI -0表示在GDT，1表示在LDT。 - RPL -请求者特权级：当相应的段选择符装入到cs寄存器中时，指示CPU当前的特权级；还可用于访问数据段时有选择地削弱处理器的特权级（Intel文档有，我暂时不感兴趣）。</p><p>高13位的Index是GDT或LDT内的索引，乘8即是相对地址（因为每个段描述符是8字节尺寸）。例如，如果GDT在0x00020000，段选择符index为2，那么段描述符的地址就是0x00020010。GDT中段描述符最多有8191个，也就是(1&lt;&lt; 13 -1)。GDT第一项强制设成0，这是为了确保空段选择符的逻辑地址无效。</p><p>段选择符首次解析段描述符进而通过偏移定位到线性地址的过程如图：</p><p><img src="20170818_5.jpg" /></p><h3 id="x86下的面子工程">x86下的面子工程</h3><p>前面隐约提到了，Linux实际上并没有利用x86提供的段式设计，而是采用页式管理（相比较而言，页式管理比较简单，同时照顾了其他不支持分段的平台）。</p><p>2.6的Linux只在x86下需要分段，而且这个分段实际上是个面子工程。Linux用户态的所有进程使用相同的段对指令和数据寻址，内核态所有进程也使用相同的段来对指令和数据寻址。这也就是最主要的四个段：</p><table style="width:100%;"><thead><tr class="header"><th>段</th><th>Base</th><th>G</th><th>Limit</th><th>S</th><th>Type</th><th>DPL</th><th>D/B</th><th>P</th></tr></thead><tbody><tr class="odd"><td>用户代码段</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>1</td><td>10</td><td>3</td><td>1</td><td>1</td></tr><tr class="even"><td>用户数据段</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>1</td><td>2</td><td>3</td><td>1</td><td>1</td></tr><tr class="odd"><td>内核代码段</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>1</td><td>10</td><td>0</td><td>1</td><td>1</td></tr><tr class="even"><td>内核数据段</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>1</td><td>2</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>所有的段都是0~0xFFFFFFFF4G的寻址空间，也就是说它们共享同一片虚拟地址空间。换句话说，对于Linux来说，逻辑地址和线性地址是一致的，这也是为什么逻辑地址并不广为人知的原因，Linux的设计让他的存在感微乎其微。</p><p>区别之处在于DPL不同，这很好理解。数据段的Type为2也就是0010B，它表示可读可写，尚未受到访问。而代码段Type为10也就是1010B，表示可读可执行，尚未受到访问。CPU映射过程中会核对这些项。如果DPL为0，CS中RPL为3，对不起，不允许。</p><blockquote><p>实际上，虽然Linux也借助x86的段式设计搞的像模像样，但实际上这里的权限判断核查，在后面Linux自身的页式管理中也会进行，可以说对于x86来说，这里的故作姿态是多余的，或者像毛德操老师说的那样，只不过是例行公事罢了。</p></blockquote><p>4个段的段选择符由宏<code>__USER_CS</code>,<code>__USER_DS</code>,<code>__KERNEL_CS</code>,<code>__KERNEL_DS</code>分别定义。当对内核代码段寻址时，内核只需要把<code>__KERNEL_CS</code>宏值装入cs即可。</p><p>CPU的CPL反映了进程实在用户态还是内核态，由存放在cs寄存器的RPL字段指定。当CPL改变时，一些段寄存器必须更新。这一点很好理解，当cs寄存器的RPL字段是3，也就是说CPL为3，表示当前进程是用户态进程，那么此时ds寄存器就应该包含的是用户数据段的段选择符，也就是<code>__USER_DS</code>，而当cs寄存器RPL切换到0时，ds寄存器也要切换到内核态数据段。除了ds，ss亦是如此。Linux每个进程都有内核栈和用户栈，ring0和ring3之间的切换也会导致系统栈的切换。</p><blockquote><p>可也注意到段描述符的定义，对于用户态和内核态来说，DPL上有着区分。</p></blockquote><h3 id="linux-gdt">Linux GDT</h3><p>每个CPU都有一个GDT，所有的GDT都在<code>cpu_gdt_table</code>数组中，所有的GDT的地址和大小都存放在<code>cpu_gdt_descr</code>数组中，它们用于初始化gdtr寄存器。</p><p><code>arch/i386/kernel/head.S</code>一探究竟： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs asm">/*<br> * 这里可以看到大小定义为GDT_ENTRIES*8-1，其中GDT_ENTRIES在include/asm-i386/segment.h中定义为32。大小后面就是32bit的cpu_gdt_table指针（.word和.long都是32bit）。再后面预留出了其他CPU的空间，每个都是8字节并用0填充。<br> */<br>cpu_gdt_descr:<br>.word GDT_ENTRIES*8-1<br>.long cpu_gdt_table<br><br>.fill NR_CPUS-1,8,0# space for the other GDT descriptors<br><br>...<br><br>/*<br> * The Global Descriptor Table contains 28 quadwords, per-CPU.<br> */<br>.align PAGE_SIZE_asm<br>ENTRY(cpu_gdt_table)<br>.quad 0x0000000000000000/* NULL descriptor */<br>.quad 0x0000000000000000/* 0x0b reserved */<br>.quad 0x0000000000000000/* 0x13 reserved */<br>.quad 0x0000000000000000/* 0x1b reserved */<br>.quad 0x0000000000000000/* 0x20 unused */<br>.quad 0x0000000000000000/* 0x28 unused */<br>.quad 0x0000000000000000/* 0x33 TLS entry 1 */<br>.quad 0x0000000000000000/* 0x3b TLS entry 2 */<br>.quad 0x0000000000000000/* 0x43 TLS entry 3 */<br>.quad 0x0000000000000000/* 0x4b reserved */<br>.quad 0x0000000000000000/* 0x53 reserved */<br>.quad 0x0000000000000000/* 0x5b reserved */<br><br>/*<br> * 这里可以看到4个段和此前的描述一致<br> */<br>.quad 0x00cf9a000000ffff/* 0x60 kernel 4GB code at 0x00000000 */<br>.quad 0x00cf92000000ffff/* 0x68 kernel 4GB data at 0x00000000 */<br>.quad 0x00cffa000000ffff/* 0x73 user 4GB code at 0x00000000 */<br>.quad 0x00cff2000000ffff/* 0x7b user 4GB data at 0x00000000 */<br><br>.quad 0x0000000000000000/* 0x80 TSS descriptor */<br>.quad 0x0000000000000000/* 0x88 LDT descriptor */<br><br>/* Segments used for calling PnP BIOS */<br>.quad 0x00c09a0000000000/* 0x90 32-bit code */<br>.quad 0x00809a0000000000/* 0x98 16-bit code */<br>.quad 0x0080920000000000/* 0xa0 16-bit data */<br>.quad 0x0080920000000000/* 0xa8 16-bit data */<br>.quad 0x0080920000000000/* 0xb0 16-bit data */<br>/*<br> * The APM segments have byte granularity and their bases<br> * and limits are set at run time.<br> */<br>.quad 0x00409a0000000000/* 0xb8 APM CS    code */<br>.quad 0x00009a0000000000/* 0xc0 APM CS 16 code (16 bit) */<br>.quad 0x0040920000000000/* 0xc8 APM DS    data */<br><br>.quad 0x0000000000000000/* 0xd0 - unused */<br>.quad 0x0000000000000000/* 0xd8 - unused */<br>.quad 0x0000000000000000/* 0xe0 - unused */<br>.quad 0x0000000000000000/* 0xe8 - unused */<br>.quad 0x0000000000000000/* 0xf0 - unused */<br>.quad 0x0000000000000000/* 0xf8 - GDT entry 31: double-fault TSS */<br></code></pre></td></tr></table></figure></p><p>可以看到4个段的偏移是0x60,0x68,0x73,0x7b。同时，我们再到<code>include/asm-i386/segment.h</code>中看看几个段选择符对应宏的定义是否一致：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GDT_ENTRY_DEFAULT_USER_CS14</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __USER_CS (GDT_ENTRY_DEFAULT_USER_CS * 8 + 3)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GDT_ENTRY_DEFAULT_USER_DS15</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __USER_DS (GDT_ENTRY_DEFAULT_USER_DS * 8 + 3)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GDT_ENTRY_KERNEL_BASE12</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GDT_ENTRY_KERNEL_CS(GDT_ENTRY_KERNEL_BASE + 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __KERNEL_CS (GDT_ENTRY_KERNEL_CS * 8)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GDT_ENTRY_KERNEL_DS(GDT_ENTRY_KERNEL_BASE + 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __KERNEL_DS (GDT_ENTRY_KERNEL_DS * 8)</span><br></code></pre></td></tr></table></figure></p><p>完全一致！</p><h3 id="linux-ldt">Linux LDT</h3><p>Linux用户态程序几乎不用LDT，内核定义了一个默认的LDT供大多数进程共享。默认LDT放在default_ldt数组中。它包含5项但内核仅用了2项：iBCS执行文件的调用门；Solaris/x86可执行文件的调用门。调用门是x86提供的一种机制，用于在调用预定义函数时改变CPU特权级。</p><p>某些进程仍然会需要创建自己的局部描述符表，比如Wine。Wine执行面向段的Windows程序。sys_modify_ldt()系统调用允许进程创建自己的LDT。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">asmlinkage <span class="hljs-type">int</span> <span class="hljs-title">sys_modify_ldt</span><span class="hljs-params">(<span class="hljs-type">int</span> func, <span class="hljs-type">void</span> __user *ptr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bytecount)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret = -ENOSYS;<br><br><span class="hljs-keyword">switch</span> (func) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>ret = <span class="hljs-built_in">read_ldt</span>(ptr, bytecount);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>ret = <span class="hljs-built_in">write_ldt</span>(ptr, bytecount, <span class="hljs-number">1</span>);<span class="hljs-comment">//参数3表示旧式写</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>ret = <span class="hljs-built_in">read_default_ldt</span>(ptr, bytecount);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x11</span>:<br>ret = <span class="hljs-built_in">write_ldt</span>(ptr, bytecount, <span class="hljs-number">0</span>);<span class="hljs-comment">//参数3表示新式写</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure> 0和2都是读，2读defaultldt。1和0x11为写，其中0x11是新式写，1是旧式写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">read_ldt</span><span class="hljs-params">(<span class="hljs-type">void</span> __user * ptr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bytecount)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> err;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> * mm = current-&gt;mm;<span class="hljs-comment">//当前的mm_struct</span><br><br><span class="hljs-keyword">if</span> (!mm-&gt;context.size)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (bytecount &gt; LDT_ENTRY_SIZE*LDT_ENTRIES)<br>bytecount = LDT_ENTRY_SIZE*LDT_ENTRIES;<br><br><span class="hljs-built_in">down</span>(&amp;mm-&gt;context.sem);<br>size = mm-&gt;context.size*LDT_ENTRY_SIZE;<br><span class="hljs-keyword">if</span> (size &gt; bytecount)<br>size = bytecount;<br><br>err = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ptr, mm-&gt;context.ldt, size))<span class="hljs-comment">//mm-&gt;context.ldt就是ldt的64bit结构</span><br>err = -EFAULT;<br><span class="hljs-built_in">up</span>(&amp;mm-&gt;context.sem);<br><span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error_return;<br><span class="hljs-keyword">if</span> (size != bytecount) &#123;<br><span class="hljs-comment">/* zero-fill the rest */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">clear_user</span>(ptr+size, bytecount-size) != <span class="hljs-number">0</span>) &#123;<br>err = -EFAULT;<br><span class="hljs-keyword">goto</span> error_return;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> bytecount;<br>error_return:<br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">read_default_ldt</span><span class="hljs-params">(<span class="hljs-type">void</span> __user * ptr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bytecount)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> err;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br><span class="hljs-type">void</span> *address;<br><br>err = <span class="hljs-number">0</span>;<br>address = &amp;default_ldt[<span class="hljs-number">0</span>];<span class="hljs-comment">//默认的全局共享ldt</span><br>size = <span class="hljs-number">5</span>*<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> desc_struct);<span class="hljs-comment">//返回的就是desc_struct，他就是i386下ldt结构体名称</span><br><span class="hljs-keyword">if</span> (size &gt; bytecount)<br>size = bytecount;<br><br>err = size;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ptr, address, size))<br>err = -EFAULT;<br><br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">write_ldt</span><span class="hljs-params">(<span class="hljs-type">void</span> __user * ptr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bytecount, <span class="hljs-type">int</span> oldmode)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> * mm = current-&gt;mm;<br>__u32 entry_1, entry_2, *lp;<br><span class="hljs-type">int</span> error;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">user_desc</span> ldt_info;<br><br>error = -EINVAL;<br><span class="hljs-keyword">if</span> (bytecount != <span class="hljs-built_in">sizeof</span>(ldt_info))<br><span class="hljs-keyword">goto</span> out;<br>error = -EFAULT; <br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(&amp;ldt_info, ptr, <span class="hljs-built_in">sizeof</span>(ldt_info)))<span class="hljs-comment">//从用户空间ptr拿到ldt信息</span><br><span class="hljs-keyword">goto</span> out;<br><br>error = -EINVAL;<br><span class="hljs-keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)<br><span class="hljs-keyword">goto</span> out;<br><span class="hljs-keyword">if</span> (ldt_info.contents == <span class="hljs-number">3</span>) &#123;<br><span class="hljs-keyword">if</span> (oldmode)<br><span class="hljs-keyword">goto</span> out;<br><span class="hljs-keyword">if</span> (ldt_info.seg_not_present == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-built_in">down</span>(&amp;mm-&gt;context.sem);<br><span class="hljs-keyword">if</span> (ldt_info.entry_number &gt;= mm-&gt;context.size) &#123;<br>error = <span class="hljs-built_in">alloc_ldt</span>(&amp;current-&gt;mm-&gt;context, ldt_info.entry_number+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (error &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> out_unlock;<br>&#125;<br><br>lp = (__u32 *) ((ldt_info.entry_number &lt;&lt; <span class="hljs-number">3</span>) + (<span class="hljs-type">char</span> *) mm-&gt;context.ldt);<br><br><span class="hljs-comment">//线性地址空间打洞，安装ldt</span><br><br>   <span class="hljs-comment">/* Allow LDTs to be cleared by the user. */</span><br>   <span class="hljs-keyword">if</span> (ldt_info.base_addr == <span class="hljs-number">0</span> &amp;&amp; ldt_info.limit == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (oldmode || <span class="hljs-built_in">LDT_empty</span>(&amp;ldt_info)) &#123;<br>entry_1 = <span class="hljs-number">0</span>;<br>entry_2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">goto</span> install;<br>&#125;<br>&#125;<br><br>entry_1 = <span class="hljs-built_in">LDT_entry_a</span>(&amp;ldt_info);<br>entry_2 = <span class="hljs-built_in">LDT_entry_b</span>(&amp;ldt_info);<br><span class="hljs-keyword">if</span> (oldmode)<br>entry_2 &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>);<br><br><span class="hljs-comment">/* Install the new entry ...  */</span><br>install:<br>*lp= entry_1;<br>*(lp+<span class="hljs-number">1</span>)= entry_2;<br>error = <span class="hljs-number">0</span>;<br><br>out_unlock:<br><span class="hljs-built_in">up</span>(&amp;mm-&gt;context.sem);<br>out:<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><p>在内核中找到mm_struct: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_area_struct</span> * mmap;<span class="hljs-comment">/* list of VMAs */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_root</span> mm_rb;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_area_struct</span> * mmap_cache;<span class="hljs-comment">/* last find_vma result */</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">long</span> <span class="hljs-params">(*get_unmapped_area)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span></span>;<br><span class="hljs-built_in">void</span> (*unmap_area) (<span class="hljs-keyword">struct</span> vm_area_struct *area);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_base;<span class="hljs-comment">/* base of mmap area */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> free_area_cache;<span class="hljs-comment">/* first hole */</span><br><span class="hljs-type">pgd_t</span> * pgd;<br><span class="hljs-type">atomic_t</span> mm_users;<span class="hljs-comment">/* How many users with user space? */</span><br><span class="hljs-type">atomic_t</span> mm_count;<span class="hljs-comment">/* How many references to &quot;struct mm_struct&quot; (users count as 1) */</span><br><span class="hljs-type">int</span> map_count;<span class="hljs-comment">/* number of VMAs */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rw_semaphore</span> mmap_sem;<br><span class="hljs-type">spinlock_t</span> page_table_lock;<span class="hljs-comment">/* Protects page tables, mm-&gt;rss, mm-&gt;anon_rss */</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> mmlist;<span class="hljs-comment">/* List of maybe swapped mm&#x27;s.  These are globally strung</span><br><span class="hljs-comment"> * together off init_mm.mmlist, and are protected</span><br><span class="hljs-comment"> * by mmlist_lock</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_code, end_code, start_data, end_data;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_brk, brk, start_stack;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg_start, arg_end, env_start, env_end;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rss, anon_rss, total_vm, locked_vm, shared_vm;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> exec_vm, stack_vm, reserved_vm, def_flags, nr_ptes;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> saved_auxv[<span class="hljs-number">42</span>]; <span class="hljs-comment">/* for /proc/PID/auxv */</span><br><br><span class="hljs-type">unsigned</span> dumpable:<span class="hljs-number">1</span>;<br><span class="hljs-type">cpumask_t</span> cpu_vm_mask;<br><br><span class="hljs-comment">/* Architecture-specific MM context */</span><br><span class="hljs-type">mm_context_t</span> context;<span class="hljs-comment">//mm_context_t中有ldt指针</span><br><br><span class="hljs-comment">/* Token based thrashing protection. */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> swap_token_time;<br><span class="hljs-type">char</span> recent_pagein;<br><br><span class="hljs-comment">/* coredumping support */</span><br><span class="hljs-type">int</span> core_waiters;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">completion</span> *core_startup_done, core_done;<br><br><span class="hljs-comment">/* aio bits */</span><br><span class="hljs-type">rwlock_t</span>ioctx_list_lock;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">kioctx</span>*ioctx_list;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">kioctx</span>default_kioctx;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hiwater_rss;<span class="hljs-comment">/* High-water RSS usage */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hiwater_vm;<span class="hljs-comment">/* High-water virtual memory usage */</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The i386 doesn&#x27;t have a mmu context, but</span><br><span class="hljs-comment"> * we put the segment information here.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * cpu_vm_mask is used to optimize ldt flushing.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123; <br><span class="hljs-type">int</span> size;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">semaphore</span> sem;<br><span class="hljs-type">void</span> *ldt;<span class="hljs-comment">//void *是为了泛用性？</span><br>&#125; <span class="hljs-type">mm_context_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __ASSEMBLY__</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">user_desc</span> &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>  entry_number;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> base_addr;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>  limit;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>  seg_32bit:<span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>  contents:<span class="hljs-number">2</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>  read_exec_only:<span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>  limit_in_pages:<span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>  seg_not_present:<span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>  useable:<span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MODIFY_LDT_CONTENTS_DATA0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MODIFY_LDT_CONTENTS_STACK1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MODIFY_LDT_CONTENTS_CODE2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* !__ASSEMBLY__ */</span></span><br></code></pre></td></tr></table></figure></p><p>对于LDT只是粗略的了解，暂不做细致的研究。</p><h2 id="硬件分页机制">硬件分页机制</h2><p>分页单元(pageunit)把线性地址转换成物理地址。线性地址以固定长度为单位进行拆分，每一组称为页。页内部连续的线性地址被映射到连续的物理地址。每一页有自己的存取权限。分页单元把所有的RAM分成固定长度的页框(pageframe)。每个页框包含一个页，所以页框的长度和页长度一致。</p><blockquote><p>页框是真实的物理页，页只是一个虚拟的概念。页可能被映射到一个页框，也可能被转储在磁盘（内存交换）。</p></blockquote><p>线性地址映射到物理地址的数据结构叫页表(pagetable)。页表放在主存中，在启用分页单元之前必须由内核对页表进行适当初始化。</p><p>x86支持分页，通过设置cr0寄存器的PG标志位。PG=0时，线性地址被解释成物理地址。x86分页单元处理4KB的页。</p><p>32位线性地址分成3个域：Directory(目录10bit) + Table(页表10bit) +Offset(偏移量12bit)。线性地址转换分成两步完成，每一步都基于一种转换表，第一种转换表被称为页目录表(pagedirectory)，第二种转换表被称为页表(page table)。</p><blockquote><p>这种设计减少了每个进程页表所需RAM的数量（如果页表只有一级，那么高20位做表项会消耗4MBRAM（每项4字节），但程序往往并不会使用4GB中所有的线性地址空间）。另一方面，每个活动进程必须有一个分配给它的页目录，但没必要为进程的所有页表都分配RAM。当进程实际需要一个页表时再分配RAM更为高效。这就起到了降低消耗的效果。</p></blockquote><p>正在使用的页目录的物理地址放在控制寄存器cr3中。线性地址内Directory字段决定页目录中的目录项，目录项指向适当的页表。Table字段决定页表中的表项，表项含有页所在页框的物理地址。Offset决定了页框内的偏移。</p><blockquote><p>Offset为12bit刚好就是4K，一个页框的大小也正是4K。页目录和页表都是1024项。不管你怎么拆，最后的寻址都是4G。</p></blockquote><p>到此，线性地址完美转换到物理地址。</p><p>放一张ulk的图：</p><p><img src="20170818_6.jpg" /></p><h3 id="页目录页表">页目录&amp;页表</h3><p>页目录项和页表项结构相同： - Present字段 -1代表页或页表在主存中，0代表不在主存中（此时剩余位可由OS自用）。如果执行一个地址转换所需的页表项或页目录项中Present清0，那么分页单元就把该线性地址存放在cr2中，并产生14号异常：缺页异常。&gt;对于未装载到RAM中的页表来说，页表项全都是0，这一标志位页是0，同样可以触发缺页异常，很巧妙的设计。- 包含页框物理地址最高20位的字段 -由于每个页框有4KB容量，所以物理地址必须是4096的倍数，那么物理地址的低12位一定是0（所以只需要高20位）。如果该字段指向一个页目录，相应的页框就含有一个页表；如果指向一个页表，相应的页框就含有一页数据。- Accessed标志 -当分页单元对相应页框寻址时置位。选中的页如果被交换出去，这一标记被OS自定义。分页单元不会重置这个标记，OS需要takecare。 - Dirty标志 -页表中才有意义。每当对一个页框进行写操作时就设置这个标志。选中的页如果被交换出去，这一标记被OS自定义。分页单元不会重置这个标记，OS需要takecare。 - Read/Write标志 - 含有页或页表的存取权限 - User/Supervisor标志 -含有访问页或页表所需的特权级 - PCD，PWT标志 -控制硬件高速缓存处理页或页表的方式 - Page Size标志 -只应用于目录项。如果置1则页目录项指的是2MB或4MB的页框。 &gt;x86引入了扩展分页，允许页框大小为4MB而不是4KB。扩展分页把大段连续线性地址转成物理地址，此时内核无需使用中间页表进行转换。此时线性地址划分成Directory高10位+Offset22位。通过设置cr4寄存器的PSE标志能使扩展分页与常规分页共存。- Global标志 - 只应用于页表项。该标记由PentiumPro引入，防止常用页从TLB高速缓存（转换后援缓冲器）中刷新出去。只有在cr4寄存器的页全局启用(PGE)标志置位时该标记才有用。</p><p>一些标志不是太懂，后面再具体分析。</p><h3 id="硬件保护">硬件保护</h3><p>分页单元的保护和分段不一样，分段的权限有4种（0-3），但分页要依赖User/Supervisor标志，只能是0或1（两种）。标志位0时，只有当CPL小于3(Linux也就只有0)才能对该页寻址；如果为1则无条件限制。此外，段有3种存取权限（读写执行），页也因为只能依赖Read/Write标志位，所以只有2种。0表示只读，1表示读写。</p><blockquote><p>为何页的保护设计上如此吝啬？是否对于Linux来说，这样低配的硬件保护已经足够。</p></blockquote><h3 id="pae分页">PAE分页</h3><p>x86处理器管脚实际上有36而不是32，这是对于需求所做的后期扩展。从硬件设计来说，寻址能力就增长到64G。不过，这需要引入一种新的分页机制把32位线性地址转换成36位物理地址才行。</p><p>这就是PAE机制，通过设置cr4寄存器的PAE标志激活PAE。页目录项的页大小标志PS启动大尺寸页(2MB)。机制的修改： -64G的RAM（显然64G只是理论上的一种概念）分为1&lt;&lt;24个页框，页表项物理地址字段从20位扩展到24位。PAE页表项必须包含12个标志位和24个物理地址，总数和为36，页表项大小从32位变成64位增加了一倍，故一个4K的页表包含512个页表项而不再是1024个，进而Table的10bit可以缩到9bit。Directory和Table一致（页目录项和页表项同结构），也是9bit，所以空闲出了2bit。- 引入页目录指针表(PDPT)，由4个64位表项组成。空闲的2bit给了PDPT。 -cr3寄存器包含一个27位的PDPT基地址字段。PDPT放在RAM的前4G中，并在32字节(1&lt;&lt;5)倍数上对齐，故27位足以表示其基地址（低5位都是0）。- 当把线性地址映射到4K的页时（页目录项中PS清0），32位线性地址解释如下：- cr3 - 指向一个PDPT - bit 31-30 - 指向PDPT中4个项中的一个 - bit 29-21 -指向页目录中512个项中的一个 - bit 20-12 - 指向页表中512项中的一个 - bit11-0 - 4K页中的偏移量 -当把线性地址映射到2MB的页时（页目录项中PS置1），32位线性地址解释如下： -cr3 - 指向一个PDPT - bit 31-30 - 指向PDPT中4个项中的一个 - bit 29-21 -指向页目录中512个项中的一个 - bit 20-0 - 2MB页中的偏移量</p><p>借CSDN，白水煮鸡蛋的图一用：</p><p>关闭PS(4K)</p><p><img src="20170818_7.jpg" /></p><p>开启PS(2M)</p><p><img src="20170818_8.jpg" /></p><p>PAE没有改变线性地址，只是扩展了物理地址。</p><h2 id="linux的分页设计">Linux的分页设计</h2><p>2.6.10前的Linux有三个分页级别，2.6.11之后有四个分页级别，分别是： -页全局目录(PGD) - 页上级目录(PUD) - 页中间目录(PMD) - 页表(PT)</p><p>PGD包含若干PUD，PUD包含若干PMD，PMD包含若干PT的地址。每个页表项指向一个页框。线性地址被分成5部分。每一部分的大小与具体的计算机体系结构有关。</p><h3 id="linux分页设计-x86硬件分页">Linux分页设计-&gt;x86硬件分页</h3><p>对于PAE未开启的系统，两级页表足够了。所以Linux对此的处理很简单，PUD和PMD的位数全部设定为0，程序员中只是摆摆样子，走个过场。</p><p><img src="20170818_9.jpg" /></p><p>如果PAE开启，则PGD对应x86的PDPT，取消了PUD，PMD对应x86的页目录，Linux的页表对应x86的页表。</p><p>64位使用三级还是四级取决于硬件对线性地址的位的划分。64位的我暂时不关心。</p><blockquote><p>每个进程有自己的PGD和PT。当发生进程切换时，Linux把cr3寄存器的内容保存到前一个执行进程的描述符中，然后把下一个要执行进程的描述符的值装入cr3寄存器。因此，新进程重新开始在CPU执行时，分页单元指向一组正确的页表。</p></blockquote><h3 id="线性地址相关宏">线性地址相关宏</h3><ul><li>PAGE_SHIFT<ul><li>x86是12, Offset字段</li></ul></li><li>PMD_SHIFT<ul><li>Offset+Table总位数，PAE禁用时为22，激活时为21。</li></ul></li><li>PUD_SHIFT<ul><li>x86总是等于PMD_SHIFT</li></ul></li><li>PGDIR_SHIFT<ul><li>PAE禁用时等同于PMD_SHIFT，激活时就是30。</li></ul></li><li>PTRS_PER_PTE, PTRS_PER_PMD, PTRS_PER_PUD以及PTRS_PER_PGD<ul><li>计算页表、页中间目录、页上级目录和页全局目录表中表项的个数。PAE被禁用时，值就是1024,1,1,1024。PAE激活时就是512,512,1,4。</li></ul></li></ul><h3 id="页表处理相关宏">页表处理相关宏</h3><ul><li><code>pte_t</code>,<code>pmd_t</code>,<code>pud_t</code>,<code>pgd_t</code>,<code>pgprot_t</code><ul><li>描述页表项，页中间目录项，页上级目录，页全局目录项格式和一个单独表项相关保护标志。PAE激活时都是64位数据类型，否则都是32位数据类型。</li></ul></li><li><code>__pte</code>,<code>__pmd</code>,<code>__pud</code>,<code>__pgd</code>,<code>__pgprot</code><ul><li>把无符号整数转成所需类型。</li></ul></li><li><code>pte_val</code>,<code>pmd_val</code>,<code>pud_val</code>,<code>pgd_val</code>,<code>pgprot_val</code><ul><li>把类型转成无符号整数</li></ul></li><li><code>pte_none</code>,<code>pmd_none</code>,<code>pud_none</code>,<code>pgd_none</code><ul><li>相应表项为1则值为0，相应表项为0则为1。</li></ul></li><li><code>pte_clear</code>,<code>pmd_clear</code>,<code>pud_clear</code>,<code>pgd_clear</code><ul><li>清除相应页表的一个表项。<code>ptep_get_and_clear()</code>清除一个页表项并返回前一个值。</li></ul></li><li><code>set_pte</code>,<code>set_pmd</code>,<code>set_pud</code>,<code>set_pgd</code><ul><li>向一个页表项写入指定的值。<code>set_pte_atomic</code>与<code>set_pte</code>作用相同，在PAE激活时保证原子写入。</li></ul></li><li><code>pte_same(a,b)</code><ul><li>如果a和b两个页表项指向同一页并指定相同的访问优先级，那么返回1，否则返回0。</li></ul></li><li><code>pmd_large(e)</code><ul><li>如果PMD项e指向一个大型页(2MB或4MB)，返回1，否则返回0。</li></ul></li><li><code>pmd_bad</code><ul><li>如果目录项指向一个不能使用的页表，返回1，否则返回0。</li><li>不可用页表包括：<ul><li>Present为0，不在主存中</li><li>只读(Read/Write为0)</li><li>Acessed或Dirty被清0（对每个现有的页表，Linux总是强制设置这些标志）</li></ul></li><li><code>pud_bad</code>,<code>pgd_bad</code>总是0。没有<code>pte_bad</code>宏，因为页表项引用一个不在主存中的页，一个不可写的页或一个根本无法访问的页都是合理的。</li></ul></li><li><code>pte_present</code>,<code>pmd_present</code><ul><li>如果页表项的Present或PageSize为1，则返回1，否则为0。</li><li>如果表项的Present为1，则pmd_present为1。pud_present和pgd_present总是1。</li></ul></li><li>一些读页标志的函数（除pte_file外，其他函数都只在pte_present为1时才有效）<ul><li><code>pte_user()</code><ul><li>读User/Supervisor</li></ul></li><li><code>pte_read()</code><ul><li>读User/Supervisor(表示x86处理器上的页不受读的保护)</li></ul></li><li><code>pte_write()</code><ul><li>读Read/Write</li></ul></li><li><code>pte_exec()</code><ul><li>读User/Supervisor(表示x86处理器上的页不受代码执行的保护)</li></ul></li><li><code>pte_dirty()</code><ul><li>读Dirty标志</li></ul></li><li><code>pte_young()</code><ul><li>读Accessed标志</li></ul></li><li><code>pte_file()</code><ul><li>读Dirty标志</li></ul></li></ul></li><li>设置页表项各标志<ul><li><code>mk_pte_huge()</code><ul><li>设置页表项中Page Size和Present标志</li></ul></li><li><code>pte_wrprotect()</code><ul><li>清Read/Write</li></ul></li><li><code>pte_rdprotect()</code><ul><li>清User/Supervisor</li></ul></li><li><code>pte_exprotect()</code><ul><li>清User/Supervisor</li></ul></li><li><code>pte_mkwrite()</code><ul><li>设置Read/Write</li></ul></li><li><code>pte_mkread()</code><ul><li>设置User/Supervisor标志</li></ul></li><li><code>pte_mkexec()</code><ul><li>设置User/Supervisor标志</li></ul></li><li><code>pte_mkclean()</code><ul><li>清Dirty</li></ul></li><li><code>pte_mkold()</code><ul><li>清Accessed（未访问）</li></ul></li><li><code>pte_mkyoung()</code><ul><li>设置Accessed（访问过）</li></ul></li><li><code>pte_modify(p,v)</code><ul><li>页表项p的所有访问权限设为指定值v</li></ul></li><li><code>ptep_set_wrprotect()</code><ul><li>与pte_wrprotect()类似，但作用于指向页表项的指针</li></ul></li><li><code>ptep_set_access_flags()</code><ul><li>如果Dirty为1，则将页存取权限设为指定值，并调用flush_tlb_page()函数。</li></ul></li><li><code>ptep_mkdirty()</code><ul><li>与pte_mkdirty()类似，作用于指向页表项的指针</li></ul></li><li><code>ptep_test_and_clear_dirty()</code><ul><li>与pte_mkclean()类似，作用于指向页表项的指针并返回Dirty标志的旧值</li></ul></li><li><code>ptep_test_and_clear_young()</code><ul><li>与pte_mkold()类似，但作用于指向页表项的指针并返回Accessed标志的旧值</li></ul></li></ul></li></ul><h3 id="页表项操作宏">页表项操作宏</h3><ul><li><code>pgd_index(addr)</code><ul><li>线性地址addr对应的目录项在PGD中索引</li></ul></li><li><code>pgd_offset(mm, addr)</code><ul><li>接收内存描述符地址mm和线性地址addr作为参数。该宏产生地址addr在页全局目录中相应表项的线性地址；通过内存描述符mm内的一个指针可以找到这个PGD</li></ul></li><li><code>pgd_offset_k(addr)</code><ul><li>产生主内核页全局目录中的某个项的线性地址，该项对应于地址addr。</li></ul></li><li><code>pgd_page(pgd)</code><ul><li>通过页全局目录项pgd产生PUD所在页框的页描述符地址。</li></ul></li><li><code>pud_offset(pgd, addr)</code><ul><li>pgd和addr产生pud线性地址</li></ul></li><li><code>pud_page(pud)</code><ul><li>pud产生pmd的线性地址</li></ul></li><li><code>pmd_index(addr)</code><ul><li>产生线性地址addr在pmd中对应目录项的索引</li></ul></li><li><code>pmd_offset(pud, addr)</code><ul><li>通过pud和addr产生pmd中的线性地址。</li></ul></li><li><code>pmd_page(pmd)</code><ul><li>通过pmd产生页表的页描述符地址。</li></ul></li><li><code>mk_pte(p, prot)</code><ul><li>接收页描述符地址p和一组存取权限prot作为参数，并创建相应的页表项</li></ul></li><li><code>pte_index(addr)</code><ul><li>产生线性地址addr对应的表项在页表中的索引</li></ul></li><li><code>pte_offset_kernel(dir, addr)</code><ul><li>addr在pmd中有对应的一项，该项由该宏产生，即页表的线性地址。（只在内核页表上使用）</li></ul></li><li><code>pte_offset_map(dir, addr)</code><ul><li>指向pmd的dir和addr产生对应的页表项的线性地址。若页表被保存在高端内存中，那么内核建立一个临时内核映射，并用pte_unmap进行释放。pte_offset_map_nested宏和pte_unmap_nested宏是相同的，但他们用不同的临时内核映射。</li></ul></li><li><code>pte_page(x)</code><ul><li>返回页表项x所引用页的描述符地址</li></ul></li><li><code>pte_to_pgoff(pte)</code><ul><li>从一个页表项的pte字段内容中提取出文件偏移量，该偏移量对应着一个非线性文件内存映射所在的页</li></ul></li><li><code>pgoff_to_pte(offset)</code><ul><li>为非线性文件内映射所在的页创建对应页表项的内容</li></ul></li></ul><h3 id="页分配函数">页分配函数</h3><ul><li><code>pgd_free(pgd)</code><ul><li>释放pgd项。PAE激活时，释放用户态线性地址对应的三个pmd</li></ul></li><li><code>pud_alloc(mm,pgd,addr)</code><ul><li>两级或三级分页系统下，do nothing，返回pgd线性地址。</li></ul></li><li><code>pud_free(x)</code><ul><li>两级或三级分页系统下，do nothing。</li></ul></li><li><code>pmd_alloc(mm,pud,addr)</code><ul><li>定义该函数使普通三级分页系统可以为线性地址addr分配一个新的pmd。PAE未激活时，函数仅返回pud值。如果PAE激活，返回addr对应的pmd的线性地址。mm被忽略</li></ul></li><li><code>pmd_free(x)</code><ul><li>do nothing，因为pmd的分配和释放随同其父亲pgd进行。</li></ul></li><li><code>pte_alloc_map(mm,pmd,addr)</code><ul><li>返回对应的页表项的地址。如果pmd为空，该函数通过调用函数pte_alloc_one()分配一个新页表，如果分配了新页表，addr对应的项就被创建，同时User/Supervisor标志置1。如果页表被保存在高端内存，则内核建立一个临时内核映射。</li></ul></li><li><code>pte_alloc_kernel(mm,pmd,addr)</code><ul><li>如果与地址addr相关的pmd为空，该函数分配一个新页表。然后返回与addr相关的页表项的线性地址。该函数仅被主内核页表所用。</li></ul></li><li><code>pte_free(pte)</code><ul><li>释放pte相关页表。</li></ul></li><li><code>pte_free_kernel(pte)</code><ul><li>等价于pte_free()，但主内核页表使用它。</li></ul></li><li><code>clear_page_range(mmu,start,end)</code><ul><li>从start到end通过反复释放页表和清除pmd项来清除进程页表的内容</li></ul></li></ul><h3 id="物理内存布局">物理内存布局</h3><p>初始化时，内核建立一个物理地址映射来指定哪些范围物理地址对内核不可用（不可用的物理地址范围内的页框和含有内核代码和已初始化的数据结构的页框，这些保留页框不会被交换到磁盘，也不会被动态分配）。</p><p>物理地址的布局并不会从RAM的0x0开始处放置内核，因为BIOS的优先级更高。BIOS暂时不感兴趣，skip。这一部分可以参考ulk，有详细的介绍。</p><h3 id="进程页表">进程页表</h3><p>对进程来说，线性地址分两部分：0x0-0xbfffffff为用户态和内核态所用，0xc0000000到0xffffffff为内核态地址(0xc0000000就是内核代码中常见的PAGE_OFFSET)。</p><h3 id="内核页表">内核页表</h3><p>内核维持着一组自己用的页表，驻留于所谓的主内核PGD(master kernel PageGlobalDirectory)中。系统初始化后，这组页表还未从任何进程或任何内核线程直接使用；主内核页全局目录的最高目录项部分作为参考模型，为系统中每个普通进程对应的PGD项提供参考。</p><p>内核页表的载入相当复杂，其采用一种分阶段的方式，在第一阶段CPU仍未实模式，PAE不可能开启，分页未启用，此时直接装载内核代码数据段，实现与物理地址相同的线性地址进行映射（达成一种实模式和保护模式都很容易对这8MB寻址的目的）。第二阶段内核利用剩余RAM建立分页表。这一部分相当复杂，还要考虑到具体的RAM大小，我本人对此不甚感冒，不展开了。</p><h2 id="参考文献">参考文献</h2><ul><li>《深入理解Linux内核》</li><li>《Linux内核源代码情景分析(上)》</li><li><ahref="http://blog.csdn.net/u011279649/article/details/9253617">GCC汇编器语法</a></li><li><ahref="http://blog.csdn.net/hsly_support/article/details/7463569">浅析linux内核内存管理之PAE</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux-kernel</tag>
      
      <tag>ulk</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
