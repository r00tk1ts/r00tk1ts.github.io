<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线性代数笔记(二十一)——特征方程</title>
    <link href="/2023/10/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%B8%80)%E2%80%94%E2%80%94%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"/>
    <url>/2023/10/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%B8%80)%E2%80%94%E2%80%94%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>本节讨论了线性代数中非常重要的两个概念：特征值与特征向量。</p><span id="more"></span><h1 id="特征方程">特征方程</h1><p>对于<spanclass="math inline">\(Ax=b\)</span>我们往往做这样的解读：矩阵<spanclass="math inline">\(A\)</span>乘以向量<spanclass="math inline">\(x\)</span>，实际上是让<spanclass="math inline">\(A\)</span>作用到向量<spanclass="math inline">\(x\)</span>上，得到新的向量<spanclass="math inline">\(b\)</span>。这里的<spanclass="math inline">\(A\)</span>像是一个函数，<spanclass="math inline">\(x\)</span>作为输入，<spanclass="math inline">\(b\)</span>作为输出。在诸多<spanclass="math inline">\(Ax\)</span>当中，我们尤其对这样的一类特殊群体感兴趣：<span class="math display">\[Ax=\lambda x\]</span></p><p>对非零向量<span class="math inline">\(x\)</span>来说，上式意味着<spanclass="math inline">\(A\)</span>发生作用之后，<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(Ax\)</span>依然保持同一方向。<strong>此时，我们把满足这个条件的非零向量<spanclass="math inline">\(x\)</span>称为<spanclass="math inline">\(A\)</span>的特征向量，<spanclass="math inline">\(\lambda\)</span>称为<spanclass="math inline">\(A\)</span>的特征值。而上式则被称为特征方程。</strong></p><h2 id="特征值lambda0">特征值<spanclass="math inline">\(\lambda=0\)</span></h2><p>对特征方程来说，这里有个比较特殊的case：当<spanclass="math inline">\(\lambda\)</span>为<spanclass="math inline">\(0\)</span>时，易得<spanclass="math inline">\(Ax=0\)</span>，即特征值为0的特征向量<spanclass="math inline">\(x\)</span>位于<spanclass="math inline">\(A\)</span>的零空间中。显然，对于奇异矩阵来说，必然存在非零向量满足<spanclass="math inline">\(Ax=0\)</span>，这也就意味着：若矩阵<spanclass="math inline">\(A\)</span>是奇异矩阵，那么它必有一个<spanclass="math inline">\(\lambda=0\)</span>的特征值。</p><h2 id="投影矩阵">投影矩阵</h2><p>若矩阵<span class="math inline">\(A\)</span>是一个投影矩阵（<spanclass="math inline">\(P=A(A^TA)^{-1}A^T\)</span>），那么它的特征值有哪些呢？</p><p>我们取比较特殊的向量：</p><ul><li>对于向量<span class="math inline">\(b\)</span>在<spanclass="math inline">\(P\)</span>上做投影，当且仅当<spanclass="math inline">\(b\)</span>本身已经处于投影空间中时（也就是<spanclass="math inline">\(P\)</span>的列空间），<spanclass="math inline">\(Pb\)</span>才和<spanclass="math inline">\(b\)</span>方向相同。因此，投影空间中的所有向量都是投影矩阵的特征向量，它们的特征值都是<spanclass="math inline">\(1\)</span>。</li><li>对于垂直于投影空间的法向量<spanclass="math inline">\(e\)</span>，有<spanclass="math inline">\(Pe=0\)</span>，因此投影空间的所有法向量（即<spanclass="math inline">\(P\)</span>的左零空间）都是投影矩阵的特征向量，它们的特征值都是<spanclass="math inline">\(0\)</span>。</li></ul><h2 id="二阶置换矩阵">二阶置换矩阵</h2><p>二阶置换矩阵<span class="math inline">\(A=\begin{bmatrix}0&amp;1\\1&amp;0\end{bmatrix}\)</span>，它的作用是交换二维向量<spanclass="math inline">\(x\)</span>的两个元素。根据特征值和特征向量的定义，使用瞪眼法可以看出：</p><ul><li><span class="math inline">\(A\)</span>有特征值为<spanclass="math inline">\(1\)</span>的特征向量，<spanclass="math inline">\(x_1=\begin{bmatrix}1\\1\end{bmatrix}\)</span>。</li><li><span class="math inline">\(A\)</span>有特征值为<spanclass="math inline">\(-1\)</span>的特征向量，<spanclass="math inline">\(x_2=\begin{bmatrix}-1\\1\end{bmatrix}\)</span></li></ul><h2 id="特征方程求解">特征方程求解</h2><p>通用的求解方法可以对特征方程进行转化：<spanclass="math inline">\((A-\lambda I)x=0\)</span>，若<spanclass="math inline">\(x\)</span>有非零解，则意味着<spanclass="math inline">\(A-\lambda I\)</span>是奇异矩阵，故<spanclass="math inline">\(\det(A-\lambda I)=0\)</span>。</p><p>根据行列式展开生成的代数余子式，我们知道它是个<spanclass="math inline">\(\lambda\)</span>的<spanclass="math inline">\(n\)</span>次方程，因此<spanclass="math inline">\(n\)</span>阶矩阵应有<spanclass="math inline">\(n\)</span>个特征值，它们之中可能有相同的值，其中可能有实数，也可能有虚数。</p><h3 id="示例">示例</h3><p>比如有矩阵<span class="math inline">\(A=\begin{bmatrix}3&amp;1 \\1&amp;3\end{bmatrix}\)</span>，求特征值和特征向量。</p><p>解：</p><p>构造矩阵<span class="math inline">\(\begin{bmatrix}3-\lambda &amp;1\\ 1&amp;3-\lambda \end{bmatrix}\)</span>，其行列式带入化简得：<spanclass="math inline">\(\lambda ^2-6\lambda +8=0\)</span>。</p><p>求得两个特征值<span class="math inline">\(\lambda_1=4,\lambda_2=2\)</span>。带入求解特征向量分别为：<spanclass="math inline">\(x_1=\begin{bmatrix}1\\1\end{bmatrix}\)</span>，<spanclass="math inline">\(x_2=\begin{bmatrix}-1\\1\end{bmatrix}\)</span>。</p><p>另一方面，我们也发现该矩阵和二阶置换矩阵相比，两个特征向量完全相同，只是特征值发生了偏移（全部增加了3个单位）。事实上，这其中有着这样的规律，考虑：<spanclass="math inline">\(A=\begin{bmatrix}0&amp;1\\1&amp;0\end{bmatrix}+3I\)</span>，原方程变为：<spanclass="math inline">\((A+3I)x=\lambdax+3x=(\lambda+3)x\)</span>，这里可以看出<spanclass="math inline">\(x\)</span>前后是没有变化的，即特征向量不变，但新的特征值变为了<spanclass="math inline">\(\lambda+3\)</span>。</p><blockquote><p>但是这一推理对于加一般矩阵<spanclass="math inline">\(B\)</span>来说是不成立的，这是因为你无法保证<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>有同样的特征向量<spanclass="math inline">\(x\)</span>，我们无法得出<spanclass="math inline">\((A+B)x=(\lambda+\alpha)x\)</span>的结论，这是因为本质上<spanclass="math inline">\(x\)</span>有差异(应该写作<spanclass="math inline">\(Ax=\lambda x, By=\alpha y\)</span>)。</p></blockquote><h3 id="特征值的性质">特征值的性质</h3><p>上面的例子其实也能看出，特征值的和与积有着一些明显特性：</p><ul><li>矩阵的特征值之和等于矩阵的迹。</li><li>矩阵的特征值之积等于矩阵的行列式。</li></ul><p>这两个性质的证明比较繁琐，但其本质就是韦达定理，这里限于篇幅不做展开论证。</p><p><img src="2023-10-09-19-47-38.png" /></p><h3 id="旋转矩阵">旋转矩阵</h3><p>对于旋转矩阵<spanclass="math inline">\(Q=\begin{bmatrix}\cos90^\circ&amp;-sin90^\circ\\sin90^\circ&amp;cos90^\circ\end{bmatrix}=\begin{bmatrix}0&amp;-1\\1&amp;0\end{bmatrix}\)</span>，作用到<spanclass="math inline">\(x\)</span>可以让向量旋转<spanclass="math inline">\(90^\circ\)</span>，利用特征值的性质，我们得到方程：<span class="math display">\[\begin{cases}\lambda_1+\lambda_2=0 \\\lambda_1\cdot\lambda_2=1\end{cases}\]</span></p><p>得到特征值<spanclass="math inline">\(\lambda_1=i,\lambda_2=-i\)</span>。尽管矩阵全部都是实数，但得到的两个特征值却是虚数。</p><blockquote><p>实际上，矩阵如果是对称的，那么特征值一定都是实数。越接近对称，特征值就越可能是实数，相反，越不对称，比如像上例中的反对称矩阵(<spanclass="math inline">\(A^T=-A\)</span>)，其特征值往往是虚数。实数特征值让特征向量伸缩，而虚数则让其旋转。</p></blockquote><h3 id="上三角阵">上三角阵</h3><p>上三角阵的情况更糟糕，有<spanclass="math inline">\(A=\begin{bmatrix}3&amp;1 \\0&amp;3\end{bmatrix}\)</span>，求特征值和特征向量。</p><p>带入<span class="math inline">\(\det(A-\lambdaI)=0\)</span>，得到<spanclass="math inline">\(\lambda_1=\lambda_2=3\)</span>，此时两个特征值相等，意味着特征向量相同（都是<spanclass="math inline">\(x=\begin{bmatrix}1\\0\end{bmatrix}\)</span>）。</p><p>对于这种二阶退化矩阵，我们只能找到一个方向上的特征向量而非两个。推广到高阶，对特化矩阵而言，重复的特征值会导致特征向量的缺失。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570098690&amp;p=21&amp;autoplay=0" scrolling="no" width="100%" height="500" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B21%5D%20%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B021.pdf">特征值和特征向量</a></li><li><ahref="https://rqtn.github.io/2019/09/01/LA-Lec21/">特征值和特征向量</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(二十)——行列式应用</title>
    <link href="/2023/10/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81)%E2%80%94%E2%80%94%E8%A1%8C%E5%88%97%E5%BC%8F%E5%BA%94%E7%94%A8/"/>
    <url>/2023/10/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81)%E2%80%94%E2%80%94%E8%A1%8C%E5%88%97%E5%BC%8F%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>这一节从行列式的性质出发，对行列式三个方面的应用进行描述：求逆矩阵、克莱姆法则和体积。</p><span id="more"></span><h1 id="行列式应用">行列式应用</h1><h2 id="求逆矩阵">求逆矩阵</h2><p>我们已经学过了用高斯-若尔当求逆矩阵的方法，尽管从实用角度出发高斯若尔当求逆法相当好用，但毕竟不够直观。而借助行列式，我们可以给出一个更直观的求逆矩阵的代数表达式：</p><p><span class="math display">\[A^{-1}=\frac{1}{|A|}C^T\]</span></p><p>这里的<spanclass="math inline">\(C\)</span>被称作代数余子式矩阵，矩阵的每个元素是由<spanclass="math inline">\(A\)</span>中对应位置元素的代数余子式组成，其转置矩阵一般也称其为伴随矩阵，记为<spanclass="math inline">\(C^T\)</span>。</p><p>这一代数表达式的证明也很简单，两边同时左乘<spanclass="math inline">\(A\)</span>，则问题转化为证明：<spanclass="math inline">\(AC^T=|A|I\)</span>，展开观察： <spanclass="math display">\[AC^T=\begin{bmatrix}a_{11}&amp;...&amp;a_{1n} \\...&amp;...&amp;...\\a_{n1}&amp;...&amp;a_{nn}\end{bmatrix}\begin{bmatrix}C_{11}&amp;...&amp;C_{n1}\\ ...&amp;...&amp;...\\C_{1n}&amp;...&amp;C_{nn}\end{bmatrix}\]</span></p><p>根据乘法运算，可以发现<spanclass="math inline">\(A\)</span>中每一个行向量与<spanclass="math inline">\(C^T\)</span>中对应列向量做内积后得到的正是<spanclass="math inline">\(\det(A)\)</span>（使用上一节的代数余子式计算行列式公式得到）。举个例子，第1行与第1列内积得到<spanclass="math inline">\(\det(A)\)</span>，第2行与第2列内积也得到<spanclass="math inline">\(\det(A)\)</span>，以此类推。因此，乘法运算得到的最终矩阵中主对角线上的元素都是<spanclass="math inline">\(\det(A)\)</span>：</p><p><span class="math display">\[\begin{bmatrix}a_{11}&amp;...&amp;a_{1n} \\...&amp;...&amp;...\\a_{n1}&amp;...&amp;a_{nn}\end{bmatrix}\begin{bmatrix}C_{11}&amp;...&amp;C_{n1}\\ ...&amp;...&amp;...\\C_{1n}&amp;...&amp;C_{nn}\end{bmatrix}=\begin{bmatrix}|A|&amp;...&amp;...\\ ...&amp;|A|&amp;...\\...&amp;...&amp;|A|\end{bmatrix}\]</span></p><p>再来观察其他位置，比如我们观察<spanclass="math inline">\(i=1,j=2\)</span>的元素，它是第1行与第2列的内积：<spanclass="math inline">\(a_{11}C_{21}+a_{12}C_{22}+...+a_{1n}C_{2n}\)</span>，类似主对角线的元素，思考一下：什么样的矩阵的行列式的代数余子式公式会这样展开呢？答案很简单：<span class="math display">\[\begin{bmatrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1n}\\a_{11}&amp;a_{12}&amp;...&amp;a_{1n}\\a_{31}&amp;a_{32}&amp;...&amp;a_{3n}\\...&amp;...&amp;...\\a_{n1}&amp;a_{n2}&amp;...&amp;a_{nn}\end{bmatrix}\]</span></p><p>对于上式展开形式，只需要将原本的矩阵<spanclass="math inline">\(A\)</span>中第二行全部换成第一行，再去求行列式，就刚好可写作<spanclass="math inline">\(a_{11}C_{21}+a_{12}C_{22}+...+a_{1n}C_{2n}\)</span>。另一方面，我们知道有相同两行的矩阵行列式值为0，因此，<spanclass="math inline">\(a_{11}C_{21}+a_{12}C_{22}+...+a_{1n}C_{2n}=0\)</span>。</p><p>故最终的乘积矩阵中，主对角线元素皆为<spanclass="math inline">\(\det(A)\)</span>，其他元素皆为<spanclass="math inline">\(0\)</span>： <span class="math display">\[\begin{bmatrix}|A|&amp;0&amp;...&amp;0\\ 0&amp;|A|&amp;...&amp;0\\...&amp;...&amp;...&amp;...\\ 0&amp;0&amp;...&amp;|A|\end{bmatrix}\]</span></p><p>综上，原式<spanclass="math inline">\(A^{-1}=\frac{1}{|A|}C^T\)</span>得证。根据逆矩阵公式，可以看到：当改变原矩阵中的元素时会给逆矩阵带来怎样的变化，具体表现为：<spanclass="math inline">\(det(A)\)</span>发生了改变、<spanclass="math inline">\(C^T\)</span>也发生了改变。</p><h2 id="克莱姆法则">克莱姆法则</h2><p>使用上述求逆矩阵公式，对于方程<spanclass="math inline">\(Ax=b\)</span>我们也可以不必使用消元法，而是换成逆矩阵公式来求解：<span class="math display">\[x=A^{-1}b=\frac{1}{|A|}C^Tb\]</span></p><p>这里的<spanclass="math inline">\(C^Tb\)</span>展开就是每一个代数余子式<spanclass="math inline">\(C\)</span>乘<spanclass="math inline">\(b\)</span>的各个分量。余子式乘数字的形式是不是很眼熟？这不就是某个矩阵的行列式计算公式嘛。那么什么样的矩阵可以展开成这样的行列式计算式呢？这次从列的视角出发，我们将矩阵<spanclass="math inline">\(A\)</span>中<spanclass="math inline">\(C_i\)</span>对应列<spanclass="math inline">\(A_i\)</span>替换为<spanclass="math inline">\(b\)</span>，即可得到这样的计算式展开，我们将替换后的矩阵记为<spanclass="math inline">\(B_i\)</span>，于是有： <spanclass="math display">\[x_1=\frac{|B_1|}{|A|}, x_2=\frac{|B_2|}{|A|},x_3=\frac{|B_3|}{|A|}...,x_n=\frac{|B_n|}{|A|}\]</span></p><p><span class="math inline">\(x\)</span>的每个分量都是对应的<spanclass="math inline">\(C_i^Tb\)</span>得到，因此，若想要求得每个分量的值，只需要构造矩阵<spanclass="math inline">\(B_i\)</span>并计算其行列式值即可。 <spanclass="math display">\[B_1=\begin{bmatrix}b_1&amp;a_{12}&amp;...&amp;a_{1n}\\b_2&amp;a_{22}&amp;...&amp;a_{2n}\\b_3&amp;a_{32}&amp;...&amp;a_{3n}\\...&amp;...&amp;...&amp;...\\b_n&amp;a_{n2}&amp;...&amp;a_{nn}\end{bmatrix}\]</span></p><p>按第一列展开成代数余子式公式：即第一个分量<spanclass="math inline">\(x_1=\frac{C_1^Tb}{|A|}\)</span>，其中<spanclass="math inline">\(|B_1|=C_1^Tb\)</span>。即：<spanclass="math inline">\(|B_1|=b_1C_{11}+b_2C_{21}+...+b_nC_{n1}\)</span>。</p><p>克莱姆法则很漂亮，但是并不实用。相对于消元法，如果使用克莱姆法则来求解<spanclass="math inline">\(Ax=b\)</span>，那么就需要求出共计<spanclass="math inline">\(n+1\)</span>个矩阵的行列式，这个计算量对人类来说太大了，但这种代数表达式的表示法可能对于计算机算法来说却更加友好，也更加具体。</p><h2 id="体积">体积</h2><p>对3阶矩阵<spanclass="math inline">\(A\)</span>，其行列式的绝对值<spanclass="math inline">\(|det(A)|\)</span>就是以矩阵<spanclass="math inline">\(A\)</span>行（列）向量为边所构成的平行六面体的体积。行列式的符号对应左手系和右手系。</p><p><img src="2023-10-09-14-21-48.png" /></p><p>行列式的绝对值为什么等于体积呢？我们知道三大基础性质定义了行列式，因此如果我们能够证明体积也具有这三大性质，那么就可以知道体积一定等于行列式。</p><h3 id="性质1">性质1</h3><p>对单位阵<span class="math inline">\(I\)</span>来说，体积就是<spanclass="math inline">\(1\)</span>，这是显而易见的。</p><h3 id="性质2">性质2</h3><p>交换两行并不会改变空间六面体，绝对值也不变。</p><h3 id="性质3a">性质3a</h3><p>相当于对其中的某一边进行缩放，体积当然也跟着缩放系数进行缩放，这一点显然。</p><h3 id="性质3b">性质3b</h3><p>这个性质不太好证明，为了便捷我们这里在2阶矩阵上验证。</p><p>对于二阶矩阵，行列式就是两条边组成的平行四边形的面积。</p><p><img src="2023-10-09-15-14-10.png" /></p><p>从二维图像上可以看出，<spanclass="math inline">\((a+a&#39;,b+b&#39;)\)</span>与<spanclass="math inline">\((c,d)\)</span>围成的平行四边形的面积刚好就是<spanclass="math inline">\((a,b),(c,d)\)</span>围成的四边形与<spanclass="math inline">\((a&#39;,b&#39;),(c,d)\)</span>围成的四边形的总和。即：<span class="math display">\[\begin{vmatrix}a+a&#39;&amp;b+b&#39;\\c&amp;d\end{vmatrix}=\begin{vmatrix}a&amp;b\\ c&amp;d\end{vmatrix}+\begin{vmatrix}a&#39;&amp;b&#39;\\ c&amp;d\end{vmatrix}\]</span></p><p>高维空间与此类似，本质上都是等价替换。</p><h3 id="求三角形的面积">求三角形的面积</h3><p>受此启发，对平面任意三点<spanclass="math inline">\((x_1,y_1),(x_2,y_2),(x_3,y_3)\)</span>构成的三角形围成的面积就是：<spanclass="math inline">\(\frac{1}{2}\begin{vmatrix}x_1&amp;y_1&amp;1\\x_2&amp;y_2&amp;1\\ x_3&amp;y_3&amp;1\end{vmatrix}\)</span>。</p><blockquote><p>第三列全为1相当于把平面投影到三维空间，而三点共面。</p></blockquote><p>再根据行列式性质令行2和行3减去行1，使得第三列除了首个元素外全归0，此时按代数余子式展开，得到面积值为：<spanclass="math inline">\(\frac{1}{2}((x_2-x_1)(y_3-y_1)-(x_3-x_1)(y_2-y_1))\)</span>。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570093614&amp;p=20&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B20%5D%20%E5%85%8B%E8%8E%B1%E5%A7%86%E6%B3%95%E5%88%99%E3%80%81%E9%80%86%E7%9F%A9%E9%98%B5%E3%80%81%E4%BD%93%E7%A7%AF/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B020.pdf">克莱姆法则、逆矩阵、体积</a></li><li><ahref="https://rqtn.github.io/2019/08/31/LA-Lec20/">克拉默法则、逆矩阵、体积</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十九)——行列式公式</title>
    <link href="/2023/09/28/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B9%9D)%E2%80%94%E2%80%94%E8%A1%8C%E5%88%97%E5%BC%8F%E5%85%AC%E5%BC%8F/"/>
    <url>/2023/09/28/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B9%9D)%E2%80%94%E2%80%94%E8%A1%8C%E5%88%97%E5%BC%8F%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>通过上一讲掌握的行列式10大特性，我们可以推导出行列式的一般求解公式。本讲从已知特性着手，深入讲解了行列式一般求解公式。</p><span id="more"></span><h1 id="行列式公式">行列式公式</h1><h2 id="二阶行列式公式">二阶行列式公式</h2><p>上一讲我们有提到对于二阶行列式：<spanclass="math inline">\(\begin{vmatrix}a&amp;b\\c&amp;d\end{vmatrix}=ad-bc\)</span>，它可以根据行列式的性质来得到：<span class="math display">\[\begin{vmatrix}a&amp;b \\c&amp;d\end{vmatrix}=\begin{vmatrix}a&amp;0 \\c&amp;d\end{vmatrix}+\begin{vmatrix}0&amp;b \\c&amp;d\end{vmatrix}=\begin{vmatrix}a&amp;0 \\c&amp;0\end{vmatrix}+\begin{vmatrix}a&amp;0 \\0&amp;d\end{vmatrix}+\begin{vmatrix}0&amp;b \\c&amp;0\end{vmatrix}+\begin{vmatrix}0&amp;b \\0&amp;d\end{vmatrix}\]</span></p><p>根据性质3分解出<span class="math inline">\(2\times2\)</span>个行列式，其中第一项和第四项由于存在全零列，故值为0。第二项根据性质7可知值为<spanclass="math inline">\(ad\)</span>，第三项根据性质2和7可知值为<spanclass="math inline">\(-bc\)</span>，因此<spanclass="math inline">\(\begin{vmatrix}a&amp;b\\c&amp;d\end{vmatrix}=ad-bc\)</span>。</p><h2 id="从二阶到三阶">从二阶到三阶</h2><p>采用同样的手法，我们也可以拆分三阶行列式：先保持2、3行不变，对第1行进行拆分，得到3个行列式，再对这3个行列式的第2行进行拆分，共得到<spanclass="math inline">\(3\times3\)</span>个行列式，再接着拆分这9个行列式的第3行，最终得到<spanclass="math inline">\(3\times 3\times3\)</span>个行列式，我们忽略存在全零列的行列式，最终得到6个行列式加和：<span class="math display">\[\begin{vmatrix}a_{11}&amp;a_{12}&amp;a_{13} \\a_{21}&amp;a_{22}&amp;a_{23} \\a_{31}&amp;a_{32}&amp;a_{33}\end{vmatrix}=\begin{vmatrix}a_{11}&amp;0&amp;0 \\0&amp;a_{22}&amp;0 \\0&amp;0&amp;a_{33}\end{vmatrix}+\begin{vmatrix}a_{11}&amp;0&amp;0 \\0&amp;0&amp;a_{23} \\0&amp;a_{32}&amp;0\end{vmatrix}+\begin{vmatrix}0&amp;a_{12}&amp;0 \\a_{21}&amp;0&amp;0 \\0&amp;0&amp;a_{33}\end{vmatrix}+\begin{vmatrix}0&amp;a_{12}&amp;0 \\0&amp;0&amp;a_{23} \\a_{31}&amp;0&amp;0\end{vmatrix}+\begin{vmatrix}0&amp;0&amp;a_{13} \\a_{21}&amp;0&amp;0 \\0&amp;a_{32}&amp;0\end{vmatrix}+\begin{vmatrix}0&amp;0&amp;a_{13} \\0&amp;a_{22}&amp;0 \\a_{31}&amp;0&amp;0\end{vmatrix}\]</span></p><p>行列式<spanclass="math inline">\(=a_{11}a_{22}a_{33}-a_{11}a_{23}a_{32}-a_{12}a_{21}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{13}a_{22}a_{31}\)</span>。</p><p>根据排列组合思想，可以得出<spanclass="math inline">\(n\)</span>阶行列式分解可以得到<spanclass="math inline">\(n!\)</span>个非零行列式，故一般公式可以写作：<span class="math display">\[\det A=\sum_{n!}\pm a_{1\alpha}a_{2\beta}a_{3\gamma}...a_{n\omega},(\alpha, \beta, \gamma, ..., \omega)=P_{n}^{n}\]</span></p><p><strong>前面的正负号，要取决于行列式转为三角阵所需行交换的步数，若步数为偶数，那么符号为正；若步数为奇数，则符号为负。</strong></p><p>有一个比较优雅的算法来判断非零行列式的符号：统计数列的逆序数，逆序数就是从左到右遍历当前排列中的每一个数，统计它的右侧有几个数比自己小，最终加和求得。比如对于排列<spanclass="math inline">\((4,3,2,1)\)</span>来说，它的逆序数就是<spanclass="math inline">\(3+2+1=6\)</span>，逆序数为偶数故为偶排列，否则就是奇排列。偶排列符号取正，奇排列符号取负。</p><h2 id="代数余子式">代数余子式</h2><p>将三阶行列式的一般公式做一下合并同类项： <spanclass="math display">\[a_{11}(a_{22}a_{33}-a{23}a{32})+a_{12}(-a_{21}a_{33}+a_{23}a_{32})+a_{13}(a_{21}a_{32}-a_{22}a_{31})\]</span></p><p>合并后，我们发现上式可以看成： <span class="math display">\[\begin{vmatrix}a_{11}&amp;0&amp;0 \\0&amp;a_{22}&amp;a_{23}\\0&amp;a_{32}&amp;a_{33}\end{vmatrix}+\begin{vmatrix}0&amp;a_{12}&amp;0 \\a_{21}&amp;0&amp;a_{23}\\a_{31}&amp;0&amp;a_{33}\end{vmatrix}+\begin{vmatrix}0&amp;0&amp;a_{13} \\a_{21}&amp;a_{22}&amp;0 \\a_{31}&amp;a_{32}&amp;0\end{vmatrix}\]</span></p><p>也就是： <span class="math display">\[a_{11}(\begin{vmatrix}a_{22}&amp;a_{23} \\a_{32}&amp;a_{33}\end{vmatrix})+a_{12}(-\begin{vmatrix}a_{21}&amp;a_{23} \\a_{31}&amp;a_{33}\end{vmatrix})+a_{13}(\begin{vmatrix}a_{21}&amp;a_{22} \\a_{31}&amp;a_{32}\end{vmatrix})\]</span></p><p>这就表明，3阶行列式由多个2阶行列式组成。由此递推，<spanclass="math inline">\(n\)</span>阶行列式就是由多个<spanclass="math inline">\(n-1\)</span>阶行列式组成。由此，我们就找出了自顶向下的递归关系。</p><p>实际上，括号里的部分我们称作代数余子式，比如<spanclass="math inline">\((a_{22}a_{33}-a{23}a{32})\)</span>就是<spanclass="math inline">\(a_{11}\)</span>的代数余子式。对于选定元素<spanclass="math inline">\(a_{ij}\)</span>，其代数余子式为：将原行列式的第<spanclass="math inline">\(i\)</span>行与第<spanclass="math inline">\(j\)</span>列元素全部抹去，剩余的<spanclass="math inline">\(n-1\)</span>阶行列式再取正负，得到的算式就是代数余子式，一般记为<spanclass="math inline">\(C_{ij}\)</span>。那么这个正负要怎么判断呢？可以根据<spanclass="math inline">\(i,j\)</span>来判定： <span class="math display">\[C_{ij}=(-1)^{i+j}\cdot \det(去掉i行j列的n-1阶方阵)\]</span></p><p>使用代数余子式可以将一般计算公式简写作：<spanclass="math inline">\(\detA=a_{11}C_{11}+a_{12}C_{12}+...+a_{1n}C_{1n}\)</span>。</p><blockquote><p>代数余子式的计算方式相比于借助行列式的特性、消元成三角阵求主元乘积的方法来说其实更麻烦一些。但是这里之所以探索一般公式，主要是为了挖掘<spanclass="math inline">\(n\)</span>阶行列式与<spanclass="math inline">\(n-1\)</span>阶行列式之间的关系，由此而递归下去。</p></blockquote><h3 id="有趣的示例">有趣的示例</h3><p>现有:<span class="math inline">\(A_1=1\)</span>，<spanclass="math inline">\(A_2=\begin{vmatrix}1&amp;1 \\ 1&amp;1\end{vmatrix}\)</span>, <spanclass="math inline">\(A_3=\begin{vmatrix}1&amp;1&amp;0 \\ 1&amp;1&amp;1\\ 0&amp;1&amp;1\end{vmatrix}\)</span>, <spanclass="math inline">\(A_4=\begin{vmatrix}1&amp;1&amp;0&amp;0\\1&amp;1&amp;1&amp;0\\ 0&amp;1&amp;1&amp;1\\0&amp;0&amp;1&amp;1\end{vmatrix}\)</span>。寻找行列式之间的规律。</p><p>容易求得<spanclass="math inline">\(A_1=1,A_2=0,A_3=-1\)</span>。我们可以发现<spanclass="math inline">\(A_4\)</span>的方阵按第一行展开，由于只有<spanclass="math inline">\(a_{11}和a_{12}\)</span>非零，故拆分成代数余子式的形式有：<span class="math display">\[A_4=1*\begin{vmatrix}1&amp;1&amp;0 \\1&amp;1&amp;1 \\0&amp;1&amp;1\end{vmatrix}+(-1)*\begin{vmatrix}1&amp;1&amp;0 \\0&amp;1&amp;1 \\0&amp;1&amp;1\end{vmatrix}\]</span></p><p>其中第二项我们发现第一列只有1个元素非零，也就是说如果继续拆分到<spanclass="math inline">\(A_2\)</span>的组合，非零项只有1个，故上式相当于：<spanclass="math inline">\(A_4=A_3-A_2\)</span>，因此求得<spanclass="math inline">\(A_4=-1\)</span>。</p><blockquote><p>实际上，这个矩阵十分特殊，它存在着这样的规律：<spanclass="math inline">\(A_n=A_{n-1}-A_{n-2}\)</span>，行列式对应的值是一个数列：<spanclass="math inline">\(1,0,-1,-1,0,1\)</span>，以6为周期。</p></blockquote><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570094031&amp;p=19&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B18%2C19%5D%20%E8%A1%8C%E5%88%97%E5%BC%8F%E4%BB%8B%E7%BB%8D/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B018%2C19.pdf">行列式介绍</a></li><li><ahref="https://rqtn.github.io/2019/08/12/LA-Lec19/">行列式公式和代数余子式</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十八)——行列式及其性质</title>
    <link href="/2023/09/27/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%85%AB)%E2%80%94%E2%80%94%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/"/>
    <url>/2023/09/27/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%85%AB)%E2%80%94%E2%80%94%E8%A1%8C%E5%88%97%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<p>从本讲开始进入线性代数的第二部分：行列式与特征值。许多国内教材都是把行列式放在第一章，这对于理解线性代数这门语言来说是非常离谱的操作。行列式因方阵而生，它的值与特性与方阵息息相关，在求解特征值过程中行列式发挥了极大的作用。我们要着重于理解其背后的机理、探索本质，而不是死记硬背几个公式或是掌握一些trick手法解几道算术题。</p><span id="more"></span><h1 id="行列式及其性质">行列式及其性质</h1><p>每个方阵都有行列式，行列式是跟该方阵有关的一个数字，行列式的值隐含了该方阵的许多特性，例如，行列式为<spanclass="math inline">\(0\)</span>的方阵一定不可逆，可逆的方阵行列式值一定不为<spanclass="math inline">\(0\)</span>。</p><p>行列式数学上写作<spanclass="math inline">\(\begin{vmatrix}A\end{vmatrix}\)</span>，一般记为<spanclass="math inline">\(\det A\)</span>。</p><h2 id="行列式的三大基础特性">行列式的三大基础特性</h2><ul><li>性质1：单位阵 <span class="math inline">\(\det I=1\)</span>。</li><li>性质2：交换任意两行后，行列式值的符号取反。</li><li>性质3：<ul><li>a: 行列式可以按行提取矩阵的系数，即:<spanclass="math inline">\(\begin{vmatrix}ta&amp;tb \\ c&amp;d \\\end{vmatrix}=t\begin{vmatrix}a&amp;b \\c&amp;d\end{vmatrix}\)</span>。</li><li>b: 行列式的行具有线性，即：<spanclass="math inline">\(\begin{vmatrix} a+a&#39;&amp;b+b&#39; \\ c&amp;d\\ \end{vmatrix}=\begin{vmatrix} a&amp;b \\c&amp;d\end{vmatrix}+\begin{vmatrix} a&#39;&amp;b&#39; \\c&amp;d\end{vmatrix}\)</span></li></ul></li></ul><blockquote><p>注意3b里的线性是指行的线性，而非行列式具有线性。</p></blockquote><h2 id="衍生推导特性">衍生推导特性</h2><p>其他的特性都可以根据三大基础特性来进行推导，它们也十分重要，在我们计算行列式和推导其他特性的过程中常常用到。</p><ul><li>性质4：如果存在相等的两行，则行列式为<spanclass="math inline">\(0\)</span>。可以用性质2来证明，交换相等的两行，行列式的值会取反，但此时方阵并没有任何改变，因此只有行列式为<spanclass="math inline">\(0\)</span>值才能满足性质2。</li><li>性质5：从<span class="math inline">\(k\)</span>行中减去<spanclass="math inline">\(i\)</span>行的<spanclass="math inline">\(l\)</span>倍，行列式不发生改变。<strong>换言之，行列式不因矩阵消元而改变。</strong>这一性质对列变换也同样生效（相当于先转置，行变换后再转置回来，就是列变换）。根据性质3，可知： <span class="math display">\[\begin{vmatrix}a&amp;b \\c-la&amp;d-lb\end{vmatrix}=\begin{vmatrix}a&amp;b \\c&amp;d\end{vmatrix}-l\begin{vmatrix}a&amp;b \\a&amp;b\end{vmatrix}\]</span> 再根据刚推导的性质4，等号右边第二项行列式为<spanclass="math inline">\(0\)</span>，性质5得证。</li><li>性质6：如果方阵的某一行全为<spanclass="math inline">\(0\)</span>，则行列式为<spanclass="math inline">\(0\)</span>。 由性质3或性质5推理显然。</li><li>性质7：上三角<spanclass="math inline">\(U\)</span>方阵的行列式值等于对角线上元素的乘积。<spanclass="math inline">\(\det U=d_1d_2\cdot d_n\)</span>： <spanclass="math display">\[U=\begin{vmatrix}d_1&amp;*&amp;...&amp;* \\0&amp;d_2&amp;...&amp;* \\...&amp;...&amp;...&amp;... \\0&amp;0&amp;...&amp;d_n\end{vmatrix}\]</span>由性质5，从最后一行开始，将对角线元素上方的非零元素依次变为<spanclass="math inline">\(0\)</span>，行列式值不变。此时可以得到只有对角线元素的对角阵<spanclass="math inline">\(D\)</span>。再根据性质3a，提取所有的对角线元素<spanclass="math inline">\(d_i\)</span>华为单位阵，结合性质1得证。</li><li>性质8：当且仅当<spanclass="math inline">\(A\)</span>是奇异矩阵时（不可逆），<spanclass="math inline">\(\det A=0\)</span>。 由性质7，如果<spanclass="math inline">\(A\)</span>是可逆，那么消元得到的上三角<spanclass="math inline">\(U\)</span>对角线上的各行都有主元，行列式必不为<spanclass="math inline">\(0\)</span>。反之，消元后会出现全零行，有性质6可知行列式为<spanclass="math inline">\(0\)</span>。</li><li>性质9：<span class="math inline">\(\det AB=\det A \cdot \detB\)</span>，行列式具备乘法性质。 由性质5，可以把<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>通过行变换最终转为对角阵<spanclass="math inline">\(A&#39;,B&#39;\)</span>，此时<spanclass="math inline">\(\det A&#39;=\det A, \det B&#39;=\detB\)</span>。而两个对角矩阵相乘的结果显而易见： <spanclass="math display">\[\begin{bmatrix}a_1&amp;0&amp;...&amp;0 \\0&amp;a_2&amp;...&amp;0 \\...&amp;...&amp;...&amp;...\\0&amp;0&amp;...&amp;a_n\end{bmatrix}\begin{bmatrix}b_1&amp;0&amp;...&amp;0 \\0&amp;b_2&amp;...&amp;0 \\...&amp;...&amp;...&amp;...\\0&amp;0&amp;...&amp;b_n\end{bmatrix}=\begin{bmatrix}a_1b_1&amp;0&amp;...&amp;0 \\0&amp;a_2b_2&amp;...&amp;0 \\...&amp;...&amp;...&amp;...\\0&amp;0&amp;...&amp;a_nb_n\end{bmatrix}\]</span> 由性质7可知<span class="math inline">\(\detA&#39;B&#39;=(a_1\cdot a_2\cdot ...\cdot a_n)(b_1\cdot b_2\cdot ...\cdotb_n)\)</span>，故<span class="math inline">\(\det A&#39;B&#39;=\detA&#39; \det B&#39;\)</span>。另一方面，<spanclass="math inline">\(AB\)</span>转为<spanclass="math inline">\(A&#39;B&#39;\)</span>的过程实际上就是分别左乘一个矩阵对<spanclass="math inline">\(A\)</span>做行变换，再右乘一个矩阵对<spanclass="math inline">\(B\)</span>做列变换，得到<spanclass="math inline">\(A&#39;B&#39;\)</span>，由性质5可知<spanclass="math inline">\(\det AB=\det A&#39;B&#39;\)</span>，故<spanclass="math inline">\(\det AB = \det A \det B\)</span>。</li></ul><blockquote><p>根据性质9，可以轻松求得<spanclass="math inline">\(A\)</span>逆矩阵的行列式，因为<spanclass="math inline">\(\det I=\det A^{-1} \cdot \detA=1\)</span>，所以行列式互为倒数（如果<spanclass="math inline">\(A\)</span>不可逆，可以看出式子也不成立）。此外还可以看出<spanclass="math inline">\(\det A^2=(\det A)^2\)</span>。</p></blockquote><ul><li>性质10：<span class="math inline">\(\det A^T=\det A\)</span>。 <spanclass="math inline">\(A=LU\)</span>，可知<spanclass="math inline">\(A^T=U^TL^T\)</span>，根据性质9：<spanclass="math inline">\(\det A^T=\det U^T \det L^T, \det A=\det U \detL\)</span>，且已知三角阵转置后还是三角阵，故<spanclass="math inline">\(\det U=\det U^T, \det L^T=\detL\)</span>，因此<span class="math inline">\(\det A^T=\detA\)</span>。</li></ul><h2 id="二阶方阵的行列式">二阶方阵的行列式</h2><p>根据上述的性质，我们可以很容易推出二阶方阵：<spanclass="math inline">\(\begin{vmatrix}a&amp;b\\ c&amp;d\end{vmatrix}\)</span>的行列式为<spanclass="math inline">\(ad-bc\)</span>。</p><p>熟练掌握这些行列式的特性，不仅可以让我们快速求解行列式，还可以看出矩阵的变换与行列式变化的联动关系。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570090316&amp;p=18&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B18%2C19%5D%20%E8%A1%8C%E5%88%97%E5%BC%8F%E4%BB%8B%E7%BB%8D/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B018%2C19.pdf">行列式介绍</a></li><li><ahref="https://rqtn.github.io/2019/08/12/LA-Lec18/">行列式及其性质</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十七)——正交矩阵和Gram-Schmidt正交化</title>
    <link href="/2023/09/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%83)%E2%80%94%E2%80%94%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E5%92%8CGram-Schmidt%E6%AD%A3%E4%BA%A4%E5%8C%96/"/>
    <url>/2023/09/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%83)%E2%80%94%E2%80%94%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E5%92%8CGram-Schmidt%E6%AD%A3%E4%BA%A4%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>书接上一回标准正交基，讲述了该正交向量组的特性与优势，并介绍了一种将一组向量标准化为标准正交向量组的重要方法：Gram-Schmidt正交化。</p><span id="more"></span><h1 id="正交矩阵和gram-schmidt正交化">正交矩阵和Gram-Schmidt正交化</h1><h2 id="标准正交基">标准正交基</h2><p>标准正交向量组构成的空间基被称为标准正交基，它有两个特性：对标准正交向量组中任意向量<spanclass="math inline">\(q\)</span>，有： <span class="math display">\[\begin{cases}q_i^Tq_j=0 \space (i\neq j) \\q_i^Tq_j=1 \space (i=j)\end{cases}\]</span></p><p>即：向量彼此垂直，模均为<span class="math inline">\(1\)</span>。</p><h2 id="标准正交矩阵">标准正交矩阵</h2><p>将标准正交向量组中的<spanclass="math inline">\(q_1,q_2,...,q_n\)</span>组成的矩阵<spanclass="math inline">\(Q\)</span>被称为正交矩阵： <spanclass="math display">\[Q=\begin{bmatrix}q_1&amp; q_2&amp; q_3&amp; ...&amp; q_n\end{bmatrix}\]</span></p><p>显然，正交矩阵<spanclass="math inline">\(Q\)</span>具有一个良好的性质：<spanclass="math inline">\(Q^TQ=I\)</span> <span class="math display">\[Q^TQ=\begin{bmatrix}q_1\\ q_2\\ q_3\\ ...\\q_n\end{bmatrix}\begin{bmatrix}q_1&amp; q_2&amp; q_3&amp; ...&amp;q_n\end{bmatrix}=\begin{bmatrix}1&amp; 0&amp; ...&amp; 0&amp;0\\ 0&amp;1&amp; ...&amp; 0&amp; 0\\ ...&amp; ...&amp; ...&amp; ...&amp; ...\\0&amp; 0&amp; ...&amp; 1&amp; 0\\ 0&amp; 0&amp; ...&amp; 0&amp;1\end{bmatrix}=I\]</span></p><h3 id="正交矩阵">正交矩阵</h3><p><strong>特别地，当<spanclass="math inline">\(Q\)</span>为方阵时，我们称这样的<spanclass="math inline">\(Q\)</span>为正交矩阵。</strong></p><p>正交矩阵有更丰富的性质，此时的方阵<spanclass="math inline">\(Q\)</span>有逆矩阵，由<spanclass="math inline">\(Q^TQ=I\)</span>可知，<spanclass="math inline">\(Q^{-1}=Q^T\)</span>。</p><blockquote><p>置换矩阵就是个经典案例。</p></blockquote><h3 id="标准正交矩阵的应用">标准正交矩阵的应用</h3><p>标准正交矩阵可以应用到投影矩阵上，我们知道：<spanclass="math inline">\(P=A(A^TA)^{-1}A^T\)</span>，当<spanclass="math inline">\(A\)</span>是标准正交矩阵时，有：<spanclass="math inline">\(Q(Q^TQ)^{-1}Q^T=QQ^T\)</span>。特别地，若<spanclass="math inline">\(Q\)</span>为方阵，此时<spanclass="math inline">\(QQ^T=QQ^{-1}=I\)</span>。（说明此时投影矩阵就是单位阵<spanclass="math inline">\(I\)</span>）</p><p><spanclass="math inline">\(P\)</span>的计算得到了极大的简化，对于<spanclass="math inline">\(P=QQ^T\)</span>，根据前面几讲的知识，我们知道<spanclass="math inline">\(QQ^T\)</span>有着一些特性：</p><ul><li>是对称阵，即<span class="math inline">\(P=P^T\)</span></li><li>乘方不变性，即<span class="math inline">\(P^2=P\)</span></li></ul><p>此外，对于前两讲中的拟合方程：<span class="math inline">\(A^TA\hatx=A^Tb\)</span>，若<spanclass="math inline">\(A\)</span>为标准正交矩阵，那么方程就变成了<spanclass="math inline">\(\hat x=Q^Tb\)</span>。<spanclass="math inline">\(\hat x\)</span>的每个分量<spanclass="math inline">\(\hat x_i=q_i^Tb\)</span>，即都是<spanclass="math inline">\(Q\)</span>中对应列向量与<spanclass="math inline">\(b\)</span>的内积。</p><blockquote><p>这个式子的物理意义就是：对已知标准正交基，向量<spanclass="math inline">\(b\)</span>在第<spanclass="math inline">\(i\)</span>个基上的投影就是对应基向量<spanclass="math inline">\(q_i^Tb\)</span>。</p></blockquote><p>因此，如果我们选择标准正交向量组作为基时，投影矩阵相关公式中的诸多计算都得到了极大的简化。</p><h2 id="gram-schmidt正交化">Gram-Schmidt正交化</h2><p>在标准正交矩阵的应用中我们可以看到，如果能够在实际运算中采用标准正交向量组，那就可以简化相当多的运算量。然而实际情况是，我们往往拿到的都只是一组线性无关的向量，它们恰好构成标准正交基的可能性微乎其微。那么有没有一种方法，可以将任意的线性无关向量组转换为标准正交基呢？</p><p><strong>答案是肯定的，这种方法就是”Gram-Schmidt正交化“。</strong></p><p>Gram-Schmidt正交化的过程很简单： <span class="math display">\[线性无关向量a,b\rightarrow 正交向量A,B\rightarrow标准正交向量q_1=\frac{A}{||A||}, q_2=\frac{B}{||B||}\]</span></p><blockquote><p>第一步转为正交向量的过程被称作Graham，第二步标准化为模1的过程被称作Schmidt。</p></blockquote><p>第二步标准化的过程很好理解，对每个分量除以模量即可，正交化的过程关键在于第一步，怎么找到<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>。</p><p>以不共线的两个<spanclass="math inline">\(a,b\)</span>向量为例，怎么转换成正交基呢？这就要用到投影：</p><p><img src="2023-09-26-16-02-58.png" /></p><p>我们先将<span class="math inline">\(a\)</span>向量固定，设为<spanclass="math inline">\(A\)</span>，然后将<spanclass="math inline">\(b\)</span>向量投影到<spanclass="math inline">\(A\)</span>上得到<spanclass="math inline">\(p\)</span>，此时误差向量<spanclass="math inline">\(e=b-p\)</span>所在直线的方向实际上就是另一个基向量<spanclass="math inline">\(B\)</span>的方向，取投影长度为<spanclass="math inline">\(B\)</span>的长度。于是有： <spanclass="math display">\[B=b-\frac{AA^Tb}{A^TA}\]</span></p><p>式子里<span class="math inline">\(A^Tb\)</span>和<spanclass="math inline">\(A^TA\)</span>都是内积标量值，因此上式一般写作：<spanclass="math inline">\(B=b-\frac{A^Tb}{A^TA}A\)</span>的形式。</p><p>得到<spanclass="math inline">\(A,B\)</span>之后，第二步就是做标准化了：<spanclass="math inline">\(q_1=\frac{A}{||A||},q_2=\frac{B}{||B||}\)</span>。</p><p>延展到三维空间，对于向量<spanclass="math inline">\(a,b,c\)</span>要怎么做正交化呢？我们可以如法炮制，首先<spanclass="math inline">\(A,B\)</span>的寻找方法不变： <spanclass="math display">\[A=a,B=b-\frac{AA^Tb}{A^TA}\]</span></p><p><span class="math inline">\(C\)</span>的计算如出一辙，我们分别让<spanclass="math inline">\(c\)</span>在<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>上进行投影，然后再减去投影得到的两个向量即为<spanclass="math inline">\(C\)</span>： <span class="math display">\[C=c-\frac{A^Tc}{A^TA}A-\frac{B^Tc}{B^TB}B\]</span></p><p>最后再对<span class="math inline">\(A,B,C\)</span>标准化即可。</p><h3 id="示例">示例</h3><p>有<span class="math inline">\(a=\begin{bmatrix}1\\ 1\\1\end{bmatrix}, b=\begin{bmatrix}1\\ 0\\2\end{bmatrix}\)</span>，求标准正交矩阵<spanclass="math inline">\(Q\)</span>。</p><p>解：</p><p>先固定<span class="math inline">\(A=a=\begin{bmatrix}1\\ 1\\1\end{bmatrix}\)</span>，用<span class="math inline">\(b\)</span>在<spanclass="math inline">\(A\)</span>上投影，差值即为: <spanclass="math display">\[B=b-\frac{A^Tb}{A^TA}A=\begin{bmatrix}1\\ 0\\2\end{bmatrix}-\frac{3}{3}\begin{bmatrix}1\\ 1\\1\end{bmatrix}=\begin{bmatrix}0\\ -1\\ 1\end{bmatrix}\]</span></p><p>标准化后得到： <span class="math display">\[Q=\begin{bmatrix}\frac{1}{\sqrt{3}}&amp; 0\\ \frac{1}{\sqrt{3}}&amp;-\frac{1}{\sqrt{2}}\\ \frac{1}{\sqrt{3}}&amp;\frac{1}{\sqrt{2}}\end{bmatrix}\]</span></p><h2 id="引申矩阵的qr分解">引申：矩阵的QR分解</h2><p>用消元法视角来看<spanclass="math inline">\(A\)</span>的分解，可以看做<spanclass="math inline">\(A=LU\)</span>，<spanclass="math inline">\(L\)</span>是进行行变换的下三角阵，<spanclass="math inline">\(U\)</span>是上三角阵。</p><p>以同样的眼光来看Gram-Schmidt正交化，有<spanclass="math inline">\(A=QR\)</span>，其中<spanclass="math inline">\(Q\)</span>为标准正交化阵，<spanclass="math inline">\(R\)</span>是一个上三角阵。 <spanclass="math display">\[\begin{bmatrix}a_1&amp; a_2\end{bmatrix}=\begin{bmatrix}q_1&amp;q_2\end{bmatrix}\begin{bmatrix}a_1^Tq_1&amp; a_2^Tq_1\\ a_1^Tq_2&amp;a_2^Tq_2\end{bmatrix}\]</span></p><p>显然左下角<span class="math inline">\(a_1^Tq_2=0\)</span>(<spanclass="math inline">\(a1是A方向，\)</span>q2<spanclass="math inline">\(是\)</span>B<spanclass="math inline">\(方向\)</span>)，拓展到高维会发现下三角都是<spanclass="math inline">\(0\)</span>，因为后构造的向量总是垂直于前面的向量。这也是Gram-Schmidt正交化的一个性质。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570089959&amp;p=17&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B17%5D%20%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E5%92%8CGram-Schmidt%20%E6%AD%A3%E4%BA%A4%E5%8C%96/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B017.pdf">正交矩阵和Gram-Schmidt正交化</a></li><li><a href="https://rqtn.github.io/2019/08/12/LA-Lec17/">Lec17 -正交矩阵和 Gram-Schmidt 正交化</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十六)——投影矩阵和最小二乘</title>
    <link href="/2023/09/25/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%85%AD)%E2%80%94%E2%80%94%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/"/>
    <url>/2023/09/25/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%85%AD)%E2%80%94%E2%80%94%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<p>在上一讲的基础上继续深度展开。</p><span id="more"></span><h1 id="投影矩阵和最小二乘">投影矩阵和最小二乘</h1><p>上一讲已经渗透了投影矩阵的概念，并以简单的线性回归作为示例，对最小二乘法和投影矩阵加以联系。</p><h2 id="投影矩阵">投影矩阵</h2><p>投影矩阵<spanclass="math inline">\(P=A(A^TA)^{-1}A^T\)</span>，其物理意义是将向量<spanclass="math inline">\(b\)</span>投影到<spanclass="math inline">\(A\)</span>的列空间中。</p><p>投影有两种极限情况：</p><ul><li>如果<span class="math inline">\(b\)</span>本身就在<spanclass="math inline">\(A\)</span>的列空间中，那么<spanclass="math inline">\(Pb=b\)</span>，此时<spanclass="math inline">\(P=I\)</span>。</li><li>如果<span class="math inline">\(b\)</span>垂直于<spanclass="math inline">\(A\)</span>列空间，此时<spanclass="math inline">\(Pb=0\)</span>，根据正交补的概念，<spanclass="math inline">\(b\)</span>是<spanclass="math inline">\(A\)</span>左零空间的向量，有<spanclass="math inline">\(A^Tb=0\)</span>。</li></ul><p><strong>综上可以归纳：任意向量<spanclass="math inline">\(b\)</span>都可以拆解成两个分量，一个分量<spanclass="math inline">\(p\)</span>在<spanclass="math inline">\(A\)</span>的列空间中，另一分量<spanclass="math inline">\(e\)</span>在<spanclass="math inline">\(A\)</span>的左零空间中。</strong></p><p><img src="2023-09-25-16-19-32.png" /></p><p><span class="math inline">\(p\)</span>是投影矩阵<spanclass="math inline">\(P\)</span>作用于<spanclass="math inline">\(b\)</span>在<spanclass="math inline">\(A\)</span>列空间的投影得到的分量，同理，如果想要投影到左零空间，那么投影矩阵就应该是<spanclass="math inline">\(I-P\)</span>。</p><blockquote><p>因为<span class="math inline">\(p=Pb, e=b-p\)</span>，所以<spanclass="math inline">\(e=b-Pb=(I-P)b\)</span>。</p></blockquote><h2 id="再探最小二乘">再探最小二乘</h2><p>还是回到例题：平面上三个点<span class="math inline">\((1,1), (2,2),(3,2)\)</span>做线性回归。</p><p><img src="2023-09-26-12-02-09.png" /></p><p>上一节我们分别通过微积分和投影矩阵两种方法进行了拟合，最终发现所求解的方程完全一致。实际上，在微积分求解法中，我们本质上算的是误差向量<spanclass="math inline">\(e1,e2,e3\)</span>模的平方和，为了让平方和最小，通过求导数找极值的方式列出了求解方程。而在投影法中，投影的本质其实就是将向量<spanclass="math inline">\(b\)</span>投影到<spanclass="math inline">\(A\)</span>列空间中最近的一点，换句话说，就是把<spanclass="math inline">\(p1,p2,p3\)</span>分别投影到所需求解的直线上去。</p><p><strong>因此，微积分算最小二乘(leastsquare)和投影矩阵具有相同的内核，也就不难理解为何二者最终需求解的解方程组殊途同归了。</strong></p><p>最终我们求得<spanclass="math inline">\(y=\frac{1}{2}x+\frac{2}{3}\)</span>，得到: <spanclass="math display">\[b=\begin{bmatrix}1\\ 2\\ 2\end{bmatrix}, p=\begin{bmatrix}\frac{7}{6}\\\frac{10}{6} \\\frac{13}{6}\end{bmatrix},e=\begin{bmatrix}-\frac{1}{6}\\ \frac{2}{6}\\-\frac{1}{6}\end{bmatrix}\]</span></p><p>简单验证一下，可以发现<span class="math inline">\(e\)</span>与<spanclass="math inline">\(p\)</span>垂直。</p><h2 id="标准正交基">标准正交基</h2><p>互相垂直的各列一定是线性无关的。于是，我们可以找到空间里的一组基，它们彼此相互垂直，这组基我们称之为正交基。</p><p>参考三维直角坐标系，我们常常选用<spanclass="math inline">\(\begin{bmatrix}1\\ 0\\0\end{bmatrix},\begin{bmatrix}0\\ 1\\ 0\end{bmatrix},\begin{bmatrix}0\\0\\ 1\end{bmatrix}\)</span>作为标准基，也就是对应<spanclass="math inline">\(x,y,z\)</span>三个轴。</p><ul><li>由于彼此相互垂直，故为一组正交基。</li><li>由于每个基向量都是单位向量，故称作标准正交基。</li></ul><p>当然，标准正交基不止这一种，例如二维空间的标准正交基还可以是：<spanclass="math inline">\(\begin{bmatrix}\cos\theta\\\sin\theta\end{bmatrix},\begin{bmatrix}-\sin\theta\\\cos\theta\end{bmatrix}\)</span>。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570095287&amp;p=16&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B16%5D%20%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E5%92%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B016.pdf">投影矩阵和最小二乘</a></li><li><a href="https://rqtn.github.io/2019/08/12/LA-Lec16/">Lec16 -投影矩阵和最小二乘法</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十五)——子空间投影</title>
    <link href="/2023/09/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%94)%E2%80%94%E2%80%94%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8A%95%E5%BD%B1/"/>
    <url>/2023/09/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%94)%E2%80%94%E2%80%94%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8A%95%E5%BD%B1/</url>
    
    <content type="html"><![CDATA[<p>这一讲从向量的投影入手，从二维延展到高维空间，将投影用矩阵形式表示出来。然后回到上一节的遗留的话题：<spanclass="math inline">\(A^TA\hatx=A^Tb\)</span>常在工程中被用来求解最优近似解，但并没有解释该解为何为最优，这一节会对此做出解释。</p><span id="more"></span><h1 id="子空间投影">子空间投影</h1><h2 id="二维空间投影">二维空间投影</h2><p><img src="2023-09-25-10-59-35.png" /></p><p>如图所示，在二维空间中，向量<spanclass="math inline">\(p\)</span>就是<spanclass="math inline">\(b\)</span>在<spanclass="math inline">\(a\)</span>上的投影，即<spanclass="math inline">\(p=xa\)</span>，显然他们的差值是<spanclass="math inline">\(b-p=e\)</span>，<spanclass="math inline">\(e\)</span>与<spanclass="math inline">\(a\)</span>垂直： <span class="math display">\[a^Te=a^T(b-p)=a^T(b-ax)=0\]</span></p><p>代入<span class="math inline">\(p=xa\)</span>，得到<spanclass="math inline">\(p=a\frac{a^Tb}{a^Ta}\)</span>。</p><p>可以看到<spanclass="math inline">\(p\)</span>的形式中，分母是一个值，而分子中包含了<spanclass="math inline">\(b\)</span>，这也就表明投影得到的<spanclass="math inline">\(p\)</span>向量是通过前面的系数矩阵作用到<spanclass="math inline">\(b\)</span>上完成的，形式上写作：<spanclass="math inline">\(p=Pb\)</span>，其中这个系数矩阵<spanclass="math inline">\(P\)</span>我们称之为投影矩阵，即<spanclass="math inline">\(P=a\frac{a^T}{a^Tb}\)</span>。</p><p>这个<span class="math inline">\(P\)</span>矩阵有两个有取的性质：</p><ol type="1"><li>由前面课程所学的知识，我们知道<spanclass="math inline">\(P\)</span>是个对称阵，因此有<spanclass="math inline">\(P^T=P\)</span>。</li><li><span class="math inline">\(P^2=P\)</span>。<ol type="1"><li>由<spanclass="math inline">\(P^2=\frac{a(a^Ta)a^T}{(a^Ta)^2}\)</span>，而<spanclass="math inline">\(a^Ta\)</span>是内积，化简得到<spanclass="math inline">\(P\)</span>。</li><li>这一点很容易看出来，<spanclass="math inline">\(P^2\)</span>相当于对<spanclass="math inline">\(b\)</span>在<spanclass="math inline">\(a\)</span>上投影得到的<spanclass="math inline">\(p\)</span>继续再做一次投影，显然<spanclass="math inline">\(p\)</span>在<spanclass="math inline">\(a\)</span>上的投影是它本身。</li></ol></li></ol><h3 id="投影的意义">投影的意义</h3><p>为什么要做投影呢？回到上一节的<spanclass="math inline">\(Ax=b\)</span>问题，我们知道<spanclass="math inline">\(Ax\)</span>总是在<spanclass="math inline">\(A\)</span>的列空间中，但是<spanclass="math inline">\(b\)</span>不一定。那么退而求其次，什么样的<spanclass="math inline">\(x\)</span>可以最逼近<spanclass="math inline">\(b\)</span>呢？换言之，就是让<spanclass="math inline">\(b\)</span>的变化能够最小，而变化最小恰恰是通过投影来实现（所以<spanclass="math inline">\(e\)</span>被视为误差），投影得到的<spanclass="math inline">\(p\)</span>就是<spanclass="math inline">\(A\)</span>列空间中最接近<spanclass="math inline">\(b\)</span>的那一个。</p><h2 id="三维空间投影">三维空间投影</h2><p><img src="2023-09-25-11-42-06.png" /></p><p>延展到三维也并无二致，如图所示，<spanclass="math inline">\(a_1\)</span>和<spanclass="math inline">\(a_2\)</span>是构成平面的一组基，<spanclass="math inline">\(p\)</span>是<spanclass="math inline">\(b\)</span>在平面上的投影，<spanclass="math inline">\(p\)</span>可以表示为分别投影在这组基的每个向量上的投影和：<spanclass="math inline">\(p=\hat x_1a_1+\hat x_2a_2\)</span>，矩阵形式写作：<span class="math display">\[p=A\hat x, 其中A=\begin{bmatrix}a1&amp;a2\end{bmatrix}, \hatx=\begin{bmatrix}\hat x_1\\ \hat x_2\end{bmatrix}\]</span></p><p>此平面即为矩阵<spanclass="math inline">\(A\)</span>的列空间，由于<spanclass="math inline">\(b\)</span>不在平面上，因此<spanclass="math inline">\(Ax=b\)</span>无解，<spanclass="math inline">\(A\hat x=p\)</span>中的<spanclass="math inline">\(\hat x\)</span>就是最优解。</p><p>同样地，有<span class="math inline">\(e=b-p=b-A\hatx\)</span>与平面垂直(<spanclass="math inline">\(A\)</span>的列空间)，因此<spanclass="math inline">\(A^Te=0\)</span>： <span class="math display">\[\begin{bmatrix}a_1^T\\ a_2^T\end{bmatrix}(b-A\hat x)=\begin{bmatrix}0\\0\end{bmatrix}\]</span></p><blockquote><p>这与二维投影的<spanclass="math inline">\(a^T(b-xa)=0\)</span>并不差别，只不过二维空间的<spanclass="math inline">\(A^T\)</span>只有一列罢了。</p></blockquote><blockquote><p>由<spanclass="math inline">\(A^Te=0\)</span>可知，由于列空间与左零空间正交，e一定在<spanclass="math inline">\(A\)</span>的左零空间。</p></blockquote><p><strong>化简上式，可得：<span class="math inline">\(A^TA\hatx=A^Tb\)</span>，而这恰恰就是上一节我们谈及为了解决<spanclass="math inline">\(Ax=b\)</span>无解时的工程惯用法式子。至此，我们总算理解了同时左乘<spanclass="math inline">\(A^T\)</span>的物理意义。</strong></p><p>继续求解，当且仅当<spanclass="math inline">\(A^TA\)</span>可逆时，我们可以求出最优解：<spanclass="math inline">\(\hatx=(A^TA)^{-1}A^Tb\)</span>。而在上一讲的最后，我们推理出如果<spanclass="math inline">\(A\)</span>的各列线性无关，那么<spanclass="math inline">\(A^TA\)</span>可逆。</p><blockquote><p>相比于求解<span class="math inline">\(Ax=b\)</span>，只有当<spanclass="math inline">\(A\)</span>可逆时，<spanclass="math inline">\(x\)</span>才有解。而在对<spanclass="math inline">\(b\)</span>进行了在<spanclass="math inline">\(A\)</span>列空间的投影后，求解<spanclass="math inline">\(\hatx\)</span>的条件得到了适当的放宽，此时只要求<spanclass="math inline">\(A\)</span>的列向量线性无关即可。在实际工程项目中，我们测量得到的<spanclass="math inline">\(m\times n\)</span>矩阵常常<spanclass="math inline">\(m\)</span>很大，<spanclass="math inline">\(n\)</span>很小，因此容易保证。</p></blockquote><p>因此，投影向量<span class="math inline">\(p=A\hatx=A(A^TA)^{-1}A^Tb\)</span>，投影矩阵为<spanclass="math inline">\(A(A^TA)^{-1}A^T\)</span>（二维空间得<spanclass="math inline">\(\frac{aa^T}{a^Ta}\)</span>）。</p><blockquote><p>若<span class="math inline">\(A\)</span>本身可逆，投影矩阵<spanclass="math inline">\(A(A^TA)^{-1}A^T\)</span>就可进一步化简，此时<spanclass="math inline">\((A^TA)^{-1}\)</span>就可以拆成<spanclass="math inline">\(A^{-1}(A^T)^{-1}\)</span>，此时<spanclass="math inline">\(A(A^TA)^{-1}A^T=AA^{-1}(A^T)^{-1}A^T=I\)</span>，即得到单位阵。这一结论显然，因为<spanclass="math inline">\(A\)</span>若本身可逆，那么<spanclass="math inline">\(Ax=b\)</span>就有解，<spanclass="math inline">\(b\)</span>本身就在<spanclass="math inline">\(A\)</span>的列空间，投影<spanclass="math inline">\(b\)</span>到<spanclass="math inline">\(A\)</span>的列空间当然得到其本身，此时投影矩阵可不就是单位阵。</p></blockquote><h2 id="最小二乘法">最小二乘法</h2><p>前面也已经提到，投影的方式让我们得到了最优近似解，而<spanclass="math inline">\(e\)</span>向量就是其中的误差。实际上这一思想与我们做线性回归时，使用最小二乘法拟合直线的理论基础不谋而合。</p><p><img src="2023-09-25-14-56-45.png" /></p><p>对上述直线，我们想通过三个点来拟合一条直线<spanclass="math inline">\(y=Cx+D\)</span>，我们将已知的三个点<spanclass="math inline">\((1,1),(2,2),(3,2)\)</span>带入方程： <spanclass="math display">\[\begin{cases}C+D=1\\ 2C+D=2\\ 3C+D=2\end{cases}\]</span></p><p>写作矩阵形式为： <span class="math display">\[Ax=\begin{bmatrix}1&amp;1\\ 2&amp;1\\3&amp;1\end{bmatrix}\begin{bmatrix}C\\ D\end{bmatrix}=\begin{bmatrix}1\\ 2\\ 2\end{bmatrix}\]</span></p><p>显然<spanclass="math inline">\(x\)</span>无解，三点根本不共线，于是利用投影找最优近似解。由于<spanclass="math inline">\(A\)</span>中各列线性无关，所以<spanclass="math inline">\(A^TA\hat x=b\)</span>有解，展开写作： <spanclass="math display">\[\begin{bmatrix}1&amp;2&amp;3\\1&amp;1&amp;1\end{bmatrix}\begin{bmatrix}1&amp;1\\ 2&amp;1\\3&amp;1\end{bmatrix}\begin{bmatrix}C\\ D\end{bmatrix}=\begin{bmatrix}1&amp;2&amp;3\\1&amp;1&amp;1\end{bmatrix}\begin{bmatrix}1\\ 2\\ 2\end{bmatrix}\]</span></p><p>矩阵乘法运算得： <span class="math display">\[\begin{bmatrix}14&amp;6\\ 6&amp;3\end{bmatrix}\begin{bmatrix}C\\ D\end{bmatrix}=\begin{bmatrix}11\\ 5\end{bmatrix}\]</span></p><p>亦即： <span class="math display">\[\begin{cases}14C+6D=11\\ 6C+3D=5\end{cases}\]</span></p><p>求得：<span class="math inline">\(C=\frac{1}{2},D=\frac{2}{3}\)</span>。</p><h3 id="微积分解法与投影矩阵的联系">微积分解法与投影矩阵的联系</h3><p>如果用传统微积分来解最小二乘，就需要对误差方程：<spanclass="math inline">\(E=(C+D-1)^2+(2C+D-2)^2+(3C+D-2)^2\)</span>求最小值，方程有两个未知数，分别对<spanclass="math inline">\(C\)</span>和<spanclass="math inline">\(D\)</span>计算偏导的零值： <spanclass="math display">\[\begin{cases}2C+2(D-1)+8C+4(D-2)+18C+6(D-2)=0\\2D+2(C-1)+2D+2(2C-2)+2D+2(3C-2)=0\end{cases}\]</span></p><p>化简得到： <span class="math display">\[\begin{cases}14C+6D=11\\ 6C+3D=5\end{cases}\]</span></p><p>可以看出这里的两个式子其实和投影矩阵法得到的两个方程一模一样。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570093730&amp;p=15&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B15%5D%20%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8A%95%E5%BD%B1/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B015.pdf">子空间投影</a></li><li><a href="https://rqtn.github.io/2019/08/12/LA-Lec15/">Lec15 -子空间投影</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十四)——正交向量与子空间</title>
    <link href="/2023/09/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%9B%9B)%E2%80%94%E2%80%94%E6%AD%A3%E4%BA%A4%E5%90%91%E9%87%8F%E4%B8%8E%E5%AD%90%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/09/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%9B%9B)%E2%80%94%E2%80%94%E6%AD%A3%E4%BA%A4%E5%90%91%E9%87%8F%E4%B8%8E%E5%AD%90%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>这一讲从正交的角度来探讨四个子空间具有的性质。</p><span id="more"></span><h1 id="正交向量与子空间">正交向量与子空间</h1><p>一图胜千言：</p><p><img src="2023-09-21-14-59-27.png" /></p><p>本节的所有内容都在阐释上面这张图。</p><h2 id="正交">正交</h2><p>何为正交？从空间角度来看，正交就是垂直。无论是两个向量之间的正交，还是空间的正交，它们在线性代数中都意味着：垂直。</p><h3 id="向量正交">向量正交</h3><p><img src="2023-09-21-15-01-50.png" /></p><p>如图，<span class="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>两个向量相互垂直，根据中学知识，我们知道两个向量垂直则意味着这两个向量的内积为0，即：<spanclass="math inline">\(x^Ty=0\)</span>。</p><p>这一结论可以用勾股定理来证明： <span class="math display">\[\begin{aligned}|x|^2+|y|^2=|x+y|^2 \\x^Tx+y^Ty = (x+y)^T(x+y) \\0 = x^Ty+y^Tx \\易知x^Ty = y^Tx，故：2x^Ty=0 \\得到：x^Ty=0\end{aligned}\]</span></p><p>进一步，如果两个向量中其中某一个是零向量，那这两个向量一定正交。</p><h3 id="空间正交">空间正交</h3><p>所谓空间的正交，就是：一个空间中的任意一个向量，都与另一个空间中的任意一个向量正交。</p><p>直觉上，我们可能会误以为三维直角坐标系中如<spanclass="math inline">\(xy\)</span>平面<spanclass="math inline">\(xz\)</span>平面正交，但实际上它们并不正交。这一点很容易证伪，我们选择两个平面交线<spanclass="math inline">\(x\)</span>轴上的向量，任取两个，显然它们并不垂直。</p><blockquote><p>反过来，这一事实也意味着：如果两个平面在某个非零向量处相交，那么它们一定不正交。</p></blockquote><p>那么怎么样的两个空间可能会正交呢？我们先从<spanclass="math inline">\(R^2\)</span>的子空间来分析，一个平面上的子空间有：</p><ul><li>整个平面<span class="math inline">\(P\)</span></li><li>平面<span class="math inline">\(P\)</span>上任意过原点的直线<spanclass="math inline">\(L\)</span></li><li>原点零向量</li></ul><p><span class="math inline">\(P\)</span>与<spanclass="math inline">\(L\)</span>永远不可能正交；当<spanclass="math inline">\(L1\)</span>与<spanclass="math inline">\(L2\)</span>在原点处垂直时，<spanclass="math inline">\(L1\)</span>和<spanclass="math inline">\(L2\)</span>正交；<spanclass="math inline">\(L\)</span>与<spanclass="math inline">\(0\)</span>永远正交。</p><p>高维空间也可以由此继续做推理。</p><h3 id="矩阵子空间的正交">矩阵子空间的正交</h3><p>回归到矩阵，为什么我们可以笃定零空间和行空间是正交的呢？实际上我们只需要从行视角和零空间视角分别来看<spanclass="math inline">\(Ax=0\)</span>即可窥得端倪：</p><p><span class="math display">\[Ax=\begin{bmatrix}row_1 of A\\ row_2 of A\\ row_3 of A\\ ...\\ row_m ofA\end{bmatrix}\begin{bmatrix}x_1\\ x_2\\ x_3\\ ...\\x_n\end{bmatrix}=\begin{bmatrix}row_1 of A \cdot x\\ row_2 of A \cdot x\\row_3 of A \cdot x\\ ... \\row_n of A \cdot x\end{bmatrix}=\begin{bmatrix}0\\ 0\\ 0\\ ...\\ 0\end{bmatrix}\]</span></p><p>从行视角看，<spanclass="math inline">\(A\)</span>中每个行向量与向量<spanclass="math inline">\(x\)</span>的内积都是<spanclass="math inline">\(0\)</span>，而从零空间视角看，<spanclass="math inline">\(x\)</span>可以是零空间任意一个向量，因此，这就意味着<spanclass="math inline">\(A\)</span>中的每个行向量都与零空间的任意向量垂直。此外，行空间的所有向量都是由<spanclass="math inline">\(A\)</span>中行向量线性组合得到，因此无论怎么组合，都无非表示成诸如<spanclass="math inline">\(c\cdot row_1 + d\cdot row_2 + ... + z\cdotrow_m\)</span>，结果依然是<span class="math inline">\(0\)</span>。</p><p><strong>由此证得矩阵的行空间与零空间正交。同理，我们对矩阵进行转置，可以得到列空间与左零空间正交。</strong></p><p>此外，行空间和零空间的关系，更像是把一个空间一分为二所得到的两个子空间：</p><ul><li>行空间与零空间的维数之和是<span class="math inline">\(n\)</span>。<ul><li>行空间维数是<spanclass="math inline">\(r\)</span>，零空间维数是<spanclass="math inline">\(n-r\)</span>。</li><li>它们都是<span class="math inline">\(R^n\)</span>的子空间。</li></ul></li><li>列空间与左零空间的维数之和是<span class="math inline">\(m\)</span>。<ul><li>列空间维数是<spanclass="math inline">\(r\)</span>，左零空间维数是<spanclass="math inline">\(m-r\)</span>。</li><li>它们都是<span class="math inline">\(R^m\)</span>的子空间。</li></ul></li></ul><p>进一步，我们把行空间和零空间称作为<spanclass="math inline">\(R^n\)</span>中的正交补，列空间和左零空间称为<spanclass="math inline">\(R^m\)</span>中的正交补。</p><blockquote><p>所谓正交补，就是指对于一个空间<spanclass="math inline">\(S\)</span>，另一个空间<spanclass="math inline">\(T\)</span>囊括了所有垂直于<spanclass="math inline">\(S\)</span>的向量而不是局部，这里的一分为二描述的是一种彻底程度。</p></blockquote><h2 id="无解方程的最优解">无解方程的最优解</h2><p>现实世界中，矩阵的数据源于测量，测量就难免有误差甚至错误，从而导致<spanclass="math inline">\(Ax=b\)</span>无解。</p><p>什么样的<spanclass="math inline">\(Ax=b\)</span>有解呢？我们知道<spanclass="math inline">\(A\)</span>得是可逆的，当<spanclass="math inline">\(m\)</span>很大，<spanclass="math inline">\(n\)</span>很小时，我们可以通过不断的移除某些行，丢弃这些坏数据，让方程有解。这听上去是个合理的方法，但实际上却难以执行。为什么呢？因为我们根本无法判断究竟哪些行是脏数据。</p><p>对于这一困难，工程上常常会进行妥协：我们可以去求近似的最优解，类似于一种拟合。</p><p>怎么求近似解呢？在已知<spanclass="math inline">\(Ax=b\)</span>无解的前提下，我们可以尝试在方程两侧同时左乘<spanclass="math inline">\(A^T\)</span>，无解方程就变成<spanclass="math inline">\(A^TA\hat x=A^Tb\)</span>。</p><blockquote><p>这里的<span class="math inline">\(\hat x\)</span>不是解<spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(x\)</span>已经是无解的了，这里只是尝试找到一个近似解。</p></blockquote><p>通过前面课程的学习，我们知道<spanclass="math inline">\(A^TA\)</span>矩阵是一种对称方阵，此时如果<spanclass="math inline">\(A^TA\)</span>可逆，那么解<spanclass="math inline">\(\hat x\)</span>就容易求得。</p><p>然而<spanclass="math inline">\(A^TA\)</span>也不见得就可逆，怎么去判断<spanclass="math inline">\(A^TA\)</span>是否可逆呢？先说结论：当<spanclass="math inline">\(A\)</span>中各列线性相关时，<spanclass="math inline">\(A^TA\)</span>不可逆。</p><p>为了证明这一点，需要先得到两个性质：</p><ol type="1"><li><spanclass="math inline">\(N(A^TA)=N(A)\)</span>：二者具有相同的零空间。<ol type="1"><li>对于<span class="math inline">\(A^TAx=0\)</span>有：<spanclass="math inline">\(x^TA^TAx=(Ax)^T(Ax)=0\)</span>，因此<spanclass="math inline">\(Ax=0\)</span></li></ol></li><li>rank(A^TA)=rank(A)：二者具有相同的秩。<ol type="1"><li>由性质1可知二者零空间维数相同，且二者具有相同的列数，因此秩相等。</li></ol></li></ol><p>而<span class="math inline">\(A^TA\)</span>若可逆，则意味着<spanclass="math inline">\(N(A^TA)\)</span>只有零向量，既然<spanclass="math inline">\(N(A)\)</span>与<spanclass="math inline">\(N(A^TA)\)</span>相同，也就意味着<spanclass="math inline">\(N(A)\)</span>中也只能有零向量，此时，<spanclass="math inline">\(A\)</span>中各列线性无关。证毕。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570087382&amp;p=14&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B14%5D%20%E6%AD%A3%E4%BA%A4%E5%90%91%E9%87%8F%E4%B8%8E%E5%AD%90%E7%A9%BA%E9%97%B4/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B014.pdf">正交向量与子空间</a></li><li><a href="https://rqtn.github.io/2019/08/12/LA-Lec14/">Lec14 -正交向量与子空间</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格物致知(2)——语言千百，殊途同归</title>
    <link href="/2023/06/13/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(2)%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%8D%83%E7%99%BE%EF%BC%8C%E6%AE%8A%E9%80%94%E5%90%8C%E5%BD%92/"/>
    <url>/2023/06/13/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(2)%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%8D%83%E7%99%BE%EF%BC%8C%E6%AE%8A%E9%80%94%E5%90%8C%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<p>开局一个段子，经典咏流传：你什么语言？我什么语言？我用Go写需求、我就算写出10个bug也能按期交付，你写C++、随便一个ABI问题都能卡你一整天。在座的这些老司机，哪个不是写Go、写Java、写Python的？你写C++，难怪你加班。什么C艹神教教父分父？真不熟！别笑我厌旧，你来你也臭，这就是现代编程语言带给我的自信(doge)~</p><p>我笑不出来，因为我写C++。</p><span id="more"></span><h1 id="语言千百殊途同归">语言千百，殊途同归</h1><p>计算机最终执行的是机器码，机器码由二进制序列组成，它们的花式排列组合实现各种算术与逻辑运算、数据存储与寻址跳转操作，复杂的操作借由简单的指令组合而最终得以实现。每一种特定ISA(InstructionSet Architecture,指令集架构)都包含了基本数据类型、指令集、寄存器、寻址模式、存储体系、中断与异常处理以及外部I/O，它们是计算机体系结构中与程序设计息息相关的部分。不同的处理器家族有着不同的指令集架构。计算机历史长河（虽然也不怎么长）诞生过相当多的指令集架构，如Mips、PowerPC等（常见于一些嵌入式系统，比如我早年做路由器的时候就用过Mips架构），然时过境迁，大浪淘沙，如今主流的指令集架构主要有三大家族：x86-64、ARM和RISC-V。</p><p><img src="2023-06-19-19-57-33.png" /></p><p>x86-64可谓耳熟能详了，Intel发展至今大成之作，从奔腾到酷睿i9，在PC市场上奠定了绝对的榜首位置。而Intel和AMD的故事也历来在业界津津乐道，AMD山寨货的喧宾夺主逼得Intel不得不妥协直到最后哥俩好到穿一条裤子（生意场上只有永远的利益），Intel系列架构的指令集在设计上被称作CISC，意为复杂指令集，专项专利的设计在很长一段时间几乎垄断了市场CPU，可谓赚到盆满钵满。而ARM架构诞生也相当早（现在都v9了），和Intel系列架构不同，它采用的是一种RISC指令集，意为精简指令集（ARM正是AdvancedRISCMachine的缩写）。ARM广泛用于嵌入式系统，主要设计目标就在于：低成本、高效能、低功耗。ARM和Intel在ISA扮演的角色身份恰如Linux和Windows，ARM的架构设计公司授权给其他公司去使用、实现具体的ARM架构（代表厂商比如Apple,Google,IBM,华为），开发自主的SoC(system-on-module)。我们平常用的手机、平板、路由器，ARM架构有着相当高的占比。至于RISC-V，见名知意，它也是一种RISC指令集，该架构起步相对较晚，但发展很快，基于RISC-V指令集架构可以设计服务器CPU，家用电器CPU，工控CPU和用在比指头小的传感器中的CPU（未来之星，智能穿戴，泰裤辣）。</p><p>ISA制定的是软硬件之间的一纸合同，其具体的实现方式我们一般称作“微架构(Mircoarchitecture)”，标准的定义向来简练，但落地往往一地鸡毛，这其中涉及的流水线级数、缓存设计无一不是门复杂的学问。有了具体的微架构以后，我们的机器码才能被送到CPU执行，至此，我们步入编程的世界。正如《系统漫游》一讲中所述：由于机器码过于抽象，不适合直接作为一种语言来直接编写，故开发者先驱在机器码的基础上进行了翻译，给出汇编助记符并最终演化成汇编语言。尽管汇编语言已经可以完成复杂程序的编写，但相比自然语言来说依然高度抽象、对开发者极不友好，于是，在经过了漫长发展史的今天，越来越多的编程语言应运而生，它们的亲和性越来越高、上手门槛越来越低，而这些语言，我们通常把它们归类为“高级编程语言”，时至今日，“编程语言”这一概念在大部分上下文中都指代高级编程语言。</p><h2 id="编程语言的本质">编程语言的本质</h2><p>刚入门的小伙伴，在对眼花缭乱的编程语言望洋兴叹之时，往往也会有一个大大的疑问：为什么会有这么多的编程语言呢？难道每一种语言都要学会才能掌握编程吗？</p><p>显然不是，想想我们每天都在用的自然语言，对大部分国人来说，掌握的可能只有普通话这门母语（不同地域还可能有各种方言，但他们都算在中文体系），受教育程度高的群体一般还会掌握英语这门国际语，而只有少数人掌握了三门以上的语言（比如日语、韩语、法语、德语）。然而归根结底，掌握自然语言的用途是为了与其他人交流，在中国当然说中国话，但在和外国人交流时，则因母语差异往往需要通过通用的国际语——英语来沟通。</p><p>实际上编程语言也不外如是，只不过它不受限于你出生的地域，你可以凭自己的喜好来选择第一门语言入坑来作为母语，但就像自然语言那样，不同语言的使用者之间存在着沟通壁垒，比如你让C语言使用者去跟Pythoner交流指针的使用艺术，完全是鸡同鸭讲。然而，还是有着一点关键性的差异：编程语言是用来和机器打交道的，你编写的程序就好比你说出去的话，最终是交由计算机来执行，由于计算机只认识自己的指令集，所以每一种语言的背后都有着强大的翻译团队，或提前打好腹稿、或同声传译，把由高级语言编写的程序的意图传达给机器（详见第零讲：《系统漫游》）。因此，和自然语言不同的是，开发者最低限度只需要掌握任意一门语言（好歹得是正经语言）就可以和机器沟通了，但至于这门语言能不能搞事情、能搞多大的动静出来，就取决于其设计之初的定位和生态丰富程度了。</p><p>有个叫<ahref="https://www.tiobe.com/tiobe-index/">TIOBE</a>的项目会定期更新编程语言流行度的排行榜：</p><p><img src="2023-06-21-11-50-09.png" /></p><blockquote><p>不同语言因其天然的特性与设计以及生态环境，在不同领域与场景的契合度不尽相同，语言本身谈不上高低优劣，关键在于机师的操作水平。</p></blockquote><blockquote><p>你说的都对，但我单方面宣布PHP是世界上最牛逼的语言(doge)~</p></blockquote><p>编程语言的本质就是和计算机交流，每一门编程语言都有它自己的审美和设计哲学，通过规范化一套自己的词法、语法、语义来完成“指令驱动数据”的最终目的。编程语言，也叫程序设计语言，按照wikipedia对这一规范化的组成拆分，主要包括以下四点：</p><ul><li>数据和数据结构</li><li>指令与流程控制</li><li>引用机制和重用</li><li>设计哲学</li></ul><h3 id="数据和数据结构">数据和数据结构</h3><h4 id="动态类型与静态类型">动态类型与静态类型</h4><p>程序中专门处理数据的系统被称作型别系统(typesystem)，语言依次可分成两大类：静态类型（如C/C++、Java、Go）和动态类型(如Lisp，Javascript，Python)。二者的根本性差异在于类型被确定的时机，对于静态类型语言来说，其数据类型在编译或者更准确的说是在运行之前就确定的，而动态类型语言则是在运行时(RT)才确定变量的类型。</p><p>比如下面这段C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>) &lt;&lt; std::endl;<br>    <span class="hljs-comment">// std::cout &lt;&lt; add(&quot;3&quot;, &quot;5&quot;) &lt;&lt; std::endl; // 编译不通过，add的参数是int型，不能传const char*</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在编译阶段就已经知道了a和b的类型是int，而对于像Python这种动态类型语言来说则不然：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))     <span class="hljs-comment"># 两者都是int型，输出8</span><br><span class="hljs-built_in">print</span>(add(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>))  <span class="hljs-comment"># 两者都是str型，输出&quot;35&quot;</span><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">3</span>, <span class="hljs-number">4.0</span>))   <span class="hljs-comment"># 传入int和float型，最终返回的是float型，输出7.0</span><br><span class="hljs-comment">#print(add(3,&quot;5&quot;))   # 运行时抛异常，TypeError: unsupported operand type(s) for +: &#x27;int&#x27; and &#x27;str&#x27;</span><br></code></pre></td></tr></table></figure><p>执行到square的时候，才知道传进来的<code>a</code>和<code>b</code>究竟是什么类型。</p><p>通过上面的例子，初学者可能会认为：动态类型好清爽，不需要在定义/声明变量的同时标注类型，不仅书写简单，用起来还灵活，你看，C++的add函数就只支持传<code>int</code>型，但python版本的则尽可能支持所有能做加法的一到两种类型。真的是这样吗？实际上这种认知并不完全正确，这里的能力实际上叫做泛型，动态类型确实让语句更短显得更干练，其RT绑定变量类型的机制也天然支持了这种泛型能力，但静态类型语言在设计上同样也可以后天弥补这种能力，对于C++来说，我们可以改造一下上述代码，通过使用函数模板来支持参数类型的泛化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T1 a, T2 b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl;    <span class="hljs-comment">// 返回的是int型，输出8</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;3&quot;</span>), std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;5&quot;</span>)) &lt;&lt; std::endl;  <span class="hljs-comment">// 返回的是std::string类型，输出&quot;35&quot;</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5.1</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// 返回的是double型，输出8.1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++中的泛型通过模板得以实现，其他像是Java，C#等静态类型语言也有相似的设计，当然也存在一些并不具备泛型能力的语言，此时可能就需要用诸如函数重载、抽象interface做类内wrapper、甚至干脆定义多个版本的<code>addXXX</code>来迂回支持。</p><blockquote><p>动态类型很大程度上提升了代码编写的灵活性，给于开发者极大的脑洞同时也是把双刃剑，灵活性的不合理运用生产了大量的屎山代码，不得不经常面对重构。故而江湖流传着这么句话：动态类型一时爽，代码重构火葬场！</p></blockquote><h4 id="强类型与弱类型">强类型与弱类型</h4><p>与动态类型和静态类型一起时常被提起的，还有一组被叫做强类型(Java,C#,Python,go,Rust...)与弱类型(C,Javascript,Perl,PHP...)语言的区分。强弱类型的核心差异在于：不同类型的变量是否允许隐式转化。不少误人子弟的网文都把强弱类型与动静态类型混为一谈，实际上这两组概念毫不相干。像Go是静态类型语言，同时它也是强类型语言，我们在编写Go程序时，甚至不能将int32隐式转换成int型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-type">int32</span> = <span class="hljs-number">100</span><br>    <span class="hljs-comment">// var b int = a    // 编译错误：cannot use a (variable of type int32) as type int in variable declaration</span><br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-type">int</span>(a)  <span class="hljs-comment">// 强制类型转换可以</span><br>    fmt.Println(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>尽管在32位机器上，int32和int尺寸相同，但对于强类型语言来说，它不支持隐式转换，哪怕你所有的上下文都将线索指向了这两种类型没有任何本质的区别。</p><blockquote><p>强弱类型这个概念直到2004才被一篇微软研究院的集大成论文《TypeSystems》所盖棺定论。在这之前往往和动静态类型混为一谈，比如Ritchie说C语言是“强类型但是弱检查”，Guido强调Python不是弱类型而是运行时类型，这才造就了后世的混淆。Strongly checked language: A language where no forbidden errors canoccur at run time (depending on the definition of forbidden error).Weakly checked language: A language that is statically checked butprovides no clear guarantee of absence of execution errors.这一定义较为抽象，它是基于对untrappederrors的容忍程度来区分强弱，由于大部分untrappederrors是由隐式类型转换而导致，所以后来逐渐演变成：以是否支持隐式转换来界定强弱类型。</p></blockquote><p>Python是动态类型语言，同时主流社区也认为它是强类型语言，为什么没有完全达成共识呢？这主要是因为Python类型转换上的一些外在表现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-built_in">print</span>(a, <span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">id</span>(a)) <span class="hljs-comment"># test &lt;class &#x27;str&#x27;&gt; 93997654303728</span><br>a = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(a, <span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">id</span>(a)) <span class="hljs-comment"># 1 &lt;class &#x27;int&#x27;&gt; 93997648968296</span><br>a += <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(a, <span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">id</span>(a)) <span class="hljs-comment"># 3 &lt;class &#x27;int&#x27;&gt; 93997648968360</span><br>a += <span class="hljs-number">5.0</span><br><span class="hljs-built_in">print</span>(a, <span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">id</span>(a)) <span class="hljs-comment"># 8.0 &lt;class &#x27;float&#x27;&gt; 94765439680288</span><br></code></pre></td></tr></table></figure><p><code>a</code>一开始是个<code>str</code>类型，在执行到<code>a = 1</code>时，表面上看是把<code>int</code>型的<code>1</code>隐式转换给<code>str</code>类型的变量<code>a</code>，但其实这种认知是错误的。Python的类型并不是和变量<code>a</code>绑定，而是和值(准确的说、是右值)绑定，<code>a</code>只是个变量名，它只是绑定到实际变量的标签，表面上看<code>a</code>的赋值操作用到了隐式转化，但实际上程序执行过程中只是更换了它的标签，让<code>a</code>重新绑定到了另一个<code>str</code>类型的变量而已。这段代码其实最隐晦的在于最后一句<code>a += 5.0</code>，看起来是对<code>int</code>和<code>float</code>做了计算，那么按照常理就势必涉及到了类似C/C++这种向上转型的隐式转换，然而python并没有做这样的隐式转换，python的一切基础类型也都是内置的<code>class</code>型（注意<code>type</code>打印的结果，前面是不是都有个<code>class</code>~），<code>class</code>型有自己的内置<code>__add__()</code>方法，不同类型的相加实际上是<code>__add__()</code>来完成的（python万物皆对象，数值类型也不例外）。</p><p>C是比较标准的弱类型语言，它支持的隐式转换相当丰富：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">double</span> b = <span class="hljs-number">4.0</span>;<br>    a = b;              <span class="hljs-comment">// 隐式转换double-&gt;int，产出右值4</span><br>    <span class="hljs-type">double</span> c = a + b;   <span class="hljs-comment">// a是int型，b是double型，按照数值计算的向上转型规则，int会转成double再做计算</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d, b=%lf, c=%lf&quot;</span>, a, b, c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然这里给的都是中规中矩不会搞出问题的模范示例，实际上C代码的bug有相当一部分恰好源于各种不合规的隐式转换（型别溢出、指针步长、越界访问...）。</p><blockquote><p>C++诞生于C，它背负了太多C的历史设计包袱，与ModernC++(11标准之后)的诸多设计显得格格不入但又因为历史债务而无法割舍。C++严格上来讲也是弱类型语言，但在强弱类型这块儿的表现却不伦不类。</p></blockquote><p>而像是Javascript这种就更魔幻了，由于它本身是动态类型，再加上隐式转换的能力，所以你在JS里经常能看到那种anti-human的案例，比如：表达式<code>"1000"+1</code>在JS里最终是<code>string</code>型，而<code>"1000"-1</code>则是<code>number</code>型，怎么样，神奇吧。Javascript这门语言能够带来震撼的case太多了，我甚至有很长一段时间以此为乐(doge)。</p><blockquote><p>Python和Javascript在设计上都过于天马行空，初学者上手容易，但越学越偏执，有那么点邪魔歪道的意思。</p></blockquote><h4 id="数据结构">数据结构</h4><p>另一个重要的组成部分就是数据结构了，很多理工科的专业本科都会开设这么一个课程，相信也是很多非科班出身小伙伴的噩梦。数据结构(DataStructure)是计算机用来存储、组织数据的方式，它利用编程语言所提供的数据类型、引用等其他操作加以实现，联合组成某种存储结构并对访问方法加以封装。不同的数据结构用来解决特定的问题，例如最常用的线性表(LinearList)（数组（Array）（也叫顺序表(Sequence List)）、链表(LinkedList)）用来组织存储同质化的多个数据、栈(Stack)这种LIFO的特性让它可以方便的维护函数调用栈帧、二叉搜索树(BinarySearchTree)可以最高效的支持基于比较操作的元素集合查找能力、又矮又胖的B+树适合在磁盘上按索引存储大量数据等等。</p><p>业内有着这么一句行话口口相传：程序 = 数据结构 +算法。这句话始源于一本古书的名字：</p><p><img src="2023-06-20-10-47-22.png" /></p><p>这本书发行于1976年，在起名这方面的才能可以说即使放在当下亦是不遑多让，这本书传授的是经典数据结构的知识，而书名的影响程度甚至超过了作者的想象（对于OIer倒是完美契合）。我们课上学习的数组、链表、栈、队列、哈希表、树等等可以看做是狭义的数据结构，它们是解决某类问题的最小结构化数据的demo，而我们真正在写程序的时候，往往会将各种数据结构与基本型、自定义类型按需求做组合封装，定义出新的自定义类型，这可以看作是广义的数据结构。</p><blockquote><p>至于Algorithms又是另一个打击面相当大的泛用词了，理工科课上的算法一般指的是传统的用来解决某一类问题的基础算法，比如二分查找、八大比较排序，研究生阶段还会上一门更具有体系的课：算法设计与分析，按照解决问题的思想大体可以拆分为枚举、模拟、递归、递推、贪心等策略，各种算法无非就是这些核心思想的应用（有过OI经验的同学一定深谙此道，刷笔试题简直是虐菜游戏）。而现如今业界火热的算法岗则指的是做MachineLearning, DeepLearning的AI算法岗，算是另一个领域的知识。尽管如此，我们去学习机器学习时，依然会发现那些经典算法的核心思想也还是这些，无非是在组合数学的基础上，施加了统计学的魔法罢了（要么说万物皆数学）。</p></blockquote><p>越是后现代的编程语言，往往本身对常用数据结构的支持越深入骨髓。像是老牌语言比如C，语法特性与标准库相当精简，仅仅天然支持数组。在C语言中，我们可以通过<code>int v[100];</code>来定义一个长度为100的定长<code>int</code>型数组，它可以在内存连续存放100个<code>int</code>型数据。当我们需要各种复杂的数据结构时，往往就需要自己去实现一套或者干脆找成品第三方库（C开发者可以说是最喜欢重复造轮子的群体，这与语言标准生态的贫瘠息息相关）。而像是后续较新的一些语言，比如C++,Java，往往其标准库更加庞大，里面集成了各种常用的数据结构，比如C++的<code>std::vector&lt;&gt;</code>（动态变长数组）,<code>std::map&lt;&gt;</code>（红黑树，平衡二叉搜索树的一种妥协实现体，本质上是2-3树）,<code>std::unordered_map&lt;&gt;</code>（哈希表、也称散列表），<code>std::tuple&lt;&gt;</code>（元组，支持存放任意多种不同类型的数据）。再到后现代的编程语言，比如Python,Go，它们甚至在语言特性本身就支持各种丰富的数据结构（比如Python的list,dict，Go的slice,map都有适配的语法糖）。</p><p>我们在编写程序时，往往会合理搭配使用各种数据结构和基础类型，封装出程序所需要的自定义类型，比如我们在C++中可以封装一个学生的结构，里面放置它的学号、姓名和分数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Subject</span> &#123;Chinese,English,Math&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-type">int64_t</span> id_;<br>  std::string name_;<br>  std::map&lt;Subject, <span class="hljs-type">int32_t</span>&gt; score_;<br>  <span class="hljs-comment">// for extend here ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>当然，这里展示的只是个toy，真实工程里的数据结构往往有着复杂的组合嵌套关系，能否良好的设计各种数据结构非常吃开发者对系统的理解和经验加成。</p></blockquote><h3 id="指令与流程控制">指令与流程控制</h3><p>还记得上面的那本书吗，如果是从宏大叙事上来讲，我心中的算法其实指的就是指令与流程控制。以cooking来比喻programming的话，如果说数据是预加工好的食材，那么流程控制就是炒菜的工序。一旦数据被确定，机器必须被告知如何对这些数据进行处理。尽管编程语言的设计风格千奇百怪，但都可以归纳为以下三种结构：顺序、分支、循环，这三种结构可以表达所有的计算机程序逻辑，</p><p><img src="2023-06-20-11-49-03.png" /></p><h4 id="顺序">顺序</h4><p>这个没什么好说的，你书写的代码一行一行从上到下依次执行，这本身就是一种结构，我们叫它顺序结构。顺序结构尽管简单但却最为常用，只要按照解决问题的顺序写出相应的语句即可。</p><h4 id="分支">分支</h4><p>分支结构也叫选择结构，无非就是根据特定条件，选择执行A or B or...代码块。语句格式为（这里采用伪代码）：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">if（条件1） </span><span class="hljs-template-variable">&#123;分支1&#125;</span><span class="language-xml">；</span><br><span class="language-xml">else if（条件2） </span><span class="hljs-template-variable">&#123;分支2&#125;</span><span class="language-xml"></span><br><span class="language-xml">else if（条件3） </span><span class="hljs-template-variable">&#123;分支3&#125;</span><span class="language-xml"></span><br><span class="language-xml">...</span><br><span class="language-xml">else if（条件n） </span><span class="hljs-template-variable">&#123;分支n&#125;</span><span class="language-xml"></span><br><span class="language-xml">else </span><span class="hljs-template-variable">&#123;分支n+1&#125;</span><br></code></pre></td></tr></table></figure><p>最简单的分支结构是单分支，即只在满足条件时执行分支语句，简化为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span>（条件<span class="hljs-number">1</span>）&#123;分支<span class="hljs-number">1</span>&#125;；<br></code></pre></td></tr></table></figure><p>分支不仅支持多分支，还可以做层级嵌套，形如：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">if</span> (条件<span class="hljs-number">1</span>) &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (条件<span class="hljs-number">1</span>A) &#123;分支<span class="hljs-number">1</span>A&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(条件<span class="hljs-number">1</span>B)</span> </span>&#123;分支<span class="hljs-number">1</span>B&#125;<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(条件<span class="hljs-number">1</span>N)</span> </span>&#123;分支<span class="hljs-number">1</span>N&#125;<br>    <span class="hljs-keyword">else</span> &#123;分支<span class="hljs-number">1</span>N+<span class="hljs-number">1</span>&#125;<br>&#125; <br><span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(条件<span class="hljs-number">2</span>)</span> </span>&#123;分支<span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>（条件n） &#123;分支n&#125;<br><span class="hljs-keyword">else</span> &#123;分支n+<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>此处允许套娃，套、都给我尽情的套！</p><p>大部分语言对分支结构的支持，都有着最基础的if-else语句，比如让我们来写一个判断某个用户输入的整数是奇数还是偶数的例子，在C++中，我们可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> number;<br>    cin &gt;&gt; number;<br><br>    <span class="hljs-keyword">if</span> (number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;偶数&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;奇数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到C++的if-else语句和伪代码相当相似，其他的一些语言也大同小异，比如同样的功能，我们在Go可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> number <span class="hljs-type">int</span><br>fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;number)<br>    <br>    <span class="hljs-keyword">if</span> number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;偶数&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;奇数&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而在以语法简练著称的Python中则写作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">number = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><br><span class="hljs-keyword">if</span> number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;偶数&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;奇数&quot;</span>)<br></code></pre></td></tr></table></figure><p>除了if-else语句外，一些语言还提供了switch语句，switch语句形如：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">switch</span> (表达式) &#123;<br>    <span class="hljs-keyword">case</span> (值<span class="hljs-number">1</span>): &#123;代码块&#125;<br>    <span class="hljs-keyword">case</span> (值<span class="hljs-number">2</span>): &#123;代码块&#125;<br>    ...<br>    <span class="hljs-keyword">default</span>: &#123;默认代码块&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>switch是对表达式的值进行枚举，按照匹配情况去执行其中某一个具体的case的代码块，对于全部不匹配的情况，会走最后一个兜底的default逻辑。switch适合那种枚举值范围较小、且case较多的情况，switch相比if-else在翻译成底层汇编指令时是有所差别的，if-else直接应对的就是指令集中的条件跳转指令，比如Intelx86汇编的<code>je</code>,<code>jne</code>,<code>ja</code>,<code>jb</code>等等，而switch则可以根据具体情况在翻译阶段优化成”offset索引+跳转表“的底层指令，if-else的多重分支的判断次数和分支数成正比，但switch则与case数量无关。</p><p>比如我们在C++中写这样一个例子：用户输入一年中第1天是星期几（0代表星期日，1~6代表星期一到星期六）以及一年中的第N天，我们输出第N天是星期几。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> first, n;<br>    cin &gt;&gt; first &gt;&gt; n;<br><br>    <span class="hljs-keyword">switch</span> (n%<span class="hljs-number">7</span>+first<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期日&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期一&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期二&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期三&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期四&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期五&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;星期六&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:    <span class="hljs-comment">// never through here</span><br>            <span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这里<code>default</code>分支永远不会命中，但对每个switch都书写<code>default</code>是个编程的好习惯。另外在C++里每个<code>case</code>需要一个<code>break</code>语句来跳出，如果不写<code>break</code>的话则会产生穿透(FallThrough)到下一个case继续执行的效果。C++的<code>switch</code>只能对有限的几种类型做枚举，一些其他语言比如Go则更加强大一些，Go不仅支持更丰富的类型值枚举，还可以在一个case里匹配复数个值，上面的代码用Go来写一版：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>        first <span class="hljs-type">int</span><br>        n <span class="hljs-type">int</span><br>    )<br>    fmt.Scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;first, &amp;n)<br><br>    <span class="hljs-keyword">switch</span> n%<span class="hljs-number">7</span>+first<span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            fmt.Printf(<span class="hljs-string">&quot;星期日\n&quot;</span>);dd<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>:<br>            fmt.Printf(<span class="hljs-string">&quot;星期%d\n&quot;</span>, n%<span class="hljs-number">7</span>+first<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">// never through here</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这段代码只是为了展示switch的能力，实际上单以这个需求而论有更优雅的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>        first <span class="hljs-type">int</span><br>        n <span class="hljs-type">int</span><br>    )<br>    fmt.Scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;first, &amp;n)<br><br>    desc := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;日&quot;</span>, <span class="hljs-string">&quot;一&quot;</span>, <span class="hljs-string">&quot;二&quot;</span>, <span class="hljs-string">&quot;三&quot;</span>, <span class="hljs-string">&quot;四&quot;</span>, <span class="hljs-string">&quot;五&quot;</span>, <span class="hljs-string">&quot;六&quot;</span>&#125;<br>    fmt.Printf(<span class="hljs-string">&quot;星期%s\n&quot;</span>, desc[n%<span class="hljs-number">7</span>+first<span class="hljs-number">-1</span>])<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可别小看这段代码，实际上这就是江湖上赫赫有名的表驱动设计的本质。</p></blockquote><p>一些语言在设计上没有switch语句，比如Python，一方面是switch的设计从美学上来讲与Python倡导的灵活性背道而驰，另一个重要的方面在于底层实现的优化不好做（类似C对switch的offset+跳转表的优化）。当然了，我们其实也可以用其他语法去模拟switch语句，比如<ahref="https://www.freecodecamp.org/news/python-switch-statement-switch-case-example/">PythonSwitch Statement – Switch Case Example</a>的举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">switch</span>(<span class="hljs-params">lang</span>):<br>    <span class="hljs-keyword">if</span> lang == <span class="hljs-string">&quot;JavaScript&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;You can become a web developer.&quot;</span><br>    <span class="hljs-keyword">elif</span> lang == <span class="hljs-string">&quot;PHP&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;You can become a backend developer.&quot;</span><br>    <span class="hljs-keyword">elif</span> lang == <span class="hljs-string">&quot;Python&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;You can become a Data Scientist&quot;</span><br>    <span class="hljs-keyword">elif</span> lang == <span class="hljs-string">&quot;Solidity&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;You can become a Blockchain developer.&quot;</span><br>    <span class="hljs-keyword">elif</span> lang == <span class="hljs-string">&quot;Java&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;You can become a mobile app developer&quot;</span><br><br><span class="hljs-built_in">print</span>(switch(<span class="hljs-string">&quot;JavaScript&quot;</span>))   <br><span class="hljs-built_in">print</span>(switch(<span class="hljs-string">&quot;PHP&quot;</span>))   <br><span class="hljs-built_in">print</span>(switch(<span class="hljs-string">&quot;Java&quot;</span>))  <br></code></pre></td></tr></table></figure><blockquote><p>Python3.10引入了新的match-case语句，与switch类似，但更像是Rust这种语言所支持的一种match表达式。</p></blockquote><h4 id="循环">循环</h4><p>循环结构由循环变量、循环体和终止条件构成，可以视作条件判断与回跳语句的组合。根据条件判断执行的位置，循环结构可以分成两类：当型循环和直到型循环。</p><ul><li>当型循环：先判断所给条件p是否成立，若p成立，则执行A（步骤）；再判断条件p是否成立；若p成立，则又执行A，若此反复，直到某一次条件p不成立时为止。</li><li>直到型循环：先执行A，再判断所给条件p是否成立，若p不成立，则再执行A，如此反复，直到p成立，该循环过程结束。</li></ul><p><img src="2023-06-21-10-14-00.png" /></p><p>当型循环的语句格式为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">for</span> (条件) <br>    &#123;执行体&#125;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>直到型则形如：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">repeat</span><br>    &#123;执行体&#125;<br><span class="hljs-keyword">until</span> (条件)<br></code></pre></td></tr></table></figure><p>大部分编程语言在循环语句的设计上大同小异，最常见的便是for和while语句，比如C++中最常见的for循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// init-expression: 在 for 语句的任何其他元素之前，init-expression 仅执行一次。 控制权然后传递给 cond-expression。</span><br><span class="hljs-comment">// cond-expression: 在执行 statement 的每次迭代之前，包括第一次迭代。 statement 只在 cond-expression 的计算结果为 true（非零）时执行。</span><br><span class="hljs-comment">// loop-expression: 在 statement 的每次迭代结束时。 执行 loop-expression 后，将计算 cond-expression。</span><br><span class="hljs-keyword">for</span> ( init-expression ; cond-expression ; loop-expression ) &#123;<br>    statement<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>for中的条件由三段式构成，每一段都可以省略，其中init-expression通常用来初始化循环索引，cond-expression通常用于测试循环终止的条件，loop-expression则通常用来控制循环变量的变化。比如最简单的示例，我们来计算1~10的数字之和，可以通过for语句实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">10</span>; ++i) &#123;<br>    sum += i;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一种常见的循环语句是while语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// expression: 每次执行循环体前进行判断，条件满足则执行循环体，否则终止循环</span><br><span class="hljs-keyword">while</span> ( expression ) &#123;<br>    statement<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>while相比for语句更简洁，它的条件判断只有一个表达式，比如上面的代码也可以用while来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>( i&lt;=<span class="hljs-number">10</span> ) &#123;<br>    sum += i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++的直到型循环则是使用do-while语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">do</span> &#123;<br>   statement<br>   ...<br>&#125; <span class="hljs-keyword">while</span> ( expression );<br></code></pre></td></tr></table></figure><p>终止条件的判定下一到了执行体执行过后判定，这对于某些场景来说采用这种实现更加优雅。</p><p>Java对循环的支持也有for,while,do-while这三种语句，它们甚至在语法上和C++都如出一辙，上面的C++代码在Java里甚至可以完全照抄（可以说在这方面两种语言有着同样的审美）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// for version </span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ++i) &#123;<br>    sum += i;<br>&#125;<br><br><span class="hljs-comment">// while version</span><br><span class="hljs-type">int</span> i=<span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;=<span class="hljs-number">10</span>) &#123;<br>    sum += i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>而像是Go语言，它在设计上只有for语句而没有while或是do-while，事实上for的能力是足够的，且Go的for有三种结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 和C++,Java的for一致</span><br><span class="hljs-keyword">for</span> init; condition; post &#123; &#125;<br><br><span class="hljs-comment">// 类似C++,Java的while</span><br><span class="hljs-keyword">for</span> condition &#123; &#125;<br><br><span class="hljs-comment">// infinite loop，只能靠内部的break语句终止，类似C++,Java的for(;;)&#123;&#125;</span><br><span class="hljs-keyword">for</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>再像是Python，它虽然有for也有while，但它的for循环实际上是另一种迭代器的形态（此for非彼for，我们稍后介绍），while则如出一辙：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> 判断条件(condition)：<br>    执行语句(statements)<br>    ...<br></code></pre></td></tr></table></figure><p>上面所举例的各种语言中的for,while语句，其本质上判断的条件都是一个表达式，实际上除了这种基于条件判断做循环的设计以外，还有另一种更常用的需求：遍历集合，对每个集合元素进行迭代。主流的现代编程语言大都支持这种迭代型循环语句，像是Python的for语句就是迭代型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">// sequence是一个可迭代对象<br>// iterating_var从前往后每次执行循环体都从sequence取单一成员<br><span class="hljs-keyword">for</span> iterating_var <span class="hljs-keyword">in</span> sequence:<br>   statements(s)<br></code></pre></td></tr></table></figure><p>比如我们想打印数组中所有成员：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&#x27;banana&#x27;</span>,<span class="hljs-string">&#x27;apple&#x27;</span>,<span class="hljs-string">&#x27;mango&#x27;</span>,<span class="hljs-string">&#x27;orange&#x27;</span>]<br><span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> fruits: <br>    <span class="hljs-built_in">print</span>(fruit)<br></code></pre></td></tr></table></figure><p>C++也支持这种迭代型循环，同样通过for语句来完成，只不过语法设计上有所差异：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; fruits&#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;mango&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; fruit : fruits) &#123;<br>    cout &lt;&lt; fruit &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>C++直到11标准才引入这种迭代型循环，在C++11之前，我们只能通过笨重的for语句配合迭代器来完成。形如<code>for(vector&lt;string&gt;::iterator iter=fruits.begin(); iter!=fruits.end(); ++iter)</code>，对于可以按下标枚举的可以简化写成<code>for(size_t i=0; i&lt;fruits.size(); ++i)</code>，相比于迭代型，不论哪种都尽显笨重。</p></blockquote><p>Java对迭代型循环的支持和C++又是如出一辙（这和两种语言在语法设计上的高度一致有关系）,Java派系一般称之为增强型for循环，也叫foreach循环。我个人认为这个foreach名称特别贴切，能够体现出逐元素迭代的语义，而foreach这个名词在C#语言中就被选取为关键字以支持迭代型循环:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">Span&lt;<span class="hljs-built_in">string</span>&gt; fruits = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123;<span class="hljs-string">&quot;banana&quot;</span>,<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;mango&quot;</span>,<span class="hljs-string">&quot;orange&quot;</span>&#125;;<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">ref</span> <span class="hljs-built_in">string</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;fruit&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Go语言对迭代型循环的支持采用的则是for-range语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">fruits := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;banana&quot;</span>,<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;mango&quot;</span>,<span class="hljs-string">&quot;orange&quot;</span>&#125;<br><span class="hljs-keyword">for</span> fruit := <span class="hljs-keyword">range</span> fruits &#123;<br>    fmt.Println(fruit)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="练习">练习</h4><p>最后让我们来利用这三种结构编写一个猜数游戏：提前想好一个100以内的数字，由用户来猜测，如果用户猜错了，就告诉用户猜测的数字是大了还是小了，重试直到猜对；如果用户猜对了就输出“Bingo”并退出。</p><p>我们简单的做一下需求分析：显然这段程序需要循环读取用户的输入，并对用户输入的数字进行条件判断，执行两个分支。当用户猜对的情况，直接打印Bingo并终止循环退出程序接口；当用户猜错的情况，就需要重头来过并提示用户数字大了还是小了。显然，这里用直到型循环书写起来更优雅。至于提前想好的数字要怎么生成呢，我们让程序随机生成一个就好。我这里用C++来实现一个版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">101</span>;<br>    <span class="hljs-type">int</span> input;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        cin &gt;&gt; input;<br>        <span class="hljs-keyword">if</span> (input == n) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Bingo!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (input &gt; n) &#123;<br>                cout &lt;&lt; input &lt;&lt; <span class="hljs-string">&quot; is larger than n.&quot;</span> &lt;&lt; endl;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; input &lt;&lt; <span class="hljs-string">&quot; is smaller than n.&quot;</span> &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Quit...&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="2023-06-21-11-27-29.png" /></p><p>如果你也有些许的编程经验，可以使用你喜欢的语言，也来写一个猜数游戏，正所谓“纸上得来终觉浅，绝知此事要躬行”。</p><h3 id="引用机制和重用">引用机制和重用</h3><h3 id="设计哲学">设计哲学</h3><p>这两部分一起讨论，承上启下、息息相关。</p><p>所谓的引用机制和重用，概念看上去很抽象，但翻译成大白话就两个字：复用。我们给变量取名是为了复用，你可以在上下文的多个地方通过名称来引用它；我们封装可调用对象也是为了复用，同一个代码片段功能体可能会反复执行多次，为了避免重复copy大段的代码，就需要对这段代码进行抽象和封装，大部分语言都会使用函数或者方法来支持这一能力，在这基础之上，又是八仙过海、各显神通。</p><h4 id="编程范式">编程范式</h4><p>然而语言千百，殊途同归，所有的编程语言所涉及的程序设计方法都可以归类到具体的编程范式(ProgrammingParadigm)。所谓编程范式，就是一类典型的编程风格，常见的编程范式有：指令式编程(ImperativeProgramming)、面向过程式设计(Oriented ProcessDesign)、面相对象式设计(Oriented ObjectDesign，简称OO)、函数式编程(Functional Programming)。</p><p>指令式编程就是最古老的直接操纵机器指令的汇编语言所用的范式，随着高级语言的诞生，面相过程语言大行其道，像是C语言这种古老的面向过程型语言，设计上高度自由（开放大世界玩法），语言本身仅仅提供结构体、函数和宏这三种抽象能力，你想怎么DIY都随你喜欢。</p><p>随着编程语言的发展，另一种面向对象型语言风靡业界，OO语言的核心思想是：万物皆对象。以Java这种最具代表性（Java是一门纯粹的OO语言）的语言对OO的答案是：抽象出“类”的概念，认为万物皆可封装成特定的类，而类与类之间有着继承(Inheritance)关系（也就是父子），每个类可以定义它自己的成员变量、成员函数(方法)，在这基础上还可以设定开放权限。另一方面，继承类可以直接继承父类的某些方法，对于不满意的，也可以通过重写(Override)的方式来DIY自己的专属版本。外部对象访问时，通过多态(Polymorphism)的机制来达到父类指针(引用)访问不同的子类对象的能力（实际上OO的本质就是为了解决Polymorphism这个元问题）。类继承与传统的组合(Composition)搭配使用，发生了强烈的化学反应，先驱者应对各类需求场景归纳出了各种设计上的定式，而这就是大名鼎鼎的“设计模式”。</p><blockquote><p>设计模式也算是面试八股文的重灾区了，说实话我到现在都不会画UML，我是低手。</p></blockquote><blockquote><p>OO只是C++语言能力的一个子集，也不是非用不可。事实上C++是所有语言中自由度最高的、也是能力最大而全的（但也因历史问题形成了严重的割裂感），只是对机师的操作要求太高，我至今没见过谁敢在简历上写“精通C++”，即使是经验丰富的老司机，谈到C++，也只敢说略懂、略懂。</p></blockquote><p><strong>领域驱动设计</strong></p><p>面对OO思想，近些年大家逐渐意识到以Java为代表的“类继承”编程范式并不是唯一解，更不是什么最优解（面向需求开发本就没什么最优解，不要想着一招鲜吃遍天）。大量的继承使用并没有降低系统的复杂性，甚至反而会增加理解整个系统的成本，表面看起来我们编写的代码变少了，但本质上这只是一种压缩而非抽象。我们在设计类的时候，都会有一个预先设定好的先决条件：如果一个对象的类型是X，那么它的行为模式Y能且只能是Z。但面对现实的需求调整，对象的行为模式不仅与其类型绑定，还会受使用者（即如何被使用）影响。横看成岭侧成峰，远近高低各不同。站在不同使用者的视角，行为模式也需要根据上下文来调整。类继承无法察觉使用者的变化，这就导致代码越写越臃肿，设计一个子类还得处理很多根本没必要参与的模式代码。</p><p>最新的一些编程语言在设计上已经开始嫌弃“类继承”这种手法了，比如Go采用的是“数据与行为分离”的思想，它的struct只定义数据、不定义行为；interface只对行为进行抽象、不涉及数据。行为就是行为，数据就是数据，当你需要它们之间产生联系时，再去编写<code>X.Y()</code>的具体代码也不迟。</p><p>随着传统类继承OO设计的没落，一种名为领域驱动设计(Domain-DrivenDesign,简称DDD)的手法异军突起：由领域模型驱动软件设计，用代码来实现该领域模型。DDD实际上就是从“类继承”所面对的困境出发，因为需求千奇八怪没有银弹，所以我们限定领域模型（任何系统的问题都是有限个领域的结合）；因为行为模式受使用者影响，所以我们抽象出有限界上下文。</p><blockquote><p>翻译成白话就是：特定领域的系统设计交给特定的业务专家，小工只需要在大神的领域按部就班即可。团队统一语言来描述概念，但每个概念都要结合上下文去理解，比如你说的apple到底是指水果还是品牌。</p></blockquote><p>DDD主要用于解决大型项目的复杂问题，尤其是面向那种成百上千开发者的情景能够有效的降低破窗风险，拉长项目可维护的生命期。诚然DDD目前鲜有成功的大型系统案例，对大部分开发者来说也完全是玄学。</p><blockquote><p>DDD始源于领域驱动设计之父Eric Evans的一本书：Domain-Driven Design:Tackling Complexity in the Heart ofSoftware，但这本书玄之又玄我真理解不上去，我这里推荐一篇通俗易懂讲人话的DDD介绍文章：https://tonydeng.github.io/2022/11/06/domain-driven-design/</p></blockquote><p><strong>函数式编程</strong></p><p>另一种常见的编程范式被称作函数式编程，它是一种面向数学的抽象，将计算描述为一种表达式求值，函数式程序本身就是一个数学表达式。在这种范式中函数与其他数据类型一样，都被视作一等公民，地位平等，函数可以赋值给变量、也可以作为参数传递、或者作为函数的返回值（所谓的高阶函数）。函数式编程关心数据的映射，而命令式编程则关心解决问题的步骤。</p><p>最经典的函数式编程语言是LISP，近现代的Haskell,Erlang等也是较为纯粹的函数式编程语言。像是C++,Rust,Python,Javascript等也或多或少提供了必要的函数式编程语法糖，只不过迂回的提供方式让函数式编程范式的一些特性（诸如高阶函数、柯里化、闭包、惰性求值）没有那么鲜明。</p><blockquote><p>这里推荐一个C++函数式编程的tutorial：https://github.com/polossk/Zero-Kara-FCPP</p></blockquote><p>函数式编程有着70年的历史，在业界历来小众，但随着硬件爹的升级换代、多核时代的到来，与并发控制格格不入（数据和操作绑定导致锁开销极大）的OO型语言遭受到越来越多开发者的质疑（实际上是反Java式类继承），而函数式编程对并发控制的编写天然友好，于是又逐渐回归到大众视线。</p><h2 id="通往异世界之旅">通往异世界之旅</h2><p>格物致知系列——编程导论的三大篇到此就全部结束了，不论你是刚刚入门的小白，还是已经有了一定编程基础的门徒，相信看到这里都能有不一样的感悟。语言千百、殊途同归，不论投身于何门何派，都要记着老祖宗的箴言：学而不思则罔，思而不学则殆。</p><p align="right">by 玉涵，完稿于2023年6月21日夜</p>]]></content>
    
    
    <categories>
      
      <category>编程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>格物致知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格物致知(1)——你什么进制？我什么进制？</title>
    <link href="/2023/05/06/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(1)%E2%80%94%E2%80%94%E4%BD%A0%E4%BB%80%E4%B9%88%E8%BF%9B%E5%88%B6%EF%BC%9F%E6%88%91%E4%BB%80%E4%B9%88%E8%BF%9B%E5%88%B6%EF%BC%9F/"/>
    <url>/2023/05/06/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(1)%E2%80%94%E2%80%94%E4%BD%A0%E4%BB%80%E4%B9%88%E8%BF%9B%E5%88%B6%EF%BC%9F%E6%88%91%E4%BB%80%E4%B9%88%E8%BF%9B%E5%88%B6%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>在我入坑之前就时长听大佬说：计算机的世界是二进制的，所有的信息都用0和1来表达。这对习惯于使用十进制的人脑来说显得捉摸不透：为什么要用二进制，十进制不香吗？另外啥叫信息？计算机为啥要表达？它要表达啥？不知道年轻的你有没有此等困惑，今天就让我们来揭开遮掩的幕布，看破这背后的戏法与魔术。</p><span id="more"></span><h1 id="你什么进制我什么进制">你什么进制？我什么进制？</h1><p>在研究计算机为什么是二进制之前，我们先抛开先入为主的偏见，思考一下：为什么人脑习惯用十进制，阿拉伯数字为啥用10当做基数来设计？这个问题很简单，掰掰我们的手指，数一数一共有几根，答案也就呼之欲出了。得益于我们的手指数量，最早的计数方式便选择10作为基数，而随着智慧的启蒙与时代的发展，阿拉伯人设计出以10作为基数的阿拉伯数字，推动了数字革命，终而家喻户晓、流传沿用至今。幼儿园老师教我们加减法运算时，其核心就在于凑10，当我们掌握了凑10技巧以后（也就是明白了进制的意义），就可以口算相当大规模的数字加减运算了。</p><p>而在计算机的世界则流行的是一种二进制运算，为什么是2而不是10呢，这是因为二值信号更容易被表示、传输和存储，2这个数字很有power，他可以表示两种极端对立的特性，比如：有和无、阴与阳、光与暗、高和低、顺时针和逆时针等等。对二值信号进行存储和计算的电子线路简单可靠、易于设计，制造商可以在一个单独的硅片上集成数百万乃至数十亿个这样的电路。</p><p>正所谓太极生两仪、两仪生四象、四象生八卦，单个二值信息本身作用有限，但是当把多个二值信息排成队、通过排列组合就可以一生万物，正如我们在第零讲中反复提到的核心思想：对抽象的事物赋予特定的语义。对连续二值信息的排列组合可以让我们对任何有限集合赋予语义，比如字符编码、CPU指令，再比如今天要讲的主角：数值信息的表达与存储。</p><h2 id="初识二进制">初识二进制</h2><p>二进制运算法则和十进制没什么区别，不过是逢2进位罢了，这里介绍一个简单的口算进制转换技巧：我们按照从低到高，记住一连串的二进制位为1的实际值，比如<code>B11111111</code>从低位到高位分别是1、2、4、8、16、32、64、128，当我们有一个十进制数为69，想要转换成二进制来表示的话，就用这些数字来凑：<spanclass="math inline">\(69=64+4+1\)</span>，亦即第0、2、6位为1（计算机的世界下标往往从0开始），其余位为0，最终写成<code>B01000101</code>。这里的前缀B表示二进制，是英文binary首字母的缩写。</p><blockquote><p>你可能还见过其他的二进制表示法，不同语言的写法可能不同，比如python里是用0b作为前缀，但这些都不重要，他只是为了区分其他进制而携带的标记，我们只需要知道它表示二进制就行。</p></blockquote><p>好，看到这里相信你已经学会怎么口算了，那么留一个问题给读者：250用二进制表示要怎么写呢？</p><h2 id="超量召唤十六进制">超量召唤：十六进制</h2><p>有的同学可能注意到，为啥69的二进制最高位在第6位，我却在最高位前面补了个0凑成8位呢？这是因为大多数计算机存储的最小单元是字节(Byte)，一个字节=8个位(bit)，常常写作1B(yte)=8b(its)，故而常常以8作为分组。因此，一个字节表达的范围就是<code>B00000000~B11111111</code>，换算到十进制就是<code>0~255</code>，由于使用二进制书写显得格外不方便，大家就对2进行了折叠，选择<code>2^4=16</code>来作为基数（<del>二进制的怪兽有四只，要上了，欧巴类、xyz召唤：十六进制</del>），用十六进制来表示（使用数字<code>0~9,A~F</code>来表示每个位值，也就是从0到15，其中<code>A~F</code>大小写均可）。如此，一个字节就只需要两个十六进制数来表示，大大缩减了书写长度，此时值域区间为<code>0x00~0xFF</code>（这里的<code>0x</code>是用户表示十六进制的前缀，可能还有<code>0xFFH、FFH</code>的写法，H是十六进制——Hex的缩写）。</p><p><img src="2023-05-11-19-53-30.png" /></p><p>所以十六进制只是二进制的折叠，本质上没有什么区别，那么十六进制怎么口算呢？很简单，我们通过展开十六进制数、转成二进制格式，在此前二进制口算窍门的基础上，再做一层映射即可：</p><p><img src="2023-05-12-09-36-50.png" /></p><p>让我们来试试：十进制的250，对应的十六进制数怎么表示呢？首先我们把250拆分成：<spanclass="math inline">\(128+64+32+16+8+2\)</span>，也就是对第1、3、4、5、6、7位置1、其余置0，二进制写作<code>B11111010</code>，进一步，每4位做一下折叠，最终得到：<code>0xFB</code>。</p><p>当然了，在我们熟悉十六进制数字之后，可以跳过二进制转换这一层，直接使用十六进制数来口算：比如<code>250=15*16+10</code>，15就是<code>F</code>、10就是<code>B</code>，也可以得到<code>0xFB</code>的结果。</p><blockquote><p>实际上我们只需要掌握十六进制数的阅读方法即可，如果口算不是为了装B，那就毫无意义(doge）。</p></blockquote><h2 id="数值类型与尺寸">数值类型与尺寸</h2><p>我们上中学的时候，对数字的划分一般都是采用自然数、实数、复数等概念来进行划分，但在计算机的世界，划分规则却迥然不同。各大编程语言往往都会定义各种各样的数据类型，它们作用不同、长短不一，但总体而言，数值在大分类上可以被归类成这两种：整型数和浮点型数。在这两大类的基础上，编程语言一般会在设计上根据尺寸长短（也就是确定数值范围、即多少个字节），将整型和浮点型细分成多种类型。另一方面，由于数值有正负之分，为了便于日常开发者的使用，在一些编程语言里还对每一种类型再进一步拆分成有符号和无符号型（比如C、C++）。</p><p>整型数就是整数，不管他的尺寸有多大，哪怕你定义成64个字节的超大范围，它能表示的数值也仅限于整数。比如我们定义一个<code>uint8_t</code>的类型，长度为1个字节，那么它所能表示的数值范围就是<code>0~255</code>，假如我们想让这个范围能表示负数，那么不妨再设计一个<code>sint8_t</code>型，长度依然是1个字节，此时数值范围就是<code>-128~127</code>。对于无符号数来说，如何使用单字节来存储<code>0~255</code>显得非常直接，0就存储为<code>0x00</code>、1就存储为<code>0x01</code>、240就存储为<code>0xF0</code>、255就存储为<code>0xFF</code>，这和十六进制表示数值的设计是完全统一的，我们姑且也把这叫做一种编码（尽管这层转换什么都没做）。但是负数要怎么存储呢？目前并没有一个单独的信息位来告诉我们这个数是positive还是negative呀。</p><h3 id="麻烦的符号">麻烦的符号</h3><p>看来简单的一比一编码行不通，一旦涉及了正负的概念，还是得考虑编码规则。考虑到正负本身无非也是一种信息，且恰好就是个二值信息，所以如果我们在原有尺寸的基础上，让出最高位、作为正负符号的表示，其余位仍然代表数值，看起来就可以解决这个case。比如对于此前我们设计的<code>sint8_t</code>，它一共有8个bits，我们让最高位（第7位）为0时代表正、为1时代表负，那么它所能表示的范围就变成了<code>-127~127</code>。此时B11111111在作为<code>sint8_t</code>的时候，它的值就是-127，而作为<code>uint8_t</code>时，它的值是255。</p><p>这种简单粗暴的设计看起来很美好，但实际上却经不起推敲：比如我们考虑对-4和+8做加法运算，二进制写作B10000100和B00001000，正常的结果应该是+4，当计算机操作二进制数按位计算时，答案却是错误的B10001100，也就是-12：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">-4:<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>0<br> 8:<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<br>+=:<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>0<br></code></pre></td></tr></table></figure><p>经过分析，我们发现这里第一个问题就在于符号位是不能直接进行加法运算的，因为我们在计算时并不知道最终结果应该是正还是负。此外，第二个问题在于正数和负数的加法运算，其实相当于是减法，这里的计算逻辑实际上忽略了这一事实，而是进行简单的4+8，所以最终才得出了-12的结果。</p><p>尽管我们经过分析，或许能够梳理出一套正确计算的逻辑，但从计算机来说，这就显得太过于复杂了，对于计算机来说，它只能做加法运算，至于你这些数字的背后代表了哪些数值，它是丝毫不关心的。因此，我们需要精心设计一个编码机制，使得它能够在计算机的世界对正负数的加减法操作（计算机只能做加法，减法也是加法（与负数相加））得到一个正确结果的相应编码值。</p><h3 id="整型数编码">整型数编码</h3><h4 id="无符号数">无符号数</h4><p>对于无符号数来说，完全可以沿用最自然的编码规则：</p><p><img src="2023-05-15-10-22-21.png" /></p><p>长度为w的0、1串映射到无符号整数，比如：</p><p><img src="2023-05-15-10-23-23.png" /></p><p>显得既直观又简单。由于无符号数不涉及减法，也没有符号，所以计算机的加法运算无论对于哪两个数操作，结果都是正确的。</p><h4 id="有符号数">有符号数</h4><p>而对于有符号数，最常见的一种编码方式叫做补码(two'scomplement)。在这个定义中，将字的最高有效位解释为负权(negativeweight)，类似无符号数，使用函数来定义：</p><p><img src="2023-05-15-10-26-28.png" /></p><p>最高位<spanclass="math inline">\(-x_{w-1}\)</span>也叫符号位，它的权重为<spanclass="math inline">\(-2^{w-1}\)</span>，当该符号位为时表示负数（值为负），为0时表示整数（值为非负，也就是正数+0），这么说比较抽象，还是展开看看几个例子：</p><p><img src="2023-05-15-10-54-08.png" /></p><p>为什么要设计这个权重呢，实际上它是对减法运算的一种模拟，对于负数来说，它最终用于表达的二进制值是权重作用后的结果，如此，当我们对复数进行加法运算时，这个权重就发挥了作用。</p><p><img src="2023-05-15-10-55-17.png" /></p><p>比如重新考虑<code>-8+4</code>，对<code>sint8_t</code>类型，-8的补码是B11111000，4的补码是B00000100，二者相加：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">-8:<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<br> 4:<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>0<br>+=:<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>0 =&gt; -4的补码<br></code></pre></td></tr></table></figure><p>通过计算机的加法运算后，得到的正好就是-4的补码。</p><p>再比如<code>-4+8</code>：-4的补码是B11111100，8的补码是B00001000，二者相加：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">-4:    <span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>0<br> 8:    <span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<br>+=: (1)<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>0 =&gt; 产生进位，丢弃溢出位，最终结果是4的补码<br></code></pre></td></tr></table></figure><p>由于尺寸限制，这里的加法运算产生了溢出，最终溢出位被丢弃，而最高位（符号位）刚好因为进位而变成0（语义上代表非负数），这一巧合实际上就是我们精心设计的补码编码规则而产生的。</p><h4 id="补码反码与原码">补码、反码与原码</h4><p>各版本大学计算机基础的教材往往都会提到这么几个概念，补码我们已经知道了，那么啥叫反码和原码呢？</p><p>反码和原码是另外两种表示有符号数的标准方法：原码(Sign-Magnitude)：最高有效位是符号位，用来确定剩下的位应该取负权还是正权：</p><p><img src="2023-05-15-11-28-20.png" /></p><p>反码(Ones' Complement)：除了最高有效位的权是<spanclass="math inline">\(-(2^{w-1}-1)\)</span>而不是<spanclass="math inline">\(-2^{w-1}\)</span>，它和补码完全一样：</p><p><img src="2023-05-15-11-27-27.png" /></p><p>对于原码和反码来说，它们对数字0的编码都有两种：<code>B00000000</code>被解释成<spanclass="math inline">\(+0\)</span>，在原码编码中<code>B10000000</code>被解释成<spanclass="math inline">\(-0\)</span>、反码编码中<code>B11111111</code>被解释成<spanclass="math inline">\(-0\)</span>。反码和原码相对于补码是截然不同的编码方式，只可惜大部分教科书混淆了三者之间的关系，从字面值上看，正数的补码和原码一致，而负数的补码则是“反码+1”（毕竟权重里多了个-1），这种取巧的办法更适合我们人类去计算有符号数的补码编码值，但实际上它们之间没什么关系，每种编码方式本身都是内部闭环的。所以坊间总流传这么一个说法：正数的补码是它的原码、负数的补码是它的反码+1。久而久之，我们只学会了怎么计算有符号数的补码编码值，却根本没搞懂补码的设计奥义，当真是买椟还珠。</p><blockquote><p>虽然上古时代曾生产过基于反码表示的机器，但现代机器都一致使用补码来编码有符号数。</p></blockquote><h3 id="c语言中的数值类型">C语言中的数值类型</h3><p>上面的<code>sint8_t</code>,<code>uint8_t</code>是我杜撰的，我们找个真实的编程语言来举例。比如，在C语言中，有着以下的常见类型：</p><p><img src="2023-05-12-17-47-18.png" /></p><p>注意到C在设计上针对整型数分成了<code>short、int、long、int32_t、int64_t</code>这几种，它们的尺寸单调非递减，且在不同位数的机器架构里长度不同。<code>char</code>是一个比较特殊的类型，它只有单个字节，常用来表示ASCII字符，但本质上存储的只是个数字罢了，它具体是什么取决于你怎么用它。<code>char</code>这种设计放在现代来看显得小家子气（比如go直接定义<code>byte</code>型），这主要是因为C诞生年代太过久远，和现代编程语言的设计相当脱轨。</p><blockquote><p>实际上x64（64位）机器也可以编译x86(32位)的C程序，此时类型尺寸按32位的标准生效。</p></blockquote><h4 id="有符号数和无符号数的转换">有符号数和无符号数的转换</h4><p>截止到目前，我们对有符号数和无符号数可以说是区别对待，可是在实际生产环境中，我们很可能会遇到两种类型数混用甚至需要进行计算的场合，那怎么办呢？大部分区分了符号数的语言往往都提供了它们之间的转换方法，比如在C语言中就有显式强制类型转换和隐式类型转换这两种。然而语言层面往往只是提供能力，二者进行计算最终得到的值，归根结底取决于你对它的解读方式。</p><p>举个例子，比如下面的C代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> v = <span class="hljs-number">-12345</span>;   <span class="hljs-comment">// 16位大小有符号数，表达范围是 -32768 ~ 32767</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> uv = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)v;  <span class="hljs-comment">// 这里进行了强制类型转换</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v=%hd, uv=%hu\n&quot;</span>, v, uv); <span class="hljs-comment">// %hd是按有符号数打印unsigned short，%hu是按无符号数打印short</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用x86-64 gcc13.1编译，最终输出的结果是：<code>v=-12345, uv=53191</code>。为什么<code>uv</code>的值是53191而不是直觉上的12345呢？这就是因为<code>-12345</code>底层存储的值是<code>B1100111111000111</code>，采用的是补码存储，而当我们把他看做是一个无符号数时，它的编码解读方式就发生了变化，最高位的符号位不再代表符号位，而是代表了<spanclass="math inline">\(2^15\)</span>这个值，不妨按照无符号数的编码方式计算一下，就会发现<code>B1100111111000111</code>对应的值正是<spanclass="math inline">\(2^{15}+2^{14}+2^{11}+2^{10}+2^9+2^8+2^7+2^6+2^2+2^1+2^0=53191\)</span>。</p><p>因此，对于上一段C代码来说，<code>unsigned short uv = (unsigned short)v</code>只不过是使用强制类型转换将<code>v</code>底层存储的编码值赋值给了<code>uv</code>，仅此而已。实际上，我们将上面的代码改写一下，完全不需要copy一份<code>v</code>，只需要对<code>v</code>使用不同的format来打印，亦会得到相同的结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> v = <span class="hljs-number">-12345</span>;   <span class="hljs-comment">// 16位大小有符号数，表达范围是 -32768 ~ 32767</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v=%hd, uv=%hu\n&quot;</span>, v, v); <span class="hljs-comment">// 依然输出v=-12345, uv=53191</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于大多数语言的无符号和有符号数类型的转换，原则都和C一样：数值可能会变，但是位模式不变。因此，当开发者对有符号数和无符号数进行混淆计算时，一定要确保非预期的结果产出，对于大部分语言来说，这都是一个存在风险且不推荐的操作。</p></blockquote><h4 id="扩展与截断">扩展与截断</h4><p>另一个常见的转换场景是不同字长的整数之间进行转换。我们原则上希望这样的转换可以保持原有数值的不变，这对于扩展来说（也就是从小尺寸转成大尺寸），可以通过设置扩展的规则来保证，但对于截断来说，显然是不可能的（你那点空间容不下人家的熵）。</p><p>对于无符号的扩展来说，只需要在扩展的高位全部填0即可，这一法则被称作无符号数的零扩展，其原理直接遵循了无符号数编码的定义。而对于有符号数来说，补码需要执行符号扩展：高位填充最高有效位的值，简单来说，就是负数用1填充，非负数用0填充。</p><p>我们还是以C语言为例，将上面的代码做一下调整：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> v = <span class="hljs-number">-12345</span>;   <span class="hljs-comment">// 16位大小有符号数，十六进制对应0xCFC7</span><br>    <span class="hljs-type">int</span> wv = v;     <span class="hljs-comment">// 16位扩展到32位，高位用符号位1来填充，扩展为0xFFFFCFC7</span><br>    <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> uv = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span>)v;  <span class="hljs-comment">// 0xCFC7，此时解码视作53191 </span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> wuv = uv;  <span class="hljs-comment">// 无符号数用零扩展，0x0000CFC7，依然是53191</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v=%hd, uv=%hu\n&quot;</span>, v, uv);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wv=%d, wuv=%u\n&quot;</span>, wv, wuv);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">v</span>=-12345, <span class="hljs-attribute">uv</span>=53191<br><span class="hljs-attribute">wv</span>=-12345, <span class="hljs-attribute">wuv</span>=53191<br></code></pre></td></tr></table></figure><p>扩展的规则易于理解，那么怎么截断呢？既然截断可能会导致原始数值的丢失，所以我们也不用有那么多顾忌，不管是无符号数还是有符号数的补码，我们都干脆把高位丢弃就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> v = <span class="hljs-number">53191</span>;                  <span class="hljs-comment">// 0x0000CFC7</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> sv = (<span class="hljs-type">short</span> <span class="hljs-type">int</span>)v;    <span class="hljs-comment">// 丢弃最高位后变成0xCFC7，此时最高位1作为符号位值为1，整个值变成了-12345</span><br><br>    <span class="hljs-type">int</span> v2 = <span class="hljs-number">0x0001CFC7</span>;            <span class="hljs-comment">// 直接用十六进制书写了，十进制为118727</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> sv2 = (<span class="hljs-type">short</span> <span class="hljs-type">int</span>)v2;  <span class="hljs-comment">// 还是0xCFC7，-12345</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sv=%hd, v=%d\n&quot;</span>, sv, v);     <span class="hljs-comment">// 输出-12345,53191</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sv2=%hd, v2=%d\n&quot;</span>, sv2, v2); <span class="hljs-comment">// 输出-12345,118727</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以截断这个操作在编程时也是个高度危险的操作，这很可能会因为熵信息丢失导致出现非预期的问题，甚至会产生一些可被黑客利用的漏洞。</p><blockquote><p>纵观历史长河，因类型转换、扩展截断而导致的漏洞数不胜数，比如CSAPP在2.2.8的旁注中给出了一个经典的开源系统FreeBSDgetpeername的设计缺陷案例。早期的语言设计诸如C/C++对类型的分类和处理比较宽松，想要写出bugfree的代码需要开发者有较深的理解且务必仔细，这种环境天然助长了大量漏洞的滋生，这也间接导致此后数十年间、二进制安全的世界精彩纷呈，各种漏洞利用手法叹为观止。</p></blockquote><blockquote><p>既然无符号数和有符号数之间混用势必产生一地鸡毛，所以一些编程语言在设计时移除了对无符号数的支持，比如Java仅支持有符号整数，大刀阔斧，魄力相当。</p></blockquote><h3 id="整型数运算">整型数运算</h3><h4 id="加法与减法">加法与减法</h4><p>由于尺寸固定的整型数类型范围受限，所以当进行加法操作时，会遇到一种在计算机世界中非常常见的现象：溢出(Overflow)。对于无符号来说，这一点显而易见，我们依然使用C语言来做测试，使用unsignedshort来溢出一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> v = <span class="hljs-number">65535</span>;             <span class="hljs-comment">// 所能表示的最大数，B1111 1111 1111 1111</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> overflow = v + <span class="hljs-number">1</span>;      <span class="hljs-comment">// 此时overflow是B(1) 0000 0000 0000 0000，最高位进位后溢出被丢弃，最终结果为0。   </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;overflow=%hu\n&quot;</span>, overflow);   <span class="hljs-comment">// 输出overflow=0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于有符号数来说，其实也没什么不同，计算机依然是墨守成规的对每个位进行相加，按需进位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">short</span> v = <span class="hljs-number">32767</span>;                        <span class="hljs-comment">// 所能表示的最大正数，B0111 1111 1111 1111</span><br>    <span class="hljs-type">short</span> overflow = v + <span class="hljs-number">1</span>;                 <span class="hljs-comment">// 此时overflow是B1000 0000 0000 0000，次高位进位后导致符号位变成1，该值为-32768的补码   </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;overflow=%hd\n&quot;</span>, overflow);     <span class="hljs-comment">// 输出overflow=-32768</span><br><br>    v = <span class="hljs-number">-32768</span>;                             <span class="hljs-comment">// 所能表示的最小负数，B1000 0000 0000 0000</span><br>    overflow = v - <span class="hljs-number">1</span>;                       <span class="hljs-comment">// 相当于v + (-1), -1的补码是B1111 1111 1111 1111，相加后最高位溢出，得到B(1) 0111 1111 1111 1111</span><br>                                            <span class="hljs-comment">// 最高位丢弃，值为32767</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;overflow=%hd\n&quot;</span>, overflow);     <span class="hljs-comment">// 输出overflow=32767</span><br>&#125;<br></code></pre></td></tr></table></figure><p>减法相当于是对负数做加法，而加法运算也同样是老老实实的按位操作，在中央处理器眼里从来都没有什么符号位，更没有什么负权。我们可以发现一个规律，向上溢出（正溢出）和向下溢出（负溢出）形成了一个周期环，所有的值都在<spanclass="math inline">\(-2^w~2^{w-1}\)</span>之间反复横跳、周而复始。</p><p><img src="2023-05-15-22-48-15.png" /></p><h4 id="乘法与除法">乘法与除法</h4><p>我们知道乘法实际上就是多次的加法运算，尽管自近现代以来，流行处理器都支持独立的乘法指令（如Intelx86系列的MUL,IMUL），然而这些乘法指令相当慢，相比于其他整数运算指令诸如：加法、减法、位运算(与、或、非、异或)、移位，要花费数十倍以上的时钟周期。现代编译器在编译程序时往往都会对乘法运算进行优化，其核心思想就是利用位移指令+加减法指令配合完成原本的乘法运算，取代费时费力的乘法指令。</p><blockquote><p>这里的优化是编译器针对于变量x常量的case，变量x变量由于无法提前预知两个值中的任意一个，所以只能使用乘法指令IMUL,MUL。而常量*常量则在编译期就已经可以计算出结果了，根本不经过CPU做runtime的乘法计算。</p></blockquote><p>首先我们得前置介绍一些位移指令，位移指令其实很简单，它分为左移和右移：前者就是将每个二进制位都想左侧的高位移动K位，低位用0补齐；而后者则相反，将每个二进制位都向右移动K位，低位丢弃、至于最高位嘛，则分两种情况，一种叫逻辑右移、另一种叫算数右移，逻辑右移很简单，就是在高位补K个0，但算数右移则根据最高位进行补齐，也就是说，如果右移前，最高位是1，那么就用1来补齐位移后的最高K个位。</p><p>可别小瞧这位移指令，举个例子，我们对<code>B0001</code>(十进制等于1)进行左移操作，移动2位，结果就是B0100（十进制等于4），其效果相当于是乘以2的某个幂数，移动K位，就是乘以<spanclass="math inline">\(2^k\)</span>。聪明的编译器根据一些数学上的技巧可以把复杂的与2的幂数对不齐的乘法转换为某个K位左移操作，进而再通过加减法进行补足。比如语句<code>n = num * 63;</code>的x86汇编指令可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ecx, dword ptr [num]; 把num初始值赋值给ecx寄存器<br>shl ecx, 6              ; 对ecx左移6位，相当于乘上2^6=64，此时ecx值为num*64                 <br>sub ecx, dword ptr [num]; 对ecx进行减法操作，减去一个num，相当于ecx=num*64-num，即ecx最终值为num * 63<br>...                     ; 其他指令，将ecx结果赋值给变量n<br></code></pre></td></tr></table></figure><p>考虑到这一技巧较为复杂，且和入门二进制关系不大，我们暂且按下不表，留待日后研讨。</p><p>除法相比乘法更加复杂、执行速度也更慢，类似乘法的左移优化，除法也有围绕2的幂数通过右移来加速的技巧。</p><h3 id="浮点数">浮点数</h3><p>浮点数就是我们平时经常说的小数，这类数有个比较明显的特点：有效位数可能相当之多，即使在日常生活中，我们计算小数时，也大都选择保留小数点后有限的几位，采用四舍五入或者干脆进一的方法。在计算机的世界也类似，比起数字精准度来说，制造商更care运算的速度，但相比我们日常的计算，各种浮点数的标准还是有着相对较高的要求。</p><p>小数的十进制表示法可以写成如下形式：<spanclass="math inline">\(d_md_{m-1}...d_1d_0.d_{-1}d_{-2}...d_{-n}\)</span>，每个十进制数<spanclass="math inline">\(d_i\)</span>的取值范围是<spanclass="math inline">\(0\sim9\)</span>，d可以按如下定义：</p><p><span class="math display">\[d = \sum_{i=-n}^{m}10^i \times d_i\]</span></p><p>小数点左边的数字的权是10的正幂，右边的则是负幂，例如<spanclass="math inline">\(12.34\)</span>可以表示为<spanclass="math inline">\(1 \times 10^1 + 2 \times 10^0 + 3 \times 10^{-1} +4 \times 10^{-2} = 12\tfrac{34}{100}\)</span>。</p><p>二进制表示法则与十进制类似，我们以2作为基底，可以写成：</p><p><span class="math display">\[b = \sum_{i=-n}^{m}2^i \times b_i\]</span></p><p>此时<spanclass="math inline">\(.\)</span>也是二进制的点，左边的位的权是2的正幂，右边位的权是2的负幂。例如，<spanclass="math inline">\(101.11_2\)</span>可以表示为：<spanclass="math inline">\(1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 + 1\times 2^{-1} + 1 \times 2^{-2} = 4 + 0 + 1 + \frac{1}{2} + \frac{1}{4}= 5\tfrac{3}{4}\)</span>。</p><p><img src="2023-05-16-19-43-12.png" /></p><p>如果我们仅考虑受限长度的编码，那么对十进制表示法来说，像是<spanclass="math inline">\(\frac{1}{3}\)</span>和<spanclass="math inline">\(\frac{5}{7}\)</span>这样的数是无法精确表示的，同样的，对于二进制表示法来说，我们能够精确表示的只有那些能够被写成<spanclass="math inline">\(x \times2^y\)</span>的数，其他值只能近似表示，我们唯一能做的就是尽量增加二进制表示的长度，长度越长，能够表达的精度就越高。</p><p>目前最流行的浮点数标准是IEEE(电气和电子工程师协会)制定的，它规定了浮点数中每个数字要如何表示和舍入的规范，相对于整型数的编码规范来说，浮点数的编码法则相当晦涩难懂，但其核心设计原理就在于用<spanclass="math inline">\(V=(-1)^s \times M \times2^E\)</span>来编码表示一个浮点数，通过将bits分成符号位、阶码和尾数三段来确定其中s,M和E的值（有各自的计算法则），与前文的表示法呼应起来了。</p><p><img src="2023-05-17-14-55-00.png" /></p><p>不过好在浮点数的编码对于绝大部分程序开发者来说并不是必要的知识储备，因此对于想要入门编程的同学，我们就暂止于此。</p><blockquote><p>对于现代处理器来说，浮点数运算一般有自己的指令集，通过集成到CPU的一种叫做浮点运算器FPU的处理单元来计算。FPU对浮点数的运算做了一些特化设计，不仅支持复杂的运算指令，还可以加速运算过程。当然，也不是说没有FPU就算不了浮点数，这就好比你没有GPU一样能打开显示器一样。</p></blockquote><p align="right">by 玉涵，完稿于2023年5月16日夜</p>]]></content>
    
    
    <categories>
      
      <category>编程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>格物致知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格物致知(0)——系统漫游</title>
    <link href="/2023/04/13/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(0)%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <url>/2023/04/13/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(0)%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>对于想要学习编程的新人来说，当下无疑是最好的时节，编程语言发展至今，新生代的语言在诞生之初往往伴随着强大的生态附属以及友好的语法特性，这大大降低了上手门槛，使得新手也可以轻松地完成任务而不必陷于囹圄。当下也是最坏的时节，现代编程语言高高在上，屏蔽了太多细节与原理，这鸿沟天堑阻绝了新人知其所以然的机会，却又如何技进于道？本系列将以CSAPP(ComputerSystems: A Programmer'sPerspective，中译本为《深入理解计算机系统》)上半为蓝本，接轨当下，让我们格物致知，打通认知体系的奇经八脉。</p><span id="more"></span><h1 id="系统漫游">系统漫游</h1><p>众所周知，计算机系统是由硬件和软件组成的，不论是超级计算机、集群服务器，还是家用电脑、移动端设备(平板、手机)、IoT设备（如路由器、摄像头）应皆如是。硬件五花八门、各司其职，对于非特定领域开发者来说，我们只需要了解两个核心硬件：中央处理器(CPU)和内存(主存，一般称RAM)即可。</p><blockquote><p>除了CPU以外，还有一种叫图形显示器(GPU)的东西，这东西在当下可是大展身手，无出其右（同学，便宜的矿卡来一块不？都是锻炼过的，GPT用了都说好）。机械硬盘(SATA)、固态硬盘(SSD)对于一台主机来说很重要，但站在程序开发者视角来说则没那么重要。至于显示器、鼠标、键盘等等都属于外设，如果不是为了打游戏，那么研究它们毫无意义(doge)</p></blockquote><p>硬件虽然服务于软件，但硬件才是大爹。事实上，互联网的崛起、从单点到分布式，以及历年的技术革命：诸如大数据、云计算、区块链再到当前潜在商业价值巨大的GPT，之所以能够surfing在浪潮之巅，根本上都是因为硬件的迭代升级。硬件的能力突破了某个瓶颈以后（算力、造价、效率等等...），业界大能才能把此前仅限于理论可行的方案落地，开辟出当前欣欣向荣的生态大环境。</p><p>那么硬件和软件是怎么沟通的呢？不同硬件厂商繁多，标准规格大相径庭，如果将这些都暴露给软件开发者，那简直是一场噩梦。事实上在上古时代，编程就是这样一件不可思议的狠活，程序开发者需要去理解使用的硬件，对着它的规格书使用原生接口来完成自己的工作。随着软件的发展，先驱者抽象出中间层（在软件开发领域，没有什么事是一个中间层搞不定的，如果有，就再加一个中间层），让它负责对接所有硬件，开发者只需要和这个中间层打交道即可。那么这个中间层是什么呢？它的真身就是我们常常说的操作系统(OS,OperatingSystem)，操作系统实际上也经历了漫长的发展历史长河，一直到现在我们耳熟能详的Windows,Linux, Mac OS, Android,IOS等。时至今日，我们更愿意称它们为“现代操作系统”，“现代”这一限定词可谓意义非凡，它浓缩了这一路上面对重重困境披荆斩棘的解决之道，并最终沉淀成标准，任岁月打磨。</p><blockquote><p>即使是家喻户晓的Windows，实际上也有着漫长的历史，严格来说，Windows不是具体的某个系统，而是一种徽章，从最古老的DOS到Windows9x再到Windows NT，底层的变化翻天覆地，而Win7（前身是赫赫有名的失败品Vista）之后历经Win 8、Win 10再到“内测”的Win11，安全加固、系统生态等方方面面都愈发成熟。</p></blockquote><blockquote><p>如果说Windows是自立门户、自成标准，那么像Linux, Mac OS, FreeBSD,Solaris都算作类Unix系统，它们有着相当多的共同点，比如遵守POSIX标准，集成了GNU套件。</p></blockquote><p>操作系统实际上也是软件，事实上，它就是我们开机以后第一个运行的体量最大的软件，OS提供了其他软件运行的土壤。现代操作系统整体分为两大部分：内核(kernel)和外壳(shell)，内核负责决策、调度和资源管理，里面住着的都是一等公民（常驻的内核代码：进程管理、内存管理、文件设备I/O、中断），外壳则面向开发者与用户进行交互：你只能通过使用我开放的接口、组合成你想实现的功能。通过这些接口（即系统API）我们可以编写各种程序，进而完成各种各样的软件，只不过受制于人（你得看具体OS厂商的脸色），能做的事儿有限。</p><p><img src="2023-04-13-19-19-46.png" /></p><blockquote><p>你可能会问：为啥现代操作系统要分层呢？大家写的程序都和OS内核平起平坐，功能岂不是更丰富？嗯，上古时期DOS就是这么干的，所以那个年代病毒满天飞，挡都挡不住。</p></blockquote><p>因此，在现代操作系统中，生态环境被分成了两部分：内核态与用户态。</p><ul><li>与硬件打交道的代码通通运行在内核层，各类硬件设备分门别类一般有着业界统一标准或是自定义标准，OS通过设备驱动来与它们交互，它们以插件的形式，或先天集成在OS内核里，或后天装载插入；</li><li>我们日常所用的大部分软件，诸如chrome浏览器、QQ音乐、Steam等它们之中的大部分工作在用户态；</li><li>像是一些防护软件比如火绒、360、QQ电脑管家等则兼具用户与内核态，为什么说是兼具呢？因为用户态有功能局限性，防护软件要和那些无孔不入的恶意程序对抗，那势必要下沉到内核去获取更高的权限与更强大的power。实际上，操作系统并不仅仅提供用户态的接口，内核层往往也会提供，而除了少量做设备驱动和二进制安全研究的人士，大部分开发者是用不到它们的。</li></ul><blockquote><p>内核态与用户态是现代操作系统的概念，在很多上下文中会等价于Ring0/3态，后者是站在CPU的视角来看的，虽然二者有一定区别，但基本绑定。</p></blockquote><blockquote><p>在我尚未学习内核/驱动编程的时候，总觉着写内核态程序的高人一等，直到上下求索、建立一定的知识体系后才明白：写程序就是写程序，本没有什么优劣，不过是所在的层与生态环境不同罢了。</p></blockquote><p>操作系统作为中间层，其常驻的内核代码会控制CPU与内存的调度与分配，我们知道程序无非就是代码+数据（代码其实也是数据，嗯，这就是二进制安全的关键），每一行代码的执行都由CPU来完成，而数据则放置于内存。对于CPU来说，各厂商的指令集迥然不同，在CPU的世界里，一切都是二进制的，它的眼里只有0和1，对于一连串的0101...0011，不同厂商对他们进行了特有的定义，比如通过规定指令集定长，其中1100表示功能A、0011表示功能B、1010表示功能C等等。那么，按照这样的设计，当我们使用不同的CPU编写程序（包括编写操作系统）时，就需要去对着厂商的手册，一点一点手码0101吗？啊，这。。。</p><p>当下显然不会，这就要说起编程语言的发展历程了~</p><h2 id="编程语言简史">编程语言简史</h2><h3 id="机器语言">机器语言</h3><p>CPU按架构会有自己的指令集，它们的背后也确实就是0101，只不过厂商赋予了语义并在硬件上实现了相应的功能。上古时期的编程确实就是直接写0101（这个时候的CPU还称不上是CPU）来完成的，彼时我们称其为机器语言，显然，机器语言对机器绝对友好，但对程序员绝对不友好，它的缺点肉眼可见：难记难改难纠错、费时费力费树脂（卧槽，原！）。痛，太痛了！</p><blockquote><p>世界上的第一个程序媛叫Ada，头像参考二进制安全必备神器：IDA Pro~</p></blockquote><p>业界把机器语言称为“第一代计算机语言”。</p><h3 id="汇编语言">汇编语言</h3><p>为了克服机器语言不说人话的问题，大佬们给CPU聘请了翻译(诶，您给翻译翻译什么叫0101？什么他么的叫0101？什么他么的叫他么的0101？)，而这就产生了第二代计算机语言：汇编语言。简单来说，汇编语言就是将机器码翻译成与实际意义相关的英文+数字缩写助记符（所以汇编指令也叫机器码助记符），比如<code>mov eax, 3</code>表示把数值<code>3</code>赋值给寄存器<code>eax</code>（至于什么是寄存器，这个学到的时候再说）。汇编语言的好处就在于相比于机器语言，编写起来没那么男的女的折磨，我们先用汇编助记符来编写程序，编写完成后经过翻译再变成机器码给到CPU去执行，而这个负责翻译的模块则被称作：汇编器。</p><p>汇编语言是一种低级语言（这里的低级不含贬义，只是说它所在的层级较低，与底层更近），它和具体的CPU指令集绑定，因此并不通用，尽管相对机器语言书写上舒服了很多，但编写门槛依然较高无法让人满意。</p><h3 id="高级语言">高级语言</h3><p>还记得前面讲操作系统时我们曾遇到的困境吗？不只是CPU，其他硬件的不同厂商标准规格都可能千差万别，如果需要开发者每一个都掌握，那属实crazy。这一点对于编程语言来说也一样，既然汇编难用又不通用，我们何不再架上一层中间层，搞一个统一的语言出来，再多安排几个翻译员，每个人专门负责从统一语言到某一个特定汇编语言的翻译工作。通过这一中间层的屏蔽，开发者只需要掌握这门统一语言即可编写在任何CPU指令集上运行的程序，而无需了解特定的指令集。（你看，我就说没什么困难是一个中间层搞不定的吧~）而且，在设计上我们也可以让这门统一语言尽量说人话，从而降低编写的难度与维护的成本。</p><p>而这，其实就是第三代编程语言：高级语言的由来。只不过，在漫长的历史长河中，有太多大能都达成了此共识，其结果就是高级编程语言如雨后春笋般，甚至直到2023的现在还在源源不断的涌现，从古早的BASIC、PASCAL、C、FORTRAN到现在的Go、Rust，它们都是高级编程语言，随着时代的进步，其中难免有一些被环境所淘汰，但也有一些历久弥新，每个不同的高级语言都蕴含了作者独特的审美与对环境生态、软件开发的理解，伴随着社区、使用群体的发展各自开宗立派、培养着自家忠实的拥趸。</p><p>高级语言在设计上大体分为两派：编译型和解释型。前者（比如C、C++）主张对编写的源代码进行前置处理：通过一种叫“编译”的方式把它变成汇编语言，再由汇编器变成机器码，最终在机器上执行，它的核心要点在于：所有代码在一开始就要全部翻译成最终的机器码，运行时直接执行；而后者（比如Ruby，Python、Javascript）则主张后置处理：在运行时通过解释器来一步一步地、当我执行到具体的某一行时，让同声传译把它变成机器码执行，每说一句就翻译一句原地执行。显然，前者把一些重活放在了编译期，得到的好处就是运行时更快，但后者则因为实时处理的模式往往在语法上可以更加灵活。而在高级语言发展过程中，这两派逐渐水乳交融、佛道双修，比如像Java、C#，它们都是半编译、半解释型，再像是Javascript、Python这种一开始做成解释型的，为了能够针对热点代码提速或是公共代码复用，也陆续引入了JIT、预编译的能力。</p><p>总之，高级语言在设计上与自然语言（英语）更接近（可别跟我提易语言，真不熟……），而与硬件功能相分离，便于开发者掌控而屏蔽底层差异。高级语言的优点在于：通用性强、兼容性好、便于移植，但同样的，天下没有免费的晚餐，相比直接写汇编来说其生成的代码更加臃肿，性能上也有所差距。因此像操作系统这种对性能要求苛刻的程序会经常在高级语言里内联汇编代码（通俗理解就是：高级语言的局部嵌入汇编代码，这需要高级语言的支持）来提速。</p><blockquote><p>但另一方面，在2023的今天，现代编译器已今非昔比可谓十分强大，在现代的一些架构上已然抹平甚至超越了使用汇编语言来编写的程序性能（编译器比我聪明系列）。</p></blockquote><h2 id="缘起hello-world">缘起"Hello, world"</h2><p>“Hello,world”之于编程，就好比“衬衫的价格是”之于英语听力。不管你是何门何派、哪个语种，入门的第一站都是"Hello,world"，经久不衰。这一切，都要从此说起：我们意兴盎然的选择了某门语言，开始修炼本门功法，不同门派的功法各有千秋：有些功法小巧精妙(C)，有些功法直捣黄龙(go)，有些功法艰深晦涩(C++)，有些功法必先自宫(Rust)，有些功法大开大阖(Java)，有些功法乱七八糟(你猜我说的是谁？)。</p><p>然而不管我们选择了哪一派，从它变成母语的那一天开始，我们就被深深地打上了相应的烙印。尽管在修炼过程中我们能够解决越来越多的问题，但与此同时它所植入的灵魂烙印也把我们的解题思维牢牢限制在本家系统之内。直到皇天不负有心人，本家功夫大成，我们得以窥探别门别派的心法口诀，坐而悟道。而本门功夫，修炼周期各有长短，这期间一旦受其他门派影响，轻则自我怀疑，重则道心破碎。</p><blockquote><p>有些选择了C语言的小伙伴，学了一年也不会做任何酷炫的app，只会在黑框框里跑四则运算，看到邻家8岁的小男孩都用python写AI画图了，顿时道心破碎，弃C如敝履。</p></blockquote><p>我们现在分别使用C、Java和Python来写一个Hello, world：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, world\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, world&quot;</span>)<br></code></pre></td></tr></table></figure><p>嗯，按照各家功法所述，我们应该分别保存成hello.c, hello.java,hello.py。还记得功法让我们怎么称呼它们吗？对，源文件！这些文件里的内容就是源代码，它们都是文本文件。那么源文件怎么执行起来输出“Hello,world”呢？这个时候，各家功法就有所分歧了.</p><h3 id="c">C</h3><p>C是一门编译型语言，使用C语言编写的hello.c需要经过预处理器、编译器、汇编器、链接器来一步一步处理，最终生成二进制可执行文件，不同平台都制定了可执行文件组织结构的标准，比如在Windows里叫PE(PortableExecutable)，像是我们平时双击的xxx.exe就是典型的PE可执行文件（实际上.sys,.dll也都是PE，前者是内核态所运行的驱动程序、后者是用于共享的动态链接库），而在大部分类Unix系统里用ELF(Executableand LinkingFormat)），它们往往没有后缀名。实际上后缀名只是一种浮于表面的印记，通过盖戳的方式让人类更容易分辨它是一个什么文件，真正决定文件制式的是它的内容信息，图片、视频、文本、可执行文件，他们各有各的标准结构。</p><blockquote><p>既然后缀名只是印记，那岂不是可以用来诱骗？早年的恶意软件、病毒可不就是充分利用了此种手段，整个Windows乌烟瘴气。用户也可以利用这一小手段：比如我上小学的时候，隐藏文件早就不用系统提供的方法了，我会把他的后缀改成其他资源的类型，诶嘿，你打不开了吧！后来到了中学，懂得套路又多了一些，这次就直接打开二进制编辑器，偷偷改掉某某视频的文件头~</p></blockquote><blockquote><p>Mac OS逼格比较高，它的可执行文件格式叫Mach-O（Mach Object FileFormat），是一种类似ELF的制式，iOS也是这套。</p></blockquote><p>也就是说，我们的源代码经过了重重流水线关卡，最终变成可执行文件。现在我来问你，这每道关卡都在折腾啥？相信这个问题应该难不倒有一年以上C编程经验的同学，毕竟C派重视基础，门徒大都喜欢刨根问底。</p><p><img src="2023-04-14-17-16-42.png" /></p><p>一言以蔽之：预处理器负责展开头文件、处理宏；编译器负责将加工后的源文件翻译成汇编语言源代码；汇编器再将汇编语言转化成机器码、生成可重定向的目标程序；最终由链接器整合所有目标程序，按照可执行文件的制式整合成可执行文件。整个过程说起来简单，但其实每一步展开都是宏篇巨幅。作为编程导论，我们暂不去深入了解每一步都是怎么做的，我们的疑问是：为什么需要这几步？如果上面的内容你有认真看过并思考过，那么这个问题的答案是显而易见的：我们需要在设计上分层，每一层各司其职，邻层相濡、隔层相忘。上图的中间部分，从C源代码编译成汇编、再从汇编到机器码这一过程相信通过上文你已经十分理解了，那么剩下的头尾各有什么作用呢？</p><p>先说头部的预处理器：预处理器这一步实际上是C语言特有的，它在设计上有一个头文件和源文件的区分，头文件做公开声明，源文件做内隐实现，你在写代码的时候可以引用别人的代码库，比如hello.c中的printf函数，它在前面通过<code>#include</code>宏引入的<code>stdio.h</code>中声明，作用就是在标准输出按照C-format制式打印字符串。此外，C语言还支持一种被称为宏(macro)的强大功能（宏和指针可谓是C的两大神器，一旦掌握了这两个东西，写起C来可谓运斤成风），宏代码的替换也是在预处理器中完成的，而具体怎么操作，等我们深入学习C语言时再做展开。</p><p>再说尾部的链接器：实际上我们生成的hello.o只包含了在hello.c中书写的单个文件的那部分代码，而对于整个工程项目来说，我们可能会写出一大堆源文件，且除了自己写的代码，可能还需要引用别人的生成代码（标准库或是第三方库，比如例子里的printf.o就是标准库所提供的），而把这些.o文件组织成最终的单一可执行文件，就是链接器的工作。</p><blockquote><p>【进阶】实际上在C语言里，上图的printf函数默认情况下并不是直接通过链接printf.o来使用，C标准库默认以动态链接库的形式存在，在程序被加载器吊起到内存时会挂载所需的动态链接库。当然，这是后话，新人不必急于理解。至于加载器，唔，可执行文件在磁盘里躺着的时候和被加载到内存去执行的时候，结构上还是有些差异的，需要个引导者来做初始化操作。</p></blockquote><p>我们来看看，经过编译器编译之后，生成的汇编源代码长什么样，这里我们选取最新的gcc12.2，先看看在Intel x86-64架构下的生成物：</p><p><img src="2023-04-18-11-52-29.png" /></p><p>当他链接成.o的时候，我们看到的则一般被称为反汇编码：</p><p><img src="2023-04-18-11-47-44.png" /></p><p>相比后者，提供给汇编器的前者一般会有一些脚手架，用来辅助编写汇编程序，比如<code>.LC0</code>部分的数据段，而后者则是CPU在真实执行时的汇编指令，或者这里叫机器指令更合适。每行汇编指令的上面还显示了对应的机器码，这里使用的是十六进制（只是二进制的一种简化写法，相对来说更加友好）显式。这些机器码就是CPU执行时真正的指令，不同的数字就是0和1的排列组合，表示了不同的功能。</p><p>好，让我们换个架构，比如从Intel x86-64换到ARM64，再编译链接一下：</p><p><img src="2023-04-18-11-48-16.png" /></p><p>不同的处理器架构指令集的设计千奇百怪，但是对于编写hello.c的开发者来说，我们完全可以不必理解它们，因为这些工作已经由翻译们（编译器）完成了。</p><h3 id="python">Python</h3><p>Python是一门解释型语言，前面也提到过，解释型语言是聘请了个同声传译，在代码运行时实时翻译成所在架构的机器码，而这个同声传译在这类语言里一般被称为虚拟机(VM,VirtualMachine)或是执行引擎（比如Javascript的V8引擎）。当我们在终端执行pythonhello.py时，会直接在终端打印出"Hello,world"，他不需要像C语言那样要先编译再执行本体："gcc hello.c -o hello&amp;&amp;./hello"，而是直接把.py文件作为参数传给python解释器，python解释器会先把<code>print('Hello, world')</code>翻译成字节码(Opcode，也叫操作码，在Python的世界里指<code>PyCodeObject</code>)，再由VM解析字节码实时变成机器码。</p><blockquote><p>字节码不是机器码，它是一些解释型语言在更上层制定的语法规则，它们一般类似机器码也有着像汇编那样的助记符，但所有平台通用（相当于也是个中间层，字节码到机器码的翻译交给了平台上具体的虚拟机）。</p></blockquote><blockquote><p>【进阶】Python代码执行一般来说经过以下四步：1.将源代码解析为解析树(ParserTree)；2.将解析树转换为抽象语法树(Abstract SyntaxTree)；3.将抽象语法树转换到控制流图(Control FlowGraph)；4.根据流图将字节码(bytecode) 发送给虚拟机(VM)。</p></blockquote><p>我们看下hello.py在执行时首先被翻译成的字节码：</p><p><img src="2023-04-18-16-34-08.png" /></p><p>是不是和汇编助记符很像？其实本质上都是一个思想，只是所处的层级不同罢了。</p><p>还记得解释型语言相比编译型语言的劣势吗？没错，运行时速度慢！毕竟你同声传译再强，也打不过提前抄标准答案的作弊狗（2023的今天，这话其实也不绝对了，解释型甚至也可以进行实时优化，根据运行时更丰富的信息生成更高效的代码，性能甚至超越编译型）。</p><blockquote><p>Python其实一开始被作者设计出来的时候，仅仅只是当做一个玩具，万万没想到的是，其简约极致的风格收获了大批粉丝，无数大佬先辈把python社区经营的如日中天，随着历史发展，python的语言生态逐渐丰富起来，就像是滚雪球一样，python最终承受了他原本不该承受的国之重任。</p></blockquote><p>就像C可以引用公共库一样，python也有公共库，只不过在python的世界里这叫做“包（package）”，当你需要使用其他人的函数方法时，只需要在文件头去<code>import xxxx</code>即可，这就和C的<code>#include &lt;xxx.h&gt;</code>有异曲同工之妙。为了能够提速，python把可以复用的包在首次执行时翻译生成的字节码转储(dump)到同名的<code>.pyc</code>后缀文件里，嗯，这里面涉及了工程的另一个思想本质：缓存、空间换时间。</p><p>所以你看，解释型和编译型的界限在2023的今天已经不是那么泾渭分明，虽然python是一门解释型语言，但到处都有编译型的影子。</p><h3 id="java">Java</h3><p>Java相比Python，从一开始的设计上就显得更理直气壮了：老子就是半编译、半解释型，你能咋地？Java也使用虚拟机（大名鼎鼎的JVM,Java VirtualMachine）和字节码的概念，我们编写的hello.java源文件首先会经过编译(<code>javac hello.java</code>)，生成完整的字节码，它被转储到文件<code>.class</code>后缀同名文件，Java编译过程并不会直接生成可执行文件，而是在运行时通过<code>java hello</code>来去自动加载所需的<code>.class</code>并通过JVM去解释opcode，最终转换成特定平台的机器码。</p><p><img src="2023-04-18-17-01-09.png" /></p><p>比如上图是一个可视化的Java字节码，它以二进制的形式存储到<code>.class</code>中。</p><p>所以Java在江湖上有一句经典口号：一次编译，到处运行！实际上，这就得益于其半编译、半解释的设计，我们在任何平台上都可以先运行编译器把它转成字节码，然后你可以随便拷贝到任何架构上，让特定的架构的JVM充当同声传译，把字节码转成相应的机器码（话虽如此，但也有水土不服的情况，毕竟理想很丰满，厂商很骨感）。</p><h3 id="小结">小结</h3><p>实际上所有的高级语言设计上都可以抽象成这样一个模型：</p><p>Source code ---&gt; |Compiler| ---Mid code---&gt; |Runtime| &lt;---Lib</p><p>只不过不同语言各有取舍，每一环节的任务或轻或重罢了。</p><h2 id="文本文件二进制文件">文本文件？二进制文件？</h2><p>上面我们曾频频提起文本文件和二进制文件，比如我们说源代码都是文本文件、生成的可执行文件、转储的字节码文件则都是二进制文件。那么二者到底是什么，又有何区别呢？不急，我们先思考这样一个问题：你编写的这些源代码，它们是怎么存放在存储媒介（比如硬盘）的呢？计算机的世界都是0和1，那么每一个字符、每一个汉字都是怎么对应到具体的0和1呢？</p><p>如果你理解了前文，那么相信聪明的你已经想到了答案：如法炮制，无非也是制定一个规则，给每个字符都映射一个0和1的排列组合嘛！没错，实际上，这一思想应用在这里，就叫做：“编码”。</p><h3 id="编码从ascii到utf8">编码：从ASCII到UTF8</h3><p>计算机是美国人发明的，美国人说英语，他们在设计之初为了满足自身使用需求，搞了一套如今广为流传的ASCII（AmericanStandard Code for Information Interchange,美国信息交换标准代码）码。</p><p><img src="2023-04-19-11-28-24.png" /></p><p>整张映射表对128个字符进行了编码，这其中包括了阿拉伯数字、26个英语字母的大小写、各种普通符号以及一些不可见的控制字符。比如大写字母A对应的ASCII码是65（二进制表示为B0100001），阿拉伯数字0的ASCII码是48（二进制表示为0110000），其他像是空格(SP)、换行(LF)等普通符号与不可见字符也有对应的映射码，它们在表中以大写名称标注。</p><blockquote><p>【维基百科】:ASCII由电报码发展而来。第一版标准发布于1963年，1967年经历了一次主要修订，最后一次更新则是在1986年，至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符。用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。</p></blockquote><p>由于一共是128个字符，这个量级刚好是2的7次方，换算成2进制的话也就是说至多需要7个二进制位（也叫bit），从B0000000一直到B1111111（这个B前缀是用于表示二进制binary）。为了方便说明，人们一般从低位到高位把每一位进行标号，对应到上图就是b7~b0。</p><p>随着计算机在世界范围的普及，ASCII的128个字符就显得捉襟见肘，在流传到一些西欧国家后，大家开始了整活儿，既然128个不够用，那我就扩展一下，加个倍，变成256个总够了吧。嗯，人性都是狭隘且自私的，愚蠢的西方人于是搞了一套EASCII(ExtendedASCII)出来，在ASCII的基础上又新增了128个字符（从B10000000到B11111111）用于表示西欧语言的特有字符，包括表格符号、计算符号、希腊字母和特殊的拉丁符号。虽然EASCII解决了部分西欧语言的显示问题，但世界可不止你西欧和北美。一旦把视角切到古老的东方，这些狭隘的编码手法在浩如烟海的象形文字面前显得是那么脆弱，那么的不堪一用。于是乎，在这段历史长河的至暗时刻，大大小小的国际组织、国家都在ASCII的基础上衍化出自己的编码标准，因编码不同而导致的水土不服问题频出。</p><p>比如在中国，先后曾衍生出GB2312、GBK、GB18030的编码，这类编码的设计思想就在于：基于128个ASCII，向上扩展到2个字节来表示中文、数学符号、罗马希腊字母、日文假名等等，而128个ASCII则原封不动还是用1个字节来表示，而这就是输入法常提示的全角与半角的由来。</p><p>终于，美国人意识到了ASCII设计之初的狭隘，几经辗转，有一个在加州的组织制定了全球统一的编码规则——Unicode(中文名称为统一码，又译作万国码、统一字元码、统一字符编码)。现在的软件系统大多采用Unicode，如XML（ExtensibleMarkupLanguage，可扩展置标语言）、Java都默认采用Unicode，Unicode不是一种特定的编码，而是更上一层的编码规则，向下有多种具体的编码格式，如今最常用的就是向下兼容ASCII的UTF-8以及和UCS-2兼容的UTF-16。</p><blockquote><p>Unicode一经问世，备受认可，为ISO纳入国际标准，成为通用字符集，即ISO/IEC10646（ISO老白嫖怪了，经典操作：方案是你的，但标准我来制定，谁叫你Unicode组织只是个商业机构呢）。</p></blockquote><p>纵观历史长河，我们发现ASCII编码的核心问题在于表示每个字符的bit位太少，所以各种扩展编码都进行了加倍甚至超级加倍的动作，只不过大家的映射表都是自制，因此可能同一个字符在不同编码映射表里的值并不相同，所以当鸡同鸭讲时、鸭听到的全是乱码，这是任由扩展而带来的衍生问题。Unicode大一统后，一概使用一致的字集编码。Unicode默认采用的编码是UCS-2，它采用16位的编码空间（也就是每个字符占用2Bytes，最多可表示2^16=65536个字符），事实上6w+的字符量已经足以cover全球主要语言的大多数字符，但unicode还是提供了一个扩展机制，允许表示一百多万个字符（还能怎样，2个字节不够，那就3个，3个不够就4个）。</p><p>为了能够兼容ASCII，像是英文字母“A”，它的ASCII值是65（十六进制表示是0x41,0x是十六进制hex的前缀），用unicode编码时我们保证其值不发生改变，由于UCS-2是16位，那么高位就用0填充，写成：U+0041。值是相同的，唯一的区别在于，从1个字节变成了2个字节，体积膨胀了一倍。至于各种其他乌七八糟的字符，我们预先按区间划分做dispatch即可，比如中文“一”对应的值是U+4e00（十进制就是19968），舒服了。</p><p>UCS-2在设计上和ASCII一样，都是定长编码，其带来的问题就在于对于那些一个Byte（8bit）就足以表达的字符，我们不得不用两个Bytes来存储，这会导致存储上的冗余（存了太多不必要的0x00）。而另一方面，由于像是ASCII囊括的那些字符，往往在日常工作中都是高频出现，这就会进一步加剧存储上的冗余。</p><blockquote><p>现代存储单元的最小单位一般是Byte(字节)。</p></blockquote><p>那么怎么办呢？我们发现罪魁祸首在于UCS-2是定长的，如果我们能设计一种变长的编码，也就是可长可短的编码方式，这个空间浪费问题不就迎刃而解了吗？</p><p>但是使用变长又会引入新的问题：我怎么知道这一次解码时，是该取长度1还是长度2呢？所以我们需要制定一种规则，让解码的时候有迹可循。比如，我们设计这样一系列规则：</p><ul><li>对于单Byte字符，8bit位中最高位必须等于0（ASCII只有128个嘛，这点可以办到）</li><li>对于需要N Bytes的字符：<ul><li>首个Byte：<ul><li>高位前N位为<code>1</code></li><li>第N位为<code>0</code></li></ul></li><li>其余Byte：<ul><li>高位以<code>10</code>开头</li></ul></li><li>未提及的位使用对应的unicode补充，不足的在高位用0补充</li></ul></li></ul><p>实际上这就是UTF-8编码，文字说起来很抽象，用图表展示会更直观：</p><p><img src="2023-04-19-15-40-11.png" /></p><p>经过这种方式，我们在解码时就可以根据第一个Byte的控制头来识别到底是要连续读入几个Byte，又要怎么把他们还原成原始code。那么现在我有个问题留给你思考：为啥其余Byte也要安排个<code>10</code>控制头呢？</p><p>经过UTF-8编码，我们的字符就变成了这样：</p><p><img src="2023-04-19-15-41-03.png" /></p><blockquote><p>除了UTF-8以外，还有其他的编码方式，比如UTF-16（2或4字节变长）、UTF-32（4字节定长）。</p></blockquote><p>细心的读者可能会发现这样一个问题：变长编码虽然解决了单字节变双字节存储冗余的问题，但由于控制字符的存在也引入了额外成本，一些字符可不仅仅是2个字节，而是3个甚至是4个（比如汉字通通都是3个），而这对比UCS-2或者是像中文的GB2312,GBK,GB18030来说，对于存储汉字实际上也是会造成冗余的。</p><p>UTF-8确实有着这一问题，但其设计实际上是早期互联网传输的带宽限制与国际字符互通的双向妥协（彼时本地存储的价格已经被降得很低，不再成为瓶颈）。因此，在2023的今天，你可能还能找到一些使用GBK等中文字符集的场景（比如MySQL），甚至可能还会有C语言遗老跟你讲strlen和中文字符长短的故事。毕竟对于包含大量中文的文本文件，使用GBK编码相比UTF-8确实能省近乎1/3的存储空间。</p><h3 id="文本文件">文本文件</h3><p>使用各种编码编写的文本，存储到文件里，这个文件就被称作“文本文件”。我们平时使用编辑器去展示和修改文本内容，实际上这一过程都是经过编解码处理的（你书写的字符经过编码存储到底层文件，编辑器把文件里的数据解码成字符显示出来）。一些常用编辑器乃至IDE(IntegratedDevelopment Environment,集成开发环境)都有选择使用何种编码的功能，即使是Windows的记事本也有着多种编码供你选择（其中就包括UTF-8）。</p><p>如果我们使用二进制编辑器打开编写的hello.c，就会看到磁盘里存储的实际上正是编码后的01序列。</p><p><img src="2023-04-19-17-28-53.png" /></p><h3 id="二进制文件">二进制文件</h3><p>除了文本文件以外，其他文件都是二进制文件。实际上二者本质并没有什么不同，你完全可以把文本文件当成一种特殊的二进制文件，业界之所以有这样的流行概念来加以区分，无非是因为很多标准、API的设计木已成舟，比如C标准库和POSIX的文件接口设计，就有着针对二者的区分。</p><p>每种不同的二进制文件都有着自己的格式，比如前文所讲的：hello.c编译链接生成的二进制可执行文件就有着自己的格式。</p><p><img src="2023-04-19-17-32-11.png" /></p><p>二进制编辑器毕竟不是可视化的，对于不同种类的二进制文件一般需要特定的编辑器才能可视化，比如图片也是二进制文件，但像是PhotoShop、美图秀秀这类可视化编辑软件却可以呈现图片的内容，这一过程本质上和文本编辑器打开文本文件没有什么区别。我们用二进制编辑器打开上面的图片，看看它里面的数据：</p><p><img src="2023-04-19-17-33-41.png" /></p><p>肉眼根本无法理解，我们没办法直接从这些二进制数据在脑海中还原出它是怎样的一张图，只能隐约看到一些“性状特征”：比如有个png字符躺在最前面，它其实是png类型文件的标志头。</p><blockquote><p>电影《黑客帝国》的大佬可是手改二进制，大脑里自动还原成小电影的哦，恐怖如斯！</p></blockquote><h2 id="机器码执行简述">机器码执行简述</h2><p>一个经典的硬件系统组成结构如图：</p><p><img src="2023-04-20-11-58-13.png" /></p><p>我们的程序被操作系统加载到内存之后，最终的机器码是交由CPU来一条条执行的。这些机器码在可执行文件中也以数据的形式存在（遵循冯诺依曼架构）。CPU内部被拆分成控制单元、运算/逻辑单元(ALU)和寄存器(Register)，ALU负责计算、寄存器负责暂存数据、控制器负责在内存、总线和寄存器之间传递数据。内存是一种临时的存储设备，关机之后它的数据会全部丢失，而我们的程序字节码平时是躺在可执行文件中寄放在硬盘上的，硬盘是一种持久化的数据存储，关机并不会擦除已经写入的数据。因此，在计算机运行期间，加载器把可执行文件加载到内存（当你双击打开exe的时候），里面的机器码通过总线送到CPU的ALU，然后一条条指令执行下去。</p><blockquote><p>【维基百科】冯·诺伊曼结构（英语：Von Neumannarchitecture），也称冯·诺伊曼模型（Von Neumannmodel）或普林斯顿结构（Princetonarchitecture），是一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构。存储程序计算机在体系结构上主要特点有：1.以运算单元为中心2.采用存储程序原理 3.存储器是按地址访问、线性编址的空间4.控制流由指令流产生 5.指令由操作码和地址码组成 6.数据以二进制编码</p></blockquote><blockquote><p>为什么内存不做成持久化的呢？一方面是成本问题，另一方面则是没有必要。内存相比机械硬盘哪怕是固态它的速度完全不在一个量级上，像我们的PC，硬盘动不动就1TB、2TB，但内存可能只有16GB、32GB。DRAM的随机读取要比你SATA的随机读取快上1000倍。</p></blockquote><p>那么为什么需要寄存器呢？答案很简单：要提速。尽管内存相比硬盘，它的速度快上了好几个量级，但是对于以纳秒为量纲的现代处理器来说，完全不在一个次元。因此CPU会设计出或多或少的寄存器在内存和ALU之间传话（如果说ALU是皇帝，内存是大臣，那么寄存器就是太监），不同的CPU架构有着不同数量的寄存器，每个寄存器都有它自己的用途，而寄存器的大小则取决于总线的宽度（也就是你一次性最多能传输多少bit数据），比如对于64位系统来说，寄存器的存储空间就是64bit=8Bytes大小。寄存器相比从内存读取数据还要再快上100倍（在2023年的今天，可能远远不止100倍了），但寄存器毕竟存储量级受限于总线宽度与个数，从制作成本和设计上来讲，想要完全通过寄存器来满足针对内存使用上的提速是远远不够的。那怎么办呢？既然寄存器造价太高，我们何不找个折中的法子：做一个中间缓存层，挑一种比DRAM更快且比寄存器更能吃的硬件如何？而这就是现代处理中颇为重要的一个概念：高速缓存。</p><p>高速缓存采用的是一种叫SRAM的存储媒介，相比DRAM它的速度更快但相应的造价也更高。而这一中间层能够起到高额的缓存命中率，本质上的原因在于：我们CPU去执行的指令或者取的数据往往都具有局部连续性，比如一大段机器指令是加载到连续的一段内存，所以在CPU通过总线去取某一条指令的时候，实际上会一次性批量把连续的内存数据（此时就是连续的机器指令）全部拿到并置入高速缓存，等到我们需要继续执行下一条机器码指令时，缓存直接命中进而达成提速的效果。</p><p>实际上现代处理器不仅有缓存，甚至是多级缓存，比如经典的三级缓存模型：</p><p><img src="2023-04-20-15-39-36.png" /></p><p>自顶向下容量逐渐增大，访问速度也逐渐降低。当缓存未命中时，缓存系统会向更底层的层次搜索。</p><ul><li>L1 Cache：在CPU核心内部，分为指令缓存和数据缓存，分开存放CPU使用的指令和数据；</li><li>L2 Cache： 在CPU核心内部，尺寸比L1更大；</li><li>L3 Cache： 在CPU核心外部，所有CPU核心共享同一个L3缓存。</li></ul><p>越顶层的缓存为了提升命中率，功能分类会越细致，层层漏斗下去，最终走到内存。整个计算机系统的存储设备可以组织成一个金字塔型：</p><p><img src="2023-04-20-15-49-24.png" /></p><p>这一张图可谓是把工程实践中“分层”与“缓存”的概念发挥得淋漓尽致。</p><h2 id="操作系统眼里的程序">操作系统眼里的程序</h2><p>一个程序从编写到执行的整个过程，目前就仅剩一个环节就可以完整的自顶向下串起来了，那就是：程序从磁盘上加载到内存的过程。这一步骤由操作系统的加载器完成，它会把躺在硬盘上的可执行文件加载映射到内存中，作为一个独立的进程存在，拥有着自己独立的虚拟内存地址空间。</p><h3 id="进程process">进程(Process)</h3><p>这里就提到了一个在操作系统中非常重要的概念：进程。我们在学操作系统这门课时，老师往往要求熟读并背诵这样两个概念：进程是资源分配的基本单位；线程是任务调度和执行的基本单位。这两句真言本身并没有错，但对于初学者来说确是难以理解的学术派黑话。什么他么资源分配、任务调度，究竟到底什么是进程？</p><p>我们来打个比方：可执行文件躺在硬盘里的时候，你可以把它看成是一种被冻结的生命模板，而在加载到内存后，模板被唤醒克隆出一个新的生命。每个生命体都是一个进程，进程在操作系统里有着唯一的ID标识，同一个生命模板也可以被加载多次，但是它们每次克隆出的都是新生命，彼此隔离。进程实际上是操作系统对一个正在运行的有生命的程序的一种抽象，为什么说它是资源分配的基本单位呢？因为在现代操作系统中，每个进程都有独立的虚拟内存地址空间（当然，不止这一种资源），站在每个进程的第一人称视角来看，它都在独占硬件（处理器、内存和I/O设备），进程之间彼此隔离，谁也看不到谁，只有操作系统才知晓所有进程的存在。</p><p>但是我们知道，硬件设备是唯一的，内存需要大家共享，CPU即使有多核，它的核数也是先天锁定的（你总不能说我CPU就8核，那进程只能有8个吧）。当我们把视角从进程第一人称切到上帝（操作系统）视角来看，就会发现其实每个进程都在交错、并发执行（也就是说轮换着共用多个CPU核）。为什么说是既交错又并发呢？因为进程数往往是远超CPU核数的，所以当多个进程同时在运行的时候，操作系统就得通过某种策略去调度分配，比如我一共有8核，那么在t0时刻，就会有8个进程在同时运行，而等到t1时刻，可能相比t0发生了轮换，此时是另外8个进程同时运行（可能和t0的8个有重叠：可能是连续执行了完整的duration，也可能是被换出之后又换入）。</p><blockquote><p>简单来说，CPU有多少核，就支持同时执行多少条指令。虽然这样说并不严谨，毕竟现代CPU往往有线程超卖的设计，但不妨碍理解。</p></blockquote><blockquote><p>不同类型的操作系统有着迥然不同的调度策略，类型上一般是分为实时操作系统和分时操作系统。我们平时使用的大部分OS像是Windows，Linux都是分时操作系统，它们有时间片的概念，时间片到期或进程(线程)主动让出的时候会让给其他进程(线程)。</p></blockquote><p>而内存则一般是做了一层从物理内存到虚拟内存的映射，操作系统会欺骗每个进程：你们都在独立使用整块DRAM（甚至超卖，比如对32位系统来说有4GB大小的虚拟内存空间，但物理内存DRAM可能只有2G），而只有在进程真正去读写某一小块特定的地址时，操作系统才会真正把物理内存交给你使用。</p><h3 id="虚拟内存线性地址空间">虚拟内存：线性地址空间</h3><p>虚拟内存空间按地址进行索引，整片空间是连续线性的，而地址空间的大小取决于系统位数，对于32位机器来说，这个大小就是4GB，对于现如今最常见的64位机器来说，大小甚至达到了256TB。</p><p><img src="2023-04-20-19-36-33.png" /></p><p>比如上图是一个进程在32位Linux系统上的线性地址空间图，它被分割成了多段，每一段存放特定的资源，比如：代码段（也就是你程序编译链接后的机器码）、数据段、堆(Heap)、栈(Stack)等等。整个寻址空间有4GB的大小，地址范围从0x00000000到0xffffffff。</p><blockquote><p>【进阶】在32位Linux上默认情况下高1GB是内核空间，所有进程共享。低3GB才是进程在用户态可用的线性地址空间。Windows上则默认是高2GB为内核空间，嗯，Windows内核真大。</p></blockquote><h3 id="线程thread">线程(Thread)</h3><p>实际上并发执行并不仅限于多个进程，在现代操作系统中，每个进程内部其实也可以并行执行多个任务，而这，就引出了线程。进程可以管理多个线程，每个线程负责一条控制流，它们共享所属进程的同一片线性地址空间（也就是说彼此天然就看得见），但各自有着私有的资源（比如每个线程都有自己的Stack）。对于那些只有一条控制流的进程，进程或是线程的概念可能显得没那么重要，事实上进程和线程只是现代操作系统抽象出的概念，它们在不同的操作系统里的设计各有差异，在Windows中，进程和线程可以说是一板一眼，进程就是个空壳子，对于那些只有一个控制流的进程它们默认会有一个主线程。而在Linux中情况就比较复杂，进程和线程的概念受历史原因有过多次改版升级，所以并不像Windows那样纯粹。</p><blockquote><p>【进阶】Linux内核弱化了进程、线程的概念（不像Windows进程严格管理线程，调度单位只能是线程，弱化了进程父子关系，使得进程看起来可以通过CreateProcess凭空捏一个出来），内核都是task_struct统一管理，比如<code>vfork()</code>出来的轻量级进程甚至可以与其他进程共享线性地址空间（只不过有个额外标志）。由于历史原因，Linux也遵守了真香定律。以pthread的两种实现LinuxThread（Linux2.4以前）和NPTL（2.5以后）为例，早期内核是没有TGID的，只有PID，所以内核根本就没有线程的概念，在内核眼里都是进程，都是调度器调度的单元，而这就给LinuxThread的实现带来了难题——LinuxThread采用1:1模型，即每个线程都是LWP对应一个内核线程（这个线程的概念是从我们的视角出发的）。而NPTL时代，内核引入TGID，此时依然是1:1模型，但不是简单的LWP了，TGID把这些线程联系了起来，NPTL创建线程时传递一个特有的CLONE_THREAD标志，内核把TGID填写为调用者的PID，PID填写新线程号（原本的进程号）。</p></blockquote><p>为了便于理解，我们采用Windows的视角，统一把线程视为执行流，进程视为管理员。因此CPU核的切换实际上是发生在线程上的，那么线程1是怎么切换到线程2上的呢？我们之前说切换的动作需要内核代码来做，内核代码是运行在内核态的，而我们的代码运行在用户态，怎么就跑着跑着就丢了，就执行到内核的切换代码去了呢？</p><p>事实上，每一个用户态的进程在运行时都会经常进入到内核态，当我们调用了一些系统调用(systemcall)的时候，就会从用户态切换到内核态，比如我们的程序进行了文件I/O、网络I/O、各种资源申请等等操作（一般会引起阻塞）时都会发生这一切换，在内核态想要切换回用户态的前夕，根据操作系统的类型以及调度策略，会去判断是否要将当前所用的CPU核轮换给另一个嗷嗷待哺的线程（比如时间片过没过期啊，优先级啊等等）。</p><p><img src="2023-04-20-20-14-56.png" /></p><p>你可能会问，假如我写个死循环在那里空转，我绝对不自己触发系统调用，那我的CPU核不就没机会让出去了吗？虽然你的想法很危险，但这确实是一个好问题。实际上，现代操作系统内核里还有个特等公民：中断。中断优先级高于内核线程，一旦发生了中断那么一定得让出一个CPU核来立即响应（中断在内核态的地位就好比Linux系统里信号在用户态的地位）。中断处理告一段落后，才会返还给内核线程，此时就产生了线程切换的时点。中断有很多种，这其中用于保证现代操作系统能够进行线性调度的那位爷叫”时钟中断“，时钟中断会通过硬件定时产生，所以年轻人，躲得了初一、躲不了十五。</p><blockquote><p>还有个缺页异常(PageFault)中断也很重要，它是实现每个进程的虚拟内存地址空间的基石，日后我们讲具体的操作系统时再做展开。</p></blockquote><h3 id="通信与竞态">通信与竞态</h3><p>同一个进程下的多个线程彼此是看得见的，因此它们完全可以在用户态互通往来，A1看得见A2，A2也看得见A1，但是A1和A2都无法看见另一个进程B下的B1,B2...另一方面，并发相比单一执行流虽然效率上成倍增长，但也带来了一个新问题：竞态(RaceCondition，也程竞争条件、竞争冒险)，它旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。此词源自于两个信号试着彼此竞争，来影响谁先输出。当线程A1和线程A2同时试图修改一块内存，在没有并发控制的情况下，最后的结果依赖于两个进程的执行顺序与时机，并发访问冲突可能会导致最后的结果不符合预期。</p><p>那么怎么解决竞态问题呢？这就需要我们对共同访问的资源（一般被称为临界区）进行互斥保护，操作系统API乃至一些现代高级语言本身都提供了各种保护的手段，归纳来讲其实就两种思路：”上锁“和”执行不可打断“。锁的设计多种多样，它的思想就是：卫生间就一个，你先进去了就要锁门，防止别人在你答辩的时候误入。等你舒服了之后，锁才会被释放，其他人才有机会使用。而所谓的执行不可打断，就是指我整个过程一气呵成，从所有人的视角看整个动作都是一瞬间完成的，不会被中途打断，也就从根源上避免了竞态，我们一般称其为”原子操作“（这一命名较为古老，是取原子为最小单元不可再拆分之意）。</p><p>当然竞态不一定非要是多核环境下才能触发，即使你只有单核，但是由于CPU轮换调度机制，你的线程A1完全可能在临界区操作中途被打断，换给了A2，而A2又进入了临界区开始操作，此情此景亦会产生竞态。</p><p>实际上我们把镜头拉起，除了同一进程下的多个线程可能会发生竞态以外，即使是多个进程之间也可能会产生竞态。尽管进程之间彼此看不到（主要是看不到彼此的地址空间和独有资源），但它们可能会共同修改同一个磁盘上的文件，我们回过头思考：线程之间的竞态解决本质上是靠线程之间彼此的交互来达成的，这对于进程来说也是一样，但进程天然彼此隔离，所以就需要操作系统去提供一些通信的手段来让进程之间也能互通往来，而这就是大名鼎鼎的IPC（Inter-ProcessCommunication, 进程间通信(Inter-ProcessCommunication)）。进程通信手法多种多样，具体则视操作系统的实现，日后我们有机会讲某一个操作系统时再做展开。</p><blockquote><p>当然，进程通信并不只是为了解决竞态，它原本的目的就是通信本身。不同进程、或是相同程序的不同进程实例之间需要交流的场景非常繁杂，甚至并不局限于同一台机器，即使是两台机器之间，也可以通过网络I/O来达成RPC(RemoteProcedure Call,远端过程调用)。RPC这一概念在2023的今天相当流行，毕竟微服务盛行，服务与服务之间都是通过RPC请求来做server/client级联交互。</p></blockquote><blockquote><p>相对于RPC的是LPC(Local ProcedureCall，本地过程调用)，也就是同一台机器不同进程之间调用（A进程调用B进程的某个接口），只不过LPC的工作都是由IPC完成的（可以这样理解：LPC和RPC在概念上都属于上层，而IPC则是一种实现机制，是底层基础，甚至类Unix系统里都抛弃了LPC的概念，它们认为RPC是LPC能力的超集）。</p></blockquote><h3 id="协程coroutine">协程(Coroutine)</h3><p>协程（Coroutine，也称作微线程（micro-thread）、纤程(fiber)）是近些年才兴起的概念，简单来说，它是一种用户态的轻量级线程。线程是操作系统的概念，物理CPU的调度是在线程之间进行轮转切换，前面我们有提到：CPU在线程之间的切换需要有一个从用户态陷入到内核态的过程，而这个过程实际上是有较高的开销的。另一方面，尽管多线程可以成倍提速（比如对于服务器来说，每个请求进来我都开个线程单独处理），但因线程本身占用资源较多，在系统内受物理资源(CPU核数、内存)限制，数量并不是多多益善（像是服务器一般要做池化管理）。而协程相比线程来说，在面向高并发场景的服务器开发来说，其天然的特性得到了发挥，相比线程具有相当的优势。</p><p>在2023的今天，许多高级语言都内置了协程的能力，像是C++、Python，甚至像Go语言天然就基于协程来编程。</p><blockquote><p>C++在20标准通过了无栈协程coroutine，但仅仅包含了编译器需要实现的底层功能（语法上形如co_awaitbalabala...），通用API的实现Executors已确认会在23标准纳入，同时还会纳入networking库。</p></blockquote><blockquote><p>Python从最初的半协程：生成器yield到asyncio、async/await、asynico，协程的体系不断被完善。</p></blockquote><p>协程之间的切换在用户态完成，并不会陷入到内核，且协程本身占用资源较少，这在异步编程的场景中，极大地节省了开销、提高了性能，于此同时，在大部分编程语言中，协程由于其可以采用结构化并发的编程技法，使得相比传统编写异步代码的CallbackHell或是Promise/Future来说，编写得到了简化、代码可读性与维护性也更高。</p><p>当然协程本身的实现颇为复杂，想要对协程有深刻的理解需要具备相当的异步编程经验（常见于服务器后台网络编程），作为编程导论，我们浅尝辄止，留待日后专题展开。</p><h2 id="总结">总结</h2><p>系统漫游作为开篇第零章，旨在让每一位开发者对自己在用的计算机有一个宏观的、整体能够衔接上的理解。本文谈及的知识点涉及了计算机的基本组成、操作系统、编程语言等专题，通过抽丝剥茧、层层递进的方式带领读者步入编程世界的大门。我们在学习一门技法的同时，一定要养成思考的习惯，如此方能将杂糅零碎的知识点拼凑成完整的体系结构，知其所以然。一旦知识体系成型，日后对于新知识的吸纳将显得顺理成章、自然而然，疑难杂症的排查亦可心中有数、有迹可循。</p><p align="right">by 玉涵，完稿于2023年4月22日深夜，雨</p>]]></content>
    
    
    <categories>
      
      <category>编程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>格物致知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++模板从入门到劝退(2)——型别推导、万能引用与完美转发</title>
    <link href="/2022/06/07/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(2)%E2%80%94%E2%80%94%E5%9E%8B%E5%88%AB%E6%8E%A8%E5%AF%BC%E3%80%81%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    <url>/2022/06/07/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(2)%E2%80%94%E2%80%94%E5%9E%8B%E5%88%AB%E6%8E%A8%E5%AF%BC%E3%80%81%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述严谨性，按照笔者的归纳方式穿针引线，为痴迷于黑魔法而又始终不得其解的同学打通任督二脉。</p><p>本篇是走进模板世界的最后一道前菜，通过型别推导、万能引用与完美转发这三个C++11所引入的新机制，我们得以对模板的世界管中窥豹。</p><span id="more"></span><h1 id="型别推导万能引用与完美转发">型别推导、万能引用与完美转发</h1><p>上一讲的最后我们提到了一种特殊的引用类型：万能引用(UniversalReference)，万能引用虽然长得很像普通的右值引用，但二者却有着本质差别。万能引用是形如<code>T&amp;&amp;</code>的引用类型，当且仅当<code>T</code>的型别需要被直接推导时，万能引用的最终类型判定需要介入引用折叠规则，虽然上一讲我们有提到，但却浅尝辄止。而说到型别推导(TypeDeduction)，这是一个迷人且拥有非常复杂的判定规则的设定，在传统C++中，它始终和模板一起出现，因此传统的C++开发者即使对模板望而生畏、不了解型别推导也不会在日常开发工作中因此而困扰，而C++11引入了<code>auto</code>和<code>decltype</code>关键字，将型别推导的作用放大到开发者的日常中，至此，在现代C++开发中，开发者或多或少都需要亿点点型别推导的知识。</p><blockquote><p><code>auto</code>这个关键字早就存在（从C语言继承过来的legacy），但是在现代操作系统中这玩意毫无卵用，C++11罕见的废弃了<code>auto</code>原本的语义而重新定义了它，要知道，C++可是个相当保守的老顽固。</p></blockquote><h2 id="函数模板实参推导">函数模板实参推导</h2><p>回想一下传统C++中的函数模板实参推导(Function Template ArgumentDeduction)，一个函数模板想要实例化出具体的函数需要确定所有的模板实参，而这里的确定一般有两种手法：一种是显式地指定；另一种是让编译器根据上下文自行推断。实际上这两种手法也常常混用，即函数模板实参的确定由二者共同完成。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里只做了模板声明，省略了定义，这里只是为了做推导演示</span><br><span class="hljs-comment">// 但我们要知道：函数一旦需要执行的话，那么其定义是必不可少的</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> To, <span class="hljs-keyword">typename</span> From&gt;</span><br><span class="hljs-function">To <span class="hljs-title">convert</span><span class="hljs-params">(From f)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">int</span>&gt;(d);    <span class="hljs-comment">// 需要实例化出int convect&lt;int, double&gt;(double)&#123;...&#125;</span><br>    <span class="hljs-type">char</span> c = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">char</span>&gt;(d);  <span class="hljs-comment">// 需要实例化出int convert&lt;int, char&gt;(char)&#123;...&#125;</span><br>    <span class="hljs-built_in">int</span>(*ptr)(<span class="hljs-type">float</span>) = convert; <span class="hljs-comment">// 需要实例化出int convert&lt;int, float&gt;(float)&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这就是一个显式指定 +型别推导的例子，第一行我们仅指定了<code>To</code>为<code>int</code>型，<code>From</code>则根据传入的参数<code>d</code>被编译器推导成<code>double</code>型，它与<code>d</code>的类型一致。第二行与第一行类似，只不过显式指定的<code>To</code>类型是<code>char</code>。第三行则有些不同，它定义了一个型别为<code>int(*)(float)</code>的函数指针变量<code>ptr</code>，使其指向<code>convert</code>函数，这里<code>To</code>和<code>From</code>都需要编译器来做推导，根据函数指针类型，分别将<code>To</code>推导成<code>int</code>、<code>From</code>推导成<code>float</code>。<code>ptr</code>实际指向的是函数模板<code>convert</code>实例化出的形如<code>int convert&lt;int, float&gt;(float)&#123;...&#125;</code>的函数，而非<code>convert</code>本身，我们知道函数模板本身只是模板，是没有实体对象的。</p><blockquote><p>该例出自https://en.cppreference.com/w/cpp/language/template_argument_deduction，道行够深的同学一定要通读。</p></blockquote><p>如果将上例中的<code>To</code>和<code>From</code>顺序颠倒，会发生什么事呢？由于模板参数<code>To</code>并没有出现在函数的参数列表中，故某些情况编译器无法通过上下文来推导出<code>To</code>的类型，我们只好这样来写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> From, <span class="hljs-keyword">typename</span> To&gt;</span><br><span class="hljs-function">To <span class="hljs-title">convert</span><span class="hljs-params">(From f)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;(d);    <span class="hljs-comment">// 完全显式指定，编译器不再需要按参数d的类型做推导</span><br>    <span class="hljs-type">char</span> c = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">double</span>, <span class="hljs-type">char</span>&gt;(d);  <span class="hljs-comment">// 完全显式指定，编译器不再需要按参数d的类型做推导</span><br>    <span class="hljs-built_in">int</span>(*ptr)(<span class="hljs-type">float</span>) = convert;         <span class="hljs-comment">// 还是可以完成推导，需要实例化出int convert&lt;int, float&gt;(float)&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>顺序的调换导致我们前两行的自动推导失效，从而不得不完全显式地指定，代码也写成了“愚型”。而另一方面，我们也可以看出，对于函数模板来说，大多数情况的模板实参型别推导还是依赖于函数调用的参数列表，这其中出现了的模板参数往往可以进行推导。我们简单总结下，对于函数模板<code>template&lt;typename T&gt;void f(T param);</code>，编译器可以根据我们实际调用时传入的实参类型来进行推导(<code>f(argument);</code>)，得出模板参数<code>T</code>的类型和相应的参数列表(<code>T param</code>)。</p><p>然而这只是一种情况，也是最简单的情况。实际上，我们需要考虑的维度有三个：</p><ul><li>模板参数本身：<code>T</code></li><li>函数参数列表：不一定是<code>T param</code>，很可能对<code>T</code>做了CV限定或是引用/指针修饰，我们记为<code>ParamType</code></li><li>函数调用实参：<code>argument</code>这个表达式的型别可以千奇百怪</li></ul><p><code>T</code>型别的推导实际上是<code>ParamType</code>和<code>argument</code>的共同作用，从<code>ParamType</code>的视角来看，大抵有着四种情况：</p><ul><li><code>ParamType</code>既非指针也非引用</li><li><code>ParamType</code>是个指针</li><li><code>ParamType</code>是个左值引用</li><li><code>ParamType</code>是个万能引用</li></ul><h3id="paramtype既非指针也非引用"><code>ParamType</code>既非指针也非引用</h3><p>这是最简单的情况：按值传递。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;<br><br><span class="hljs-built_in">f</span>(argument);<br></code></pre></td></tr></table></figure><p>值传递的推导规则非常轻量：编译器在推导时会忽略掉<code>argument</code>的顶层CV限定和引用修饰。结合第一讲中的值语义，这一点其实非常好理解：值传递的形参本质上是实参的副本，所以实参的顶层<code>const</code>,<code>volatile</code>特性形参完全可以不care，拷贝以后就跟数据源头毫无瓜葛了，通俗的理解是”大可以我改我的，反正我又不影响你“。至于引用修饰，那就更没关系了，都值语义了，它只能影响从哪个源头拷贝而已。</p><p>此外还要注意，值传递推导所忽略的CV限定只有顶层(top)，底层(bottom)CV限定是不能被忽略的，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> ptr = <span class="hljs-string">&quot;Fun with pointers&quot;</span>;    <span class="hljs-comment">// ptr是个指向const对象的const指针</span><br><span class="hljs-built_in">f</span>(ptr); <span class="hljs-comment">// T被推导成const char*，底层const得以保留，也必须保留</span><br></code></pre></td></tr></table></figure><blockquote><p><code>const</code>是限定<code>char</code>还是限定pointer，要看它的位置在<code>*</code>的左边还是右边。</p></blockquote><p>其实这也很好理解，因为值语义拷贝的是个指针，指针本身的<code>const</code>限定可以被擦掉，但是它所指向的类型的<code>const</code>限定是绝对不可以擦掉的。</p><p>来看一些用例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// param类型和T类型始终一致</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    <span class="hljs-comment">// 打印T的型别和param的型别</span><br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);       <span class="hljs-comment">// 最简单的情景，T被推导为int</span><br>    <span class="hljs-built_in">f</span>(cx);      <span class="hljs-comment">// 由于const被忽略，T依然被推导为int</span><br>    <span class="hljs-built_in">f</span>(rx);      <span class="hljs-comment">// 先忽略掉引用、再忽略掉const，T还是被推导成int</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);      <span class="hljs-comment">// T被推导为int*</span><br>    <span class="hljs-built_in">f</span>(&amp;cx);     <span class="hljs-comment">// T被推导为const int*，底层const特性不能忽略</span><br>    <span class="hljs-built_in">f</span>(&amp;rx);     <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(pcx);     <span class="hljs-comment">// T被推导为const int*, 底层const特性不能忽略</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// 顶层const被忽略，T被推导为const int*</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">intint<br>intint<br>intint<br>int *int *<br>const int *const int *<br>const int *const int *<br>const int *const int *<br>const int *const int *<br></code></pre></td></tr></table></figure><p>C++标准库的<code>typeid</code>贼鸡儿难用，由于标准没有规定其<code>name</code>成员函数的输出结果，各大编译器花式整活，输出结果尽是些听不懂的“方言”，另一方面<code>typeid</code>也是运行期输出，没那个味儿。作为一名C++程序员，我们遇到困难，也不要怕，微笑着(bushi)……自己实现一个编译期类型计算的方法(当然，本鶸搬运的是so大神的实现)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span><br><span class="hljs-function">std::string_view</span><br><span class="hljs-function"><span class="hljs-title">type_name</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __clang__</span><br>    string_view p = __PRETTY_FUNCTION__;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">34</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">34</span> - <span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(__GNUC__)</span><br>    string_view p = __PRETTY_FUNCTION__;<br><span class="hljs-meta">#  <span class="hljs-keyword">if</span> __cplusplus &lt; 201402</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">36</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">36</span> - <span class="hljs-number">1</span>);<br><span class="hljs-meta">#  <span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">49</span>, p.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;;&#x27;</span>, <span class="hljs-number">49</span>) - <span class="hljs-number">49</span>);<br><span class="hljs-meta">#  <span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>    string_view p = __FUNCSIG__;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">84</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">84</span> - <span class="hljs-number">7</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>现阶段初学者还不需要理解这段代码，实际上他并没有做什么神奇的操作，只是对不同的编译器生成的函数签名中截取了想要的部分字符串而已。总之，现在只需要知道<code>type_name</code>这个函数模板可以输出任何模板参数<code>T</code>的类型。</p><h3 id="paramtype是个指针"><code>ParamType</code>是个指针</h3><p>模板形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T* param)</span></span>;  <br></code></pre></td></tr></table></figure><p>此时，形参<code>param</code>的类型已经被限制成必须是某个类型的指针型，指针型本质上也是按值传递（拷贝的是地址值，即指针型变量存储的value），推导规则就尝试将实参<code>argument</code>“适配”到形参上去，形参类型确定了，那么<code>T</code>的类型也就确定了，此时形参和<code>T</code>是不同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T* param)</span> </span>&#123;<br>    <span class="hljs-comment">// 输出T的类型和形参param的类型</span><br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">int</span>* px = &amp;x;<br>    <span class="hljs-type">int</span>*&amp; rpx = px;             <span class="hljs-comment">// 指针的引用，</span><br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* pcx = &amp;x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> pcpx = &amp;x; <span class="hljs-comment">// 当然了，像rpx,pcpx这种东西你日常编程基本遇不到，这里只是为了让例子尽量丰满</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);   <span class="hljs-comment">// T被推导为int, param被推导为int*</span><br>    <span class="hljs-built_in">f</span>(px);   <span class="hljs-comment">// 同上</span><br>    <span class="hljs-built_in">f</span>(rpx);  <span class="hljs-comment">// 同上</span><br>    <span class="hljs-built_in">f</span>(pcx);  <span class="hljs-comment">// T被推导为const int, param被推导为const int* </span><br>    <span class="hljs-built_in">f</span>(pcpx); <span class="hljs-comment">// T被推导为const int, param被推导为const int*</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zsh">intint *<br>intint *<br>intint *<br>const intconst int *<br>const intconst int *<br></code></pre></td></tr></table></figure><p>实际上，指针型的推导和第一种情况的值推导很相似，引用修饰和顶层const同样会被忽略，只不过<code>T</code>的类型和形参<code>param</code>的类型有所区别罢了。</p><h3 id="paramtype是左值引用"><code>ParamType</code>是左值引用</h3><p>模板形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;<br></code></pre></td></tr></table></figure><p>这种情况相当于限定了形参<code>param</code>的类型一定是某个类型的左值引用，这就意味着我们的传参方式是按引用传递(传址)，因此一方面实参<code>argument</code>的引用修饰会被忽略（因为不管是不是引用类型，最终推导出的形参都必须是个左值引用），另一方面其CV限定不会也不能被忽略，因为相比于值传递，我们此时传递的对象并不会拷贝一份，因此其<code>const</code>,<code>volatile</code>特性绝对不能忽略或者舍弃。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);       <span class="hljs-comment">// T被推导为int, param被推导为int&amp;</span><br>    <span class="hljs-built_in">f</span>(cx);      <span class="hljs-comment">// T被推导为const int, param被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(rx);      <span class="hljs-comment">// rx本身的reference会被忽略，因此和传递cx没什么两样</span><br><br>    <span class="hljs-comment">//f(&amp;x);    // 这三个都不能通过编译，因为param是左值引用必须绑定到左值上</span><br>    <span class="hljs-comment">//f(&amp;cx);   // 取地址符表达式是prvalue，不能被lvalue reference绑定</span><br>    <span class="hljs-comment">//f(&amp;rx);</span><br><br>    <span class="hljs-built_in">f</span>(pcx);     <span class="hljs-comment">// T被推导为const int*, param被推导为const int*&amp;</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// T被推导为const int* const, param被推导为const int* const&amp;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zsh">intint &amp;<br>const intconst int &amp;<br>const intconst int &amp;<br>const int *const int *&amp;<br>const int *constconst int *const &amp;<br></code></pre></td></tr></table></figure><p>而说到左值引用，就不得不提到C++中的万金油：const左值引用，试想如果我们前置地对<code>param</code>型别增加一个<code>const</code>限定会如何呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);   <span class="hljs-comment">// T被推导为int, param被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(cx);  <span class="hljs-comment">// T被推导为int, param被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(rx);  <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);  <span class="hljs-comment">// const左值引用也可以绑定到右值上，因此编译通过。T被推导为int*，param被推导为const int*&amp;</span><br>    <span class="hljs-built_in">f</span>(&amp;cx); <span class="hljs-comment">// T被推导为const int*，param被推导为const int* const &amp;</span><br>    <span class="hljs-built_in">f</span>(&amp;rx); <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(pcx); <span class="hljs-comment">// pcx是左值，T被推导为const int*, param绑定其上，本身追加const限定，因此被推导为const int* const&amp;</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// 同上，不管T本身是否有顶层const, param都会具有顶层const</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">intconst int &amp;<br>intconst int &amp;<br>intconst int &amp;<br>int *int *const &amp;<br>const int *const int *const &amp;<br>const int *const int *const &amp;<br>const int *const int *const &amp;<br>const int *const int *const &amp;<br></code></pre></td></tr></table></figure><p>这些例子看起来很绕，但实际上，如果你搞懂了基于值语义和引用语义的型别推导原则，它们都是显而易见的。</p><h3 id="paramtype是万能引用"><code>ParamType</code>是万能引用</h3><p>这里就和上一讲的结尾接轨了，它是C++11引入右值引用后，自然而然演化出的产物。我将C++标准对万能引用的定义翻译成白话：万能引用是一种特殊的引用类型，它所引用的类型需要被推导，且携带了用于型别推导的实参的值分类信息，使得其可以被<code>std::forward</code>完美转发。我们先忽略最后半句，通过函数模板参数来理解一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123; <span class="hljs-comment">// 此时T&amp;&amp;是个万能引用，不论类型如何，我们知道param一定是引用，所以是按引用传递</span><br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);       <span class="hljs-comment">// x是左值，按引用传递就视为左值引用，这和你用x作为实参去调用一个形参为int&amp;的函数没什么区别</span><br>                <span class="hljs-comment">// 因此T被推导成int&amp;, param也被推导成int&amp;（此时发生了引用折叠）</span><br>    <span class="hljs-built_in">f</span>(cx);      <span class="hljs-comment">// cx也是左值，但因为按引用传递，const特性必须保留</span><br>                <span class="hljs-comment">// 因此T被推导成const int&amp;, param也被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(rx);      <span class="hljs-comment">// 同上，是否按引用传递取决于形参有没有reference修饰，这一点跟实参本身是不是reference没关系</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);      <span class="hljs-comment">// &amp;x是右值，只有右值引用才能绑定到右值上，因此param只能被推导成int* &amp;&amp;(int指针型的右值引用)</span><br>                <span class="hljs-comment">// 此时T被推导为int*</span><br>    <span class="hljs-built_in">f</span>(&amp;cx);     <span class="hljs-comment">// 同上</span><br>    <span class="hljs-built_in">f</span>(&amp;rx);     <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(pcx);     <span class="hljs-comment">// pcx是左值，故T被推导为const int*&amp;，param也一样</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// cpcx是左值，故T被推导为const int* const &amp;, param也一样</span><br>                <span class="hljs-comment">// 只不过按引用传递的情况，顶层const必须保留</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">int &amp;int &amp;<br>const int &amp;const int &amp;<br>const int &amp;const int &amp;<br>int *int *&amp;&amp;<br>const int *const int *&amp;&amp;<br>const int *const int *&amp;&amp;<br>const int *&amp;const int *&amp;<br>const int *const &amp;const int *const &amp;<br></code></pre></td></tr></table></figure><p>可以看到万能引用终归是个引用，不管是左值引用还是右值引用，不管有没有CV限定，最终都得是按引用传递，因此规则上和第三种：<code>ParamType</code>为左值引用时相同，只不过它多了一步根据实参来确定引用类型（同时也解决了传统C++中，只能用const左值引用来按引用传递右值以避免拷贝的局限性设计问题）。</p><p>事实上，我们大可以将分类改成两类，即前两种是一类，后两种是一类，分类的口径则是形参的传递方式（值传递还是引用传递）。</p><blockquote><p>不管是标准手册还是广为流传的参考书，它们对型别推导的归纳看上去都非常的复杂（哪怕是用很简单的例子），本质上是因为它们没有从值语义或是引用语义来出发，事实上，只要你拿捏住一件事：推导过程中形参究竟是值传递还是引用传递，那么不管多复杂的case，都有迹可循。</p></blockquote><h2 id="auto与decltype">auto与decltype</h2><p>以函数模板实参推导为例，我们看穿了型别推导背后的机制：值传递和引用传递的差别对待。C++11为了简化历来饱受诟病的又臭又长的语法(诸如<code>std::map&lt;std::string, std::vector&lt;std::string&gt;&gt;::const_iterator</code>)，引入了<code>auto</code>和<code>decltype</code>这两个关键字。这两位爷都是用于型别推导的，只是推导的规则不同，<code>auto</code>这个关键字的使用在现代C++中要分两个场景来看：其一是最常见的为变量做型别推导；其二是为函数返回类型做推导（C++14之后才发糖支持）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 第一种场景：变量型别推导</span><br><span class="hljs-keyword">auto</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; r = a;<br><span class="hljs-keyword">auto</span> *p = &amp;a;<br><br><span class="hljs-comment">// 第二种场景：函数返回类型推导</span><br><span class="hljs-comment">// 在C++11中，只能写作：</span><br><span class="hljs-comment">// auto f() -&gt; decltype(666) &#123; return 666; &#125;</span><br><span class="hljs-comment">// 虽然看起来只是加了个尾部型别推导，但这里的auto只是个占位符（PlaceHolder），与C++14中真正用于推导的auto有本质差别</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">666</span>; &#125;<br></code></pre></td></tr></table></figure><p>无论哪一种场景，<code>auto</code>所应用的推导规则实际上就是模板实参推导的规则。我们知道，前面在做函数模板实参推导时，需要考量的有3个维度：模板参数<code>T</code>，函数形参类型<code>ParamType</code>和传递的实参<code>argument</code>。如何类比呢？实际上我们可以把<code>auto</code>看做模板参数<code>T</code>，而<code>auto</code>结合CV限定和引用、指针修饰而成的最终变量类型则看做<code>ParamType</code>，<code>=</code>右边的表达式看做<code>argument</code>。</p><blockquote><p><code>auto</code>的型别推导与模板实参推导的规则实际上有一点不同：前者会将花括号语法视为<code>std::initializer_list</code>(C++17有所调整，仅限于'='右边)，而后者并不会。<code>std::initializer_list</code>这个东西在C++11引入，主要是为了给花括号初始化语法做补丁，然而C++语法的复杂导致这个东西在很多使用场景下显得格格不入，之后的标准演进中也一直在缝缝补补。</p></blockquote><p>我们直接看例子，按照上面描述的置换规则置换一下，再根据在模板实参推导中已掌握的知识，揣摩一下输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;            <span class="hljs-comment">// 值传递，对应case 1，T被推导为int，x的类型也是int</span><br>    <span class="hljs-keyword">auto</span>&amp; rx = x;           <span class="hljs-comment">// 引用传递，对应case3, T被推导为int, rx的类型是int&amp;</span><br>    <span class="hljs-keyword">auto</span>&amp;&amp; rrx = <span class="hljs-number">666</span>;       <span class="hljs-comment">// 引用传递，对应case4，auto&amp;&amp;是个万能引用</span><br>                            <span class="hljs-comment">// 666是prvalue，故T被推导为int，rrx的类型是int&amp;&amp;</span><br>    <span class="hljs-keyword">auto</span>&amp;&amp; lrx = x;         <span class="hljs-comment">// 引用传递，对应case4，auto&amp;&amp;是个万能引用</span><br>                            <span class="hljs-comment">// x是lvalue，故T被推导为int&amp;，lrx的类型也是int&amp;</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> cx = x;      <span class="hljs-comment">// 值传递，T被推导为int, cx的类型是const int</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; rcx = x;    <span class="hljs-comment">// 引用传递，T被推导为int, rcx的类型是const int&amp;</span><br><br>    <span class="hljs-keyword">auto</span>* px = &amp;x;          <span class="hljs-comment">// 值传递，T被推导为int, px的类型是int*</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>* pcx = &amp;cx;  <span class="hljs-comment">// 值传递，T被推导为int, pcx的类型是const int*    </span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>* <span class="hljs-type">const</span> cpcx = &amp;cx;   <span class="hljs-comment">// 值传递，T被推导为int, cpcx的类型是const int* const</span><br><br>    <span class="hljs-comment">// 这里用到了decltype这个specifier，我们暂且只需要知道decltype(variable)可以原封不动的给出variable的类型</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of x: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(x)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of rx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(rx)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of rrx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(rrx)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of cx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(cx)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of rcx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(rcx)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of px: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(px)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of pcx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(pcx)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of cpcx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(cpcx)&gt;() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of x: int<br>type of rx: int &amp;<br>type of rrx: int &amp;&amp;<br>type of lrx: int &amp;<br>type of cx: const int<br>type of rcx: const int &amp;<br>type of px: int *<br>type of pcx: const int *<br>type of cpcx: const int *const<br></code></pre></td></tr></table></figure><blockquote><p>思考一下：如果<code>auto* pcx2 = &amp;cx;</code>，<code>pcx2</code>是什么类型？<code>auto* const &amp; pcx3 = &amp;cx;</code>呢？如果你可以轻松地推导出来，那么恭喜你，你已经领悟了型别推导的奥义。</p></blockquote><p><code>decltype</code>也有两个与<code>auto</code>类似的使用场景，一种就是像上例那样使用的对变量做'='右边表达式的型别推导，另一种也是用在函数返回值推导中，写作<code>decltype(auto)</code>。</p><p><code>decltype</code>相比<code>auto</code>则没有那么麻烦的推导规则，它只是简单粗暴的告诉我们给定实参(<code>argument</code>)的真实类型（意味着不会忽略CV限定、引用修饰）。<code>argument</code>是一个表达式（也包括实体(entity)的情况），但通过前两节的学习，我们知道表达式的值类型有多种情况，所以还是要分情况讨论下：</p><ul><li>如果<code>argument</code>是没有套上小括号的变量(严格的说法是id-expression，不过为了便于理解我们忽略官方的黑话)或是类成员访问表达式(通俗的理解这也是个变量)，decltype给出其本身的类型。</li><li>否则，对于其他类型<code>T</code>的表达式<ul><li>如果表达式的值分类是xvalue，则推导为<code>T&amp;&amp;</code></li><li>如果表达式的值分类是lvalue，则推导为<code>T&amp;</code></li><li>如果表达式的值分类是prvalue，则推导为<code>T</code></li></ul></li></ul><p>这实际上就是cppreference给出的<code>decltype</code>说明符的解释，初学者可能会对第一条款中提到的小括号包裹感到奇怪，实际上它的本质原因在于entity和expresion的区别，假设有变量<code>int a = 3;</code>，<code>a</code>我们可以说它是一个entity，但是<code>(a)</code>就不再是一个实体，而是一个表达式了，套上小括号意味着表达式需要被计算(或处理)，即使我们对<code>a</code>什么都没做，它也需要处理。因此，对于<code>(a)</code>来说，它是个表达式，要根据第二条款来判定，由于<code>(a)</code>是个lvalue，所以此时型别为<code>int&amp;</code>。</p><blockquote><p>说到这里就不得不提一个现代C++中很有意思的坑：返回值类型支持<code>decltype(auto)</code>推导后，对于函数返回语句如果要返回一个变量，那么写成<code>return a;</code>和<code>return (a);</code>意义完全不同，前者会被推导为<code>a</code>的类型，而后者被推导为<code>a</code>的左值引用类型。而如果没有用到推导，而是老老实实的返回<code>a</code>的类型，那么这两种写法其实都可以，只不过后者做了一次计算，不会引入其他问题。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">double</span> x;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">get_ref</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *p)</span> </span>&#123; <span class="hljs-keyword">return</span> *p; &#125;<br><br><span class="hljs-comment">// 相当于C++11中的auto get_ref_forward1(const int* p) -&gt; decltype(get_ref(p))</span><br><span class="hljs-comment">// 由于get_ref(p)是个表达式返回的是个lvalue，故推导成const int&amp;</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">get_ref_forward1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_ref</span>(p);<br>&#125;<br><br><span class="hljs-comment">// 值传递，返回的一定是个值类型，此时的实参是get_ref(p)，忽略掉顶层CV限定，于是推导为int</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_ref_forward2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_ref</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-keyword">decltype</span>(a.x) y = <span class="hljs-number">1.0</span>;  <span class="hljs-comment">// 对于entity，y推导成其本身的类型double</span><br>    <span class="hljs-keyword">decltype</span>((a.x)) z = y;  <span class="hljs-comment">// 由于小括号的存在导致按表达式来推导，(a.x)是左值故推导成double&amp;</span><br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;             <br>    <span class="hljs-keyword">decltype</span>(i) j = i;      <span class="hljs-comment">// 对于entity，j推导成本身类型int</span><br>    <span class="hljs-keyword">decltype</span>((i)) k = j;    <span class="hljs-comment">// 由于小括号的存在导致按表达式来推导，(i)是左值故推导成int&amp;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i;       <br>    <span class="hljs-keyword">decltype</span>(ci) cj = ci;   <span class="hljs-comment">// 推导成const int，decltype不会像auto那样忽略顶层CV限定</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of y: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(y)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of z: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(z)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of j: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(j)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of k: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(k)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of cj: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(cj)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of return value of get_ref_forward1: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">get_ref_forward1</span>(&amp;ci))&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of return value of get_ref_forward2: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">get_ref_forward2</span>(&amp;ci))&gt;() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of y: double<br>type of z: double &amp;<br>type of j: int<br>type of k: int &amp;<br>type of cj: const int<br>type of return value of get_ref_forward1: const int &amp;<br>type of return value of get_ref_forward2: int<br></code></pre></td></tr></table></figure><blockquote><p>思考一下：如果get_ref_forward2的返回类型写作<code>auto&amp;</code>，又该是什么类型呢？</p></blockquote><h2 id="恼人的数组与函数">恼人的数组与函数</h2><p>凡是总有例外，在C++中，有两种类型天生需要被特殊处理，那就是从C语言继承过来的数组和函数名称。在C语言中，数组和指针常常混用，绝大部分场景都可以互为代替使用，这就导致很多人将数组和指针视为同一种东西的不同写法，虽然这个看法是错误的，但在日常开发中，用这样一种局限性的看法来读写代码确实会使事情简单化。函数名称则简单不少，在C中几乎被视为相应的函数指针类型。C++继承了C的legacy，但随着C++语法规则的不断演进，数组和函数名称逐渐显得格格不入，为此，C++做了很多语法上兼容性处理，在很多语境下，数组会退化(decay)成指向其首元素的指针型，而函数名称会退化(decay)成相应的函数指针型。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> name[] = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-comment">// name的类型是const char[6]</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* p1 = name;          <span class="hljs-comment">// 数组退化，p1指向name的首元素</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* p2 = <span class="hljs-string">&quot;world&quot;</span>;       <span class="hljs-comment">// &quot;world&quot;是一个字符串字面量左值，类型为const char[6]</span><br>                                <span class="hljs-comment">// 数组退化，p2指向&quot;world&quot;首元素</span><br></code></pre></td></tr></table></figure><p>从C++的视角来看，假如没有退化规则，那么对指针的初始化显然是不合法的，但为了兼容C的legacy，不得不做了容忍。另一方面，在C中我们经常写:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-comment">// 这在C中非常常见，但如果是在C++11之后是不合法的，尽管编译器只抛了warning：</span><br>                        <span class="hljs-comment">// ISO C++11 does not allow conversion from string literal to &#x27;char *&#x27; </span><br>                        <span class="hljs-comment">// 字符串字面量是左值（意味着可以被取地址），它有着const特性，底层const不能丢，所以得用const char*</span><br><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;world&quot;</span>;   <span class="hljs-comment">// 这是C语言对字符数组发放的语法糖，str的类型实际上是char[6]</span><br>                        <span class="hljs-comment">// 等价于char str[6] = &#123;&#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;\0&#x27;&#125;</span><br>                        <span class="hljs-comment">// C语言一方面支持定界值省略，另一方面对字符数组做了照顾：花括号初始化语法可以改写为字符串字面量</span><br>                        <span class="hljs-comment">// C++继承了C，所以这在C++中也合法，且语义相同，注意区分和前者的差别</span><br></code></pre></td></tr></table></figure><p>为了说明两种语法的差别，我们编写如下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;world&quot;</span>;<br><br>    cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of p: %p\n&quot;</span>, p);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of \&quot;hello\&quot;: %p\n&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of str: %p\n:&quot;</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of \&quot;world\&quot;: %p\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zsh">hello world<br>address of p: 0x10232bea4<br>address of &quot;hello&quot;: 0x10232bea4<br>address of str: 0x16dad76f8<br>:address of &quot;world&quot;: 0x10232bf03<br></code></pre></td></tr></table></figure><p>显然，<code>p</code>和<code>"hello"</code>的地址是相同的，说明它们是同一个对象。而<code>str</code>则和<code>"world"</code>有所不同，<code>str</code>只是以<code>char</code>为单位逐个拷贝了<code>"world"</code>的数据到自身的存储单元而已，其类型是<code>char[6]</code>。</p><p>再来看看当数组涉及型别推导时，效果如何：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">f</span>(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of T: int *<br>type of param: int *<br>type of T: char *<br>type of param: char *<br></code></pre></td></tr></table></figure><p>由于<code>param</code>值传递，所以推导时数组类型发生了退化，降级成对应的首元素指针型。而如果改为按引用传递，则不会发生decay：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);                          <br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-built_in">move</span>(str));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of T: int (&amp;)[5]<br>type of param: int (&amp;)[5]<br>type of T: char [6]<br>type of param: char (&amp;&amp;)[6]<br></code></pre></td></tr></table></figure><p>可以看到param就是传递进来的参数的原本类型。</p><p>如果说上面的例子根据我们的口诀来看还算中规中矩，那下面这个就有点反人类了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里的定界6不能少，否则param是个非法的数组引用</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T (&amp;param)[<span class="hljs-number">6</span>])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 虽然写作T[]，但因为值传递的关系，还是退化成了T*，定界写不写都无所谓，随便写什么都行</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T param[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);<br>    <span class="hljs-built_in">g</span>(v);<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">f</span>(str);<br>    <span class="hljs-built_in">g</span>(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of T: int<br>type of param: int (&amp;)[6]<br>type of T: int<br>type of param: int *<br>type of T: char<br>type of param: char (&amp;)[6]<br>type of T: char<br>type of param: char *<br></code></pre></td></tr></table></figure><blockquote><p>我特意把v改成了6个成员，思考一下如果这里不改的话会不会有啥问题？</p></blockquote><p>另外，由于数组引用并不是个直截了当的类型，如果我们写成<code>T (&amp;&amp;param)[6]</code>会编译报错，因为此时param不再是一个万能引用。</p><p>你以为这样就结束了？当数组和非类型模板参数相遇时，还有更离谱的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 函数模板也可以重载，但要注意可能会引发的ambiguous调用问题</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T (&amp;param)[<span class="hljs-number">5</span>])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;template f:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T (&amp;param)[N])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;nontype template f:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T param[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;template g:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T param[N])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;nontype template g:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);                   <span class="hljs-comment">// 优先匹配template f，template f比nontype template f更特殊</span><br>    <span class="hljs-built_in">g</span>(v);                   <span class="hljs-comment">// 只能匹配template g，因为值传递会退化成指针</span><br>                            <span class="hljs-comment">// 即使把template g注释掉也无法匹配nontype template g</span><br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;   <br>    <span class="hljs-built_in">f</span>(str);                 <span class="hljs-comment">// 只能匹配nontype template f，因为template f不满足匹配条件无法成为candidate</span><br>    <span class="hljs-built_in">g</span>(str);                 <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs zsh">template f:<br>type of T: int<br>type of param: int (&amp;)[5]<br>template g:<br>type of T: int<br>type of param: int *<br>nontype template f:<br>type of T: char<br>type of param: char (&amp;)[6]<br>template g:<br>type of T: char<br>type of param: char *<br></code></pre></td></tr></table></figure><p>因为decay的关系，nontype templateg实际上无法被用到，如果我们把它改写成传引用呢：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T (&amp;param)[N])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;nontype template g:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时就会遇到编译错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs zsh">test_array3.cpp:37:5: error: call to &#x27;g&#x27; is ambiguous<br>    g(v);<br>    ^<br>test_array3.cpp:21:6: note: candidate function [with T = int]<br>void g(T param[]) &#123;<br>     ^<br>test_array3.cpp:28:6: note: candidate function [with T = int, N = 5]<br>void g(T (&amp;param)[N]) &#123;<br>     ^<br>test_array3.cpp:40:5: error: call to &#x27;g&#x27; is ambiguous<br>    g(str);<br>    ^<br>test_array3.cpp:21:6: note: candidate function [with T = char]<br>void g(T param[]) &#123;<br>     ^<br>test_array3.cpp:28:6: note: candidate function [with T = char, N = 6]<br>void g(T (&amp;param)[N]) &#123;<br>     ^<br>2 errors generated.<br></code></pre></td></tr></table></figure><p>因为两个版本此时都可以完成匹配作为candidate，但二者之间论优先级或者说特殊性并不能分出高下，所以导致了函数模板重载所常见的ambiguous错误。</p><blockquote><p>实际上当涉及到类模板对数组的特化时，情形远远比这里给出的例子要复杂得多，另一方面未定界数组实际上也有特殊的手法来传递推导。考虑到不希望这一部分内容喧宾夺主故不做展开，有兴趣的同学可以看一下《C++Templates》5.4的内容。</p></blockquote><p>函数名称和函数指针的情景和数组很像：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &lt; b ? b : a;<br>&#125;<br><br><span class="hljs-keyword">using</span> func = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>(my_max);              <span class="hljs-comment">// decay，退化成函数指针</span><br>    <span class="hljs-built_in">g</span>(my_max);              <span class="hljs-comment">// 不会decay</span><br>    <span class="hljs-built_in">g</span>(std::<span class="hljs-built_in">move</span>(my_max));   <span class="hljs-comment">// 对函数名称进行move没意义</span><br><br>    func fp = my_max;       <span class="hljs-comment">// fp本身就是函数指针类型</span><br>    <span class="hljs-built_in">f</span>(fp);                  <span class="hljs-comment">// 不需要退化，单纯的值传递</span><br>    <span class="hljs-built_in">g</span>(fp);                  <span class="hljs-comment">// 注意是函数指针的左值引用</span><br>    <span class="hljs-built_in">g</span>(std::<span class="hljs-built_in">move</span>(fp));       <span class="hljs-comment">// 注意是函数指针的右值引用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs zsh">int (*)(int, int)<br>int (*)(int, int)<br>int (int, int)&amp;<br>int (int, int)&amp;<br>int (int, int)&amp;<br>int (int, int)&amp;<br>int (*)(int, int)<br>int (*)(int, int)<br>int (*)(int, int)&amp;<br>int (*)(int, int)&amp;<br>int (*)(int, int)<br>int (*)(int, int)&amp;&amp;<br></code></pre></td></tr></table></figure><p>相信读到这里的你，一定会觉着上面的结果一目了然。</p><h2 id="完美转发">完美转发</h2><p>最后谈谈完美转发。</p><p>除了我们之前详细解读过的<code>std::move</code>，C++11在标准库中还定义了一个非常常用的<code>std::forward</code>，相信对于大部分现代C++初学者来说，<code>std::forward</code>和<code>std::move</code>一度云里雾里。我们先撇开<code>std::forward</code>，来看看如下的一个使用场景：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(T&amp;&amp;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in func1, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>    <span class="hljs-comment">// 我们希望把param原封不动的“渗透”到下一层</span><br>    <span class="hljs-built_in">func2</span>(param);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;in func2, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">666</span>;<br>    <span class="hljs-built_in">func1</span>(a);       <span class="hljs-comment">// a是左值，所以func1中T被推导成int&amp;，param也是int&amp;，此时向下调用func2传递的依然是左值引用</span><br>                    <span class="hljs-comment">// 所以func2中的T和param也都是int&amp;，这是符合预期的 </span><br>    <span class="hljs-built_in">func1</span>(<span class="hljs-number">2333</span>);    <span class="hljs-comment">// 2333是纯右值，func1中T被推导成int，param被推导成int&amp;&amp;，此时向下调用func2传递的是右值引用类型的param</span><br>                    <span class="hljs-comment">// 尽管param的类型是右值引用，但param本身是个左值（具名的变量），这就导致渗透传递时func2中</span><br>                    <span class="hljs-comment">// T和param被推导成int&amp;，这就不符合预期了，我们的引用型在渗透过程中变质了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">in func1, T:int&amp;, param:int&amp;<br>in func2, T:int&amp;, param:int&amp;<br>in func1, T:int, param:int&amp;&amp;<br>in func2, T:int&amp;, param:int&amp;<br></code></pre></td></tr></table></figure><p>我们在<code>func1</code>中又调用了<code>func2</code>，且原封不动的将参数<code>param</code>传递了下去，希望能够把左值引用或是右值引用这一特性渗透到下一层，然而事与愿违，由于在C++语法中，即使类型为右值引用的具名变量其本身依然是个左值，这就导致了不可传递性。</p><p>可能有的小伙伴说了，我们不是学过<code>std::move</code>吗，只需要调用<code>func2</code>时对<code>param</code>再<code>move</code>一下不就行了吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in func1, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>    <span class="hljs-comment">// 强制传递右值引用</span><br>    <span class="hljs-built_in">func2</span>(<span class="hljs-built_in">move</span>(param));<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，如果按照这个写法，上述例子中后者的运行结果符合预期，可是前者却又出了问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">in func1, T:int&amp;, param:int&amp;<br>in func2, T:int, param:int&amp;&amp;<br>in func1, T:int, param:int&amp;&amp;<br>in func2, T:int, param:int&amp;&amp;<br></code></pre></td></tr></table></figure><p>为什么呢？因为你把一个原本是左值引用的param强制转成了右值引用向下传递！可以说是按下葫芦浮起瓢。可是这种需求在我们日常开发中很常见啊，就真的没办法兼容吗？不，成年人的世界从来都是：我全都要~</p><p>我们采用标准库中的<code>std::forward</code>试一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in func1, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>    <span class="hljs-built_in">func2</span>(forward&lt;T&gt;(param));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">in func1, T:int&amp;, param:int&amp;<br>in func2, T:int&amp;, param:int&amp;<br>in func1, T:int, param:int&amp;&amp;<br>in func2, T:int, param:int&amp;&amp;<br></code></pre></td></tr></table></figure><p>可以发现确实达成了我们想要的结果，而这就是C++中所谓的完美转发(PerfectForwarding)。那么问题来了，<code>std::forward</code>只不过是标准库中的函数，既不是什么语法糖，也不是什么黑科技，它是怎么做到完美转发的呢？</p><p>实际上<code>std::forward</code>并没有做什么神奇的操作，它背后所依赖的原理就在于：我们需要区分左值引用和右值引用，而这一信息其实通过param是可以知晓的，param要么是一个左值引用、要么是一个右值引用，而对于这两种情况，我们需要一种if-else的逻辑来分别处理，对于前者来说，我们直接传递下去即可；而对于后者来说，渗透传递时我们要做一次<code>std::move</code>来把它强制转成右值引用。</p><p>另一方面，<code>std::forward</code>是一个函数模板，我们传入了<code>param</code>作为参数，而<code>param</code>携带了引用类型的信息，所以只需要编写重载函数，分别处理左值引用和右值引用的不同<code>param</code>即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp; param)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp;&amp; param)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>remove_reference_t</code>是标准库中的一种typetrait，可以洗掉类型<code>T</code>的引用修饰，这里是为了先确保拿到一个纯净类型，然后再分别施加左值引用或者是右值引用的修饰，注意，对于后者而言<code>remove_reference_t&lt;T&gt;&amp;&amp;</code>不是万能引用，而是一个彻彻底底的右值引用。于是，当我们向<code>std::forward</code>传递一个左值时，会匹配到第一个函数模板，此时<code>T</code>是左值引用，因此返回的类型根据引用折叠规则已然是一个左值引用；而当传递右值时，则会匹配到第二个函数模板，此时<code>T</code>不是引用类型，但返回的类型由于<code>static_cast&lt;T&amp;&amp;&gt;</code>将<code>T</code>强制转成了其右值引用类型。</p><p>实际上上面的代码与各大编译器厂商实现的标准库<code>std::forward</code>如出一辙，只是标准库中的代码有更多的诸如constexpr、noexcept等杂七杂八的修饰。</p><h2 id="参考文献">参考文献</h2><ul><li><ahref="https://en.cppreference.com/w/cpp/language/template_argument_deduction">Templateargument deduction</a></li><li><ahref="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/">EffectiveModern C++</a></li><li><ahref="https://en.cppreference.com/w/cpp/language/reference">Referencedeclaration</a></li><li><ahref="https://en.cppreference.com/w/cpp/language/auto">Placeholder typespecifiers</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>program-language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>cpp-templates</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++模板从入门到劝退(1)——右值引用与移动语义</title>
    <link href="/2022/06/04/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(1)%E2%80%94%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
    <url>/2022/06/04/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(1)%E2%80%94%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述严谨性，按照笔者的归纳方式穿针引线，为痴迷于黑魔法而又始终不得其解的同学打通任督二脉。</p><p>本篇是走进模板世界的第二道前菜，只有搞懂了这些C++中的基本概念，才能掌握模板世界的黑魔法。</p><span id="more"></span><h1 id="右值引用与移动语义">右值引用与移动语义</h1><h2 id="右值引用初探">右值引用初探</h2><p>上一讲我们对表达式的值分类进行了展开，围绕值语义和引用语义的探讨对现代C++的左值和右值有了深入的理解。但搞懂值分类的区分仅是第一步，我们尚未揭晓移动语义的帷幕。</p><p>在传统C++中，引用非常纯粹，比如代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> &amp;b = a; <span class="hljs-comment">// 这里的&amp;不是取址符，而是左值引用的声明符</span><br></code></pre></td></tr></table></figure><p>其中<code>b</code>就是<code>a</code>的引用，开发者简单地将<code>b</code>视为变量<code>a</code>的别名，通过<code>b</code>和<code>a</code>对变量值进行读写本质上并没有什么不同。引用语法相比从C继承的指针来说更加简洁，也更容易理解。而从现代C++的视角来看，这里的<code>b</code>是一个左值引用（显然，它绑定的<code>a</code>是个左值），这里对左值的强调是为了区分C++11所引入的另一种引用类型：右值引用。那么右值引用如何声明呢？既然是全新的语法，那肯定得量身定制：语法规定用<code>&amp;&amp;</code>作为右值引用的声明符。因此，形如<code>S&amp; D;</code>是将<code>D</code>声明为<code>S</code>所确定类型的左值引用；形如<code>S&amp;&amp; D;</code>则是将<code>D</code>声明为<code>S</code>所确定类型的右值引用。顾名思义，左值引用绑定到左值，右值引用绑定到右值（也就是xvalue和prvalue）。</p><blockquote><p>你可能还见到过别人这样写:<code>int&amp; b = a;</code>，声明符的空格位置和上述写法相反，而实际上这里怎么书写都是正确的（<code>&amp;</code>两边都有空格也无所谓），因为<code>&amp;</code>是声明符而非取地址符(addressof)，我个人习惯于这种写法，它有一种把<code>&amp;</code>和<code>int</code>联系起来的感觉。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span>&amp; b = a;         <span class="hljs-comment">// 正确：b是绑定到左值a的左值引用</span><br><span class="hljs-type">int</span>&amp; c = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 错误：字面量1是prvalue，左值引用不能绑定到右值</span><br><span class="hljs-type">int</span>&amp;&amp; d = a + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 正确：算术运算符表达式是prvalue</span><br><br>std::string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>std::strin&amp;&amp; r1 = s1;                                   <span class="hljs-comment">// 错误：右值引用不能绑定到左值</span><br>std::string&amp;&amp; r2 = s1 + s1;                             <span class="hljs-comment">// 正确：左右操作数为std::string的操作符重载(operator+)返回的是一个值类型，值分类上是prvalue</span><br>std::string&amp;&amp; r3 = <span class="hljs-built_in">static_cast</span>&lt;std::string&amp;&amp;&gt;(s1);      <span class="hljs-comment">// 正确：到右值引用类型转换的表达式值类型是xvalue</span><br></code></pre></td></tr></table></figure><p>上面是用基础内建类型<code>int</code>和标准库的<code>std::string</code>类类型作为示例演示的说明。</p><p>关于引用，还有些开发者必须知道的细节：</p><ul><li>引用必须被初始化为指代一个有效的对象或函数，这一点对左值引用一如既往，对右值引用也一视同仁。</li><li>尽管void类型存在指针，但不存在引用，实际上<code>void*</code>语义上也并非<code>void</code>类型的指针，而是某种未知/不确定类型的指针。</li><li>不存在引用类型的引用（禁止套娃），也不存在引用类型的指针或是引用的数组（但是存在数组的引用(<code>int(&amp;a)[3]</code>)），本质原因在于引用并非对象。</li><li>引用类型本身不能有CV(const/volatile)限定（顶层），但被引用的类型可以有CV限定(底层)，本质原因同样是在于引用并非对象。</li></ul><h2 id="引用与const限定">引用与const限定</h2><p>上述的最后一个条例提到了CV限定，它是指C++运行时对对象的一种<code>const</code>或<code>volatile</code>限定，后者对于大部分开发场景来说十分罕见(这货跟其他语言比如Java的<code>volatile</code>有着甚许微妙差别，而<code>volatile</code>在Java日常编程中十分常见)，而前者则常伴于身。对于引用来说，<code>const</code>限定无疑让语法的复杂度提升了一个维度，我们先用<code>int</code>基础内建类型来做示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b = a;           <span class="hljs-comment">// 正确：const左值引用可以绑定到非const变量</span><br>b = <span class="hljs-number">2</span>;                      <span class="hljs-comment">// 错误：左值引用b所绑定的变量有const限定，RT不可修改</span><br><span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(b) = <span class="hljs-number">2</span>;    <span class="hljs-comment">// 正确：const引用的RT限定可以通过const_cast来擦除，这里确实修改了变量a的值为2；</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">test2.cpp:9:7: error: cannot assign to variable &#x27;b&#x27; with const-qualified type &#x27;const int &amp;&#x27;</span><br><span class="hljs-comment">    b = 2;</span><br><span class="hljs-comment">    ~ ^</span><br><span class="hljs-comment">test2.cpp:8:16: note: variable &#x27;b&#x27; declared const here</span><br><span class="hljs-comment">    const int&amp; b = a;</span><br><span class="hljs-comment">    ~~~~~~~~~~~^~~~~</span><br><span class="hljs-comment">1 error generated.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;ra = a;     <span class="hljs-comment">// 错误：常量右值引用亦不能绑定到左值</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">test2.cpp:11:17: error: rvalue reference to type &#x27;const int&#x27; cannot bind to lvalue of type &#x27;int&#x27;</span><br><span class="hljs-comment">    const int&amp;&amp; ra = a;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;rb = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 正确：常量右值引用当然可以绑定到prvalue，只不过毫无卵用</span><br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span>&amp; d = c;         <span class="hljs-comment">// 错误：左值引用类型与所绑定的变量类型不一致</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">test2.cpp:11:11: error: binding reference of type &#x27;int&#x27; to value of type &#x27;const int&#x27; drops &#x27;const&#x27; qualifier</span><br><span class="hljs-comment">    int&amp;&amp; d = c;</span><br><span class="hljs-comment">          ^   ~</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; e = c;  <span class="hljs-comment">// 正确</span><br><span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(e) = <span class="hljs-number">2</span>;    <span class="hljs-comment">//正确：虽然语法上可以通过const_cast擦除来间接访问修改const对象，但产生的结果是undefined behaviour，不要依赖UB行为</span><br><span class="hljs-type">int</span>&amp;&amp; f = c;        <span class="hljs-comment">// 错误：右值引用类型与所绑定的变量类型不一致（第一关都没过去）</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">test2.cpp:17:11: error: binding reference of type &#x27;int&#x27; to value of type &#x27;const int&#x27; drops &#x27;const&#x27; qualifier</span><br><span class="hljs-comment">    int &amp;&amp;f = c;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-comment">// 一个出人意料的case</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; g = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 正确：虽然字面量1是prvalue，但是const左值引用可以绑定到右值（可以理解成字面量值先隐式转换成了一个匿名的const int，然后将const引用与其绑定）</span><br></code></pre></td></tr></table></figure><p>根据上述代码，我们简单归纳一下：</p><ul><li>引用绑定过程中const限定不能drop，但是可以add。换句话说，非const引用不能绑定const值，但const引用可以绑定到非const值。</li><li>对于绑定到非const值的const引用，可以通过<code>const_cast</code>来做临时的remove以开绿灯。</li><li>const左值引用之所以可以绑定到右值，是为了语言的向前兼容性，传统C++无所谓左值引用，可以理解成是const引用到非左值的绑定。</li></ul><blockquote><p>关于const左值引用可以绑定到右值的历史原因与标准化演进，可以参考《C++设计与演化》一书。</p></blockquote><table><thead><tr class="header"><th>引用类型</th><th>非const左值</th><th>const左值</th><th>非const右值</th><th>const右值</th></tr></thead><tbody><tr class="odd"><td>非const左值引用</td><td>是</td><td>否</td><td>否</td><td>否</td></tr><tr class="even"><td>const左值引用</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr class="odd"><td>非const右值引用</td><td>否</td><td>否</td><td>是</td><td>否</td></tr><tr class="even"><td>const右值引用</td><td>否</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h2 id="移动构造和移动赋值运算符">移动构造和移动赋值运算符</h2><p>连同上一讲，我们耗费了大量的篇幅来对左值、右值、引用与const做了阐释，可是不论是左值引用还是右值引用，引用终归只是个引用，我们知道引用本身不会产生拷贝，但是这和移动语义有什么关系呢？截止到目前，我们利用右值引用并不能做将资源A移动给资源B的操作。</p><p>到这里，就需要正式介绍C++11所引入的移动语义了，与传统的类成员函数：拷贝构造器(copyctor)和拷贝赋值运算符(copyassignment)对应，C++11为支持移动语义，引入了额外的两个类成员函数：移动构造器(movector)和移动赋值运算符(moveassignment)。正如拷贝构造器和拷贝赋值运算符的“孪生性”，移动构造器和移动赋值运算符也是如此，相比前一对的<code>const Object&amp;</code>参数，后一对的参数换成了右值引用<code>Object&amp;&amp;</code>。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Object</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;default ctor&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">const</span> Object&amp; rhs) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy ctor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Object</span>(Object &amp;&amp;rhs) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move ctor&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    Object&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Object&amp; rhs) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy assignment&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    Object&amp; <span class="hljs-keyword">operator</span>=(Object&amp;&amp; rhs) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move assignment&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Object</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Object a;       <span class="hljs-comment">// 调用默认构造器</span><br>    Object b = a;   <span class="hljs-comment">// 调用拷贝构造器</span><br><br>    Object c;       <span class="hljs-comment">// 调用默认构造器</span><br>    c = a;          <span class="hljs-comment">// 调用拷贝赋值运算符</span><br><br>    Object d = <span class="hljs-built_in">static_cast</span>&lt;Object&amp;&amp;&gt;(c);    <span class="hljs-comment">// 调用移动构造器</span><br>    Object e;                               <span class="hljs-comment">// 调用默认构造器</span><br>    e = <span class="hljs-built_in">static_cast</span>&lt;Object&amp;&amp;&gt;(c);           <span class="hljs-comment">// 调用移动赋值运算符</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs zsh">default ctor<br>copy ctor<br>default ctor<br>copy assignment<br>move ctor<br>default ctor<br>move assignment<br></code></pre></td></tr></table></figure><p>实际上看到这里你就会发现，所谓的移动构造器，不过就是一种参数为对象右值引用类型的构造器罢了，C++语法上的扩充仅仅是右值语义而已，移动构造和移动赋值运算符不过是一种优雅的称谓。</p><blockquote><p>你可能听说过默认构造器+BigFive（传统C++的BigThree(拷贝构造、拷贝赋值运算符、析构)再填上这两个移动兄弟，正好凑成五排(bushi)），当然这不是标准化的称谓（应该是侯捷老师带来的叫法），但编译器确实会按照标准所规定的那样，对默认构造和BigFive做一些特殊照顾。</p></blockquote><blockquote><p>思考：如果上述代码不定义移动构造器和移动赋值，那么<code>Object d = static_cast&lt;Object&amp;&amp;&gt;(c);</code>和<code>e = static_cast&lt;Object&amp;&amp;&gt;(c);</code>会不会编译报错呢？如果不会又该调用谁呢？</p></blockquote><p>然而很快你就会发现另一个问题，对<code>Object</code>来说，移动构造器和拷贝构造器除了打印信息不同以外，没有任何区别。回想一下传统C++中曾学过的拷贝构造器，如果是编译器默认生成的版本，拷贝构造器所做的事非常简单：</p><ul><li>对于基础内建类型、POD(Plain OfData)和指针类型，它以bit为单位将对象A中相应数据成员复制到对象B对应数据成员的存储地址。</li><li>对于复杂类型，则调用其拷贝构造函数，如有嵌套则逐层递归。</li></ul><p>基于第一条，如果数据成员里有指针类型，我们就<strong>必须</strong>自己重写BigFive，因为尽管C++基于值语义的默认拷贝动作是深拷贝，但是对于指针型变量来说，深拷贝拷贝的是地址值，而不是该地址所指向的对象（所以在C++中，这种情况被称作浅拷贝，此浅拷贝和其他引用语义编程语言中的浅拷贝有着微妙差别）。</p><blockquote><p>这里的“必须“并不是语法要求，而是基于编程常理，或者换句话说，如果不这样做，就很可能会引入诸如doublefree, uaf, memory leak等问题。这也是C++上手门槛高的一个原因。</p></blockquote><p>而另一方面，<code>Object</code>是个空类，我们原本打算通过<code>Object d = static_cast&lt;Object&amp;&amp;&gt;(c);</code>调用移动构造器把<code>c</code>“搬空”，资源归属转移到<code>d</code>而不是复制给<code>d</code>，可在实际实现移动构造器的时候才发现<code>Object</code>空空如也。没错，这个例子中<code>Object</code>是个空类（当然这种情况其实例化对象也是有size的），对于这种类本不用定义它的BigFive（编译器会默认生成），因为它并没有需要区分拷贝或者移动的资源。</p><p>我们改进一下，引入三个数据成员，分别用具有代表性的基础类型<code>int</code>，标准库的复杂类类型<code>std::string</code>和指针类型<code>char*</code>，请一定仔细阅读代码注释：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// custom ctor</span><br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">const</span> string&amp; name, <span class="hljs-type">int</span> size) : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">size_</span>(std::<span class="hljs-built_in">max</span>(size, <span class="hljs-number">16</span>)), <span class="hljs-built_in">data_ptr_</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size_]) &#123;&#125;<br><br>    <span class="hljs-comment">// copy ctor</span><br>    <span class="hljs-comment">// 对于拷贝构造器来说，我们需要对name_调用std::string的拷贝构造器来做一次copy</span><br>    <span class="hljs-comment">// 而基础内建类型没有拷贝构造器，它只能进行bit copy，这也是自动生成的拷贝构造器的动作</span><br>    <span class="hljs-comment">// 自动生成的copy ctor对data_ptr_做的也是bit copy，但显然我们希望对其做深拷贝，因此要自己写逻辑</span><br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">const</span> Object&amp; rhs) : <span class="hljs-built_in">name_</span>(rhs.name_), <span class="hljs-built_in">size_</span>(rhs.size_), <span class="hljs-built_in">data_ptr_</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[rhs.size_]) &#123;<br>        std::<span class="hljs-built_in">copy</span>(rhs.data_ptr_, rhs.data_ptr_ + rhs.size_, data_ptr_);<br>    &#125;<br><br>    <span class="hljs-comment">// move ctor</span><br>    <span class="hljs-comment">// 对于移动构造器来说，我们只需要对name_调用std::string的移动构造器来做move而非copy</span><br>    <span class="hljs-comment">// 基础内建类型没有移动构造器，它只能进行bit copy，这也是自动生成的移动构造器的动作</span><br>    <span class="hljs-comment">// 自动生成的move ctor对于data_ptr_做的也是bit copy，但显然我们不仅希望做浅拷贝，还希望传进来的右值引用所refer to的值可以被转移释放（偷走）</span><br>    <span class="hljs-built_in">Object</span>(Object &amp;&amp;rhs) : <span class="hljs-built_in">name_</span>(std::<span class="hljs-built_in">move</span>(rhs.name_)), <span class="hljs-built_in">size_</span>(rhs.size_), <span class="hljs-built_in">data_ptr_</span>(rhs.data_ptr_) &#123;<br>        rhs.data_ptr_ = <span class="hljs-literal">nullptr</span>;<br>        rhs.size_ = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// copy assignment</span><br>    <span class="hljs-comment">// 拷贝赋值运算符是copy ctor的孪生，用于适配非初始化赋值情景的赋值值语义</span><br>    <span class="hljs-comment">// 参数类型为const左值引用，意味着可以绑定到所有const/非const左值或右值，因此右操作数是啥都接得住</span><br>    Object&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Object&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            <span class="hljs-type">char</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[rhs.size_];<br>            std::<span class="hljs-built_in">copy</span>(rhs.data_ptr_, rhs.data_ptr_ + rhs.size_, ptr);<br>            <span class="hljs-keyword">if</span> (data_ptr_ != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">delete</span>[] data_ptr_;<br>            &#125;<br>            data_ptr_ = ptr;<br>            size_ = rhs.size_;<br>            name_ = rhs.name_;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// move assignment</span><br>    <span class="hljs-comment">// 移动赋值运算符是move ctor的孪生，用于适配非初始化赋值情景的赋值值语义</span><br>    <span class="hljs-comment">// 参数类型为右值引用，意味着仅可以绑定到非const右值引用，同时对于传递非const右值引用时</span><br>    <span class="hljs-comment">// 根据函数重载的优先级会优先匹配，换句话说，如果没有该定义，那就只能退一步去调用copy assignment</span><br>    Object&amp; <span class="hljs-keyword">operator</span>=(Object&amp;&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>            <span class="hljs-keyword">if</span> (data_ptr_ != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">delete</span>[] data_ptr_;<br>            &#125;<br>            data_ptr_ = rhs.data_ptr_;<br>            size_ = rhs.size_;<br><br>            name_ = std::<span class="hljs-built_in">move</span>(rhs.name_);<br>            rhs.data_ptr_ = <span class="hljs-literal">nullptr</span>;<br>            rhs.size_ = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// dtor</span><br>    <span class="hljs-comment">// 对于拥有raw pointer数据成员的类来说，析构都是少不了的</span><br>    ~<span class="hljs-built_in">Object</span>() &#123; <span class="hljs-keyword">if</span>(data_ptr_ != <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">delete</span>[] data_ptr_; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DebugPrint</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; size_ &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(data_ptr_) &lt;&lt; std::endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    <span class="hljs-type">int</span> size_;<br>    <span class="hljs-type">char</span>* data_ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Object <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">32</span>)</span></span>;<br>    <span class="hljs-function">Object <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">64</span>)</span></span>;<br><br>    Object c = a;<br>    Object d = std::<span class="hljs-built_in">move</span>(b);    <span class="hljs-comment">// std::move见下文</span><br><br>    a.<span class="hljs-built_in">DebugPrint</span>();     <br>    b.<span class="hljs-built_in">DebugPrint</span>();    <br>    c.<span class="hljs-built_in">DebugPrint</span>();<br>    d.<span class="hljs-built_in">DebugPrint</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">a320x60000180d120<br>00x0<br>a320x60000180d140<br>b640x600000d0c1c0<br></code></pre></td></tr></table></figure><p>在解释运行结果之前，我们先来说明一个C++11标准库所引入的一个非常常见的函数模板：<code>std::move</code>，该函数的名称如果是从C++的语法角度来看非常的具有误导性，<code>std::move</code>本身并不能做”移动“或者说“资源归属转移”操作，它仅仅是返回一个调用参数的右值引用而已，在我们的代码中，它曾两次出现：</p><ul><li><code>Object d = std::move(b);</code></li><li><code>Object(Object &amp;&amp;rhs) : name_(std::move(rhs.name_)), size_(rhs.size_), data_ptr_(rhs.data_ptr_)&#123;...&#125;</code></li></ul><p>由于<code>std::move</code>函数模板本身比较复杂（个锤子），这里暂且按下不表，只需要了解这两行可以等价替换成：</p><ul><li><code>Object d = static_cast&lt;Object&amp;&amp;&gt;(b);</code></li><li><code>Object(Object &amp;&amp;rhs) : name_(static_cast&lt;std::string&amp;&amp;&gt;(rhs.name_)), size_(rhs.size_), data_ptr_(rhs.data_ptr_)&#123;...&#125;</code></li></ul><p>再来看看运行结果，<code>a</code>的打印结果直截了当，三个成员的值(<code>data_ptr_</code>的值就是地址，只不过通过<code>cout</code>打印需要做一点小小的trick)符合预期，尽管我们曾进行了<code>Object c = a;</code>的操作，但是由于值语义，这里调用的是<code>Object</code>的拷贝构造器，拷贝构造器并没有修改<code>a</code>的数据成员（事实上const左值引用也修改不了（不考虑const_cast绿灯大法））</p><p>而<code>b</code>的打印结果就不那么直观了，看上去<code>name_</code>变成了空字符串，<code>size_</code>也变成了<code>0</code>，<code>data_ptr_</code>更是变成了空指针。这是为什么呢，我们不是明明调用customctor构造了一个“有血有肉”的<code>b</code>对象实例吗，为何它的数据看起来就像是被搬空了一样呢？没错，它的数据正是被搬空了，答案就在于<code>Object d = std::move(b);</code>这一行代码，这里由于参数类型是<code>Object&amp;&amp;</code>，故优先匹配上了移动构造器而非拷贝构造器，而移动构造器中，我们的所作所为正是将参数的数据成员搬空！<strong>换言之，<code>std::move</code>就像是一个标记器，它将一个左值标记成了将亡值(还记得上一讲的表达式值分类吗？返回类型为右值引用的类型转换表达式是一个xvalue)，而后根据值语义和重载函数参数匹配规则，触发了移动构造器(或移动赋值运算符)的调用，而真正做资源归属转移的正是移动构造器(或移动赋值运算符)，这也就是上文一再强调，<code>std::move</code>本身没有做移动操作，真凶另有其人，<code>std::move</code>只能算作一个帮凶，没有移动构造器(或移动赋值运算符)，它什么也做不成。</strong></p><p>接下来，<code>c</code>是复制的<code>a</code>，由于我们的拷贝构造器中对<code>data_ptr_</code>做了深拷贝，故其打印结果与<code>a</code>并不相同。而<code>d</code>是移动的<code>b</code>，打印出的结果实际上就是<code>b</code>未被搬空前的成员值。</p><p>总结一下，这里用了三种典型的数据类型来对比拷贝和移动的差别：</p><ul><li>对于基础内建类型，无所谓拷贝还是移动，通通copy bit by bit</li><li>对于复杂的类类型嵌套，递归调用它本身的拷贝或移动构造器(or赋值运算符)</li><li>对于指针类型，默认行为是copy bit bybit，但我们往往需要自己重写BigFive来谨慎处理</li></ul><p>看到这里，一些同学一定会有这样的问题：说好的移动语义，怎么看上去还是东拼西凑呢？语法上为什么不对基础类型也来一个移动语义呢？比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> b = std::<span class="hljs-built_in">move</span>(a);<br><br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; b &lt;&lt; endl;<br>cout &lt;&lt; &amp;a &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;<br><span class="hljs-comment">// 输出结果:</span><br><span class="hljs-comment">// 3  3</span><br><span class="hljs-comment">// 0x16d11b7180x16d11b714</span><br><span class="hljs-comment">// a并没能被搬空，甚至继续使用也没有问题，a和b的地址也各不相同</span><br></code></pre></td></tr></table></figure><p>还记得移动语义的初衷吗？我们想要解决的是大对象冗余的拷贝，像是基础内建类型这种size非常小的数据，比如64bit机寄存器就可以一次性装载8B数据了，copy的成本过于低廉，真要支持个移动说不定反而效率更低(其他引用语义的语言如Java又何尝不是如此)。</p><blockquote><p>基础类型的raw数组也一样是copy bit by bit,但这个成本可能会很高昂，这也是modern C++不推荐用raw数组的原因之一。</p></blockquote><p>而另一方面，对于复杂的类类型比如<code>std::string</code>，它本身也是基础类型、指针和其他复杂类型堆砌而成，因此，它内部的移动构造或是移动赋值运算符的实现其实和我们这里对<code>size_</code>和<code>data_ptr_</code>的处理大同小异。</p><h2 id="移动语义的本质">移动语义的本质</h2><p>在了解了语言层面的移动语义实现机制后，我们需要再从复杂的语法规则中跳出来，高屋建瓴的思考移动语义的适用场景。一言以蔽之：<strong>移动语义适用于那些当某种资源已确定不再被需要的场景，此时仅需要通过移动语义做资源归属转移而非复制。</strong>C++为支撑移动语义所提供的语言机制，从值分类到右值引用再到移动构造/赋值运算符帮助我们完成了这一项工作，仅此而已。</p><p>上文中的例子是个"can be cast toxvalue"的场景，其中<code>b</code>不再被需要，通过<code>std::move</code>我们拿到其xvalue传递给了<code>d</code>的移动构造器，进而窃取资源。实际使用中，往往还有另一种场景，就是传入移动构造器的参数不是xvalue，而是一个prvalue，这常见于将那些返回类型为非引用类型的函数调用结果作为构造器参数的情景（虽然以前也有(N)RVO遮了羞）。</p><p>于是，对于移动构造器来说，我们在将参数的资源窃为己有后，一般会将其重置为默认态或者零值态（标准没有硬性规定要如何善后，但是规定了接下来对它的操作皆是UB行为（由编译器具体实现机制来买单）），正如我们在上例中对<code>size_</code>清零，对<code>data_ptr_</code>置空的操作，而<code>std::string</code>的移动构造器则是将字符串重置成空串作为善后处理手段。而移动赋值运算符则麻烦一点，因为被赋值的对象可能有历史的数据，尤其是对于指针型就要及时释放，避免memoryleak。</p><p>此外，移动构造器和移动赋值运算符只是两种比较特别的成员函数，并不是说移动只能在这两种函数内处理，比如，我们定义这样一个构造器：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>&#123;<br><span class="hljs-keyword">public</span>：<br>    <span class="hljs-built_in">Object</span>(std::string&amp;&amp; name) : <span class="hljs-built_in">name_</span>(std::<span class="hljs-built_in">move</span>(name)), <span class="hljs-built_in">size_</span>(<span class="hljs-number">16</span>), <span class="hljs-built_in">data_ptr_</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">16</span>]) &#123;&#125;<br>    。。。<br>&#125;;<br></code></pre></td></tr></table></figure>参数也可以是一个右值引用，此时我们可以通过<code>std::string</code>的移动构造器来将参数的资源偷走，而如果不进行窃取的话，比如改成：<code>name_(name)</code>（就会调用<code>std::string</code>的拷贝构造，因为<code>name</code>本身是左值）。</p><h2 id="stdmove">std::move</h2><p>上文也提到<code>std::move</code>是个函数模板，它的标准定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp;&amp;&gt;(<span class="hljs-type">__t</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>想要理解<code>std::move</code>，需要前置掌握这两个知识点：</p><ol type="1"><li><code>std::remove_reference_t&lt;T&gt;</code>是个typetrait，它会cut掉类型<code>T</code>的引用修饰符，返回裁剪后的类型，实际上是<code>typename std::remove_reference&lt;T&gt;::type</code>的别名模板，由C++14标准引入。</li><li>函数参数类型<code>T&amp;&amp;</code>在此并非右值引用，这里它搭配模板参数一起出现（本质上是<code>T</code>需要被推导时），是一个万能引用(UniversalReference)，它的真实类型遵循引用折叠规则。<ol type="1"><li>左值引用-左值引用<code>T&amp; &amp;</code>：左值引用<code>T&amp;</code></li><li>左值引用-右值引用<code>T&amp; &amp;&amp;</code>：左值引用<code>T&amp;</code></li><li>右值引用-左值引用<code>T&amp;&amp; &amp;</code>：左值引用<code>T&amp;</code></li><li>右值引用-右值引用<code>T&amp;&amp; &amp;&amp;</code>：右值引用<code>T&amp;&amp;</code></li></ol></li></ol><blockquote><p>Scott的《Effective Modern C++》的称其为万能引用（UniversalReference），这并不是标准的称呼，C++标准出台后称其为转发引用(ForwardingReference)，这个名称历来被诟病见名不知义，远不如Scott给出的称呼（当然它能当选也说明有忠实的拥趸，必有可取之处），故坊间皆以“万能引用”的说法传世，我们也弃用这个标准的说法，使用“万能引用”。</p></blockquote><blockquote><p>所有的引用折叠最终都代表一个引用，要么是左值引用，要么是右值引用。如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</p></blockquote><p>因此，对于<code>std::move</code>来说：</p><ul><li>如果传入的是左值，则参数类型被推导成左值引用，通过<code>static_cast</code>类型转换成右值引用返回。</li><li>如果传入的是右值，则参数类型被推导成右值引用，也通过<code>static_cast</code>类型转换成右值引用返回。</li></ul><p>至此，我们完成了右值引用和移动语义的学习，下一讲我们深入了解引用折叠、万能引用和完美转发机制。</p><h2 id="参考文献">参考文献</h2><ul><li><ahref="https://docs.microsoft.com/en-us/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170">Lvaluesand Rvalues</a></li><li><ahref="https://en.cppreference.com/w/cpp/language/value_category">Valuecategories</a></li><li><ahref="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/">EffectiveModern C++</a></li><li><ahref="https://stackoverflow.com/questions/39552272/is-there-a-difference-between-universal-references-and-forwarding-references">Isthere a difference between universal references and forwardingreferences?</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>program-language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>cpp-templates</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++模板从入门到劝退(0)——左值与右值</title>
    <link href="/2022/05/27/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(0)%E2%80%94%E2%80%94%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/"/>
    <url>/2022/05/27/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(0)%E2%80%94%E2%80%94%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述严谨性，按照笔者的归纳方式穿针引线，为痴迷于黑魔法而又始终不得其解的同学打通任督二脉。</p><p>本篇是走进模板世界的第一道前菜，只有搞懂了这些C++中的基本概念，才能掌握模板世界的黑魔法。</p><span id="more"></span><h1 id="左值与右值">左值与右值</h1><p>随着C++11新标准的制定，C++正式进入现代(modern)时代，相对于传统(traditional/old)C++、新标准的推行可谓是革命性的船新版本。而这一变革带来了两种情况：</p><ol type="1"><li>C++神教的新教徒在阅读传统C++代码时会满脸黑人问号：这是个什么方言？</li><li>尚未解锁现代C++的传统C++程序员在接触新标准时会惊呼：还有这种操作？快住手，这根本不是C++！</li></ol><blockquote><p>在《C++ Primer5th》问世时，我曾自信满满淘得一本，自诩有着刷了4遍4th的经验，打开了新世界的大门，然后直接自闭。</p></blockquote><p>当大家聊起C++11时，最先想到的可能就是移动语义，没错，这个移动语义可谓是万恶之源，它一方面解决了C++长久以来的顽疾，另一方面也让原本就复杂的语法规则变本加厉。</p><h2 id="值语义">值语义</h2><p>传统C++的顽疾在于基于值语义(ValueSemantics)的冗余拷贝和赋值。所谓值语义，这是很多OO(ObjectOriented)语言中没有的概念，诸如Java,C#等大多数语言，几乎所有的变量都是引用语义(ReferenceSemantics)（它们天生有着GC(GarbageCollector)来管理所有对象的生命周期，开发者无需操心）。而C++并没有做如此现代化的封装，对外呈现的语言生态相当裸露，值语义是指目标对象由源对象拷贝生成，生成的目标对象与源对象毫无关系彼此独立（一些引用语义的编程语言可能只有基础类型是值语义，但同样的它们为了消除违和感对值语义只字不提，而是强调基础类型的特殊性）。对于不了解值语义的C++初学者来说，会想当然的把C++中的引用看成和其他引用语义编程语言中引用的对等概念，这在传统C++中最多是在使用体验上感觉到有些别扭，而到了C++11后，由于对左值引用、右值引用进行了区分，就使得原本理解上的缺失被进一步放大，自然而然得感觉右值引用莫名其妙。</p><blockquote><p>C++对变量生命周期的一种优雅管理方式是RAII，不过不代表RAII能解决所有场景的变量生命期管理需求，更不代表GC没用。</p></blockquote><p>我们以纯OO语言Java为例，如果写这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1;<br><br>        System.out.println(System.identityHashCode(s1));<br>        System.out.println(System.identityHashCode(s2));<br>        System.out.println(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs zsh">2060468723<br>2060468723<br>true<br></code></pre></td></tr></table></figure><p>可以看到，Java中<code>s1,s2</code>就是引用语义的典范，它们指向的对象是同一个，而在引用语义的编程语言中，这也被称作浅拷贝(ShallowCopy)：在进行赋值、方法传参和返回值时，对于引用类型（非基本类型）一概按引用传递（传址）。</p><blockquote><p>是不是觉着很简单很直观，如果再定义一个<code>String s3 = "hello";</code>，思考下<code>s3</code>和<code>s1</code>是不是同一个对象呢？如果换成<code>String s3 = new String("hello"); String s4 = new String("hello");</code>，<code>s3</code>和<code>s4</code>和<code>s1</code>又是什么关系呢？当然，这是Java体系下的另一个话题了。</p></blockquote><p>再看Python 3:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&quot;hello&quot;</span><br>s2 = s1<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(s1))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(s2))<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">4341128096<br>4341128096<br></code></pre></td></tr></table></figure><p>显然赋值操作是按引用进行传递，<code>s1,s2</code>所指是同一个对象。</p><blockquote><p>我常说python是一门乱七八糟的语言，所谓“动态类型一时爽，代码重构火葬场”。如果定义<code>s3 = "hello"</code>，<code>s3</code>和<code>s1</code>是什么关系呢？如果把"hello"换成"helloworld"呢？当然，这也是Python体系下的另一个话题了。</p></blockquote><blockquote><p>对于Java和Python这类工程/工具语言，没必要过于学究，实际上许多经验丰富的Java/Python程序员对这两个问题也是懵逼的，但这丝毫不影响写出健壮可用的代码，这些问题可能也就面试会被问到。。。但是对于C++来说，凡事都得学究一点，哪怕是经验丰富的C++程序员也常常犯语法错误。</p></blockquote><p>那么在C++中，对于标准库的<code>string</code>来说，我们进行类似的赋值是什么结果呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span>&#123;<br>    string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>    string s2 = s1;<br><br>    cout &lt;&lt; &amp;s1 &lt;&lt; endl;<br>    cout &lt;&lt; &amp;s2 &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">0x16d94f678<br>0x16d94f660<br></code></pre></td></tr></table></figure><p>可以看到<code>s1,s2</code>的地址并不相同，对于非基础类型，C++中使用相同类型的对象做初始化赋值的语义是去调用该类型的拷贝构造器(copyctor)（C++中初始化赋值和普通的赋值语义并不等同，后者在这种情况下调用的是拷贝赋值操作符(copyassignment))。此外，对于第一行<code>string s1 = "hello";</code>也并没有表面看上去那样简单，<code>std::string</code>并不是基础类型，赋值初始化在C++的语义是调用相应的拷贝构造器，但是由于<code>"hello"</code>这个字符串字面量的类型是<code>const char[6]</code>（有界常量字符数组，而且标准规定字符串字面量是左值），并不能匹配拷贝构造器的参数，因此按照常理来说编译应该报错才对。但另一方面，C++在某些特定场合支持适宜的隐式(implicit)转换，上述代码会先用<code>"hello"</code>隐式的生成一个临时的string对象（这需要<code>std::string</code>有一个接受<code>const char[6]</code>或其退化(decay)类型的构造器），然后再调用拷贝构造器将临时对象复制给<code>s1</code>。</p><p>我们尝试来探讨一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 如果加explicit关键字，那么String s1 = &quot;hello&quot;;就无法进行隐式转换而报错</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pstr) : <span class="hljs-built_in">s_</span>(pstr) &#123; cout &lt;&lt; <span class="hljs-string">&quot;call custom ctor&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; rhs) : <span class="hljs-built_in">s_</span>(rhs.s_) &#123; cout &lt;&lt; <span class="hljs-string">&quot;call copy ctor&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-keyword">private</span>:<br>    string s_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span>&#123;<br>    String s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>    String s2 = s1;<br><br>    cout &lt;&lt; &amp;s1 &lt;&lt; endl;<br>    cout &lt;&lt; &amp;s2 &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">call custom ctor<br>call copy ctor<br>0x7ff7b4ac1658<br>0x7ff7b4ac1640<br></code></pre></td></tr></table></figure><p>显然，运行结果并不符合预期，理论上除了<code>String s2=s1;</code>这一行会调用copyctor以外，<code>String s1 = "hello";</code>也应该调用一次才对，为什么只看到了一次customctor呢？这是因为C++11标准定义了复制省略(CopyElision)技术（诸如<code>String s1 = "hello";</code>的写法其实非常的符合直觉，但是因为值语义的关系，C++却不得不多做一次值拷贝），要求编译器在实现时对这一情景做一次合理的拷贝消除。实际上，在C++11标准化之前各大厂商的编译器就已经为这事买单了（委员会的“懒汉们”永远是亡羊补牢），传统C++的开发者应该也了解诸如RVO(ReturnValue Optimization), NRVO(Named Return ValueOptimization)等技术，而这本质上做的就是特定场合的复制省略（未标准化之前，可以视作语言天然缺陷的遮羞布）。</p><p>如果我们通过编译选项关闭复制省略(-fno-elide-constructors)，重新运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zsh">call custom ctor<br>call copy ctor<br>call copy ctor<br>0x7ff7bf7ba658<br>0x7ff7bf7ba618<br></code></pre></td></tr></table></figure><h2 id="表达式值分类">表达式值分类</h2><p>C++中基于值语义的拷贝构造和拷贝赋值，可能会导致大对象的冗余拷贝从而引发性能瓶颈。虽然开发者可以通过指针和引用来规避掉部分场景的copy（编译器也十分配合的蒙上遮羞布），但还是有诸多场景无可避免。我曾看过这么一个形象的比喻：要把大象从A冰箱转移到B冰箱需要几步呢？普通青年的做法是3步：打开冰箱A和B的门；把大象从A转移(move)到B；关闭冰箱A和B。2B青年的做法则是：打开冰箱A和B的门；启用量子复制系统在冰箱B克隆出大象；启用射频消融技术将A中大象解体气化。没错，C++曾经就是这个2B青年。</p><p>移动(move)这件事本身很好理解，因为这是一个符合直觉的做法，但是对背着重重历史包袱的C++来说，想要从语言层面理解移动，就需要前置理解这样一个概念：左值(lvalue)和右值(rvalue)。实际上，左值和右值并不是C++11所引入的术语，这两个概念的历史由来可以追溯到编程语言CPL，那么彼时何为左值和右值呢？顾名思义，在赋值操作符('=')左边的就是左值，右边的就是右值，而这也是左值和右值得以命名的历史原因。C语言继承了CPL的分类法，但是弱化了赋值的作用，C语言中左值一开始表示可以被赋值的对象，但由于<code>const</code>的引入，这类对象被修正称作“可更改的左值”，而右值则被视为“值”的同义词，分类上通通都叫作其他(others)（函数和非对象值）。由于const，我们不能再通过表达式值可否修改来判断是否是左值，而是通过是否可寻址（于是坊间流传的一个不严谨的说法就是：左值对应变量的存储位置，右值对应变量的值本身）。</p><blockquote><p>一种说法是ISO C中的lvalue其实是locatorvalue的缩写，算是个美丽的巧合。</p></blockquote><p>传统C++(C++98)对表达式的值分类继承了C的做法，但复辟了右值的称呼，此外，C++98规定函数为左值（因为可以被取地址，在后续的标准演进中函数甚至当家做主成了一等公民，实际上除了函数还有一些其他类似情况的表达式也被视为左值），而C++中的引用可以被绑定在左值之上，但不能绑定到右值（只有const引用可以绑定到右值）。截止C++03，我们把具有标识(identity)的表达式视为左值，没有标识的表达式视为右值。因此，名称、指针、引用都是左值，是命名对象，它们有可以寻址的确定内存地址；字面量、临时对象等视为右值，右值仅在创建它的表达式中可以被访问。函数名称是左值，数组名称是常量左值（只不过大多数表达式中函数名和数组名被自动隐式转换成右值）。右值的生命周期短暂，所以需要左值去捕获它，把右值拷贝(copy)给左值是常规操作。</p><p>然而在C++11之后，为了支撑移动语义引入了右值引用，因此左值和右值的定义发生了很大变化。右值引用可以绑定到右值上来给临时对象续命，而移动语义则把临时对象移动(move)而不是拷贝(copy)到左值对象上。对于左值和右值的分类，标准不得不做一些扩充和修正：</p><ul><li>左值(lvalue): 指定一个对象(object)或函数(function)。<ul><li>如果<code>E</code>是某种类型的指针类型，那么<code>*E</code>就是一个左值表达式，它引用的是<code>E</code>所指向的对象(object)或函数(function)。</li><li>调用一个返回类型为左值引用的函数，其结果是一个左值。</li></ul></li><li>将亡值(xvalue): expiringvalue的缩写，也指定一个对象，这个对象通常是生命周期即将结束的状态，因此它可以被移动。xvalue是某些涉及右值引用的表达式的结果。<ul><li>调用一个返回类型为右值引用的函数，其结果就是一个xvalue。</li></ul></li><li>泛左值(glvalue): lvalue或者是xvalue。</li><li>右值(rvalue):xvalue，临时的对象或子对象，或者是与对象无关的值。</li><li>纯右值(prvalue): 非xvalue的rvalue。<ul><li>调用一个返回类型为非引用类型的函数，其结果就是一个prvalue。</li></ul></li></ul><p><img src="2022-05-30-14-22-25.png" /></p><blockquote><p>大部分初学者都会因为不了解xvalue和prvalue的概念而想当然地把lvalue和rvalue想象成同一层级的概念，而这在学习过程中就会遇到重重困扰，进而对rvalue的概念云里雾里。实际上rvalue是个混合分类。</p></blockquote><p>自此，表达式的值分类不仅考虑了标识(identify)，还考虑了可移动性(movability)。我们按照标准做一下归纳：</p><ul><li>左值(lvalue): 具有标识，不可移动。</li><li>将亡值(xvalue): 具有标识，可以移动。</li><li>纯右值(prvalue): 没有标识，可以移动。</li><li>泛左值(glvalue): 具有标识</li><li>右值(rvalue): 可以移动</li></ul><p>这样一分类，是不是有种恍然大悟的感觉~</p><p>那么再看看三种基本值类型都对应哪些表达式呢？这里参考reference手册并裁剪掉一些cornercase：</p><ul><li>左值(lvalue):<ul><li>变量名、函数名、数据成员<ul><li>即使变量类型是右值引用，变量本身依然是左值(这不是特例，是正统的语法规则)</li><li><code>std::getline</code></li><li><code>std::cin</code>, <code>std::endl</code></li></ul></li><li>返回类型为左值引用的函数调用或操作符重载或类型转换<ul><li><code>std::getline(std::cin, str)</code></li><li><code>std::cout &lt;&lt; 1</code>, <code>str1 = str2</code>,<code>++it</code></li><li><code>static_cast&lt;int&amp;&gt;(val)</code></li></ul></li><li>返回类型为函数右值引用的函数调用或操作符重载或类型转换<ul><li><code>static_cast&lt;void (&amp;&amp;)(int)&gt;(x)</code></li></ul></li><li>内建(built-in)的赋值与复合赋值表达式<ul><li><code>a=b</code></li><li><code>a+=b</code>,<code>a*=b</code></li></ul></li><li>内建(built-in)的前缀自增、自减<ul><li><code>a++</code></li><li><code>a--</code></li></ul></li><li>内建(built-in)的解引用表达式<ul><li><code>*p</code></li></ul></li><li>内建(built-in)的下标操作符表达式<ul><li><code>a[n]</code>, <code>p[n]</code></li></ul></li><li>对象成员访问，内建(built-int)的指针成员访问<ul><li><code>a.m</code>(<code>m</code>不能是枚举成员，也不能是非静态成员函数）</li><li><code>t.m</code>(<code>t</code>为右值且<code>m</code>为非静态数据成员)</li><li><code>p-&gt;m</code>(<code>m</code>不能是成员枚举值，也不能是非静态成员函数)</li></ul></li><li>对象的成员指针访问，内建(built-in)的指针的成员指针访问（成员指针的指针本质上是偏移，和普通的指针不太一样，导致这两个东西非常的拗口和别扭）<ul><li><code>a.*mp</code>(<code>a</code>是左值，<code>mp</code>是数据成员指针)</li><li><code>p-&gt;*mp</code>(<code>mp</code>是数据成员指针)</li></ul></li><li>右端为左值的逗号表达式<ul><li><code>a, b</code>(<code>b</code>是左值)</li></ul></li><li>二、三操作数为特定值的三元运算符</li><li>字符串字面量(String Literal)<ul><li><code>"hello"</code></li></ul></li></ul></li><li>纯右值(prvalue):<ul><li>字面量<ul><li><code>42</code></li><li><code>'a'</code></li><li><code>true</code></li><li><code>nullptr</code></li></ul></li><li>返回类型为非引用的函数调用或操作符重载或类型转换<ul><li><code>str.substr(1, 2)</code></li><li><code>str1 + str2</code></li><li><code>it++</code></li><li><code>static_cast&lt;double&gt;(x)</code>,<code>std::string&#123;&#125;</code>, <code>(int)42</code></li></ul></li><li>内建(built-in)的后缀自增、自减表达式<ul><li><code>a++</code></li><li><code>b--</code></li></ul></li><li>内建(built-in)的算数、逻辑、比较、取地址表达式<ul><li><code>a + b</code>, <code>a % b</code>, <code>a &amp; b</code>,<code>a &lt;&lt; b</code></li><li><code>a &amp;&amp; b</code>, <code>a || b</code>,<code>!a</code></li><li><code>a &lt; b</code>, <code>a == b</code>,<code>a &gt;= b</code></li><li><code>&amp;a</code></li></ul></li><li>对象成员访问，内建(built-in)的指针成员访问<ul><li><code>a.m</code>(<code>m</code>是成员枚举值或非静态成员函数)</li><li><code>p-&gt;m</code>(<code>m</code>是成员枚举值或非静态成员函数)</li></ul></li><li>对象的成员指针访问，内建(built-in)的指针的成员指针访问<ul><li><code>a.*mp</code>(<code>mp</code>是成员函数指针)</li><li><code>p-&gt;*mp</code>(<code>mp</code>是成员函数指针)</li></ul></li><li>右端为右值的逗号表达式</li><li>二、三操作数为特定值的三元表达式</li><li><code>this</code>指针</li><li>枚举值</li><li>lambda表达式<ul><li><code>[](int x)&#123; return x * x; &#125;</code></li></ul></li></ul></li><li>将亡值(xvalue):<ul><li>返回类型为右值引用的函数调用或操作符重载或类型转换<ul><li><code>std::move(x)</code></li><li><code>static_cast&lt;char&amp;&amp;&gt;(x)</code></li></ul></li><li>对象成员访问<ul><li><code>t.m</code>(<code>t</code>是右值且<code>m</code>是非静态非引用数据成员)</li></ul></li><li>对象的成员指针访问<ul><li><code>t.*mp</code>(<code>t</code>是右值且<code>mp</code>是数据成员指针)</li></ul></li><li>二、三操作数为特定值的三元表达式</li></ul></li></ul><blockquote><p>三元表达式目前的分类比较复杂，详见https://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator</p></blockquote><p>这里的分类因C++历史的演进而变得非常复杂，初学者没必要全盘记住，实际上日后了解了更多的细节后，会发现这里的分类其实是非常直观的。至此，如果你能看到这里，那么恭喜你，基础的内容你已经掌握了，下一讲，我们谈谈右值引用和移动语义。</p><h2 id="参考文献">参考文献</h2><ul><li><ahref="https://docs.microsoft.com/en-us/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170">Lvaluesand Rvalues</a></li><li><ahref="https://en.cppreference.com/w/cpp/language/value_category">Valuecategories</a></li><li><ahref="https://en.wikipedia.org/wiki/Value_(computer_science)">Value(ComputerScience)</a></li><li><ahref="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/">EffectiveModern C++</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>program-language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>cpp-templates</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十二)——图和网络</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%8C)%E2%80%94%E2%80%94%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%8C)%E2%80%94%E2%80%94%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>这一讲作为第一部分的最后一节内容，主要着重于描述线性代数的应用。</p><span id="more"></span><h1 id="图和网络">图和网络</h1><h2 id="有向图">有向图</h2><p>给定一个有向图：4节点，5条边</p><p><img src="2022-05-14-16-56-35.png" /></p><p>可以用如下方式来抽象描述： <span class="math display">\[\begin{array}{c | c c c c}&amp; node_1 &amp; node_2 &amp; node_3 &amp; node_4\\ \hlineedge_1 &amp; -1     &amp; 1      &amp; 0      &amp; 0\\ edge_2 &amp; 0      &amp; -1     &amp; 1      &amp; 0\\ edge_3 &amp; -1     &amp; 0      &amp; 1      &amp; 0\\ edge_4 &amp; -1     &amp; 0      &amp; 0      &amp; 1\\ edge_5 &amp; 0      &amp; 0      &amp; -1     &amp; 1\end{array}\]</span></p><p>写成<span class="math inline">\(5\times 4\)</span>矩阵来表示如下：<span class="math display">\[A=\begin{bmatrix}-1 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; -1 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; -1 &amp; 1\end{bmatrix}\]</span></p><p>这种矩阵叫做关联矩阵，其中每一列代表一个节点，每一行代表一条边（正负代表方向）。关联矩阵一般是稀疏阵，因为每一行只有两个非零元素。通过观察前三行，可以看出这三个行向量线性相关，而实际上，它的物理意义就是这三个向量（三条边）可以形成回路。</p><h3 id="a的零空间"><span class="math inline">\(A\)</span>的零空间</h3><p>矩阵<span class="math inline">\(A\)</span>的零空间可以通过解<spanclass="math inline">\(Ax=0\)</span>来得到，有： <spanclass="math display">\[Ax=\begin{bmatrix}-1 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; -1 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; -1 &amp; 1\end{bmatrix}\begin{bmatrix}x_1\\ x_2\\ x_3\\ x_4\end{bmatrix}=0\]</span></p><p>展开得： <span class="math display">\[\begin{bmatrix}x_2-x_1\\ x_3-x_2\\ x_3-x_1\\ x_4-x_1\\ x_4-x_3\end{bmatrix}=\begin{bmatrix}0\\ 0\\ 0\\ 0\\ 0\end{bmatrix}\]</span></p><p>引入矩阵的实际意义：将<spanclass="math inline">\(x=\begin{bmatrix}x_1 &amp; x_2 &amp; x_3 &amp;x_4\end{bmatrix}\)</span>视为各节点电势，则式子中的诸如<spanclass="math inline">\(x_2-x_1\)</span>的元素，可以看做该边上的电势差。容易看出其中一个解<spanclass="math inline">\(x=\begin{bmatrix}1\\ 1\\ 1\\1\end{bmatrix}\)</span>，即等电势情况，此时电势差为<spanclass="math inline">\(0\)</span>。化简<spanclass="math inline">\(A\)</span>易得<spanclass="math inline">\(rank(A)=3\)</span>，所以其零空间维数应为<spanclass="math inline">\(n-r=4-3=1\)</span>，即<spanclass="math inline">\(\begin{bmatrix}1\\1\\1\\1\end{bmatrix}\)</span>就是其零空间的一组基。</p><p>Q: 那么以电势为例，零空间的物理意义是什么呢？ A:电势差和电流的形成之间有着直接关系，<spanclass="math inline">\(b=0\)</span>说明我们求解的情况是各个边上都没有电流（或者说电势差）的情况，而我们最后所得到的解就意味着，当各点电势相等时，边上电流（电势差）为零，符合我们的常识。而这就是零空间的物理意义。</p><h3 id="a的左零空间"><spanclass="math inline">\(A\)</span>的左零空间</h3><p><span class="math inline">\(A\)</span>的左零空间是什么呢？或者说<spanclass="math inline">\(A^T\)</span>的零空间是什么呢？即求<spanclass="math inline">\(A^Ty=0\)</span>： <span class="math display">\[A^Ty=0=\begin{bmatrix}-1 &amp; 0 &amp; -1 &amp; -1 &amp; 0\\ 1 &amp; -1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; -1\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}\begin{bmatrix}y_1\\ y_2\\ y_3\\ y_4\\ y_5\end{bmatrix}=\begin{bmatrix}-y_1-y_3-y_4\\ y_1-y_2\\ y_2+y_3-y_5\\ y_4+y_5\end{bmatrix}=\begin{bmatrix}0\\ 0\\ 0\\ 0\end{bmatrix}\]</span></p><p>接着说上文提到的的电势差，引入<spanclass="math inline">\(y\)</span>的实际物理意义：即各边上的电流。电流和电势差的关系服从欧姆定律：边上的电流值是边上电势差的倍数，这个倍速就是边的电导，亦即电阻的倒数，通常我们把这个常数视为一个系数矩阵记为<spanclass="math inline">\(C\)</span>。于是，矩阵<spanclass="math inline">\(C\)</span>就将电势差与电流联系了起来： <spanclass="math display">\[y=\begin{bmatrix}y_1\\ y_2\\ y_3\\ y_4\\ y_5\end{bmatrix}=C\begin{bmatrix}x_2-x_1\\ x_3-x_2\\ x_3-x_1\\ x_4-x_1\\ x_4-x_3\end{bmatrix}\]</span></p><p>实际上<spanclass="math inline">\(A^Ty=0\)</span>阐释的就是“基尔霍夫电流定律”（KCL），基尔霍夫电流定律是一个平衡方程，守恒定律，它说明了流入等于流出，电荷在结点上不会积累。</p><p>对于<spanclass="math inline">\(A^T\)</span>，根据上文得出其零空间的维数是<spanclass="math inline">\(2\)</span>，则零空间的基应该有两个向量。假设<spanclass="math inline">\(y_1=1\)</span>，也就是令<spanclass="math inline">\(1\)</span>安培的电流在边<spanclass="math inline">\(1\)</span>上流动，由图看出<spanclass="math inline">\(y_2\)</span>也应该为<spanclass="math inline">\(1\)</span>，再令<spanclass="math inline">\(y_3=-1\)</span>，也就是让<spanclass="math inline">\(1\)</span>安培的电流流回节点<spanclass="math inline">\(1\)</span>，得出<spanclass="math inline">\(y_4=y_5=0\)</span>；</p><p>得到一个符合KCL的向量<span class="math inline">\(\begin{bmatrix}1\\1\\ -1\\ 0\\0\end{bmatrix}\)</span>，代回方程组发现此向量即为一个解，这个解发生在节点<spanclass="math inline">\(1,2,3\)</span>组成的回路中，该解即为零空间的一个基。</p><p>如法炮制可以得出另一个基向量：<spanclass="math inline">\(\begin{bmatrix}0\\ 0\\ 1\\ -1\\1\end{bmatrix}\)</span>，这实际上是节点<spanclass="math inline">\(1,3,4\)</span>构成的回路。</p><p>如此，我们得到<spanclass="math inline">\(N(A^T)\)</span>的一组基为<spanclass="math inline">\(\begin{bmatrix}1\\ 1\\ -1\\ 0\\0\end{bmatrix}\quad\begin{bmatrix}0\\ 0\\ 1\\ -1\\1\end{bmatrix}\)</span>。</p><blockquote><p>节点<spanclass="math inline">\(1,2,3,4\)</span>构成的大回路实际上是两个基向量回路的叠加。</p></blockquote><h3 id="a的行空间"><span class="math inline">\(A\)</span>的行空间</h3><p>亦即<spanclass="math inline">\(A^T\)</span>的列空间，方便起见我们直接计算<spanclass="math inline">\(A^T\)</span>的列空间： <spanclass="math display">\[A^T=\begin{bmatrix}-1 &amp; 0 &amp; -1 &amp; -1 &amp; 0\\ 1 &amp; -1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; -1\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}\]</span></p><p>显然，<span class="math inline">\(A^T\)</span>的主列为第<spanclass="math inline">\(1,2,4\)</span>列，对应在图中就是边<spanclass="math inline">\(1,2,4\)</span>，可以发现这三条边没有组成回路（<strong>换句话说，线性无关等价于没有回路</strong>）。由<spanclass="math inline">\(4\)</span>个节点与<spanclass="math inline">\(3\)</span>条边组成的图没有回路，就表明<spanclass="math inline">\(A^T\)</span>的对应列向量线性无关，也就是（<spanclass="math inline">\(nodes-1\)</span>）条边线性无关。</p><blockquote><p>没有回路的图叫作树。</p></blockquote><p>再看左零空间的维数公式：<span class="math inline">\(dimN(A^T)=m-r\)</span>，左零空间的维数就是相互无关的回路的数量，于是得到<spanclass="math inline">\(loops=edges-(nodes-1)\)</span>，整理得： <spanclass="math display">\[nodes-edges+loops=1\]</span></p><p>此等式对任何图均有效，任何图都有此拓扑性质，这就是著名的欧拉公式：<span class="math display">\[节点数-边数+最小回路数=1\]</span></p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=570094064&amp;p=12&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B12%5D%20%E7%9F%A9%E9%98%B5%E5%BA%94%E7%94%A8%EF%BC%9A%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B012.pdf">矩阵应用：图与网络</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十一)——矩阵空间、秩1矩阵和小世界图</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4%E3%80%81%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4%E3%80%81%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>本讲是上一讲的扩展内容，共分为三部分：第一部分延续上一讲介绍了矩阵空间的特性并延展到微分方程的例子；第二部分介绍了一个特殊的秩1矩阵；第三部分介绍了图的概念以及图与矩阵的关系。</p><span id="more"></span><h1 id="矩阵空间秩1矩阵和小世界图">矩阵空间、秩1矩阵和小世界图</h1><h2 id="矩阵空间">矩阵空间</h2><p>话接上一讲，所有<span class="math inline">\(3\times3\)</span>的矩阵可以构成的封闭的空间（数乘和加法运算），记为<spanclass="math inline">\(M\)</span>，则其一组基为： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>对称矩阵构成的空间<spanclass="math inline">\(S\)</span>和上三角矩阵构成的空间<spanclass="math inline">\(U\)</span>是<spanclass="math inline">\(M\)</span>的子空间： 对称阵<spanclass="math inline">\(S\)</span>的基容易找到： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\end{bmatrix}\]</span></p><p>上三角阵<span class="math inline">\(U\)</span>的基： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>对角矩阵是对称阵和上三角矩阵的交，可以得到另一个子空间：<spanclass="math inline">\(D\)</span>，<spanclass="math inline">\(D\)</span>的基容易找到： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>因此，有：<span class="math inline">\(dim M=9\)</span>，<spanclass="math inline">\(dim S=6\)</span>，<span class="math inline">\(dimU=6\)</span>，<span class="math inline">\(dim D=3\)</span>。</p><ul><li>求和（sum）：<span class="math inline">\(S+U=M,dim(S+U)=9\)</span>；</li><li>求交（intersect）：<span class="math inline">\(S \cap U=D, dim(S\cap U)=3\)</span>；</li></ul><p>可以看出：<span class="math inline">\(dim S + dim U=12=dim(S+U) +dim(S \cap U)\)</span>。</p><blockquote><p><span class="math inline">\(S+U\)</span>其实就是<spanclass="math inline">\(M\)</span>，但是要注意<spanclass="math inline">\(S+U\)</span>并不是<span class="math inline">\(S\cup U\)</span>（这东西也不封闭，构不成空间），后者只包含了<spanclass="math inline">\(S\)</span>和<spanclass="math inline">\(U\)</span>，而前者包含的是<spanclass="math inline">\(S\)</span>中元素和<spanclass="math inline">\(U\)</span>中元素的线性组合，这样的线性组合显然包含了<spanclass="math inline">\(S\)</span>和<spanclass="math inline">\(U\)</span>，也即 <span class="math inline">\((S\cup U) \subseteq (S + U)\)</span>。</p></blockquote><h2 id="微分方程">微分方程</h2><p>空间内元素还可以进一步扩展，不仅限于矩阵或向量，比如还可以是微分方程的解。</p><p>例如，求解：<spanclass="math inline">\(\frac{d^2y}{dx^2}+y=0\)</span>，即<spanclass="math inline">\(y&#39;&#39;+y=0\)</span></p><p>方程的解有：<span class="math inline">\(y=\cos{x}, \quad y=\sin{x},\quad y=e^{ix}, \quad y=e^{-ix}\)</span>等等（<spanclass="math inline">\(e^{ix}=\cos{x}+i\sin{x}, \quade^{-ix}=\cos{x}-i\sin{x}\)</span>）</p><p>只考虑实数范围，该方程的通解为：<span class="math inline">\(y=c_1\cos{x} + c_2 \sin{x}\)</span>。</p><p>这很类似于零空间，可以把这些解看成零空间中的向量，其一组基为<spanclass="math inline">\(\cos{x},\sin{x}\)</span>，零空间的维数为2。同理，如果考虑复数范围，那么<spanclass="math inline">\(e^{ix}, e^{-ix}\)</span>也可以作为另一组基。</p><p>该微分方程的所有解的集合实际上就可以看做是一个“向量空间”，或者应该叫“解空间”，他们满足加法和数乘的封闭性。</p><h2 id="秩1矩阵">秩1矩阵</h2><p>秩<span class="math inline">\(1\)</span>矩阵，即秩为<spanclass="math inline">\(1\)</span>的矩阵。所有的秩<spanclass="math inline">\(1\)</span>矩阵都可以分解成一列乘以一行（<spanclass="math inline">\(A=UV^T\)</span>）的形式，如： <spanclass="math display">\[A=\begin{bmatrix}1&amp;4&amp;5\\ 2&amp;8&amp;10\end{bmatrix}=\begin{bmatrix}1\\ 2\end{bmatrix}\begin{bmatrix}1&amp;4&amp;5\end{bmatrix}\]</span></p><p>其中<span class="math inline">\(dimC(A)=1=dimC(A^T)\)</span>，<spanclass="math inline">\(U, V\)</span>均为列向量。</p><p>秩<spanclass="math inline">\(1\)</span>矩阵类似积木，任何矩阵都是由秩<spanclass="math inline">\(1\)</span>矩阵搭建而成的，如对于一个<spanclass="math inline">\(5 \times 17\)</span>秩为<spanclass="math inline">\(4\)</span>的矩阵，只需要<spanclass="math inline">\(4\)</span>个秩一矩阵就可以组合出来，具体过程类似于我们在第3讲中提到的矩阵乘法中的“列乘行”形式。</p><h2 id="同秩矩阵的集合">同秩矩阵的集合</h2><p>另外，矩阵的加法存在这样的性质：<span class="math inline">\(rank(A+B)\lerank(A)+rank(B)\)</span>。这意味着：对于同样规模的同秩矩阵所组成的集合，其加法是不封闭的。两个<spanclass="math inline">\(5\times 6\)</span>的秩为<spanclass="math inline">\(4\)</span>矩阵相加，结果的秩可能大于<spanclass="math inline">\(4\)</span>，因此，所有秩为<spanclass="math inline">\(4\)</span>的矩阵构成的集合并不是空间，同理，秩<spanclass="math inline">\(1\)</span>矩阵集合也不是空间。</p><h2 id="子空间转化">子空间转化</h2><p><span class="math inline">\(\mathbb{R}^4\)</span>空间中任一向量<spanclass="math inline">\(v=\begin{bmatrix}v_1\\ v_2\\ v_3\\v_4\end{bmatrix}\)</span>共有4个分量，取<spanclass="math inline">\(\mathbb{R}^4\)</span>中满足<spanclass="math inline">\(v_1+v_2+v_3+v_4=0\)</span>的所有向量组成一个向量空间<spanclass="math inline">\(S\)</span>，则<spanclass="math inline">\(S\)</span>显然是一个向量子空间。易看出，不论是使用系数乘以该向量，或是用两个满足条件的向量相加，其结果仍然落在分量和为零的向量空间中。</p><p><strong><span class="math inline">\(S\)</span>的维数</strong>从另一个角度看，<spanclass="math inline">\(v_1+v_2+v_3+v_4=0\)</span>等价于: <spanclass="math display">\[\begin{bmatrix}1&amp;1&amp;1&amp;1\end{bmatrix}\begin{bmatrix}v_1\\v_2\\v_3\\v_4\end{bmatrix}=0\]</span></p><p>则<span class="math inline">\(S\)</span>就是<spanclass="math inline">\(A=\begin{bmatrix}1&amp;1&amp;1&amp;1\end{bmatrix}\)</span>的零空间。<spanclass="math inline">\(rank(A)=1\)</span>，则对其零空间有<spanclass="math inline">\(rank(N(A))=n-r=3=dim N(A)\)</span>，则<spanclass="math inline">\(S\)</span>的维数是<spanclass="math inline">\(3\)</span>，其基为<spanclass="math inline">\(Av=0\)</span>的三个特解：<spanclass="math inline">\(\begin{bmatrix}-1\\1\\0\\0\end{bmatrix}\)</span>,<spanclass="math inline">\(\begin{bmatrix}-1\\0\\1\\0\end{bmatrix}\)</span>,<spanclass="math inline">\(\begin{bmatrix}-1\\0\\0\\1\end{bmatrix}\)</span></p><p>矩阵<span class="math inline">\(A\)</span>的四个基本子空间：</p><ul><li>列空间：<span class="math inline">\(dimC(A)=1\)</span>，其中一组基是<spanclass="math inline">\(\begin{bmatrix}1\end{bmatrix}\)</span>，可以看出列空间就是整个<spanclass="math inline">\(\mathbb{R}^1\)</span>空间。</li><li>零空间：<span class="math inline">\(dimN(A)=3\)</span>，其中的一组基是<spanclass="math inline">\(\begin{bmatrix}-1\\ 1\\ 0\\0\end{bmatrix}\begin{bmatrix}-1\\ 0\\ 1\\0\end{bmatrix}\begin{bmatrix}-1\\ 0\\ 0\\ 1\end{bmatrix}\)</span>。</li><li>行空间：<span class="math inline">\(dimC(A^T)=1\)</span>，其中的一组基是<spanclass="math inline">\(\begin{bmatrix}1\\ 1\\ 1\\1\end{bmatrix}\)</span>；</li><li>左零空间：<span class="math inline">\(dimN(A^T)=0\)</span>，因为<spanclass="math inline">\(A\)</span>转置后没有非零的<spanclass="math inline">\(v\)</span>可以使<spanclass="math inline">\(Av=0\)</span>成立，左零空间就只有<spanclass="math inline">\(\begin{bmatrix}0\end{bmatrix}\)</span>。</li></ul><p>综上： <span class="math display">\[dim C(A^T)+dim N(A)=4=n, dim C(A)+dim N(A^T)=1=m\]</span></p><h2 id="小世界图">小世界图</h2><p><strong>图是点和边的集合，边连通各个点。</strong></p><p><img src="2022-05-14-16-41-56.png" /></p><p>假设，每个人是图中的一个节点，如果两个人为朋友关系，则在这两个人的节点间添加一条边，通常来说，从一个节点到另一个节点只需要不超过<spanclass="math inline">\(6\)</span>步（即六条边）即可到达，这就是大名鼎鼎的“<strong>六度分割理论</strong>”。</p><p>图与矩阵有怎样的联系呢？下一讲会进行阐述。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569901788&amp;p=11&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B11%5D%20%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4%20%E7%A7%A91%20%E7%9F%A9%E9%98%B5/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B011.pdf">矩阵空间秩1 矩阵</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十)——四个基本子空间</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81)%E2%80%94%E2%80%94%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81)%E2%80%94%E2%80%94%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>这一讲系统地讲解了矩阵的四个基本子空间：行空间，列空间，零空间和左零空间。他们关系密切且极其重要，对于每个子空间，我们探索了基和维数并高度概括了其背后的关联性。</p><span id="more"></span><h1 id="四个基本子空间">四个基本子空间</h1><p>现有<span class="math inline">\(m \times n\)</span>矩阵<spanclass="math inline">\(A\)</span>，已知<spanclass="math inline">\(rank(A)=r, r\le min(n,m)\)</span>，则有：</p><ul><li>列空间<span class="math inline">\(C(A) \in \mathbb{R}^m, dimC(A)=r\)</span>。</li><li>零空间<span class="math inline">\(N(A) \in \mathbb{R}^n, dimN(A)=n-r\)</span>。</li><li>行空间<span class="math inline">\(C(A^T) \in \mathbb{R}^n, dimC(A^T)=r\)</span>。</li><li>左零空间<span class="math inline">\(N(A^T) \in \mathbb{R}^m, dimN(A^T)=m-r\)</span>。</li></ul><p>根据上一讲的内容，列空间和零空间的维数和基我们都已了然于胸，而实际上，行空间和左零空间也如出一辙，不过就是把<spanclass="math inline">\(A\)</span>做了转置以后，如法炮制得到的列空间和零空间。</p><blockquote><p>列空间的基：主元所在列的所有向量；零空间的基：所有线性无关的特解。</p></blockquote><p>事实上，除了先转置再如法炮制的法子以外，对于行空间和左零空间，我们还有更便捷的求解方法。</p><h2 id="行空间">行空间</h2>假如我们换个角度思考，直接来看<spanclass="math inline">\(A\)</span>的行向量组，消元得到： $ A=<span class="math display">\[\begin{bmatrix}1 &amp; 2 &amp; 3 &amp; 1\\ 1 &amp; 1 &amp; 2 &amp; 1\\ 1 &amp; 2 &amp; 3 &amp; 1\end{bmatrix}\underrightarrow{消元}\begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1\\ 0 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}\]</span><p>=R $</p><p>消元的本质是做行变换，此时A的列空间发生变化（<spanclass="math inline">\(C(R) \neqC(A)\)</span>），但却并不影响行空间。可以在<spanclass="math inline">\(R\)</span>中看出前两行就是行空间的一组基。所以，可以得出无论对于矩阵<spanclass="math inline">\(A\)</span>还是<spanclass="math inline">\(R\)</span>，其行空间的一组基，可以由<spanclass="math inline">\(R\)</span>矩阵的前<spanclass="math inline">\(r\)</span>行向量组成。</p><blockquote><p>这里的<spanclass="math inline">\(R\)</span>就是第七讲提到的简化行阶梯形式。</p></blockquote><h2 id="左零空间">左零空间</h2><p>对于左零空间，有<span class="math inline">\(A^Ty=0 \rightarrow(A^Ty)^T=0^T\rightarrow y^TA=0\)</span>，因此得名。</p><p>从转置视角来看，零空间的向量是A列向量的线性组合得到，同理左零空间的向量就是A行向量的线性组合。由此联想到前面的<spanclass="math inline">\(R\)</span>最简消元，<spanclass="math inline">\(R\)</span>的最后一个零行代表着行的线性组合产生了零向量，因此有：<spanclass="math inline">\(EA=R\)</span>，矩阵<spanclass="math inline">\(E\)</span>的最后一行向量就是将<spanclass="math inline">\(A\)</span>各行组合得到零向量的方式。</p><p>还记得怎么得到<spanclass="math inline">\(E\)</span>吗？采用Gauss-Jordan消元，将增广矩阵<spanclass="math inline">\(\left[\begin{array}{c|c}A_{m \times n} &amp; I_{m\times m}\end{array}\right]\)</span>中<spanclass="math inline">\(A\)</span>的部分划为简化行阶梯形式<spanclass="math inline">\(\left[\begin{array}{c|c}R_{m \times n} &amp; E_{m\times m}\end{array}\right]\)</span>，<spanclass="math inline">\(E\)</span>将<spanclass="math inline">\(A\)</span>变为<spanclass="math inline">\(R\)</span>的同时，也把<spanclass="math inline">\(I\)</span>变成了<spanclass="math inline">\(E\)</span>，化简完毕我们就得到了矩阵<spanclass="math inline">\(E\)</span>，而它则会把所有的行变换操作记录下来。</p><p>本例中： <span class="math display">\[\left[\begin{array}{c|c}A_{m \times n} &amp; I_{m \timesm}\end{array}\right]=\left[\begin{array}{c c c c|c c c}1 &amp; 2 &amp; 3 &amp; 1 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 1 &amp; 2 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\ 1 &amp; 2 &amp; 3 &amp; 1 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\underrightarrow{消元}\left[\begin{array}{c c c c|c c c}1 &amp; 0 &amp; 1 &amp; 1 &amp; -1 &amp; 2 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; -1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 1\end{array}\right]=\left[\begin{array}{c|c}R_{m \times n} &amp; E_{m \timesm}\end{array}\right]\]</span></p><p>则 <span class="math display">\[EA=\begin{bmatrix}-1 &amp; 2  &amp; 0\\ 1  &amp; -1 &amp; 0\\ -1 &amp; 0  &amp; 1\end{bmatrix}\cdot\begin{bmatrix}1 &amp; 2 &amp; 3 &amp; 1\\ 1 &amp; 1 &amp; 2 &amp; 1\\ 1 &amp; 2 &amp; 3 &amp; 1\end{bmatrix}=\begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1\\ 0 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}=R\]</span></p><p>很明显，式中<span class="math inline">\(E\)</span>的最后一行对<spanclass="math inline">\(A\)</span>的行做线性组合后（行视角：-1个行1+0个行2+1个行3），得到<spanclass="math inline">\(R\)</span>的最后一行，即<spanclass="math inline">\(0\)</span>向量，也就是<spanclass="math inline">\(y^TA=0\)</span>。另一方面，<spanclass="math inline">\(E\)</span>的第三行对应的行向量就是矩阵<spanclass="math inline">\(A\)</span>的左零空间的基，维数是1。</p><h2 id="矩阵空间">矩阵空间</h2><p>不只是向量可以构建出空间，万物皆可构造出空间，只要满足加法和数乘的封闭性即可。</p><p>举个例子，矩阵可以同向量一样，做求和、数乘。那么什么样的矩阵构成的空间满足封闭性呢？比如，设所有<span class="math inline">\(3 \times3\)</span>矩阵组成的矩阵空间为<spanclass="math inline">\(M\)</span>。则上三角矩阵、对称矩阵、对角矩阵（前两者的交集）都可以构成矩阵空间。</p><p>观察一下对角矩阵，如果取：<span class="math inline">\(\begin{bmatrix}1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0\end{bmatrix} \quad \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 3 &amp;0 \\ 0 &amp; 0 &amp; 0 \end{bmatrix} \quad \begin{bmatrix} 0 &amp; 0&amp; 0 \\ 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 7 \end{bmatrix}\)</span>，可以发现，任何三阶对角矩阵均可用这三个矩阵的线性组合生成，因此，他们生成了三阶对角矩阵空间，即这三个矩阵是三阶对角矩阵空间的一组基。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569896824&amp;p=10&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B10%5D%20%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B010.pdf">四个基本子空间</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(九)——线性相关性、基和维数</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B9%9D)%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E3%80%81%E5%9F%BA%E5%92%8C%E7%BB%B4%E6%95%B0/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B9%9D)%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E3%80%81%E5%9F%BA%E5%92%8C%E7%BB%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>这一讲对向量组的线性相关性、线性无关性做了进一步的阐释，之后引出向量空间中基和维数的概念。</p><span id="more"></span><h1 id="线性相关性基和维数">线性相关性、基和维数</h1><h2 id="线性相关线性无关">线性相关、线性无关</h2><p>所谓的线性相关和线性无关是用于描述向量组中所有向量的关系，根据此前所掌握的知识，我们知道：以<spanclass="math inline">\(A\)</span>中列向量组为例，如果不存在零解以外的零向量的线性组合，那么列向量组就是线性无关的，否则就是线性相关的。</p><p>进一步，如果向量组包含一个零向量，那么该向量组一定是线性相关的（零向量取任意分量，其他向量取零分量）。</p><p>总结： 给定<span class="math inline">\(v_1,\ v_2,\ \cdots,\v_n\)</span>是<span class="math inline">\(m\times n\)</span>矩阵<spanclass="math inline">\(A\)</span>的列向量： - 如果<spanclass="math inline">\(A\)</span>零空间中有且仅有<spanclass="math inline">\(0\)</span>向量，则各向量线性无关，此时有：<spanclass="math inline">\(rank(A)=n\)</span>。 - 如果存在非零向量<spanclass="math inline">\(c\)</span>使得<spanclass="math inline">\(Ac=0\)</span>，则存在线性相关向量，此时有：<spanclass="math inline">\(rank(A)\lt n\)</span>。</p><p>用此前课程所掌握的知识来描述，前者就是列满秩，此时没有自由列，也就没有自由变量，因此零空间只有零向量，因而向量组线性无关；后者则存在自由列，零空间除了零向量以外还有其他向量，因而向量组线性相关。</p><p>至此，向量组的线性相关性与矩阵的零空间就联系起来了。</p><h2 id="基和维数">基和维数</h2><p>对于线性无关的情况，我们实际上关心的正是这一组“最小的”向量组：它们线性无关，且能生成相应大小的向量空间。而这恰恰就是“基”的概念。</p><p>向量空间的基本质上就是一个向量组，我们之所以额外地称这些向量组为基是因为其既有两个性质：- 向量组中的向量线性无关 -向量组中的向量能够生成相应大小的整个向量空间</p><p>因此，如果需要确定一个向量空间，那么只需要把向量空间对应的基找出来即可，向量空间对应的基包含了这个向量空间的全部有用信息。</p><p>进一步，对于向量空间<spanclass="math inline">\(\mathbb{R}^n\)</span>中的<spanclass="math inline">\(n\)</span>个向量，如果想要构成基，那么以这<spanclass="math inline">\(n\)</span>个向量为列向量的矩阵<spanclass="math inline">\(A\)</span>必然是可逆的。</p><p>显然向量空间<spanclass="math inline">\(\mathbb{R}^n\)</span>的基有无穷多个，而我们平常在选取的时候，则一般会选择标准基，所谓的<strong>标准基</strong>，就是向量空间中最明显的基，把每个基向量以一定顺序作为列向量，可以组成一个单位矩阵。另一方面，这无穷多个基有着一个共同点：基所包含的向量（基向量）的个数是一定的。而这个确定的基向量的个数实际上就表示了向量空间的大小，我们一般称其为向量空间的“<strong>维数</strong>”。</p><h2 id="案例">案例</h2><p><span class="math inline">\(A=\begin{bmatrix} 1 &amp; 2 &amp; 3 &amp;1 \\ 1 &amp; 1 &amp; 2 &amp; 1 \\ 1 &amp; 2 &amp; 3 &amp; 1\end{bmatrix}\)</span></p><h3 id="a的各列是不是a列空间的基">A的各列是不是A列空间的基？</h3><p>显然不是，列3是列1和列2的加和，列4和列1完全相同，A的列向量线性相关，所以不是基。这也意味着其零空间中有非零向量，不难看出<spanclass="math inline">\(rank(A)=2\)</span>。可以很容易的求得<spanclass="math inline">\(Ax=0\)</span>的两个解，如<spanclass="math inline">\(x_1=\begin{bmatrix} -1 \\ -1 \\ 1 \\ 0\end{bmatrix}, x_2= \begin{bmatrix} -1 \\ 0 \\ 0 \\ 1\end{bmatrix}\)</span>，而特解的个数就是自由变量的个数，所以<spanclass="math inline">\(n-rank(A)=2\)</span>，即自由变量存在的列数，亦是零空间的维数。</p><h3 id="给出a列空间的基和维数">给出A列空间的基和维数。</h3><p>可以取前两列线性无关列作为基。A列空间的维数是2。</p><h3 id="a零空间的维数是多少">A零空间的维数是多少？</h3><p>先找出零空间的基的个数，<spanclass="math inline">\(Ax=0\)</span>的特解有两个（自由变量有两个），所以零空间的维数也是2。</p><p>由此观之：</p><ul><li>列空间维数<span class="math inline">\(dim C(A)=rank(A), C(A)\in\mathbb{R}^m\)</span></li><li>零空间维数<span class="math inline">\(dim N(A)=n-rank(A), N(A)\in\mathbb{R}^n\)</span></li></ul><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569906223&amp;p=9&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B09%5D%20%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%EF%BC%8C%E5%9F%BA%EF%BC%8C%E7%BB%B4%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B09.pdf">线性相关性，基，维数</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(八)——求解Ax=b：可解性和解的结构</title>
    <link href="/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AB)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-b%EF%BC%9A%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <url>/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AB)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-b%EF%BC%9A%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>这一讲系统的讲解了线性方程组<spanclass="math inline">\(Ax=b\)</span>的求解，对可解性和解的结构进行了展开说明，得到了具体的通用解法：<spanclass="math inline">\(X_p+X_n\)</span>，并按照秩与<spanclass="math inline">\(m,n\)</span>的关系对解做了归类。</p><h1 id="求解axb可解性和解的结构">求解<spanclass="math inline">\(Ax=b\)</span>：可解性和解的结构</h1><p>我们知道<span class="math inline">\(Ax=b\)</span>未必有解，当<spanclass="math inline">\(A\)</span>的列空间无法线性组合出<spanclass="math inline">\(b\)</span>时，方程组是无解的。而在有解时可能存在唯一解，也可能存在无穷多个解，那么这其中又有什么规律呢？我们尝试按照上一讲对<spanclass="math inline">\(Ax=0\)</span>的研究方法来进行消元操作。</p><h2 id="可解性">可解性</h2><p>依然采用上一讲的矩阵：<span class="math inline">\(A=\begin{bmatrix} 1&amp; 2 &amp; 2 &amp; 2 \\ 2 &amp; 4 &amp; 6 &amp; 8 \\ 3 &amp; 6 &amp;8 &amp; 10 \end{bmatrix}\)</span>，求<spanclass="math inline">\(Ax=b\)</span>的特解。</p><p>这一次<span class="math inline">\(b\)</span>不再是<spanclass="math inline">\(0\)</span>向量，我们消元时写出增广矩阵： <spanclass="math display">\[\left[\begin{array}{c c c c|c}1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\ 2 &amp; 4 &amp; 6 &amp; 8 &amp; b_2\\ 3 &amp; 6 &amp; 8 &amp; 10 &amp; b_3\end{array}\right]\underrightarrow{消元}\left[\begin{array}{c c c c|c}1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\ 0 &amp; 0 &amp; 2 &amp; 4 &amp; b_2-2b_1\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; b_3-b_2-b_1\end{array}\right]\]</span></p><p>从最后一行可见，要使<spanclass="math inline">\(Ax=b\)</span>有解，则必须满足<spanclass="math inline">\(b_3-b_2-b_1=0\)</span>，而这就是可解性。</p><p>我们此前按照列空间视角，对此可以给出这样的解释：<spanclass="math inline">\(b\)</span>必须要属于<spanclass="math inline">\(A\)</span>的列空间才有解，也就是<spanclass="math inline">\(A\)</span>中各列的线性组合。</p><p>现在让我们换个角度来理解可解性：<strong>如果<spanclass="math inline">\(A\)</span>中各行线性组合产生了零行，那么向量<spanclass="math inline">\(b\)</span>的分量在同样的线性组合后也必须为零。</strong></p><h2 id="解的结构">解的结构</h2><p>设<span class="math inline">\(b=\begin{bmatrix} 1\\ 5\\ 6\end{bmatrix}\)</span>满足可解性，那么<spanclass="math inline">\(Ax=b\)</span>的解是什么呢？直观上来看，消元以后我们得到了两个方程，但是未知数有4个，因此，理论上我们可以找到无穷多个解（因为存在自由变量）。<span class="math display">\[\begin{cases}x_1+2x_2+2x_3+2x_4 = 1\\ 2x_3+4x_4 = 3\end{cases}\]</span></p><p>想要求得通解，首先我们要找出特解：先让所有的自由变量取<spanclass="math inline">\(0\)</span>，以解出此时主变量的值。这里自由变量是<spanclass="math inline">\(x_2\)</span>和<spanclass="math inline">\(x_4\)</span>，回代求得<spanclass="math inline">\(x_1=-2,x_3=\frac{3}{2}\)</span>，故特解<spanclass="math inline">\(x_p=\begin{bmatrix}-2\\ 0\\ \frac{3}{2}\\0\end{bmatrix}\)</span>。</p><blockquote><p>自由变量取<spanclass="math inline">\(0\)</span>只是为了方便计算，实际上你想取啥都行，因为它们会被主变量抵消、毫无贡献。</p></blockquote><p>显然，将特解<spanclass="math inline">\(x_p\)</span>加上上一讲所学的零空间中的任意向量(写为<spanclass="math inline">\(x_n\)</span>)就可以得到通解：<spanclass="math inline">\(x=x_p+x_n\)</span>。这是因为零空间的向量带入方程后结果永远是<spanclass="math inline">\(0\)</span>，它不会影响等式（<spanclass="math inline">\(A(x_p+x_n)=Ax_p+Ax_n=b+0=b\)</span>）。</p><p>而上一讲中我们得到了零空间解集为：<spanclass="math inline">\(x_n=c\begin{bmatrix} -2\\ 1\\ 0\\ 0\end{bmatrix}+d\begin{bmatrix} 2\\ 0\\ -2\\ 1 \end{bmatrix}\)</span></p><p>因此，<span class="math inline">\(Ax=b\)</span>的通解为<spanclass="math inline">\(\begin{bmatrix}-2\\ 0\\ \frac{3}{2}\\0\end{bmatrix}+c\begin{bmatrix} -2\\ 1\\ 0\\0\end{bmatrix}+d\begin{bmatrix}2\\ 0\\ -2\\ 1\end{bmatrix}\)</span></p><h2 id="解与秩的关系">解与秩的关系</h2><p>考虑秩为<span class="math inline">\(r\)</span>的<spanclass="math inline">\(m*n\)</span>矩阵<spanclass="math inline">\(A\)</span>，显然<span class="math inline">\(r\leqm, r\leq n\)</span>。</p><ul><li>当列满秩时(<span class="math inline">\(r=n\)</span>)，消元后<spanclass="math inline">\(R\)</span>为<spanclass="math inline">\(\begin{bmatrix}I \\0\end{bmatrix}\)</span>，意味着每一列都有主元，那么也就没有自由变量，此时零空间里只有零向量，因此若<spanclass="math inline">\(b\)</span>满足可解性，则解必唯一。</li><li>当行满秩时(<span class="math inline">\(r=m\)</span>)，消元后<spanclass="math inline">\(R\)</span>为<spanclass="math inline">\(\begin{bmatrix}I &amp;F\end{bmatrix}\)</span>，意味着没有零行，此时对<spanclass="math inline">\(b\)</span>就没有任何约束，那么<spanclass="math inline">\(Ax=b\)</span>是必然有解，自由变量有<spanclass="math inline">\(n-m\)</span>个，此时解有无穷多个。</li><li>当<spanclass="math inline">\(m=n=r\)</span>时，行列皆满秩，消元后<spanclass="math inline">\(R\)</span>为单位阵，不存在自由列，也没有零行对<spanclass="math inline">\(b\)</span>进行约束，因此必有解且解唯一。</li><li>当不满秩，即<span class="math inline">\(r&lt;n\)</span>且<spanclass="math inline">\(r&lt;m\)</span>时，消元后<spanclass="math inline">\(R\)</span>为<spanclass="math inline">\(\begin{bmatrix}I &amp; F \\ 0 &amp;0\end{bmatrix}\)</span>的形式，此时有两种情况：<ul><li>无解。零行约束了<span class="math inline">\(b\)</span>，但<spanclass="math inline">\(b\)</span>不满足约束条件。</li><li>无穷多个解。<spanclass="math inline">\(b\)</span>满足零行约束，解集为：特解+零空间任意向量</li></ul></li></ul><p>总结如下： <span class="math display">\[\begin{array}{c|c|c|c}r=m=n&amp;r=n\lt m&amp;r=m\lt n&amp;r\lt m,r\lt n\\ R=I&amp;R=\begin{bmatrix}I\\0\end{bmatrix}&amp;R=\begin{bmatrix}I&amp;F\end{bmatrix}&amp;R=\begin{bmatrix}I&amp;F\\0&amp;0\end{bmatrix}\\1\ solution&amp;0\ or\ 1\ solution&amp;\infty\ solution&amp;0\ or\\infty\ solution\end{array}\]</span></p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569898565&amp;p=8&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B08%5D%20Ax%3Db%20%E7%9A%84%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B08.pdf">Ax=b的可解性和解的结构</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(七)——求解Ax=0：主变量，特解</title>
    <link href="/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%83)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-0%EF%BC%9A%E4%B8%BB%E5%8F%98%E9%87%8F%EF%BC%8C%E7%89%B9%E8%A7%A3/"/>
    <url>/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%83)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-0%EF%BC%9A%E4%B8%BB%E5%8F%98%E9%87%8F%EF%BC%8C%E7%89%B9%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>这一讲深入探讨了求解<spanclass="math inline">\(Ax=0\)</span>过程中，消元法所得到的主列、自由列、自由变量与特解以及它们与矩阵的秩的关系。</p><span id="more"></span><h1 id="求解ax0-主变量特解">求解<spanclass="math inline">\(Ax=0\)</span>: 主变量，特解</h1><p>给定一个<span class="math inline">\(3\times 4\)</span>的矩阵： <spanclass="math inline">\(A=\begin{bmatrix}  1&amp;2&amp;2&amp;2  \\2&amp;4&amp;6&amp;8  \\ 3&amp;6&amp;8&amp;10 \end{bmatrix}\)</span></p><h2 id="求解零空间">求解零空间</h2><p>零空间由求<spanclass="math inline">\(Ax=0\)</span>的解集合组成，除了零向量以外，欲求其他解，首先要通过高斯消元法找到主变量：<span class="math display">\[A=\begin{bmatrix}1 &amp; 2 &amp; 2 &amp; 2\\ 2 &amp; 4 &amp; 6 &amp; 8\\ 3 &amp; 6 &amp; 8 &amp; 10\end{bmatrix}\underrightarrow{eliminate}\begin{bmatrix}\underline{1} &amp; 2 &amp; 2 &amp; 2\\ 0 &amp; 0 &amp; \underline{2} &amp; 4\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}=U\]</span></p><p>可以看出经过消元后，主变量还剩2个（下划线元素），因此矩阵<spanclass="math inline">\(A\)</span>的秩就是2，即<spanclass="math inline">\(r=2\)</span>。主变量所在的列我们称为主列，其余列则称为自由列。自由列对应的变量我们称为自由变量，那么自由变量的个数就是：<spanclass="math inline">\(n-r=4-2=2\)</span>。</p><p>高斯消元处理后，线性相关的行就会被暴露出来，比如<spanclass="math inline">\(A\)</span>矩阵的行三实际上就是行一和行二的加和，所以在消元后整行都变成了<spanclass="math inline">\(0\)</span>(<spanclass="math inline">\(0\)</span>行，即没有主元)。另一方面，线性相关的列也会被暴露，我们在消元过程中发现第二列原本要做主元的元素变成了0，这恰恰是因为第二列和前面的列（这里只有第一列）线性相关（刚好是两倍的列1），因此第二列没有主元，是自由列。而同样的，第四列也没有主元，这就说明第四列实际上是前三列的线性组合（两倍的第三列减第二列）。</p><p>消元的本质是行变换，行变换改变的是列向量（从而可能改变列空间），但是无法改变列向量之间的线性相关性。另一方面，消元不会改变零空间，因为<spanclass="math inline">\(b\)</span>为<spanclass="math inline">\(0\)</span>时，随你怎么折腾，他都是<spanclass="math inline">\(0\)</span>，解不会改变。</p><p>因此，<span class="math inline">\(Ax=0\)</span>求解问题变成了对<spanclass="math inline">\(Ux=0\)</span>的求解，首先我们找出主变量和自由变量，<spanclass="math inline">\(x_1\)</span>和<spanclass="math inline">\(x_3\)</span>是主变量，<spanclass="math inline">\(x_2\)</span>和<spanclass="math inline">\(x_4\)</span>是自由变量。自由变量可以对其分配任意的值（不管你赋什么值，都会被计算出来的主变量抵消掉）。</p><p><strong>我们对自由变量随意赋值，一般采用的一种简单策略是：对其中一个自由变量赋值为<spanclass="math inline">\(1\)</span>，其余赋值为<spanclass="math inline">\(0\)</span>，循环往复。</strong></p><p>通过这样的策略，我们对自由变量进行赋值，并回代求出主变量：</p><ul><li>令<span class="math inline">\(x_2=1, x_4=0\)</span>，得解<spanclass="math inline">\(x=\begin{bmatrix}-2\\ 1\\ 0\\0\end{bmatrix}\)</span></li><li>令<span class="math inline">\(x_2=0, x_4=1\)</span>，得解<spanclass="math inline">\(x=\begin{bmatrix}2\\ 0\\ -2\\1\end{bmatrix}\)</span></li></ul><p>这两个解我们称之为特解，<strong>特解的线性组合构成的向量空间就是零空间，零空间的每个向量都是方程组的解</strong>：<span class="math display">\[x=c\begin{bmatrix}-2\\ 1\\ 0\\ 0\end{bmatrix}+d\begin{bmatrix}2\\ 0\\-2\\ 1\end{bmatrix}\]</span></p><p><strong>特解之间线性无关。</strong></p><blockquote><p>求特解的策略非常优雅直观，采用控制变量的思想，我们每次只关注其中一个自由变量，避免自由变量的相互影响，从而得到所有的线性无关的特解。</p></blockquote><p><strong>归纳：对于<spanclass="math inline">\(m*n\)</span>矩阵，若其秩为<spanclass="math inline">\(r\)</span>，则主变量有<spanclass="math inline">\(r\)</span>个，自由变量有<spanclass="math inline">\(n-r\)</span>个。</strong></p><h2 id="rrefreduced-row-echelon-form">RREF(Reduced row echelonform)</h2><p>上例中消元得到的<spanclass="math inline">\(U\)</span>矩阵是个上三角阵，实际上还可以进一步简化成<spanclass="math inline">\(R\)</span>矩阵，即RREF(Reduced row echelonform)——简化行阶梯形式。</p><p><spanclass="math inline">\(R\)</span>矩阵中主元上下的元素都是0，主元提取公倍数化简为1：<span class="math display">\[U=\begin{bmatrix}\underline{1} &amp; 2 &amp; 2 &amp; 2\\ 0 &amp; 0 &amp; \underline{2} &amp; 4\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}\underrightarrow{自底向上}\begin{bmatrix}\underline{1} &amp; 2 &amp; 0 &amp; -2\\ 0 &amp; 0 &amp; \underline{1} &amp; 2\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}=R\]</span></p><p>将<spanclass="math inline">\(R\)</span>矩阵中的主列放在一起，自由列放在一起（列交换），得到：<span class="math display">\[R=\begin{bmatrix}\underline{1} &amp; 2 &amp; 0 &amp; -2\\ 0 &amp; 0 &amp; \underline{1} &amp; 2\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}\underrightarrow{列交换}\left[\begin{array}{c c | c c}1&amp;0&amp;2&amp;-2\\0&amp;1&amp;0&amp;2\\ \hline 0&amp;0&amp;0&amp;0\end{array}\right]=\begin{bmatrix}I &amp; F\\ 0 &amp; 0\end{bmatrix}\textrm{，其中}I\textrm{为主列组成的$r*r$大小的单位矩阵，}F\textrm{为自由列经过化简后组成的矩阵}\]</span></p><p>计算零空间矩阵<span class="math inline">\(N\)</span>（nullspacematrix），其列为特解，有<span class="math inline">\(RN=0\)</span>。<span class="math display">\[\begin{align}x_{pivot}=-Fx_{free}\\ \begin{bmatrix}I&amp;F\end{bmatrix}\begin{bmatrix}x_{pivot}\\ x_{free}\end{bmatrix}=0\\ N=\begin{bmatrix}-F\\ I\end{bmatrix}\end{align}\]</span></p><p>在本例中<span class="math inline">\(N=\begin{bmatrix}  -2&amp;2  \\0&amp;-2  \\ 1&amp;0  \\ 0&amp;1\end{bmatrix}\)</span>，与上面求得的两个<spanclass="math inline">\(x\)</span>特解一致，因此，可以利用<spanclass="math inline">\(R\)</span>直接求解零空间。</p><blockquote><p>主元的概念是消元带来的，而消元过程中挖掘的实际上就是行、列的线性相关性。</p></blockquote><p><strong>总结：<span class="math inline">\(A\)</span> 的主元个数 =<span class="math inline">\(A\)</span> 矩阵线性无关的列的个数 = <spanclass="math inline">\(A^T\)</span> 矩阵线性无关的行的个数 = <spanclass="math inline">\(A^T\)</span> 的主元个数。</strong></p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569901010&amp;p=7&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B07%5D%20%E6%B1%82%E8%A7%A3%20Ax%20%3D%200%EF%BC%8C%E4%B8%BB%E5%8F%98%E9%87%8F%EF%BC%8C%E7%89%B9%E8%A7%A3/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%5B%E4%B8%83%5D.pdf">求解Ax = 0，主变量，特解</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(六)——列空间和零空间</title>
    <link href="/2022/05/03/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AD)%E2%80%94%E2%80%94%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/05/03/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AD)%E2%80%94%E2%80%94%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>这一讲主要介绍了<strong>列空间</strong>和<strong>零空间</strong>。二者都是四个基本子空间的重要成员。</p><span id="more"></span><h1 id="列空间和零空间">列空间和零空间</h1><h2 id="子空间的并和交">子空间的并和交</h2><p>某向量空间的两个子空间<span class="math inline">\(S\)</span>和<spanclass="math inline">\(T\)</span>，它们的并（<spanclass="math inline">\(S\cup T\)</span>）不一定是子空间，但它们的交(<spanclass="math inline">\(S\capT\)</span>)一定是子空间，这一点是显而易见的：以<spanclass="math inline">\(R^3\)</span>举例，过原点的某个平面<spanclass="math inline">\(P\)</span>是一个子空间，过原点的某条直线<spanclass="math inline">\(L\)</span>也是一个子空间，如果<spanclass="math inline">\(L\)</span>不在平面<spanclass="math inline">\(P\)</span>上，那么我们从原点出发，取<spanclass="math inline">\(L\)</span>上的任意向量<spanclass="math inline">\(v\)</span>和平面<spanclass="math inline">\(P\)</span>上的任意向量<spanclass="math inline">\(w\)</span>，对二者进行加法操作，得到的向量<spanclass="math inline">\(v+w\)</span>既不在平面<spanclass="math inline">\(P\)</span>上，也不在直线<spanclass="math inline">\(L\)</span>上，所以子空间的交不一定是子空间（直线<spanclass="math inline">\(L\)</span>在平面<spanclass="math inline">\(P\)</span>上时才是）；而对于<spanclass="math inline">\(P\)</span>和<spanclass="math inline">\(L\)</span>的交来说，要么只有一个原点，要么是<spanclass="math inline">\(L\)</span>（此时<spanclass="math inline">\(L\)</span>在平面<spanclass="math inline">\(P\)</span>之内），它们的交依然是一个子空间。</p><p>沿此思路扩展到高维空间亦是如此，子空间的并放宽了限制条件导致规则被破坏，而子空间的交则实际上是进行了更严格的限制，(<spanclass="math inline">\(S\cap T\)</span>)既满足<spanclass="math inline">\(S\)</span>的法则，也满足<spanclass="math inline">\(T\)</span>的法则，因此它当然是子空间。</p><blockquote><p>严格的证明需要对数乘封闭和加法封闭分别进行论证。</p></blockquote><h2 id="列空间大小">列空间大小</h2><p><span class="math display">\[\begin{bmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1(n-1)} &amp; a_{1n}\\ a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2(n-1)} &amp; a_{2n}\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots\\ a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{m(n-1)} &amp; a_{mn}\end{bmatrix}\cdot\begin{bmatrix}x_{1}\\ x_{2}\\ \vdots\\ x_{n-1}\\ x_{n}\end{bmatrix}=\begin{bmatrix}b_{1}\\ b_{2}\\ \vdots\\ b_{m}\end{bmatrix}\]</span></p><p>矩阵<spanclass="math inline">\(A\)</span>的列空间是由它的各列线性组合构成。在探究列空间的大小时，又将回到这个问题：<spanclass="math inline">\(Ax=b\)</span>是否对任意的<spanclass="math inline">\(b\)</span>都有解？或者退一步，什么样的<spanclass="math inline">\(b\)</span>方程组才有解？</p><p>从列空间的视角出发，这一问题有更加具象的回答方式：<strong><spanclass="math inline">\(Ax=b\)</span>有解，当且仅当<spanclass="math inline">\(b\)</span>属于<spanclass="math inline">\(A\)</span>的列空间。只有当<spanclass="math inline">\(b\)</span>是<spanclass="math inline">\(A\)</span>各列的线性组合时，<spanclass="math inline">\(Ax=b\)</span>才有解。</strong></p><p>举个例子： <span class="math display">\[Ax=\begin{bmatrix}1 &amp; 1 &amp; 2\\ 2 &amp; 1 &amp; 3\\ 3 &amp; 1 &amp; 4\\ 4 &amp; 1 &amp; 5\end{bmatrix}\cdot\begin{bmatrix}x_1\\ x_2\\ x_3\end{bmatrix}=\begin{bmatrix}b_1\\ b_2\\ b_3\\ b_4\end{bmatrix}=b\]</span></p><p><span class="math inline">\(A\)</span>的三个列向量构成的是<spanclass="math inline">\(R^4\)</span>的一个子空间，由于列向量仅有3个，显然无论如何线性组合也无法铺满整个四维空间（正如两个三维向量无法铺满整个三维空间一样，它最多只能构成一个平面），因此，我们无法保证任意的向量<spanclass="math inline">\(b\)</span>，方程组都有解。当且仅当<spanclass="math inline">\(b\)</span>在三个列向量构成的<spanclass="math inline">\(R^4\)</span>子空间之内时，方程组才有解。</p><p>此外，我们还注意到，第三个列向量<spanclass="math inline">\(\begin{bmatrix}2\\3\\4\\5\end{bmatrix}\)</span>是前两个列向量的线性组合（两者相加），也就是说，第三个列向量对于线性组合来说毫无贡献，三个列向量最终形成的是一个<spanclass="math inline">\(R^4\)</span>空间内的平面。</p><p>因此，矩阵列空间的大小实际上与各列的线性无关性有关系，越多的列线性无关，那么它们能构成的列空间就越大，越多的列线性相关，那么其中相关的那一部分对列空间的构建就毫无贡献。</p><h2 id="零空间">零空间</h2><p>所谓零空间，就是由<spanclass="math inline">\(Ax=0\)</span>的所有解向量<spanclass="math inline">\(x\)</span>构成的空间。</p><p>还是考虑上例： <span class="math display">\[\begin{bmatrix}1 &amp; 1 &amp; 2\\ 2 &amp; 1 &amp; 3\\ 3 &amp; 1 &amp; 4\\ 4 &amp; 1 &amp; 5\end{bmatrix}\cdot\begin{bmatrix}x_1\\ x_2\\ x_3\end{bmatrix}=0\]</span></p><p><span class="math inline">\(x\)</span>有三个分量，所以<spanclass="math inline">\(x\)</span>构成的是一个<spanclass="math inline">\(R^3\)</span>的子空间。因此，对于<spanclass="math inline">\(m*n\)</span>的矩阵来说，其列空间是<spanclass="math inline">\(R^m\)</span>的子空间（列向量的维数），零空间是<spanclass="math inline">\(R^n\)</span>的子空间（列向量的个数）。</p><p>显然，零空间一定包含零向量：所有<spanclass="math inline">\(x_i\)</span>都为0显然是一个解，另一方面，不难证明零空间本身也是一个向量空间，满足矩阵加法与数乘的封闭性。</p><blockquote><p>零空间内任取两个向量<span class="math inline">\(v\)</span>和<spanclass="math inline">\(w\)</span>，由于<spanclass="math inline">\(Av=Aw=0\)</span>，故<spanclass="math inline">\(A(v+w)=0\)</span>，<spanclass="math inline">\(c(Av)=A(cv)=0\)</span>，证毕。</p></blockquote><blockquote><p>特别注意：零空间不是零向量空间，零向量空间只包含一个零向量，本质上是<spanclass="math inline">\(R^0\)</span>，零空间是一种子空间，可以包含无数个向量。</p></blockquote><p>针对上例，由于第三列是前两列的加和，我们可以轻松拿到一个特解：<spanclass="math inline">\(\begin{bmatrix}1\\1\\-1\end{bmatrix}\)</span>，其零空间就是：<spanclass="math inline">\(C\begin{bmatrix}1\\1\\-1\end{bmatrix}\)</span>（<spanclass="math inline">\(C\)</span>表示任意常数），即<spanclass="math inline">\(R^3\)</span>中的一条过原点的直线。</p><h3 id="思考">思考</h3><p>如果<span class="math inline">\(b\not=0\)</span>，那么对于<spanclass="math inline">\(x\)</span>的求解是否也能够找到一个向量空间呢？</p><p>答案是不能：若 <spanclass="math inline">\(b\not=0\)</span>，那么<spanclass="math inline">\(x\)</span>就不可能等于<spanclass="math inline">\(0\)</span>，这就意味着如果要形成向量空间，那么它无法包含零向量，这一点就已经违背了空间的法则。因此，解集无法构成一个向量空间。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569895746&amp;p=6&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B06%5D%20%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4/%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4.pdf">列空间和零空间</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(五)——转置、置换和向量空间R</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%94)%E2%80%94%E2%80%94%E8%BD%AC%E7%BD%AE%E3%80%81%E7%BD%AE%E6%8D%A2%E5%92%8C%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%94)%E2%80%94%E2%80%94%E8%BD%AC%E7%BD%AE%E3%80%81%E7%BD%AE%E6%8D%A2%E5%92%8C%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R/</url>
    
    <content type="html"><![CDATA[<p>这一讲内容包括转置、置换和向量空间<spanclass="math inline">\(R\)</span>，实际上是基于<spanclass="math inline">\(A=LU\)</span>的剖解提纲挈领，形而上学，引出线性代数的核心内容——向量空间。</p><span id="more"></span><h1 id="转置置换和向量空间r">转置、置换和向量空间R</h1><p>对于可逆矩阵<spanclass="math inline">\(A\)</span>，在消元过程中可能会遇到主元为0的情况，此时就需要进行行变换，而行变换的本质实际上就是左乘一个置换矩阵<spanclass="math inline">\(P\)</span>而已。上一讲中已经讲过了置换矩阵<spanclass="math inline">\(P\)</span>，当它左乘矩阵<spanclass="math inline">\(A\)</span>时，从行视角来看实际上就是对<spanclass="math inline">\(A\)</span>的行进行交换。当行变换找到新的不为0的主元时，消元得以继续进行。所以完全体应该写作<spanclass="math inline">\(PA=LU\)</span>。</p><h2 id="对称矩阵">对称矩阵</h2><p>转置以后矩阵没有发生变化的矩阵，称为对称矩阵，即<spanclass="math inline">\(A^T=A\)</span>（置换矩阵群中有4个就是对称矩阵）。例如：<span class="math display">\[\begin{bmatrix}3 &amp; 1 &amp; 7\\ 1 &amp; 2 &amp; 9\\ 7 &amp; 9 &amp; 4\end{bmatrix}\]</span></p><p>如何得到对称阵呢？一种简单的生成方法是：矩阵的转置和矩阵自身相乘<spanclass="math inline">\((R^TR)\)</span>。</p><p>证明如下： <span class="math display">\[(R^TR)^T = R^T(R^T)^T = R^TR\]</span></p><p>可以看到，<span class="math inline">\(R^TR\)</span>转置后还是<spanclass="math inline">\(R^TR\)</span>，故为对称阵。</p><h2 id="向量空间">向量空间</h2><p>所谓向量空间，它表示的是由一组向量集合共同构成的某个空间。然而，并非任意的向量集合都可以组成空间，空间必须得满足这一法则：对线性运算（加法与数乘）封闭。如果集合内任意向量的线性运算结果仍然在空间之内，那么构成的就是向量空间。显然，向量空间至少包含原点（<spanclass="math inline">\(v-v=0\)</span>），也就是零向量。</p><p>高维向量空间又包含各种低维的向量子空间。</p><h3 id="二维向量空间">二维向量空间</h3><p>对于<spanclass="math inline">\(R^2\)</span>来说，向量空间内的子空间可以轻易的枚举：</p><ul><li><span class="math inline">\(R^2\)</span>本身（构成一个平面）</li><li>任何过原点的直线</li><li>零向量空间(只包含零向量)</li></ul><h3 id="三维向量空间">三维向量空间</h3><p>进一步，扩展到<spanclass="math inline">\(R^3\)</span>，子空间就多了一个维度：</p><ul><li><span class="math inline">\(R^3\)</span>本身</li><li>任何过原点的平面</li><li>任何过原点的直线</li><li>零向量空间(只包含零向量)</li></ul><p>显然，<spanclass="math inline">\(R^2\)</span>的向量子空间是更高维度<spanclass="math inline">\(R^3\)</span>子空间的子集，以此类推。</p><h3 id="列空间简述">列空间简述</h3><p>那么矩阵是如何构建向量子空间的呢？显而易见的方法是通过枚举列向量来构造：即选取各列进行线性组合，所有线性组合的结果构成的就是一个特定的子空间，这个子空间一般称作矩阵的列空间，记为<spanclass="math inline">\(C(A)\)</span>，它也是矩阵4大子空间中的一个。</p><blockquote><p>这一讲主要是为了让大家先接受向量空间这一概念，因为线性代数的核心都是围绕着向量空间来描摹，如果不能在脑海中将矩阵投射成向量空间来理解，那么后续的课程也都无法真正掌握。</p></blockquote><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569897195&amp;p=5&amp;autoplay=0" scrolling="no" border="0" width="100%" height="500" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B05%5D%20%E8%BD%AC%E7%BD%AE-%E8%BD%AC%E6%8D%A2-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%20R/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%5B%E4%BA%94%5D.pdf">转置-转换-向量空间R</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(四)——A的LU分解</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%9B%9B)%E2%80%94%E2%80%94A%E7%9A%84LU%E5%88%86%E8%A7%A3/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%9B%9B)%E2%80%94%E2%80%94A%E7%9A%84LU%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>本讲主要是围绕<span class="math inline">\(A\)</span>的<spanclass="math inline">\(LU\)</span>分解，深入展开矩阵乘法、逆与转置的关系。最后自然而然的引出了置换矩阵。</p><span id="more"></span><h1 id="a的lu分解"><span class="math inline">\(A\)</span>的<spanclass="math inline">\(LU\)</span>分解</h1><h2 id="ab的逆"><span class="math inline">\(AB\)</span>的逆</h2><p><span class="math inline">\(AB\)</span>如果有逆，那么其逆显然是<spanclass="math inline">\(B^{-1}A^{-1}\)</span>，因为有： <spanclass="math display">\[\begin{align}(AB)(B^{-1} A^{-1})=I\\ (B^{-1} A^{-1})(AB)=I\end{align}\]</span></p><p>根据结合律法则，我们把括号挪一下，俩俩结合成<spanclass="math inline">\(I\)</span>，上式一目了然。</p><h2 id="ab的转置"><span class="math inline">\(AB\)</span>的转置</h2><p>显然是<span class="math inline">\(B^TA^T\)</span>（对结果<spanclass="math inline">\(C\)</span>中的每个元素求和分别计算即可证等），由此可见转置如果想要拆除括号，则内层矩阵的转置顺序要倒置。</p><h2 id="at的逆"><span class="math inline">\(A^T\)</span>的逆</h2><p>显然： <span class="math display">\[\begin{align}(AA^{-1})^T = I^T = I\\ (A^{-1})^TA^T = I\end{align}\]</span></p><p>因此<span class="math inline">\(A^T\)</span>的逆矩阵就是<spanclass="math inline">\((A^{-1})^T\)</span>，即<spanclass="math inline">\((A^T)^{-1}=(A^{-1})^T\)</span>，因此得出：对单个矩阵，转置和取逆操作顺序可以互换。</p><h2 id="alu和eau的关系"><span class="math inline">\(A=LU\)</span>和<spanclass="math inline">\(EA=U\)</span>的关系</h2><p>通过不断的左乘<spanclass="math inline">\(E_{xy}\)</span>做高斯消元，可以让矩阵<spanclass="math inline">\(A\)</span>变换为<spanclass="math inline">\(U\)</span>，而只需要在等号两边同时左乘<spanclass="math inline">\(E^{-1}\)</span>，就得到<spanclass="math inline">\(A=E^{-1}U\)</span>，显然，<spanclass="math inline">\(L\)</span>和<spanclass="math inline">\(E\)</span>互为逆矩阵。高斯消元本质上做的是行变换，最终得到的<spanclass="math inline">\(U\)</span>是一个上三角阵，而<spanclass="math inline">\(L\)</span>则是一个下三角阵。</p><p><span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(A\)</span>变换为<spanclass="math inline">\(LU\)</span>需要的计算量有多少呢？对100阶方阵，从第2行开始到第100行针对列1元素都需要进行行变换，每行有100个元素，计算次数为<spanclass="math inline">\(99\times100\)</span>，然后对于列2，则需要从第3行开始到第100行，计算次数为<spanclass="math inline">\(98\times99\)</span>，递归下去，总的时间复杂度可用平方和来预估：<spanclass="math inline">\(O(n^2+(n-1)^2+\dots+2^2+1^2)\)</span>，即<spanclass="math inline">\(O(\frac{n^3}{3})\)</span>。</p><h2 id="置换矩阵">置换矩阵</h2><p>3阶置换矩阵有6个： <span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\end{bmatrix}\]</span></p><p>这6个置换矩阵组成了一个很有意思的矩阵群（任取两个矩阵相乘，结果仍在该矩阵群中），它们有非常有意思的性质：置换矩阵的逆等于其转置，这一点非常好理解，相当于被交换的行又再次被交换回来。</p><p>根据每行中1的位置，可以知道<spanclass="math inline">\(n\)</span>阶方阵的置换矩阵个数就是全排列数：共<spanclass="math inline">\(\binom{n}{1}=n!\)</span>个。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569890100&amp;p=4&amp;autoplay=0" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B04%5DA%20%E7%9A%84%20LU%20%E5%88%86%E8%A7%A3/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%5B%E5%9B%9B%5D.pdf">A的LU分解</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(三)——乘法和逆矩阵</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%89)%E2%80%94%E2%80%94%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%89)%E2%80%94%E2%80%94%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p>这一讲是对矩阵乘法和逆矩阵的深入说明。矩阵乘法主要介绍了按不同视角来理解的多种计算方式。逆矩阵则给出了求解非奇异矩阵的逆矩阵的方法。</p><span id="more"></span><h1 id="乘法和逆矩阵">乘法和逆矩阵</h1><h2 id="矩阵乘法的视觉意义">矩阵乘法的视觉意义</h2><p>矩阵乘法<span class="math inline">\(AB=C\)</span>，其中<spanclass="math inline">\(A\)</span>是<span class="math inline">\(m\timesn\)</span>阵，<span class="math inline">\(B\)</span>是<spanclass="math inline">\(n\times p\)</span>阵，我们知道得到的<spanclass="math inline">\(C\)</span>是一个<spanclass="math inline">\(m\times p\)</span>阵。对于<spanclass="math inline">\(C\)</span>中第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(j\)</span>列元素<spanclass="math inline">\(C_{ij}\)</span>。</p><p>从不同视角看矩阵乘法，我们可以给出不同的计算式：</p><h3 id="从每个元素的角度">从每个元素的角度</h3><p>有： <span class="math display">\[c_{ij}=row_i\cdot column_j = \sum_{k=i}^na_{ik}b_{kj}\]</span></p><p>其中<span class="math inline">\(a_{ik}\)</span>是矩阵<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(k\)</span>列元素，<spanclass="math inline">\(b_{kj}\)</span>是<spanclass="math inline">\(B\)</span>矩阵第<spanclass="math inline">\(k\)</span>行第<spanclass="math inline">\(j\)</span>列元素。 <spanclass="math inline">\(c_{ij}\)</span>可以看成是<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行乘以<spanclass="math inline">\(B\)</span>的第<spanclass="math inline">\(j\)</span>列。</p><h3 id="列的线性组合">列的线性组合</h3><p>从列的角度看，<span class="math inline">\(C\)</span>的各列是<spanclass="math inline">\(A\)</span>中各列的线性组合，组合方式由<spanclass="math inline">\(B\)</span>来确定。比如<spanclass="math inline">\(C\)</span>的第一列是 <spanclass="math inline">\(A\)</span>中各列相对于<spanclass="math inline">\(B\)</span>的第一列的一个线性组合。</p><p><span class="math display">\[\begin{bmatrix}&amp;&amp;\\ A_{col1}&amp;A_{col2}&amp;\cdots&amp;A_{coln}\\ &amp;&amp;\end{bmatrix}\begin{bmatrix}\cdots&amp;b_{1j}&amp;\cdots\\ \cdots&amp;b_{2j}&amp;\cdots\\ \cdots&amp;\vdots&amp;\cdots\\ \cdots&amp;b_{nj}&amp;\cdots\\ \end{bmatrix}=\begin{bmatrix}&amp;&amp;\\\cdots&amp;\left(b_{1j}A_{col1}+b_{2j}A_{col2}+\cdots+b_{nj}A_{coln}\right)&amp;\cdots\\ &amp;&amp;\end{bmatrix}\]</span></p><p>上面的运算为<span class="math inline">\(B\)</span>的第<spanclass="math inline">\(j\)</span>个列向量右乘矩阵<spanclass="math inline">\(A\)</span>，求得的结果就是<spanclass="math inline">\(C\)</span>矩阵的第<spanclass="math inline">\(j\)</span>列，即<spanclass="math inline">\(C\)</span>的第<spanclass="math inline">\(j\)</span>列是<spanclass="math inline">\(A\)</span>的列向量以<spanclass="math inline">\(B\)</span>的第<spanclass="math inline">\(j\)</span>列作为系数所求得的线性组合，<spanclass="math inline">\(C_j=b_{1j}A_{col1}+b_{2j}A_{col2}+\cdots+b_{nj}A_{coln}\)</span>。</p><h3 id="行的线性组合">行的线性组合</h3><p><span class="math inline">\(C\)</span>的各行是<spanclass="math inline">\(B\)</span>中各行的一个线性组合，组合方式由<spanclass="math inline">\(A\)</span>决定。比如<spanclass="math inline">\(C\)</span>的第一行是<spanclass="math inline">\(B\)</span>中各行相对于<spanclass="math inline">\(A\)</span>的第一行的一个线性组合。</p><p><span class="math display">\[\begin{bmatrix}\vdots&amp;\vdots&amp;\vdots&amp;\vdots\\ a_{i1}&amp;a_{i2}&amp;\cdots&amp;a_{in}\\ \vdots&amp;\vdots&amp;\vdots&amp;\vdots\end{bmatrix}\begin{bmatrix}&amp;B_{row1}&amp;\\ &amp;B_{row2}&amp;\\ &amp;\vdots&amp;\\ &amp;B_{rown}&amp;\end{bmatrix}=\begin{bmatrix}\vdots\\ \left(a_{i1}B_{row1}+a_{i2}B_{row2}+\cdots+a_{in}B_{rown}\right)\\ \vdots\end{bmatrix}\]</span></p><p>上面的运算为<span class="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>个行向量左乘矩阵<spanclass="math inline">\(B\)</span>，求得的结果就是<spanclass="math inline">\(C\)</span>矩阵的第<spanclass="math inline">\(i\)</span>行，即<spanclass="math inline">\(C\)</span>的第<spanclass="math inline">\(i\)</span>行是<spanclass="math inline">\(B\)</span>的行向量以<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行作为系数所求的的线性组合，<spanclass="math inline">\(C_i=a_{i1}B_{row1}+a_{i2}B_{row2}+\cdots+a_{in}B_{rown}\)</span>。</p><h3 id="从矩阵的角度看">从矩阵的角度看</h3><p><span class="math inline">\(A\)</span>的列乘以<spanclass="math inline">\(B\)</span>的行： <span class="math display">\[\begin{bmatrix}&amp;&amp;\\ A_{col1}&amp;A_{col2}&amp;\cdots&amp;A_{coln}\\ &amp;&amp;\end{bmatrix}\begin{bmatrix}&amp;B_{row1}&amp;\\ &amp;B_{row2}&amp;\\ &amp;\vdots&amp;\\ &amp;B_{rown}&amp;\end{bmatrix}=A_{col1}B_{row1}+A_{col2}B_{row2}+\cdots+A_{coln}B_{rown}\]</span></p><p><span class="math inline">\(A_{coli}B_{rowi}\)</span>是一个<spanclass="math inline">\(m\times 1\)</span>向量乘以一个<spanclass="math inline">\(1\times p\)</span>向量，其结果是一个<spanclass="math inline">\(m\times p\)</span>矩阵，而所有的<spanclass="math inline">\(m\times p\)</span>矩阵之和就是计算结果。</p><h3 id="分块来看">分块来看</h3><p><span class="math display">\[\left[\begin{array}{c|c}A_1&amp;A_2\\ \hlineA_3&amp;A_4\end{array}\right]\left[\begin{array}{c|c}B_1&amp;B_2\\\hlineB_3&amp;B_4\end{array}\right]=\left[\begin{array}{c|c}A_1B_1+A_2B_3&amp;A_1B_2+A_2B_4\\\hline A_3B_1+A_4B_3&amp;A_3B_2+A_4B_4\end{array}\right]\]</span></p><p>简写成： <span class="math display">\[\left[\begin{array}{c|c}A_1&amp;A_2\\ \hlineA_3&amp;A_4\end{array}\right]\left[\begin{array}{c|c}B_1&amp;B_2\\\hlineB_3&amp;B_4\end{array}\right]=\left[\begin{array}{c|c}C_1&amp;C_2\\\hline C_3&amp;C_4\end{array}\right]\]</span></p><p>可以看到 矩阵完全可以拆成多个块，各块的关联关系也一目了然。</p><h2 id="逆矩阵">逆矩阵</h2><p>逆矩阵分为左逆和右逆，不是所有方阵都可逆，对于方阵来说，左逆和右逆是相等的。</p><p>对这些有逆的矩阵，我们称其为可逆的或非奇异的。</p><p>如何判断一个矩阵是可逆的？从列图像来看，如果<spanclass="math inline">\(A^{-1}\)</span>存在，那么有<spanclass="math inline">\(AA^{-1}=I\)</span>，如果<spanclass="math inline">\(A\)</span>中各列无法线性组合成单位阵，则矩阵不可逆。相反，如果可以找到非零向量<spanclass="math inline">\(x\)</span>使得<spanclass="math inline">\(Ax=0\)</span>有解，那么<spanclass="math inline">\(A\)</span>也是不可逆的（某些列是相关的，反证法非常容易求证）。</p><p>那么如何求解一个逆矩阵呢？可以采用高斯-若尔当思想：构造这样一个增广矩阵： <spanclass="math inline">\(\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\\2&amp;7&amp;0&amp;1\end{array}\right]\)</span>，</p><p>右侧补充一个单位阵<spanclass="math inline">\(I\)</span>，接下来用消元法将左侧变为单位矩阵：</p><p><span class="math display">\[\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\\2&amp;7&amp;0&amp;1\end{array}\right]\xrightarrow{row_2-2row_1}\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\\0&amp;1&amp;-2&amp;1\end{array}\right]\xrightarrow{row_1-3row_2}\left[\begin{array}{cc|cc}1&amp;0&amp;7&amp;-3\\0&amp;1&amp;-2&amp;1\end{array}\right]\]</span></p><p>于是，我们就将矩阵从<spanclass="math inline">\(\left[\begin{array}{c|c}A&amp;I\end{array}\right]\)</span>变为<spanclass="math inline">\(\left[\begin{array}{c|c}I&amp;A^{-1}\end{array}\right]\)</span></p><p>而高斯-若尔当思想的本质是使用消元矩阵<spanclass="math inline">\(E\)</span>，对<spanclass="math inline">\(A\)</span>进行操作，<spanclass="math inline">\(E\left[\begin{array}{c|c}A&amp;I\end{array}\right]\)</span>，利用一步步消元有<spanclass="math inline">\(EA=I\)</span>，进而得到<spanclass="math inline">\(\left[\begin{array}{c|c}I&amp;E\end{array}\right]\)</span>，其实这个消元矩阵<spanclass="math inline">\(E\)</span>就是<spanclass="math inline">\(A^{-1}\)</span>，而高斯-若尔当法中的<spanclass="math inline">\(I\)</span>只是负责记录消元的每一步操作，待消元完成，逆矩阵就自然出现了。</p><p><strong>结论：如果矩阵可以通过行变换变成<spanclass="math inline">\(I\)</span>，那么矩阵就是可逆的。</strong></p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569894536&amp;p=3&amp;autoplay=0" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B03%5D%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%5B%E4%B8%89%5D.pdf">乘法和逆矩阵</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(二)——矩阵消元</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83/</url>
    
    <content type="html"><![CDATA[<p>高斯消元法是如今小学生都耳熟能详的解决齐次线性方程组的方法，课程第二讲主要讲授了高斯消元法应用在矩阵上的视觉效果与解读。</p><span id="more"></span><h1 id="矩阵消元">矩阵消元</h1><h2 id="非矩阵视角的消元">非矩阵视角的消元</h2><p>有三元方程组： <spanclass="math inline">\(\begin{cases}  x&amp;+2y&amp;+z&amp;=2  \\3x&amp;+8y&amp;+z&amp;=12  \\&amp;4y&amp;+z&amp;=2  \end{cases}\)</span></p><p>如果我们想通过消元法来解决，那么一般是考虑选中其中的一行，乘以某个系数对另外两行进行加法（系数为负就是减法）操作，以消除掉<spanclass="math inline">\(x\)</span>未知数，如此，后两个方程组就变成了二元一次方程组求解问题，而方法也是以此类推，用其中的一个消掉另一个的<spanclass="math inline">\(y\)</span>，最终剩下的那一行就只有<spanclass="math inline">\(z\)</span>了。在解出<spanclass="math inline">\(z\)</span>以后，再将<spanclass="math inline">\(z\)</span>回代到方程组，进而再解另外两个未知数<spanclass="math inline">\(x,y\)</span>。这种方法我们在小学的时候就已经掌握了。</p><h2 id="矩阵视角的消元">矩阵视角的消元</h2><p>方程组对应的矩阵形式<span class="math inline">\(Ax=b\)</span>为：<span class="math inline">\(\begin{bmatrix}  1&amp;2&amp;1  \\3&amp;8&amp;1  \\ 0&amp;4&amp;1  \end{bmatrix}\begin{bmatrix}  x  \\y  \\ z  \end{bmatrix}=\begin{bmatrix}  2  \\ 12  \\2\end{bmatrix}\)</span>。</p><p>实际上如果将消元的手法应用到矩阵上，本质上也并没有什么不同，从矩阵的视角来看，消元的第一步是选定第一行的第一个元素作为主元（对应<spanclass="math inline">\(x\)</span>系数），分别乘以不同的系数对第二、三行进行加法操作，进而消除掉第二、三行的首个元素。由于第三行原本首个元素就是0，故这里只需要对第二行操作：<spanclass="math inline">\(\begin{bmatrix}  \underline{1}&amp;2&amp;1  \\3&amp;8&amp;1  \\0&amp;4&amp;1\end{bmatrix}\xrightarrow{row_2-3row_1}\begin{bmatrix}  \underline{1}&amp;2&amp;1  \\0&amp;2&amp;-2  \\ 0&amp;4&amp;1\end{bmatrix}\)</span></p><p>这里暂时先不管对<spanclass="math inline">\(b\)</span>的影响（实际上也要跟着变化），矩阵<spanclass="math inline">\(A\)</span>经过消元变成了这个样子。</p><p>接下来，我们如法炮制，选择第二行的第二个元素(对应<spanclass="math inline">\(y\)</span>系数)作为主元，对第三行进行消元动作：<spanclass="math inline">\(\begin{bmatrix}  \underline{1}&amp;2&amp;1  \\0&amp;\underline{2}&amp;-2  \\0&amp;4&amp;1\end{bmatrix}\xrightarrow{row_3-2row_2}\begin{bmatrix}\underline{1}&amp;2&amp;1  \\0&amp;\underline{2}&amp;-2  \\0&amp;0&amp;\underline{5}\end{bmatrix}\)</span></p><p>到此，消元动作结束，最后一行仅剩<spanclass="math inline">\(z\)</span>的系数，即第三个元素5。</p><p>上例的矩阵是精心设计的，实际上消元过程中可能会遇到一些失效的情形：首先主元不能为0，为0的主元无论乘上什么样的系数都无法消除其他行的对应列。其次，如果消元过程中遇到主元位置为0，则需要交换行，使主元不为0。</p><p>消元结束后，我们就可以进行回代，由于方程组在矩阵消元时发生了变化，我们需要对<spanclass="math inline">\(b\)</span>也进行相同的操作以同步这些变化，如此我们写成下面的增广矩阵形式：<span class="math display">\[\left[\begin{array}{c|c}A&amp;b\end{array}\right]=\left[\begin{array}{ccc|c}  1&amp;2&amp;1&amp;2  \\ 3&amp;8&amp;1&amp;12  \\ 0&amp;4&amp;1&amp;2  \end{array}\right]\to\left[\begin{array}{ccc|c}1&amp;2&amp;1&amp;2\\ 0&amp;2&amp;-2&amp;6\\ 0&amp;4&amp;1&amp;2\end{array}\right]\to\left[\begin{array}{ccc|c}1&amp;2&amp;1&amp;2\\ 0&amp;2&amp;-2&amp;6\\ 0&amp;0&amp;5&amp;-10\end{array}\right]\]</span></p><p>此时方程组变为：<spanclass="math inline">\(\begin{cases}x&amp;+2y&amp;+z&amp;=2\\&amp;2y&amp;-2z&amp;=6\\&amp;&amp;5z&amp;=-10\end{cases}\)</span>，最后一行可以得出<spanclass="math inline">\(z=-2\)</span>，回代到<spanclass="math inline">\(2y-2z=6\)</span>得到<spanclass="math inline">\(y=1\)</span>，再进一步得到<spanclass="math inline">\(x=2\)</span>。</p><blockquote><p>可以用这里的方程组和我们小学时学到的消元法得到的方程组作对比，本质上完全一样。</p></blockquote><h2 id="矩阵消元的本质">矩阵消元的本质</h2><p>通过第一节课我们知道，对于矩阵乘法<spanclass="math inline">\(AB\)</span>可以看成是对矩阵<spanclass="math inline">\(B\)</span>中行按<spanclass="math inline">\(A\)</span>中系数的线性组合，如果<spanclass="math inline">\(B\)</span>想要维持不变，那么<spanclass="math inline">\(A\)</span>就得是个单位矩阵<spanclass="math inline">\(I\)</span>: <spanclass="math inline">\(\begin{bmatrix}  1&amp;0&amp;0  \\0&amp;1&amp;0  \\ 0&amp;0&amp;1\end{bmatrix}\)</span>这个单位矩阵就相当于我们实数运算中的1，只不过在矩阵的世界，它长这个样子。</p><blockquote><p>单位阵的三行彼此换一换，就能得到一个置换矩阵群，这个东西很有意思，以后会讲到。</p></blockquote><p>于是我们还原一下消元的第一步操作：<spanclass="math inline">\(row_2-3row_1\)</span> <spanclass="math inline">\(\begin{bmatrix}  1&amp;0&amp;0  \\-3&amp;1&amp;0  \\0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}  1&amp;2&amp;1  \\3&amp;8&amp;1  \\0&amp;4&amp;1\end{bmatrix}=\begin{bmatrix}  1&amp;2&amp;1  \\0&amp;2&amp;-2  \\ 0&amp;4&amp;1\end{bmatrix}\)</span></p><p>这个消元矩阵我们记作<spanclass="math inline">\(E_{21}\)</span>，即将第二行第一个元素变为0。</p><p>同理，我们找到<spanclass="math inline">\(E_{32}\)</span>，将第三行第二个元素变为0： <spanclass="math inline">\(\begin{bmatrix}  1&amp;0&amp;0  \\0&amp;1&amp;0  \\0&amp;-2&amp;1  \end{bmatrix}\begin{bmatrix}  1&amp;2&amp;1  \\0&amp;2&amp;-2  \\0&amp;4&amp;1\end{bmatrix}=\begin{bmatrix}  1&amp;2&amp;1  \\0&amp;2&amp;-2  \\ 0&amp;0&amp;5\end{bmatrix}\)</span></p><p><span class="math inline">\(E_{21}\)</span>和<spanclass="math inline">\(E_{32}\)</span>就是消元过程中用到的两个初等矩阵。</p><p>最后，我们将两步综合起来，即<spanclass="math inline">\(E_{32}(E_{21}A)=U\)</span>。矩阵的乘法是满足结合律的，所以这里的括号可以移动一下，即<spanclass="math inline">\((E_{32}E_{21})A=U\)</span>，这里的<spanclass="math inline">\(U\)</span>表示upper，即上三角矩阵（对角线下面的元素全都是0）。</p><h2 id="逆">逆</h2><p>如此，我们可以通过对<spanclass="math inline">\(A\)</span>做行变换得到<spanclass="math inline">\(U\)</span>，那么显然，如果要从<spanclass="math inline">\(U\)</span>变回<spanclass="math inline">\(A\)</span>我们只需要再反向操作一波即可，比如<spanclass="math inline">\(E_{21}\)</span>是从第二行减去三倍的第一行，那么它的反向操作就应该是第二行加上3倍的第一行，所以其逆矩阵就应该是<spanclass="math inline">\(\begin{bmatrix}1&amp;0&amp;0\\ 3&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix}\)</span>。</p><p>我们把矩阵<span class="math inline">\(E\)</span>的逆记作<spanclass="math inline">\(E^{-1}\)</span>，显然有<spanclass="math inline">\(E^{-1}E=I\)</span>，从行变换意义上来看，单位阵<spanclass="math inline">\(I\)</span>乘以<spanclass="math inline">\(A\)</span>相当于什么都没有改变，也就是二者抵消后的结果。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569889975&amp;p=2&amp;autoplay=0" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B02%5D%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%5B%E4%BA%8C%5D.pdf">矩阵消元</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(一)——方程组的几何解释</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E2%80%94%E2%80%94%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E2%80%94%E2%80%94%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<p>开篇第一讲主要通过线性方程组引出矩阵，并传授了如何通过<strong>行图像</strong>和<strong>列图像</strong>来分别理解矩阵的意义。最后基于列的线性组合视角来初步解答了这样的一个问题：对任意向量<spanclass="math inline">\(b\)</span>，能否求解<spanclass="math inline">\(Ax=b\)</span>。</p><span id="more"></span><h1 id="方程组的几何解释">方程组的几何解释</h1><h2 id="二元一次方程组">二元一次方程组</h2><p>方程组： <span class="math inline">\(\begin{cases}  2x&amp;-y&amp;=0\\  -x&amp;+2y&amp;=3 \end{cases}\)</span></p><p>写作矩阵形式有： <spanclass="math inline">\(\begin{bmatrix}  2&amp;-1 \\  -1&amp;2\end{bmatrix} \begin{bmatrix}  x \\  y \end{bmatrix}= \begin{bmatrix} 0\\ 3 \end{bmatrix}\)</span></p><p>第一个矩阵一般称为系数矩阵<spanclass="math inline">\(A\)</span>，第二个矩阵成为向量<spanclass="math inline">\(x\)</span>，第三个矩阵称为向量<spanclass="math inline">\(b\)</span>，线性方程组写为<spanclass="math inline">\(Ax=b\)</span>。</p><h2 id="行图像row-picture">行图像(Row picture)</h2><p>如上例，按行解读如下：</p><ul><li>第一行为2个x和-1个y组合成0</li><li>第二行为-1个x和2个y组合成3</li></ul><p>这种解读与我们此前对二元一次方程组的解读方法是一致的，我们都知道，二元一次方程组实际上就是求解二维平面两条直线的交点：<img src="2022-05-02-12-15-37.png" /></p><p>交点坐标为<span class="math inline">\((1,2)\)</span>，即<spanclass="math inline">\(x=1, y=2\)</span>为方程组的解。</p><h2 id="列图像column-picture">列图像(Column picture)</h2><p>那么，如果我们换一个视角呢？我们把矩阵<spanclass="math inline">\(A\)</span>拆成列向量，进行如下线性组合： <spanclass="math inline">\(x \begin{bmatrix}  2 \\  -1 \end{bmatrix}+y\begin{bmatrix} -1 \\ 2 \end{bmatrix}= \begin{bmatrix} 0 \\ 3\end{bmatrix}\)</span></p><p>那么就可以解读为<span class="math inline">\(x\)</span>个<spanclass="math inline">\(col_1\)</span>和<spanclass="math inline">\(y\)</span>个<spanclass="math inline">\(col_2\)</span>的组合，其中<spanclass="math inline">\(\begin{bmatrix}2\\-1\end{bmatrix}\)</span>称为<spanclass="math inline">\(col_1\)</span>，<spanclass="math inline">\(\begin{bmatrix}-1\\2\end{bmatrix}\)</span>称为<spanclass="math inline">\(col_2\)</span>。</p><p>肉眼观察就可以看出，需要1个<spanclass="math inline">\(col_1\)</span>和2个<spanclass="math inline">\(col_2\)</span>，组合起来就可以变成<spanclass="math inline">\(\begin{bmatrix}0\\3\end{bmatrix}\)</span>。因此同样得出<spanclass="math inline">\(x=1, y=2\)</span>。</p><p>列向量相加的几何意义： <img src="2022-05-02-13-01-08.png" /></p><p>绿向量<span class="math inline">\(col_1\)</span>与蓝向量<spanclass="math inline">\(col_2\)</span>相加，按照平行四边形法则，合成的就是红向量<spanclass="math inline">\(b\)</span>。</p><p>进一步思考<span class="math inline">\(col_1\)</span>和<spanclass="math inline">\(col_2\)</span>的所有线性组合能够得到什么呢？显然它们可以铺满整个二维平面。那么<spanclass="math inline">\(Ax=b\)</span>如果按照列的线性组合来看，<strong>求解<spanclass="math inline">\(Ax=b\)</span>实际上就是在问询对于给定的<spanclass="math inline">\(b\)</span>，是否能够找到一种组合方式来让<spanclass="math inline">\(A\)</span>中各列向量<spanclass="math inline">\(col_i\)</span>可以组合成列向量<spanclass="math inline">\(b\)</span>。</strong></p><h2 id="三元一次方程组">三元一次方程组</h2><p><span class="math inline">\(\begin{cases}  2x&amp;-y&amp;&amp;=0\\  -x&amp;+2y&amp;-z&amp;=-1 \\  &amp;-3y&amp;+4z&amp;=4\end{cases}\)</span></p><p>写作矩阵形式： <span class="math inline">\(A=\begin{bmatrix}2&amp;-1&amp;0 \\ -1&amp;2&amp;-1 \\ 0&amp;-3&amp;4\end{bmatrix}\)</span>,<span class="math inline">\(b=\begin{bmatrix} 0\\ -1 \\ 4 \end{bmatrix}\)</span></p><p>如果按行图像来思考：三维直角坐标系中，每个方程都将确定一个平面，三个平面会相交于一点，该点即为方程组的解。</p><p>如果按列图像来思考，拆写成： <spanclass="math inline">\(x\begin{bmatrix} 2 \\ -1 \\ 0\end{bmatrix}+y\begin{bmatrix} -1 \\  2 \\-3\end{bmatrix}+z\begin{bmatrix} 0 \\ -1 \\4\end{bmatrix}=\begin{bmatrix} 0 \\ -1 \\ 4\end{bmatrix}\)</span></p><p>也就是<span class="math inline">\(x\)</span>个<spanclass="math inline">\(col_1\)</span>，<spanclass="math inline">\(y\)</span>个<spanclass="math inline">\(col_2\)</span>和<spanclass="math inline">\(z\)</span>个<spanclass="math inline">\(col_3\)</span>线性组合成列向量<spanclass="math inline">\(b\)</span>。通过列视角来看这个方程组的解非常显然，只需要<spanclass="math inline">\(x=0,y=0,z=1\)</span>即可满足（<spanclass="math inline">\(z\)</span>刚好等于<spanclass="math inline">\(b\)</span>），而从行视角来看就没有那么一目了然。</p><blockquote><p>当然了，这是精心构造的一组例子，并不是说列视角就比行视角优越，只是培养列视角分析问题的sense对线性代数这门课（我觉着更像一门语言）来说非常重要。</p></blockquote><p>那么问题又回来了，对于任意<spanclass="math inline">\(b\)</span>，是否都能求解<spanclass="math inline">\(Ax=b\)</span>呢？用列向量视角来说，就是<spanclass="math inline">\(col_1,col_2,col_3\)</span>三个列向量的线性组合是否可以填满整个三维坐标系？对上例来说，答案是肯定的。因为实际上这个<spanclass="math inline">\(A\)</span>矩阵是个<strong>非奇异矩阵、可逆矩阵</strong>（后续课程会讲到），对于任意的列向量<spanclass="math inline">\(b\)</span>，它总是有解的。</p><p>那么在什么情况下，三个列向量的组合得不到所有的<spanclass="math inline">\(b\)</span>呢？试想这样一种情况：三个列向量在同一平面，那么无论它们如何组合，产生的列向量也一定在该平面上，因此，对于不在该平面的列向量<spanclass="math inline">\(b\)</span>，方程组就是无解的。后续课程会学习到这种情况叫做<strong>奇异矩阵、不可逆矩阵</strong>。</p><p>人类的大脑是三维的，所以四维以上的空间是无法具象化的，但是我们从二维到三维，和从三维到更高维的过程实际上并没有什么差别，因此，通过列视角的线性组合，哪怕是100维的向量，思考与处理也如法炮制。</p><h1 id="附录">附录</h1><h2 id="视频">视频</h2><iframe src="//player.bilibili.com/player.html?aid=382989698&amp;bvid=BV16Z4y1U7oU&amp;cid=569893465&amp;p=1&amp;autoplay=0" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes/blob/master/%5B01%5D%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%5B%E4%B8%80%5D.pdf">方程组的几何解释</a></li><li><ahref="https://github.com/kf-liu/The-Art-of-Linear-Algebra-zh-CN">线性代数的艺术</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>楔子</title>
    <link href="/2022/05/01/%E6%A5%94%E5%AD%90/"/>
    <url>/2022/05/01/%E6%A5%94%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>上次折腾博客还是醉心于binarysecurity的时节，如今却是弃之如敝履。彼时彼刻，正如此时此刻，何移之速也！</p><p>互联网变化之快让人越来越浮躁，工作越久、越难以静下心来去专研某个领域的知识，不学无术就愈发膨胀，一点点丧失核心竞争力，最后与前沿脱轨，熬成药渣，泄入深渊。我不知道一个人应该如何消化掉鸡飞蛋打、毫无成就的日常工作的挫败感和996福报带来的身心俱疲，只是入行这么多年，的的确确是弄丢了意气风发、快意恩仇，满脑子想的尽是冠冕堂皇的不粘锅、踢皮球，冰与火，周旋久。</p><span id="more"></span><p>用如今的流行梗来说：小僧没有那种世俗的欲望。“举世誉之而不加劝，举世非之而不加沮。不以物喜，不以己悲。”秉承着这样的人生信条，靠物我两忘屏蔽了职场所有的画饼和PUA，也接受了“是岁年大旱，衢州人食人”的魔幻与惨案，甚至乐在其中。坦白来说，我不红眼那些蹭上时代红利的既得利益者，也不在乎能不能坐上位高权重的玉座，毕生所求不过自由，而自由其实并不意味着“想做什么就可以做什么”，而是“不想做什么，就可以不做”。壁立千仞，无欲则刚。</p><p>这么多年过去，扪心自问这一身本领从何而来，只道是“年少轻狂不服气，万千道法书中藏。穷经皓首等闲事，千锤百炼证沧桑。”算来前前后后，一共经历了三重心境上的变化：</p><ol type="1"><li>待到秋来九月八，我花开后百花杀：以前觉着自己得天独厚，是故事的主角，只要是自己想做的，一定可以做到最好。因此接受不了自己的平庸，拼尽全力证明自己。</li><li>横看成岭侧成峰，远近高低各不同：几经挫折后发现人确实有不同的天赋，我要找到自己擅长的领域，做到最好；不擅长的东西不要强求。</li><li>沉舟侧畔千帆过，病树前头万木春：终于认识到人与人的差距比人与狗的差距还大，强中自有强中手，一山更比一山高，逐渐接受了自己的平庸，与自己妥协，但心意却更加坚定。</li></ol><p>当认识到自己是一个废物的时候，就再也没有包袱了：没有必要和别人比较，我只想看看自己的天花板有多高。遂重整旗鼓，勤将劝勉，闭关清修……这回必定给大伙整个好活~</p><p>千头万绪，百感交集，不知从何说起，唯愿顺其自然，一切随缘。飘蓬入海沉浮定，马齿徒增未可知。</p><p align="right">by 玉涵，写于2022年5月1日深夜，雨</p>]]></content>
    
    
    <categories>
      
      <category>杂感</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
