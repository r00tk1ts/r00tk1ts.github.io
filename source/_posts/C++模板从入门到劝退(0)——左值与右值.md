---
title: C++模板从入门到劝退(0)——左值与右值
date: 2022-05-27 17:18:50
tags: cpp cpp-templates
category: program-language
---

谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述严谨性，按照笔者的归纳方式穿针引线，为痴迷于黑魔法而又始终不得其解的同学打通任督二脉。

<!--more-->

# 左值与右值
随着C++11新标准的制定，C++正式进入现代(modern)时代，相对于传统(traditional or old)C++、新标准的推行可谓是革命性的船新版本。而这一变革带来了两种情况：

1. C++神教的新教徒在阅读传统C++代码时会满脸黑人问号：这是个什么方言？
2. 尚未解锁现代C++的传统C++程序员在接触新标准时会惊呼：还有这种操作？快住手，这根本不是C++！

> 在《C++ Primer 5th》问世时，我曾自信满满淘得一本，自诩有着刷了4遍4th的经验，打开了新世界的大门，然后直接自闭。

当大家聊起C++11时，最先想到的可能就是移动语义，没错，这个移动语义可谓是万恶之源，它一方面解决了C++长久以来的顽疾，另一方面也让原本就复杂的语法规则变本加厉。

传统C++的顽疾在于基于值语义(Value Semantics)的冗余拷贝和赋值。所谓值语义，这是很多OO(Object Oriented)语言中没有的概念，诸如Java,C#等大多数语言，几乎所有的变量都是引用语义(Reference Semantics)（它们天生有着GC(Garbage Collector)来管理所有对象的生命周期，开发者无需操心）。而C++并没有做如此现代化的封装，对外呈现的语言生态相当裸露，值语义是指目标对象由源对象拷贝生成，生成的目标对象与源对象毫无关系彼此独立（一些引用语义的编程语言可能只有基础类型是值语义，但同样的它们为了消除违和感对值语义只字不提，而是强调基础类型的特殊性）。对于不了解值语义的C++初学者来说，会想当然的把C++中的引用看成和其他引用语义编程语言中引用的对等概念，这在传统C++中最多是在使用体验上感觉到有些别扭，而到了C++11后，由于对左值引用、右值引用进行了区分，就使得原本理解上的缺失被进一步放大，自然而然得感觉右值引用莫名其妙。

我们以纯OO语言Java为例，如果写这样一段代码：

```java
public class Test{
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = s1;

        System.out.println(System.identityHashCode(s1));
        System.out.println(System.identityHashCode(s2));
        System.out.println(s1 == s2);
    }
}
```

运行结果如下：

```zsh
2060468723
2060468723
true
```

可以看到，Java中`s1,s2`就是引用语义的典范，它们指向的对象是同一个，而在引用语义的编程语言中，这也被称作浅拷贝(Shallow Copy)：在进行赋值、方法传参和返回值时，对于引用类型（非基本类型）一概按引用传递（传址）。

再看Python 3:

```python
s1 = "hello"
s2 = s1

print(id(s1))
print(id(s2))
```

运行结果如下：

```zsh
4341128096
4341128096
```

显然赋值操作是按引用进行传递，`s1,s2`所指是同一个对象。

那么在C++中，对于标准库的`string`来说，我们进行类似的赋值是什么结果呢？

```cpp
#include <iostream>
#include <string>

using namespace std;

int main(int argc, char* argv[]){
    string s1 = "hello";
    string s2 = s1;

    cout << &s1 << endl;
    cout << &s2 << endl;
    return 0;
}
```

运行结果：

```zsh
0x16d94f678
0x16d94f660
```

可以看到`s1,s2`的地址并不相同，对于非基础类型，C++中使用相同类型的对象做初始化赋值的语义是去调用该类型的拷贝构造器(copy ctor)（C++中初始化赋值和普通的赋值语义并不等同，后者在这种情况下调用的是拷贝赋值操作符(copy assignment))。此外，对于第一行`string s1 = "hello";`也并没有表面上看上去的那样简单。

> C++对变量生命周期的一种优雅管理方式是RAII，不过不代表RAII能解决所有场景的变量生命期管理需求，更不代表GC没用。

C++中基于值语义的拷贝构造和拷贝赋值，可能会导致大对象的冗余拷贝从而引发性能瓶颈。虽然开发者可以通过指针和引用来规避掉部分场景的copy（编译器虽有RVO,NRVO等复制省略技术，但只能视作语言天然缺陷的遮羞布），但还是有诸多场景无可避免。我记得以前看过这么一个形象的比喻：要把大象从A冰箱转移到B冰箱需要几步呢？普通青年的做法是3步：打开冰箱A和B的门；把大象从A转移(move)到B；关闭冰箱A和B。2B青年的做法则是：打开冰箱A和B的门；启用量子复制系统在冰箱B克隆出大象；启用射频消融技术将A中大象解体气化。没错，C++曾经就是这个2B青年。

移动(move)这件事本身很好理解，因为这是一个符合直觉的做法，但是对背着重重历史包袱的C++来说，想要从语言层面理解移动，就需要前置理解这样一个概念：左值(lvalue)和右值(rvalue)。实际上，左值和右值并不是C++11所引入的术语，这两个概念的历史由来可以追溯到编程语言CPL，那么彼时何为左值和右值呢？顾名思义，在赋值操作符('=')左边的就是左值，右边的就是右值，而这也是左值和右值得以命名的历史原因。C语言继承了CPL的分类法，但是弱化了赋值的作用，C中表达式被分为左值(lvalue)和其他(others)，左值被定义成标识一个对象的表达式（也有一种说法，此时的lvalue是locator value的简写，因此lvalue对应的实际上是内存地址）。传统C++则继承了C中表达式的分类法，但是将others统称为rvalue(右值)，于是坊间流传的一个不严谨的说法就是：左值对应变量的存储位置，右值对应变量的值本身。 

然而在C++11之后，为了支撑移动语义，标准不得不对值类别做了一些扩充和修正：

- 左值(lvalue): 指定一个对象(object)或函数(function)。
  - 如果`E`是某种类型的指针类型，那么`*E`就是一个左值表达式，它引用的是`E`所指向的对象(object)或函数(function)。
  - 调用一个返回类型为左值引用的函数，其结果是一个左值。
- 将亡值(xvalue): expiring value的缩写，也指定一个对象，这个对象通常是生命周期即将结束的状态，因此它可以被移动。xvalue是某些涉及右值引用的表达式的结果。
  - 调用一个返回类型为右值引用的函数，其结果就是一个xvalue。
- 广义左值(glvalue): lvalue或者是xvalue。
- 右值(rvalue): xvalue，临时的对象或子对象，或者是与对象无关的值。
- 纯右值(prvalue): 非xvalue的rvalue。
  - 调用一个返回类型为非引用类型的函数，其结果就是一个prvalue。

![](2022-05-30-14-22-25.png)

> 大部分初学者都会因为不了解xvalue和prvalue的概念而想当然地把lvalue和rvalue想象成同一层级的概念，而这在学习过程中就会遇到重重困扰，进而对rvalue的概念云里雾里。实际上rvalue是个混合分类。

