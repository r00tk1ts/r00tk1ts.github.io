---
title: C++模板从入门到劝退(2)——型别推导、万能引用与完美转发
date: 2022-06-07 11:59:10
tags: [cpp, cpp-templates]
category: program-language
---

谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述严谨性，按照笔者的归纳方式穿针引线，为痴迷于黑魔法而又始终不得其解的同学打通任督二脉。

本篇是走进模板世界的最后一道前菜，通过型别推导、万能引用与完美转发这三个C++11所引入的新机制，我们得以对模板的世界管中窥豹。

<!--more-->

# 型别推导、万能引用与完美转发
上一讲的最后我们提到了一种特殊的引用类型：万能引用(Universal Reference)，万能引用虽然长得很像普通的右值引用，但二者却有着本质差别。万能引用是形如`T&&`的引用类型，当且仅当`T`的型别需要被直接推导时，万能引用的最终类型判定需要介入引用折叠规则，虽然上一讲我们有提到，但却浅尝辄止。而说到型别推导(Type Deduction)，这是一个迷人且拥有非常复杂的判定规则的设定，在传统C++中，它始终和模板一起出现，因此传统的C++开发者即使对模板望而生畏、不了解型别推导也不会在日常开发工作中因此而困扰，而C++11引入了`auto`和`decltype`关键字，将型别推导的作用放大到开发者的日常中，至此，在现代C++开发中，开发者或多或少都需要亿点点型别推导的知识。

> `auto`这个关键字早就存在（从C语言继承过来的legacy），但是在现代操作系统中这玩意毫无卵用，C++11罕见的废弃了`auto`原本的语义而重新定义了它，要知道，C++可是个相当保守的老顽固。

## 函数模板实参推导
回想一下传统C++中的函数模板实参推导(Function Template Argument Deduction)，一个函数模板想要实例化出具体的函数需要确定所有的模板实参，而这里的确定一般有两种手法：一种是显式地指定；另一种是让编译器根据上下文自行推断。实际上这两种手法也常常混用，即函数模板实参的确定由二者共同完成。举个例子：

```cpp
// 这里只做了模板声明，省略了定义，这里只是为了做推导演示
// 但我们要知道：函数一旦需要执行的话，那么其定义是必不可少的
template<typename To, typename From>
To convert(From f);

void g(double d) {
    int i = convert<int>(d);    // 需要实例化出int convect<int, double>(double){...}
    char c = convert<char>(d);  // 需要实例化出int convert<int, char>(char){...}
    int(*ptr)(float) = convert; // 需要实例化出int convert<int, float>(float){...}
}
```

这就是一个显式指定 + 型别推导的例子，第一行我们仅指定了`To`为`int`型，`From`则根据传入的参数`d`被编译器推导成`double`型，它与`d`的类型一致。第二行与第一行类似，只不过显式指定的`To`类型是`char`。第三行则有些不同，它定义了一个型别为`int(*)(float)`的函数指针变量`ptr`，使其指向`convert`函数，这里`To`和`From`都需要编译器来做推导，根据函数指针类型，分别将`To`推导成`int`、`From`推导成`float`。`ptr`实际指向的是函数模板`convert`实例化出的形如`int convert<int, float>(float){...}`的函数，而非`convert`本身，我们知道函数模板本身只是模板，是没有实体对象的。

> 该例出自https://en.cppreference.com/w/cpp/language/template_argument_deduction，道行够深的同学一定要通读。

如果将上例中的`To`和`From`顺序颠倒，会发生什么事呢？由于模板参数`To`并没有出现在函数的参数列表中，故某些情况编译器无法通过上下文来推导出`To`的类型，我们只好这样来写：

```cpp
template<typename From, typename To>
To convert(From f);

void g(double d) {
    int i = convert<double, int>(d);    // 完全显式指定，编译器不再需要按参数d的类型做推导
    char c = convert<double, char>(d);  // 完全显式指定，编译器不再需要按参数d的类型做推导
    int(*ptr)(float) = convert;         // 还是可以完成推导，需要实例化出int convert<int, float>(float){...}
}
```

顺序的调换导致我们前两行的自动推导失效，从而不得不完全显式地指定，代码也写成了“愚型”。而另一方面，我们也可以看出，对于函数模板来说，大多数情况的模板实参型别推导还是依赖于函数调用的参数列表，这其中出现了的模板参数往往可以进行推导。我们简单总结下，对于函数模板`template<typename T>void f(T param);`，编译器可以根据我们实际调用时传入的实参类型来进行推导(`f(argument);`)，得出模板参数`T`的类型和相应的参数列表(`T param`)。

然而这只是一种情况，也是最简单的情况。实际上，我们需要考虑的维度有三个：

- 模板参数本身：`T`
- 函数参数列表：不一定是`T param`，很可能对`T`做了CV限定或是引用/指针修饰，我们记为`ParamType`
- 函数调用实参：`argument`这个表达式的型别可以千奇百怪

`T`型别的推导实际上是`ParamType`和`argument`的共同作用，从`ParamType`的视角来看，大抵有着三种情况：

- `ParamType`既非指针也非引用
- `ParamType`是个指针或引用（万能引用除外）
- `ParamType`是个万能引用

### `ParamType`既非指针也非引用
这是最简单的情况：按值传递。

```cpp
template<typename T>
void f(T param);

f(argument);
```

值传递的推导规则非常轻量：编译器在推导时会忽略掉`argument`的顶层CV限定和引用修饰。结合第一讲中的值语义，这一点其实非常好理解：值传递的形参本质上是实参的副本，所以实参的顶层`const`,`volatile`特性形参完全可以不care，拷贝以后就跟数据源头毫无瓜葛了，通俗的理解是”大可以我改我的，反正我又不影响你“。至于引用修饰，那就更没关系了，都值语义了，它只能影响从哪个源头拷贝而已。

此外还要注意，值传递推导所忽略的CV限定只有顶层(top)，底层(bottom)CV限定是不能被忽略的，比如：

```cpp
const char* const ptr = "Fun with pointers";    // ptr是个指向const对象的const指针
f(ptr); // T被推导成const char*，底层const得以保留，也必须保留
```

> `const`是限定`char`还是限定pointer，要看它的位置在`*`的左边还是右边。

其实这也很好理解，因为值语义拷贝的是个指针，指针本身的`const`限定可以被擦掉，但是它所指向的类型的`const`限定是绝对不可以擦掉的。

### `ParamType`是个指针或引用（万能引用除外）


## 参考文献
- [Template argument deduction](https://en.cppreference.com/w/cpp/language/template_argument_deduction)
- [Effective Modern C++](https://www.oreilly.com/library/view/effective-modern-c/9781491908419/)