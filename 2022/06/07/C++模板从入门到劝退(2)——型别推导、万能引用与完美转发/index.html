

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="r00tk1t">
  <meta name="keywords" content="">
  
    <meta name="description" content="谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述">
<meta property="og:type" content="article">
<meta property="og:title" content="C++模板从入门到劝退(2)——型别推导、万能引用与完美转发">
<meta property="og:url" content="https://r00tk1ts.github.io/2022/06/07/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(2)%E2%80%94%E2%80%94%E5%9E%8B%E5%88%AB%E6%8E%A8%E5%AF%BC%E3%80%81%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/index.html">
<meta property="og:site_name" content="玉涵的技能书">
<meta property="og:description" content="谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-07T03:59:10.000Z">
<meta property="article:modified_time" content="2023-11-01T08:09:45.622Z">
<meta property="article:author" content="r00tk1t">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="cpp-templates">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C++模板从入门到劝退(2)——型别推导、万能引用与完美转发 - 玉涵的技能书</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"r00tk1ts.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>玉涵的技能书</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/doc/">
                <i class="iconfont icon-books"></i>
                <span>藏经阁</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++模板从入门到劝退(2)——型别推导、万能引用与完美转发"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-06-07 11:59" pubdate>
          2022年6月7日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          26k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          214 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++模板从入门到劝退(2)——型别推导、万能引用与完美转发</h1>
            
            
              <div class="markdown-body">
                
                <p>谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述严谨性，按照笔者的归纳方式穿针引线，为痴迷于黑魔法而又始终不得其解的同学打通任督二脉。</p>
<p>本篇是走进模板世界的最后一道前菜，通过型别推导、万能引用与完美转发这三个C++11所引入的新机制，我们得以对模板的世界管中窥豹。</p>
<span id="more"></span>
<h1 id="型别推导万能引用与完美转发">型别推导、万能引用与完美转发</h1>
<p>上一讲的最后我们提到了一种特殊的引用类型：万能引用(Universal
Reference)，万能引用虽然长得很像普通的右值引用，但二者却有着本质差别。万能引用是形如<code>T&amp;&amp;</code>的引用类型，当且仅当<code>T</code>的型别需要被直接推导时，万能引用的最终类型判定需要介入引用折叠规则，虽然上一讲我们有提到，但却浅尝辄止。而说到型别推导(Type
Deduction)，这是一个迷人且拥有非常复杂的判定规则的设定，在传统C++中，它始终和模板一起出现，因此传统的C++开发者即使对模板望而生畏、不了解型别推导也不会在日常开发工作中因此而困扰，而C++11引入了<code>auto</code>和<code>decltype</code>关键字，将型别推导的作用放大到开发者的日常中，至此，在现代C++开发中，开发者或多或少都需要亿点点型别推导的知识。</p>
<blockquote>
<p><code>auto</code>这个关键字早就存在（从C语言继承过来的legacy），但是在现代操作系统中这玩意毫无卵用，C++11罕见的废弃了<code>auto</code>原本的语义而重新定义了它，要知道，C++可是个相当保守的老顽固。</p>
</blockquote>
<h2 id="函数模板实参推导">函数模板实参推导</h2>
<p>回想一下传统C++中的函数模板实参推导(Function Template Argument
Deduction)，一个函数模板想要实例化出具体的函数需要确定所有的模板实参，而这里的确定一般有两种手法：一种是显式地指定；另一种是让编译器根据上下文自行推断。实际上这两种手法也常常混用，即函数模板实参的确定由二者共同完成。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里只做了模板声明，省略了定义，这里只是为了做推导演示</span><br><span class="hljs-comment">// 但我们要知道：函数一旦需要执行的话，那么其定义是必不可少的</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> To, <span class="hljs-keyword">typename</span> From&gt;</span><br><span class="hljs-function">To <span class="hljs-title">convert</span><span class="hljs-params">(From f)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">int</span>&gt;(d);    <span class="hljs-comment">// 需要实例化出int convect&lt;int, double&gt;(double)&#123;...&#125;</span><br>    <span class="hljs-type">char</span> c = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">char</span>&gt;(d);  <span class="hljs-comment">// 需要实例化出int convert&lt;int, char&gt;(char)&#123;...&#125;</span><br>    <span class="hljs-built_in">int</span>(*ptr)(<span class="hljs-type">float</span>) = convert; <span class="hljs-comment">// 需要实例化出int convert&lt;int, float&gt;(float)&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这就是一个显式指定 +
型别推导的例子，第一行我们仅指定了<code>To</code>为<code>int</code>型，<code>From</code>则根据传入的参数<code>d</code>被编译器推导成<code>double</code>型，它与<code>d</code>的类型一致。第二行与第一行类似，只不过显式指定的<code>To</code>类型是<code>char</code>。第三行则有些不同，它定义了一个型别为<code>int(*)(float)</code>的函数指针变量<code>ptr</code>，使其指向<code>convert</code>函数，这里<code>To</code>和<code>From</code>都需要编译器来做推导，根据函数指针类型，分别将<code>To</code>推导成<code>int</code>、<code>From</code>推导成<code>float</code>。<code>ptr</code>实际指向的是函数模板<code>convert</code>实例化出的形如<code>int convert&lt;int, float&gt;(float)&#123;...&#125;</code>的函数，而非<code>convert</code>本身，我们知道函数模板本身只是模板，是没有实体对象的。</p>
<blockquote>
<p>该例出自https://en.cppreference.com/w/cpp/language/template_argument_deduction，道行够深的同学一定要通读。</p>
</blockquote>
<p>如果将上例中的<code>To</code>和<code>From</code>顺序颠倒，会发生什么事呢？由于模板参数<code>To</code>并没有出现在函数的参数列表中，故某些情况编译器无法通过上下文来推导出<code>To</code>的类型，我们只好这样来写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> From, <span class="hljs-keyword">typename</span> To&gt;</span><br><span class="hljs-function">To <span class="hljs-title">convert</span><span class="hljs-params">(From f)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;(d);    <span class="hljs-comment">// 完全显式指定，编译器不再需要按参数d的类型做推导</span><br>    <span class="hljs-type">char</span> c = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">double</span>, <span class="hljs-type">char</span>&gt;(d);  <span class="hljs-comment">// 完全显式指定，编译器不再需要按参数d的类型做推导</span><br>    <span class="hljs-built_in">int</span>(*ptr)(<span class="hljs-type">float</span>) = convert;         <span class="hljs-comment">// 还是可以完成推导，需要实例化出int convert&lt;int, float&gt;(float)&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>顺序的调换导致我们前两行的自动推导失效，从而不得不完全显式地指定，代码也写成了“愚型”。而另一方面，我们也可以看出，对于函数模板来说，大多数情况的模板实参型别推导还是依赖于函数调用的参数列表，这其中出现了的模板参数往往可以进行推导。我们简单总结下，对于函数模板<code>template&lt;typename T&gt;void f(T param);</code>，编译器可以根据我们实际调用时传入的实参类型来进行推导(<code>f(argument);</code>)，得出模板参数<code>T</code>的类型和相应的参数列表(<code>T param</code>)。</p>
<p>然而这只是一种情况，也是最简单的情况。实际上，我们需要考虑的维度有三个：</p>
<ul>
<li>模板参数本身：<code>T</code></li>
<li>函数参数列表：不一定是<code>T param</code>，很可能对<code>T</code>做了CV限定或是引用/指针修饰，我们记为<code>ParamType</code></li>
<li>函数调用实参：<code>argument</code>这个表达式的型别可以千奇百怪</li>
</ul>
<p><code>T</code>型别的推导实际上是<code>ParamType</code>和<code>argument</code>的共同作用，从<code>ParamType</code>的视角来看，大抵有着四种情况：</p>
<ul>
<li><code>ParamType</code>既非指针也非引用</li>
<li><code>ParamType</code>是个指针</li>
<li><code>ParamType</code>是个左值引用</li>
<li><code>ParamType</code>是个万能引用</li>
</ul>
<h3
id="paramtype既非指针也非引用"><code>ParamType</code>既非指针也非引用</h3>
<p>这是最简单的情况：按值传递。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;<br><br><span class="hljs-built_in">f</span>(argument);<br></code></pre></td></tr></table></figure>
<p>值传递的推导规则非常轻量：编译器在推导时会忽略掉<code>argument</code>的顶层CV限定和引用修饰。结合第一讲中的值语义，这一点其实非常好理解：值传递的形参本质上是实参的副本，所以实参的顶层<code>const</code>,<code>volatile</code>特性形参完全可以不care，拷贝以后就跟数据源头毫无瓜葛了，通俗的理解是”大可以我改我的，反正我又不影响你“。至于引用修饰，那就更没关系了，都值语义了，它只能影响从哪个源头拷贝而已。</p>
<p>此外还要注意，值传递推导所忽略的CV限定只有顶层(top)，底层(bottom)CV限定是不能被忽略的，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> ptr = <span class="hljs-string">&quot;Fun with pointers&quot;</span>;    <span class="hljs-comment">// ptr是个指向const对象的const指针</span><br><span class="hljs-built_in">f</span>(ptr); <span class="hljs-comment">// T被推导成const char*，底层const得以保留，也必须保留</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>const</code>是限定<code>char</code>还是限定pointer，要看它的位置在<code>*</code>的左边还是右边。</p>
</blockquote>
<p>其实这也很好理解，因为值语义拷贝的是个指针，指针本身的<code>const</code>限定可以被擦掉，但是它所指向的类型的<code>const</code>限定是绝对不可以擦掉的。</p>
<p>来看一些用例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// param类型和T类型始终一致</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    <span class="hljs-comment">// 打印T的型别和param的型别</span><br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);       <span class="hljs-comment">// 最简单的情景，T被推导为int</span><br>    <span class="hljs-built_in">f</span>(cx);      <span class="hljs-comment">// 由于const被忽略，T依然被推导为int</span><br>    <span class="hljs-built_in">f</span>(rx);      <span class="hljs-comment">// 先忽略掉引用、再忽略掉const，T还是被推导成int</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);      <span class="hljs-comment">// T被推导为int*</span><br>    <span class="hljs-built_in">f</span>(&amp;cx);     <span class="hljs-comment">// T被推导为const int*，底层const特性不能忽略</span><br>    <span class="hljs-built_in">f</span>(&amp;rx);     <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(pcx);     <span class="hljs-comment">// T被推导为const int*, 底层const特性不能忽略</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// 顶层const被忽略，T被推导为const int*</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">int	int<br>int	int<br>int	int<br>int *	int *<br>const int *	const int *<br>const int *	const int *<br>const int *	const int *<br>const int *	const int *<br></code></pre></td></tr></table></figure>
<p>C++标准库的<code>typeid</code>贼鸡儿难用，由于标准没有规定其<code>name</code>成员函数的输出结果，各大编译器花式整活，输出结果尽是些听不懂的“方言”，另一方面<code>typeid</code>也是运行期输出，没那个味儿。作为一名C++程序员，我们遇到困难，也不要怕，微笑着(bushi)……自己实现一个编译期类型计算的方法(当然，本鶸搬运的是so大神的实现)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span><br><span class="hljs-function">std::string_view</span><br><span class="hljs-function"><span class="hljs-title">type_name</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __clang__</span><br>    string_view p = __PRETTY_FUNCTION__;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">34</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">34</span> - <span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(__GNUC__)</span><br>    string_view p = __PRETTY_FUNCTION__;<br><span class="hljs-meta">#  <span class="hljs-keyword">if</span> __cplusplus &lt; 201402</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">36</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">36</span> - <span class="hljs-number">1</span>);<br><span class="hljs-meta">#  <span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">49</span>, p.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;;&#x27;</span>, <span class="hljs-number">49</span>) - <span class="hljs-number">49</span>);<br><span class="hljs-meta">#  <span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>    string_view p = __FUNCSIG__;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string_view</span>(p.<span class="hljs-built_in">data</span>() + <span class="hljs-number">84</span>, p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">84</span> - <span class="hljs-number">7</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>现阶段初学者还不需要理解这段代码，实际上他并没有做什么神奇的操作，只是对不同的编译器生成的函数签名中截取了想要的部分字符串而已。总之，现在只需要知道<code>type_name</code>这个函数模板可以输出任何模板参数<code>T</code>的类型。</p>
<h3 id="paramtype是个指针"><code>ParamType</code>是个指针</h3>
<p>模板形如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T* param)</span></span>;  <br></code></pre></td></tr></table></figure>
<p>此时，形参<code>param</code>的类型已经被限制成必须是某个类型的指针型，指针型本质上也是按值传递（拷贝的是地址值，即指针型变量存储的value），推导规则就尝试将实参<code>argument</code>“适配”到形参上去，形参类型确定了，那么<code>T</code>的类型也就确定了，此时形参和<code>T</code>是不同的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T* param)</span> </span>&#123;<br>    <span class="hljs-comment">// 输出T的类型和形参param的类型</span><br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">int</span>* px = &amp;x;<br>    <span class="hljs-type">int</span>*&amp; rpx = px;             <span class="hljs-comment">// 指针的引用，</span><br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* pcx = &amp;x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> pcpx = &amp;x; <span class="hljs-comment">// 当然了，像rpx,pcpx这种东西你日常编程基本遇不到，这里只是为了让例子尽量丰满</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);   <span class="hljs-comment">// T被推导为int, param被推导为int*</span><br>    <span class="hljs-built_in">f</span>(px);   <span class="hljs-comment">// 同上</span><br>    <span class="hljs-built_in">f</span>(rpx);  <span class="hljs-comment">// 同上</span><br>    <span class="hljs-built_in">f</span>(pcx);  <span class="hljs-comment">// T被推导为const int, param被推导为const int* </span><br>    <span class="hljs-built_in">f</span>(pcpx); <span class="hljs-comment">// T被推导为const int, param被推导为const int*</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zsh">int	int *<br>int	int *<br>int	int *<br>const int	const int *<br>const int	const int *<br></code></pre></td></tr></table></figure>
<p>实际上，指针型的推导和第一种情况的值推导很相似，引用修饰和顶层const同样会被忽略，只不过<code>T</code>的类型和形参<code>param</code>的类型有所区别罢了。</p>
<h3 id="paramtype是左值引用"><code>ParamType</code>是左值引用</h3>
<p>模板形如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;<br></code></pre></td></tr></table></figure>
<p>这种情况相当于限定了形参<code>param</code>的类型一定是某个类型的左值引用，这就意味着我们的传参方式是按引用传递(传址)，因此一方面实参<code>argument</code>的引用修饰会被忽略（因为不管是不是引用类型，最终推导出的形参都必须是个左值引用），另一方面其CV限定不会也不能被忽略，因为相比于值传递，我们此时传递的对象并不会拷贝一份，因此其<code>const</code>,<code>volatile</code>特性绝对不能忽略或者舍弃。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);       <span class="hljs-comment">// T被推导为int, param被推导为int&amp;</span><br>    <span class="hljs-built_in">f</span>(cx);      <span class="hljs-comment">// T被推导为const int, param被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(rx);      <span class="hljs-comment">// rx本身的reference会被忽略，因此和传递cx没什么两样</span><br><br>    <span class="hljs-comment">//f(&amp;x);    // 这三个都不能通过编译，因为param是左值引用必须绑定到左值上</span><br>    <span class="hljs-comment">//f(&amp;cx);   // 取地址符表达式是prvalue，不能被lvalue reference绑定</span><br>    <span class="hljs-comment">//f(&amp;rx);</span><br><br>    <span class="hljs-built_in">f</span>(pcx);     <span class="hljs-comment">// T被推导为const int*, param被推导为const int*&amp;</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// T被推导为const int* const, param被推导为const int* const&amp;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zsh">int	int &amp;<br>const int	const int &amp;<br>const int	const int &amp;<br>const int *	const int *&amp;<br>const int *const	const int *const &amp;<br></code></pre></td></tr></table></figure>
<p>而说到左值引用，就不得不提到C++中的万金油：const左值引用，试想如果我们前置地对<code>param</code>型别增加一个<code>const</code>限定会如何呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);   <span class="hljs-comment">// T被推导为int, param被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(cx);  <span class="hljs-comment">// T被推导为int, param被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(rx);  <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);  <span class="hljs-comment">// const左值引用也可以绑定到右值上，因此编译通过。T被推导为int*，param被推导为const int*&amp;</span><br>    <span class="hljs-built_in">f</span>(&amp;cx); <span class="hljs-comment">// T被推导为const int*，param被推导为const int* const &amp;</span><br>    <span class="hljs-built_in">f</span>(&amp;rx); <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(pcx); <span class="hljs-comment">// pcx是左值，T被推导为const int*, param绑定其上，本身追加const限定，因此被推导为const int* const&amp;</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// 同上，不管T本身是否有顶层const, param都会具有顶层const</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">int	const int &amp;<br>int	const int &amp;<br>int	const int &amp;<br>int *	int *const &amp;<br>const int *	const int *const &amp;<br>const int *	const int *const &amp;<br>const int *	const int *const &amp;<br>const int *	const int *const &amp;<br></code></pre></td></tr></table></figure>
<p>这些例子看起来很绕，但实际上，如果你搞懂了基于值语义和引用语义的型别推导原则，它们都是显而易见的。</p>
<h3 id="paramtype是万能引用"><code>ParamType</code>是万能引用</h3>
<p>这里就和上一讲的结尾接轨了，它是C++11引入右值引用后，自然而然演化出的产物。我将C++标准对万能引用的定义翻译成白话：万能引用是一种特殊的引用类型，它所引用的类型需要被推导，且携带了用于型别推导的实参的值分类信息，使得其可以被<code>std::forward</code>完美转发。我们先忽略最后半句，通过函数模板参数来理解一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123; <span class="hljs-comment">// 此时T&amp;&amp;是个万能引用，不论类型如何，我们知道param一定是引用，所以是按引用传递</span><br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pcx = &amp;cx;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> cpcx = &amp;cx;<br><br>    <span class="hljs-built_in">f</span>(x);       <span class="hljs-comment">// x是左值，按引用传递就视为左值引用，这和你用x作为实参去调用一个形参为int&amp;的函数没什么区别</span><br>                <span class="hljs-comment">// 因此T被推导成int&amp;, param也被推导成int&amp;（此时发生了引用折叠）</span><br>    <span class="hljs-built_in">f</span>(cx);      <span class="hljs-comment">// cx也是左值，但因为按引用传递，const特性必须保留</span><br>                <span class="hljs-comment">// 因此T被推导成const int&amp;, param也被推导为const int&amp;</span><br>    <span class="hljs-built_in">f</span>(rx);      <span class="hljs-comment">// 同上，是否按引用传递取决于形参有没有reference修饰，这一点跟实参本身是不是reference没关系</span><br><br>    <span class="hljs-built_in">f</span>(&amp;x);      <span class="hljs-comment">// &amp;x是右值，只有右值引用才能绑定到右值上，因此param只能被推导成int* &amp;&amp;(int指针型的右值引用)</span><br>                <span class="hljs-comment">// 此时T被推导为int*</span><br>    <span class="hljs-built_in">f</span>(&amp;cx);     <span class="hljs-comment">// 同上</span><br>    <span class="hljs-built_in">f</span>(&amp;rx);     <span class="hljs-comment">// 同上</span><br><br>    <span class="hljs-built_in">f</span>(pcx);     <span class="hljs-comment">// pcx是左值，故T被推导为const int*&amp;，param也一样</span><br>    <span class="hljs-built_in">f</span>(cpcx);    <span class="hljs-comment">// cpcx是左值，故T被推导为const int* const &amp;, param也一样</span><br>                <span class="hljs-comment">// 只不过按引用传递的情况，顶层const必须保留</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">int &amp;	int &amp;<br>const int &amp;	const int &amp;<br>const int &amp;	const int &amp;<br>int *	int *&amp;&amp;<br>const int *	const int *&amp;&amp;<br>const int *	const int *&amp;&amp;<br>const int *&amp;	const int *&amp;<br>const int *const &amp;	const int *const &amp;<br></code></pre></td></tr></table></figure>
<p>可以看到万能引用终归是个引用，不管是左值引用还是右值引用，不管有没有CV限定，最终都得是按引用传递，因此规则上和第三种：<code>ParamType</code>为左值引用时相同，只不过它多了一步根据实参来确定引用类型（同时也解决了传统C++中，只能用const左值引用来按引用传递右值以避免拷贝的局限性设计问题）。</p>
<p>事实上，我们大可以将分类改成两类，即前两种是一类，后两种是一类，分类的口径则是形参的传递方式（值传递还是引用传递）。</p>
<blockquote>
<p>不管是标准手册还是广为流传的参考书，它们对型别推导的归纳看上去都非常的复杂（哪怕是用很简单的例子），本质上是因为它们没有从值语义或是引用语义来出发，事实上，只要你拿捏住一件事：推导过程中形参究竟是值传递还是引用传递，那么不管多复杂的case，都有迹可循。</p>
</blockquote>
<h2 id="auto与decltype">auto与decltype</h2>
<p>以函数模板实参推导为例，我们看穿了型别推导背后的机制：值传递和引用传递的差别对待。C++11为了简化历来饱受诟病的又臭又长的语法(诸如<code>std::map&lt;std::string, std::vector&lt;std::string&gt;&gt;::const_iterator</code>)，引入了<code>auto</code>和<code>decltype</code>这两个关键字。这两位爷都是用于型别推导的，只是推导的规则不同，<code>auto</code>这个关键字的使用在现代C++中要分两个场景来看：其一是最常见的为变量做型别推导；其二是为函数返回类型做推导（C++14之后才发糖支持）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 第一种场景：变量型别推导</span><br><span class="hljs-keyword">auto</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; r = a;<br><span class="hljs-keyword">auto</span> *p = &amp;a;<br><br><span class="hljs-comment">// 第二种场景：函数返回类型推导</span><br><span class="hljs-comment">// 在C++11中，只能写作：</span><br><span class="hljs-comment">// auto f() -&gt; decltype(666) &#123; return 666; &#125;</span><br><span class="hljs-comment">// 虽然看起来只是加了个尾部型别推导，但这里的auto只是个占位符（PlaceHolder），与C++14中真正用于推导的auto有本质差别</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">666</span>; &#125;<br></code></pre></td></tr></table></figure>
<p>无论哪一种场景，<code>auto</code>所应用的推导规则实际上就是模板实参推导的规则。我们知道，前面在做函数模板实参推导时，需要考量的有3个维度：模板参数<code>T</code>，函数形参类型<code>ParamType</code>和传递的实参<code>argument</code>。如何类比呢？实际上我们可以把<code>auto</code>看做模板参数<code>T</code>，而<code>auto</code>结合CV限定和引用、指针修饰而成的最终变量类型则看做<code>ParamType</code>，<code>=</code>右边的表达式看做<code>argument</code>。</p>
<blockquote>
<p><code>auto</code>的型别推导与模板实参推导的规则实际上有一点不同：前者会将花括号语法视为<code>std::initializer_list</code>(C++17有所调整，仅限于'='右边)，而后者并不会。<code>std::initializer_list</code>这个东西在C++11引入，主要是为了给花括号初始化语法做补丁，然而C++语法的复杂导致这个东西在很多使用场景下显得格格不入，之后的标准演进中也一直在缝缝补补。</p>
</blockquote>
<p>我们直接看例子，按照上面描述的置换规则置换一下，再根据在模板实参推导中已掌握的知识，揣摩一下输出结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;            <span class="hljs-comment">// 值传递，对应case 1，T被推导为int，x的类型也是int</span><br>    <span class="hljs-keyword">auto</span>&amp; rx = x;           <span class="hljs-comment">// 引用传递，对应case3, T被推导为int, rx的类型是int&amp;</span><br>    <span class="hljs-keyword">auto</span>&amp;&amp; rrx = <span class="hljs-number">666</span>;       <span class="hljs-comment">// 引用传递，对应case4，auto&amp;&amp;是个万能引用</span><br>                            <span class="hljs-comment">// 666是prvalue，故T被推导为int，rrx的类型是int&amp;&amp;</span><br>    <span class="hljs-keyword">auto</span>&amp;&amp; lrx = x;         <span class="hljs-comment">// 引用传递，对应case4，auto&amp;&amp;是个万能引用</span><br>                            <span class="hljs-comment">// x是lvalue，故T被推导为int&amp;，lrx的类型也是int&amp;</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> cx = x;      <span class="hljs-comment">// 值传递，T被推导为int, cx的类型是const int</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; rcx = x;    <span class="hljs-comment">// 引用传递，T被推导为int, rcx的类型是const int&amp;</span><br><br>    <span class="hljs-keyword">auto</span>* px = &amp;x;          <span class="hljs-comment">// 值传递，T被推导为int, px的类型是int*</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>* pcx = &amp;cx;  <span class="hljs-comment">// 值传递，T被推导为int, pcx的类型是const int*    </span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>* <span class="hljs-type">const</span> cpcx = &amp;cx;   <span class="hljs-comment">// 值传递，T被推导为int, cpcx的类型是const int* const</span><br><br>    <span class="hljs-comment">// 这里用到了decltype这个specifier，我们暂且只需要知道decltype(variable)可以原封不动的给出variable的类型</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of x: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(x)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of rx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(rx)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of rrx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(rrx)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of cx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(cx)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of rcx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(rcx)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of px: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(px)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of pcx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(pcx)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of cpcx: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(cpcx)&gt;() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of x: int<br>type of rx: int &amp;<br>type of rrx: int &amp;&amp;<br>type of lrx: int &amp;<br>type of cx: const int<br>type of rcx: const int &amp;<br>type of px: int *<br>type of pcx: const int *<br>type of cpcx: const int *const<br></code></pre></td></tr></table></figure>
<blockquote>
<p>思考一下：如果<code>auto* pcx2 = &amp;cx;</code>，<code>pcx2</code>是什么类型？<code>auto* const &amp; pcx3 = &amp;cx;</code>呢？如果你可以轻松地推导出来，那么恭喜你，你已经领悟了型别推导的奥义。</p>
</blockquote>
<p><code>decltype</code>也有两个与<code>auto</code>类似的使用场景，一种就是像上例那样使用的对变量做'='右边表达式的型别推导，另一种也是用在函数返回值推导中，写作<code>decltype(auto)</code>。</p>
<p><code>decltype</code>相比<code>auto</code>则没有那么麻烦的推导规则，它只是简单粗暴的告诉我们给定实参(<code>argument</code>)的真实类型（意味着不会忽略CV限定、引用修饰）。<code>argument</code>是一个表达式（也包括实体(entity)的情况），但通过前两节的学习，我们知道表达式的值类型有多种情况，所以还是要分情况讨论下：</p>
<ul>
<li>如果<code>argument</code>是没有套上小括号的变量(严格的说法是id-expression，不过为了便于理解我们忽略官方的黑话)或是类成员访问表达式(通俗的理解这也是个变量)，decltype给出其本身的类型。</li>
<li>否则，对于其他类型<code>T</code>的表达式
<ul>
<li>如果表达式的值分类是xvalue，则推导为<code>T&amp;&amp;</code></li>
<li>如果表达式的值分类是lvalue，则推导为<code>T&amp;</code></li>
<li>如果表达式的值分类是prvalue，则推导为<code>T</code></li>
</ul></li>
</ul>
<p>这实际上就是cppreference给出的<code>decltype</code>说明符的解释，初学者可能会对第一条款中提到的小括号包裹感到奇怪，实际上它的本质原因在于entity和expresion的区别，假设有变量<code>int a = 3;</code>，<code>a</code>我们可以说它是一个entity，但是<code>(a)</code>就不再是一个实体，而是一个表达式了，套上小括号意味着表达式需要被计算(或处理)，即使我们对<code>a</code>什么都没做，它也需要处理。因此，对于<code>(a)</code>来说，它是个表达式，要根据第二条款来判定，由于<code>(a)</code>是个lvalue，所以此时型别为<code>int&amp;</code>。</p>
<blockquote>
<p>说到这里就不得不提一个现代C++中很有意思的坑：返回值类型支持<code>decltype(auto)</code>推导后，对于函数返回语句如果要返回一个变量，那么写成<code>return a;</code>和<code>return (a);</code>意义完全不同，前者会被推导为<code>a</code>的类型，而后者被推导为<code>a</code>的左值引用类型。而如果没有用到推导，而是老老实实的返回<code>a</code>的类型，那么这两种写法其实都可以，只不过后者做了一次计算，不会引入其他问题。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type_info.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">double</span> x;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">get_ref</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *p)</span> </span>&#123; <span class="hljs-keyword">return</span> *p; &#125;<br><br><span class="hljs-comment">// 相当于C++11中的auto get_ref_forward1(const int* p) -&gt; decltype(get_ref(p))</span><br><span class="hljs-comment">// 由于get_ref(p)是个表达式返回的是个lvalue，故推导成const int&amp;</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">get_ref_forward1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_ref</span>(p);<br>&#125;<br><br><span class="hljs-comment">// 值传递，返回的一定是个值类型，此时的实参是get_ref(p)，忽略掉顶层CV限定，于是推导为int</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_ref_forward2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_ref</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-keyword">decltype</span>(a.x) y = <span class="hljs-number">1.0</span>;  <span class="hljs-comment">// 对于entity，y推导成其本身的类型double</span><br>    <span class="hljs-keyword">decltype</span>((a.x)) z = y;  <span class="hljs-comment">// 由于小括号的存在导致按表达式来推导，(a.x)是左值故推导成double&amp;</span><br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;             <br>    <span class="hljs-keyword">decltype</span>(i) j = i;      <span class="hljs-comment">// 对于entity，j推导成本身类型int</span><br>    <span class="hljs-keyword">decltype</span>((i)) k = j;    <span class="hljs-comment">// 由于小括号的存在导致按表达式来推导，(i)是左值故推导成int&amp;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i;       <br>    <span class="hljs-keyword">decltype</span>(ci) cj = ci;   <span class="hljs-comment">// 推导成const int，decltype不会像auto那样忽略顶层CV限定</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of y: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(y)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of z: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(z)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of j: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(j)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of k: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(k)&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of cj: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(cj)&gt;() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;type of return value of get_ref_forward1: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">get_ref_forward1</span>(&amp;ci))&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of return value of get_ref_forward2: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">get_ref_forward2</span>(&amp;ci))&gt;() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of y: double<br>type of z: double &amp;<br>type of j: int<br>type of k: int &amp;<br>type of cj: const int<br>type of return value of get_ref_forward1: const int &amp;<br>type of return value of get_ref_forward2: int<br></code></pre></td></tr></table></figure>
<blockquote>
<p>思考一下：如果get_ref_forward2的返回类型写作<code>auto&amp;</code>，又该是什么类型呢？</p>
</blockquote>
<h2 id="恼人的数组与函数">恼人的数组与函数</h2>
<p>凡是总有例外，在C++中，有两种类型天生需要被特殊处理，那就是从C语言继承过来的数组和函数名称。在C语言中，数组和指针常常混用，绝大部分场景都可以互为代替使用，这就导致很多人将数组和指针视为同一种东西的不同写法，虽然这个看法是错误的，但在日常开发中，用这样一种局限性的看法来读写代码确实会使事情简单化。函数名称则简单不少，在C中几乎被视为相应的函数指针类型。C++继承了C的legacy，但随着C++语法规则的不断演进，数组和函数名称逐渐显得格格不入，为此，C++做了很多语法上兼容性处理，在很多语境下，数组会退化(decay)成指向其首元素的指针型，而函数名称会退化(decay)成相应的函数指针型。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> name[] = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-comment">// name的类型是const char[6]</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* p1 = name;          <span class="hljs-comment">// 数组退化，p1指向name的首元素</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* p2 = <span class="hljs-string">&quot;world&quot;</span>;       <span class="hljs-comment">// &quot;world&quot;是一个字符串字面量左值，类型为const char[6]</span><br>                                <span class="hljs-comment">// 数组退化，p2指向&quot;world&quot;首元素</span><br></code></pre></td></tr></table></figure>
<p>从C++的视角来看，假如没有退化规则，那么对指针的初始化显然是不合法的，但为了兼容C的legacy，不得不做了容忍。另一方面，在C中我们经常写:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-comment">// 这在C中非常常见，但如果是在C++11之后是不合法的，尽管编译器只抛了warning：</span><br>                        <span class="hljs-comment">// ISO C++11 does not allow conversion from string literal to &#x27;char *&#x27; </span><br>                        <span class="hljs-comment">// 字符串字面量是左值（意味着可以被取地址），它有着const特性，底层const不能丢，所以得用const char*</span><br><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;world&quot;</span>;   <span class="hljs-comment">// 这是C语言对字符数组发放的语法糖，str的类型实际上是char[6]</span><br>                        <span class="hljs-comment">// 等价于char str[6] = &#123;&#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;\0&#x27;&#125;</span><br>                        <span class="hljs-comment">// C语言一方面支持定界值省略，另一方面对字符数组做了照顾：花括号初始化语法可以改写为字符串字面量</span><br>                        <span class="hljs-comment">// C++继承了C，所以这在C++中也合法，且语义相同，注意区分和前者的差别</span><br></code></pre></td></tr></table></figure>
<p>为了说明两种语法的差别，我们编写如下程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;world&quot;</span>;<br><br>    cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of p: %p\n&quot;</span>, p);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of \&quot;hello\&quot;: %p\n&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of str: %p\n:&quot;</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address of \&quot;world\&quot;: %p\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zsh">hello world<br>address of p: 0x10232bea4<br>address of &quot;hello&quot;: 0x10232bea4<br>address of str: 0x16dad76f8<br>:address of &quot;world&quot;: 0x10232bf03<br></code></pre></td></tr></table></figure>
<p>显然，<code>p</code>和<code>"hello"</code>的地址是相同的，说明它们是同一个对象。而<code>str</code>则和<code>"world"</code>有所不同，<code>str</code>只是以<code>char</code>为单位逐个拷贝了<code>"world"</code>的数据到自身的存储单元而已，其类型是<code>char[6]</code>。</p>
<p>再来看看当数组涉及型别推导时，效果如何：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">f</span>(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of T: int *<br>type of param: int *<br>type of T: char *<br>type of param: char *<br></code></pre></td></tr></table></figure>
<p>由于<code>param</code>值传递，所以推导时数组类型发生了退化，降级成对应的首元素指针型。而如果改为按引用传递，则不会发生decay：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);                          <br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-built_in">move</span>(str));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of T: int (&amp;)[5]<br>type of param: int (&amp;)[5]<br>type of T: char [6]<br>type of param: char (&amp;&amp;)[6]<br></code></pre></td></tr></table></figure>
<p>可以看到param就是传递进来的参数的原本类型。</p>
<p>如果说上面的例子根据我们的口诀来看还算中规中矩，那下面这个就有点反人类了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里的定界6不能少，否则param是个非法的数组引用</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T (&amp;param)[<span class="hljs-number">6</span>])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 虽然写作T[]，但因为值传递的关系，还是退化成了T*，定界写不写都无所谓，随便写什么都行</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T param[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);<br>    <span class="hljs-built_in">g</span>(v);<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">f</span>(str);<br>    <span class="hljs-built_in">g</span>(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">type of T: int<br>type of param: int (&amp;)[6]<br>type of T: int<br>type of param: int *<br>type of T: char<br>type of param: char (&amp;)[6]<br>type of T: char<br>type of param: char *<br></code></pre></td></tr></table></figure>
<blockquote>
<p>我特意把v改成了6个成员，思考一下如果这里不改的话会不会有啥问题？</p>
</blockquote>
<p>另外，由于数组引用并不是个直截了当的类型，如果我们写成<code>T (&amp;&amp;param)[6]</code>会编译报错，因为此时param不再是一个万能引用。</p>
<p>你以为这样就结束了？当数组和非类型模板参数相遇时，还有更离谱的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 函数模板也可以重载，但要注意可能会引发的ambiguous调用问题</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T (&amp;param)[<span class="hljs-number">5</span>])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;template f:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T (&amp;param)[N])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;nontype template f:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T param[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;template g:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T param[N])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;nontype template g:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">f</span>(v);                   <span class="hljs-comment">// 优先匹配template f，template f比nontype template f更特殊</span><br>    <span class="hljs-built_in">g</span>(v);                   <span class="hljs-comment">// 只能匹配template g，因为值传递会退化成指针</span><br>                            <span class="hljs-comment">// 即使把template g注释掉也无法匹配nontype template g</span><br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello&quot;</span>;   <br>    <span class="hljs-built_in">f</span>(str);                 <span class="hljs-comment">// 只能匹配nontype template f，因为template f不满足匹配条件无法成为candidate</span><br>    <span class="hljs-built_in">g</span>(str);                 <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs zsh">template f:<br>type of T: int<br>type of param: int (&amp;)[5]<br>template g:<br>type of T: int<br>type of param: int *<br>nontype template f:<br>type of T: char<br>type of param: char (&amp;)[6]<br>template g:<br>type of T: char<br>type of param: char *<br></code></pre></td></tr></table></figure>
<p>因为decay的关系，nontype template
g实际上无法被用到，如果我们把它改写成传引用呢：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T (&amp;param)[N])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;nontype template g:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of T: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;type of param: &quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时就会遇到编译错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs zsh">test_array3.cpp:37:5: error: call to &#x27;g&#x27; is ambiguous<br>    g(v);<br>    ^<br>test_array3.cpp:21:6: note: candidate function [with T = int]<br>void g(T param[]) &#123;<br>     ^<br>test_array3.cpp:28:6: note: candidate function [with T = int, N = 5]<br>void g(T (&amp;param)[N]) &#123;<br>     ^<br>test_array3.cpp:40:5: error: call to &#x27;g&#x27; is ambiguous<br>    g(str);<br>    ^<br>test_array3.cpp:21:6: note: candidate function [with T = char]<br>void g(T param[]) &#123;<br>     ^<br>test_array3.cpp:28:6: note: candidate function [with T = char, N = 6]<br>void g(T (&amp;param)[N]) &#123;<br>     ^<br>2 errors generated.<br></code></pre></td></tr></table></figure>
<p>因为两个版本此时都可以完成匹配作为candidate，但二者之间论优先级或者说特殊性并不能分出高下，所以导致了函数模板重载所常见的ambiguous错误。</p>
<blockquote>
<p>实际上当涉及到类模板对数组的特化时，情形远远比这里给出的例子要复杂得多，另一方面未定界数组实际上也有特殊的手法来传递推导。考虑到不希望这一部分内容喧宾夺主故不做展开，有兴趣的同学可以看一下《C++
Templates》5.4的内容。</p>
</blockquote>
<p>函数名称和函数指针的情景和数组很像：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &lt; b ? b : a;<br>&#125;<br><br><span class="hljs-keyword">using</span> func = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>(my_max);              <span class="hljs-comment">// decay，退化成函数指针</span><br>    <span class="hljs-built_in">g</span>(my_max);              <span class="hljs-comment">// 不会decay</span><br>    <span class="hljs-built_in">g</span>(std::<span class="hljs-built_in">move</span>(my_max));   <span class="hljs-comment">// 对函数名称进行move没意义</span><br><br>    func fp = my_max;       <span class="hljs-comment">// fp本身就是函数指针类型</span><br>    <span class="hljs-built_in">f</span>(fp);                  <span class="hljs-comment">// 不需要退化，单纯的值传递</span><br>    <span class="hljs-built_in">g</span>(fp);                  <span class="hljs-comment">// 注意是函数指针的左值引用</span><br>    <span class="hljs-built_in">g</span>(std::<span class="hljs-built_in">move</span>(fp));       <span class="hljs-comment">// 注意是函数指针的右值引用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs zsh">int (*)(int, int)<br>int (*)(int, int)<br>int (int, int)&amp;<br>int (int, int)&amp;<br>int (int, int)&amp;<br>int (int, int)&amp;<br>int (*)(int, int)<br>int (*)(int, int)<br>int (*)(int, int)&amp;<br>int (*)(int, int)&amp;<br>int (*)(int, int)<br>int (*)(int, int)&amp;&amp;<br></code></pre></td></tr></table></figure>
<p>相信读到这里的你，一定会觉着上面的结果一目了然。</p>
<h2 id="完美转发">完美转发</h2>
<p>最后谈谈完美转发。</p>
<p>除了我们之前详细解读过的<code>std::move</code>，C++11在标准库中还定义了一个非常常用的<code>std::forward</code>，相信对于大部分现代C++初学者来说，<code>std::forward</code>和<code>std::move</code>一度云里雾里。我们先撇开<code>std::forward</code>，来看看如下的一个使用场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(T&amp;&amp;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in func1, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>    <span class="hljs-comment">// 我们希望把param原封不动的“渗透”到下一层</span><br>    <span class="hljs-built_in">func2</span>(param);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;in func2, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">666</span>;<br>    <span class="hljs-built_in">func1</span>(a);       <span class="hljs-comment">// a是左值，所以func1中T被推导成int&amp;，param也是int&amp;，此时向下调用func2传递的依然是左值引用</span><br>                    <span class="hljs-comment">// 所以func2中的T和param也都是int&amp;，这是符合预期的 </span><br>    <span class="hljs-built_in">func1</span>(<span class="hljs-number">2333</span>);    <span class="hljs-comment">// 2333是纯右值，func1中T被推导成int，param被推导成int&amp;&amp;，此时向下调用func2传递的是右值引用类型的param</span><br>                    <span class="hljs-comment">// 尽管param的类型是右值引用，但param本身是个左值（具名的变量），这就导致渗透传递时func2中</span><br>                    <span class="hljs-comment">// T和param被推导成int&amp;，这就不符合预期了，我们的引用型在渗透过程中变质了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">in func1, T:int&amp;, param:int&amp;<br>in func2, T:int&amp;, param:int&amp;<br>in func1, T:int, param:int&amp;&amp;<br>in func2, T:int&amp;, param:int&amp;<br></code></pre></td></tr></table></figure>
<p>我们在<code>func1</code>中又调用了<code>func2</code>，且原封不动的将参数<code>param</code>传递了下去，希望能够把左值引用或是右值引用这一特性渗透到下一层，然而事与愿违，由于在C++语法中，即使类型为右值引用的具名变量其本身依然是个左值，这就导致了不可传递性。</p>
<p>可能有的小伙伴说了，我们不是学过<code>std::move</code>吗，只需要调用<code>func2</code>时对<code>param</code>再<code>move</code>一下不就行了吗？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in func1, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>    <span class="hljs-comment">// 强制传递右值引用</span><br>    <span class="hljs-built_in">func2</span>(<span class="hljs-built_in">move</span>(param));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>显然，如果按照这个写法，上述例子中后者的运行结果符合预期，可是前者却又出了问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">in func1, T:int&amp;, param:int&amp;<br>in func2, T:int, param:int&amp;&amp;<br>in func1, T:int, param:int&amp;&amp;<br>in func2, T:int, param:int&amp;&amp;<br></code></pre></td></tr></table></figure>
<p>为什么呢？因为你把一个原本是左值引用的param强制转成了右值引用向下传递！可以说是按下葫芦浮起瓢。可是这种需求在我们日常开发中很常见啊，就真的没办法兼容吗？不，成年人的世界从来都是：我全都要~</p>
<p>我们采用标准库中的<code>std::forward</code>试一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in func1, T:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;T&gt;() &lt;&lt; <span class="hljs-string">&quot;, param:&quot;</span> &lt;&lt; <span class="hljs-built_in">type_name</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;() &lt;&lt; endl;<br>    <span class="hljs-built_in">func2</span>(forward&lt;T&gt;(param));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">in func1, T:int&amp;, param:int&amp;<br>in func2, T:int&amp;, param:int&amp;<br>in func1, T:int, param:int&amp;&amp;<br>in func2, T:int, param:int&amp;&amp;<br></code></pre></td></tr></table></figure>
<p>可以发现确实达成了我们想要的结果，而这就是C++中所谓的完美转发(Perfect
Forwarding)。那么问题来了，<code>std::forward</code>只不过是标准库中的函数，既不是什么语法糖，也不是什么黑科技，它是怎么做到完美转发的呢？</p>
<p>实际上<code>std::forward</code>并没有做什么神奇的操作，它背后所依赖的原理就在于：我们需要区分左值引用和右值引用，而这一信息其实通过param是可以知晓的，param要么是一个左值引用、要么是一个右值引用，而对于这两种情况，我们需要一种if-else的逻辑来分别处理，对于前者来说，我们直接传递下去即可；而对于后者来说，渗透传递时我们要做一次<code>std::move</code>来把它强制转成右值引用。</p>
<p>另一方面，<code>std::forward</code>是一个函数模板，我们传入了<code>param</code>作为参数，而<code>param</code>携带了引用类型的信息，所以只需要编写重载函数，分别处理左值引用和右值引用的不同<code>param</code>即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp; param)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp;&amp; param)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>remove_reference_t</code>是标准库中的一种type
trait，可以洗掉类型<code>T</code>的引用修饰，这里是为了先确保拿到一个纯净类型，然后再分别施加左值引用或者是右值引用的修饰，注意，对于后者而言<code>remove_reference_t&lt;T&gt;&amp;&amp;</code>不是万能引用，而是一个彻彻底底的右值引用。于是，当我们向<code>std::forward</code>传递一个左值时，会匹配到第一个函数模板，此时<code>T</code>是左值引用，因此返回的类型根据引用折叠规则已然是一个左值引用；而当传递右值时，则会匹配到第二个函数模板，此时<code>T</code>不是引用类型，但返回的类型由于<code>static_cast&lt;T&amp;&amp;&gt;</code>将<code>T</code>强制转成了其右值引用类型。</p>
<p>实际上上面的代码与各大编译器厂商实现的标准库<code>std::forward</code>如出一辙，只是标准库中的代码有更多的诸如constexpr、noexcept等杂七杂八的修饰。</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/template_argument_deduction">Template
argument deduction</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/">Effective
Modern C++</a></li>
<li><a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/reference">Reference
declaration</a></li>
<li><a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/auto">Placeholder type
specifiers</a></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="category-chain-item">编程语言</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/cpp/" class="print-no-link">#cpp</a>
      
        <a href="/tags/cpp-templates/" class="print-no-link">#cpp-templates</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++模板从入门到劝退(2)——型别推导、万能引用与完美转发</div>
      <div>https://r00tk1ts.github.io/2022/06/07/C++模板从入门到劝退(2)——型别推导、万能引用与完美转发/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>r00tk1t</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年6月7日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/13/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(0)%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/" title="格物致知(0)——系统漫游">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">格物致知(0)——系统漫游</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/04/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(1)%E2%80%94%E2%80%94%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" title="C++模板从入门到劝退(1)——右值引用与移动语义">
                        <span class="hidden-mobile">C++模板从入门到劝退(1)——右值引用与移动语义</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
