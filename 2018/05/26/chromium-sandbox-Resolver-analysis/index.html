

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="r00tk1t">
  <meta name="keywords" content="">
  
    <meta name="description" content="本篇是sandbox源码剖析的第十一篇，承接了上一篇Interception的分析。Resolver是负责操纵Interceptions的相关模块。阅读本篇前，请先阅读前四篇及第十篇。 想要流程的阅读本系列你需要以下几个条件： 1. 较高水平的C++编码能力（至少通读C++ Primer 5th，刷过课后题，有一定编码量）。 2. 熟悉Windows API编程，尤其是安全相关的内容。 3. 对二">
<meta property="og:type" content="article">
<meta property="og:title" content="Chromium-sandbox-Resolver-analysis">
<meta property="og:url" content="https://r00tk1ts.github.io/2018/05/26/chromium-sandbox-Resolver-analysis/index.html">
<meta property="og:site_name" content="玉涵的技能书">
<meta property="og:description" content="本篇是sandbox源码剖析的第十一篇，承接了上一篇Interception的分析。Resolver是负责操纵Interceptions的相关模块。阅读本篇前，请先阅读前四篇及第十篇。 想要流程的阅读本系列你需要以下几个条件： 1. 较高水平的C++编码能力（至少通读C++ Primer 5th，刷过课后题，有一定编码量）。 2. 熟悉Windows API编程，尤其是安全相关的内容。 3. 对二">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://r00tk1ts.github.io/images/internal_thunk.png">
<meta property="article:published_time" content="2018-05-26T02:27:11.000Z">
<meta property="article:modified_time" content="2024-04-22T03:34:00.166Z">
<meta property="article:author" content="r00tk1t">
<meta property="article:tag" content="chromium">
<meta property="article:tag" content="chromium-sandbox">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://r00tk1ts.github.io/images/internal_thunk.png">
  
  
  
  <title>Chromium-sandbox-Resolver-analysis - 玉涵的技能书</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"r00tk1ts.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>玉涵的技能书</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/doc/">
                <i class="iconfont icon-books"></i>
                <span>藏经阁</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Chromium-sandbox-Resolver-analysis"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2018-05-26 10:27" pubdate>
          2018年5月26日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          56k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          466 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Chromium-sandbox-Resolver-analysis</h1>
            
            
              <div class="markdown-body">
                
                <p>本篇是sandbox源码剖析的第十一篇，承接了上一篇Interception的分析。Resolver是负责操纵Interceptions的相关模块。阅读本篇前，请先阅读前四篇及第十篇。</p>
<p>想要流程的阅读本系列你需要以下几个条件： 1.
较高水平的C++编码能力（至少通读C++ Primer
5th，刷过课后题，有一定编码量）。 2. 熟悉Windows
API编程，尤其是安全相关的内容。 3.
对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p>
<span id="more"></span>
<h1
id="chromium-sandbox-resolver-analysis">chromium-sandbox-Resolver-analysis</h1>
<p>本节分析负责执行Interceptions的相关类。</p>
<p>不跟你多BB，直接从上一节的疑问看起。也就是<code>ResolverThunk</code>类。</p>
<h2 id="resolverthunk"><code>ResolverThunk</code></h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A resolver is the object in charge of performing the actual interception of</span><br><span class="hljs-comment">// a function. There should be a concrete implementation of a resolver roughly</span><br><span class="hljs-comment">// per type of interception.</span><br><span class="hljs-comment">// resolver负责处理某个函数具体的拦截，每种类型的interception都应该有一个具体的resolver对象</span><br><span class="hljs-comment">// 这也就是上一节看到的，resolver对应每个的3个类型都有着一个派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResolverThunk</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ResolverThunk</span>() &#123;&#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ResolverThunk</span>() &#123;&#125;<br><br>  <span class="hljs-comment">// Performs the actual interception of a function.</span><br>  <span class="hljs-comment">// target_name is an exported function from the module loaded at</span><br>  <span class="hljs-comment">// target_module, and must be replaced by interceptor_name, exported from</span><br>  <span class="hljs-comment">// interceptor_module. interceptor_entry_point can be provided instead of</span><br>  <span class="hljs-comment">// interceptor_name / interceptor_module.</span><br>  <span class="hljs-comment">// thunk_storage must point to a buffer on the child&#x27;s address space, to hold</span><br>  <span class="hljs-comment">// the patch thunk, and related data. If provided, storage_used will receive</span><br>  <span class="hljs-comment">// the number of bytes used from thunk_storage.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Example: (without error checking)</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// size_t size = resolver.GetThunkSize();</span><br>  <span class="hljs-comment">// char* buffer = ::VirtualAllocEx(child_process, nullptr, size,</span><br>  <span class="hljs-comment">//                                 MEM_COMMIT, PAGE_READWRITE);</span><br>  <span class="hljs-comment">// resolver.Setup(ntdll_module, nullptr, L&quot;NtCreateFile&quot;, nullptr,</span><br>  <span class="hljs-comment">//                &amp;MyReplacementFunction, buffer, size, nullptr);</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// In general, the idea is to allocate a single big buffer for all</span><br>  <span class="hljs-comment">// interceptions on the same dll, and call Setup n times.</span><br>  <span class="hljs-comment">// WARNING: This means that any data member that is specific to a single</span><br>  <span class="hljs-comment">// interception must be reset within this method.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> NTSTATUS <span class="hljs-title">Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,<span class="hljs-comment">//函数所在dll</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,<span class="hljs-comment">//hook函数所在dll</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,<span class="hljs-comment">//original函数名称</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,<span class="hljs-comment">//hook函数名称</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,<span class="hljs-comment">//hook入口地址</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">void</span>* thunk_storage,<span class="hljs-comment">//存储thunk的buffer</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">size_t</span> storage_bytes,<span class="hljs-comment">//buffer的大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">size_t</span>* storage_used)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 下面两个函数用于确定hook和original函数的地址</span><br>  <span class="hljs-comment">// Gets the address of function_name inside module (main exe).</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> NTSTATUS <span class="hljs-title">ResolveInterceptor</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">void</span>** address)</span></span>;<br><br>  <span class="hljs-comment">// Gets the address of an exported function_name inside module.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> NTSTATUS <span class="hljs-title">ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">void</span>** address)</span></span>;<br><br>  <span class="hljs-comment">// Gets the required buffer size for this type of thunk.</span><br>  <span class="hljs-comment">// 计算该thunk需要的buffer大小</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">size_t</span> <span class="hljs-title">GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// Performs basic initialization on behalf of a concrete instance of a</span><br>  <span class="hljs-comment">// resolver. That is, parameter validation and resolution of the target</span><br>  <span class="hljs-comment">// and the interceptor into the member variables.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// target_name is an exported function from the module loaded at</span><br>  <span class="hljs-comment">// target_module, and must be replaced by interceptor_name, exported from</span><br>  <span class="hljs-comment">// interceptor_module. interceptor_entry_point can be provided instead of</span><br>  <span class="hljs-comment">// interceptor_name / interceptor_module.</span><br>  <span class="hljs-comment">// thunk_storage must point to a buffer on the child&#x27;s address space, to hold</span><br>  <span class="hljs-comment">// the patch thunk, and related data.</span><br>  <span class="hljs-comment">// 常规套路init</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> NTSTATUS <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">size_t</span> storage_bytes)</span></span>;<br><br>  <span class="hljs-comment">// Gets the required buffer size for the internal part of the thunk.</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetInternalThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Initializes the internal part of the thunk.</span><br>  <span class="hljs-comment">// interceptor is the function to be called instead of original_function.</span><br>  <span class="hljs-comment">// 调用此接口来用interceptor替换original的调用</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetInternalThunk</span><span class="hljs-params">(<span class="hljs-type">void</span>* storage, <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> <span class="hljs-type">void</span>* original_function, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor)</span></span>;<br><br>  <span class="hljs-comment">// Holds the resolved interception target.</span><br>  <span class="hljs-type">void</span>* target_;	<span class="hljs-comment">//这个对应original function地址</span><br>  <span class="hljs-comment">// Holds the resolved interception interceptor.</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_;	<span class="hljs-comment">//对应hook函数地址</span><br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(ResolverThunk);<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="init"><code>Init</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">ResolverThunk::Init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">size_t</span> storage_bytes)</span> </span>&#123;<br>  <span class="hljs-comment">// 传入的这些值必须得有效</span><br>  <span class="hljs-keyword">if</span> (!thunk_storage || <span class="hljs-number">0</span> == storage_bytes || !target_module || !target_name)<br>    <span class="hljs-keyword">return</span> STATUS_INVALID_PARAMETER;<br><br>  <span class="hljs-keyword">if</span> (storage_bytes &lt; <span class="hljs-built_in">GetThunkSize</span>())<br>    <span class="hljs-keyword">return</span> STATUS_BUFFER_TOO_SMALL;<br><br>  NTSTATUS ret = STATUS_SUCCESS;<br>  <span class="hljs-comment">// InterceptionManager中看到的两个Add方法，其中一个写入的是interceptor_entry_point，没有interceptor_name。</span><br>  <span class="hljs-comment">// 这种情况刚刚好，我们要的就是地址（毕竟不是非要用已知的函数来hook另一个函数，大可以diy）</span><br>  <span class="hljs-comment">// 而另一个Add传入的是interceptor_name，此时也必然有interceptor_module。</span><br>  <span class="hljs-comment">// 这时用interceptor_module和interceptor_name解析出interceptor_entry_point</span><br>  <span class="hljs-keyword">if</span> (!interceptor_entry_point) &#123;<br>    ret = <span class="hljs-built_in">ResolveInterceptor</span>(interceptor_module, interceptor_name,<br>                             &amp;interceptor_entry_point);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>      <span class="hljs-keyword">return</span> ret;<br>  &#125;<br><br>  <span class="hljs-comment">// 解析出original函数的地址</span><br>  <span class="hljs-comment">// original函数地址给到target_成员</span><br>  <span class="hljs-comment">// interceptor地址给到interceptor_成员</span><br>  ret = <span class="hljs-built_in">ResolveTarget</span>(target_module, target_name, &amp;target_);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  interceptor_ = interceptor_entry_point;<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>展开看看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">ResolverThunk::ResolveInterceptor</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> <span class="hljs-type">void</span>** address)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_NT</span>(address);<br>  <span class="hljs-keyword">if</span> (!interceptor_module)<br>    <span class="hljs-keyword">return</span> STATUS_INVALID_PARAMETER;<br><br>  <span class="hljs-comment">// 基础代码中对PE文件结构的封装</span><br>  base::<span class="hljs-function">win::PEImage <span class="hljs-title">pe</span><span class="hljs-params">(interceptor_module)</span></span>;<br>  <span class="hljs-comment">// 验证是否是有效PE</span><br>  <span class="hljs-keyword">if</span> (!pe.<span class="hljs-built_in">VerifyMagic</span>())<br>    <span class="hljs-keyword">return</span> STATUS_INVALID_IMAGE_FORMAT;<br><br>  <span class="hljs-comment">// 获取interceptor_name的地址</span><br>  *address = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(pe.<span class="hljs-built_in">GetProcAddress</span>(interceptor_name));<br><br>  <span class="hljs-keyword">if</span> (!(*address))<br>    <span class="hljs-keyword">return</span> STATUS_PROCEDURE_NOT_FOUND;<br><br>  <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br><br><span class="hljs-function">NTSTATUS <span class="hljs-title">ResolverThunk::ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">void</span>** address)</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>** casted = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>**&gt;(address);<br>  <span class="hljs-keyword">return</span> ResolverThunk::<span class="hljs-built_in">ResolveInterceptor</span>(<span class="hljs-keyword">module</span>, function_name, casted);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>可以看到基类的两个Resolve方法实际上都是<code>PEImage</code>中<code>GetProcAddress</code>。</p>
<h3 id="x86-internalthunk">x86: <code>InternalThunk</code></h3>
<p>再继续分析前，我们需要看一些基础设施，防止后续分析时一脸懵逼。</p>
<p>在resolver_32.cc中有一个非常漂亮的内联汇编payload：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push, 1)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InternalThunk</span> &#123;<br>  <span class="hljs-comment">// This struct contains roughly the following code:</span><br>  <span class="hljs-comment">// sub esp, 8                             // Create working space</span><br>  <span class="hljs-comment">// push edx                               // Save register</span><br>  <span class="hljs-comment">// mov edx, [esp + 0xc]                   // Get return adddress</span><br>  <span class="hljs-comment">// mov [esp + 8], edx                     // Store return address</span><br>  <span class="hljs-comment">// mov dword ptr [esp + 0xc], 0x7c401200  // Store extra argument</span><br>  <span class="hljs-comment">// mov dword ptr [esp + 4], 0x40010203    // Store address to jump to</span><br>  <span class="hljs-comment">// pop edx                                // Restore register</span><br>  <span class="hljs-comment">// ret                                    // Jump to interceptor</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// This code only modifies esp and eip so it must work with to normal calling</span><br>  <span class="hljs-comment">// convention. It is assembled as:</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// 00 83ec08           sub     esp,8</span><br>  <span class="hljs-comment">// 03 52               push    edx</span><br>  <span class="hljs-comment">// 04 8b54240c         mov     edx,dword ptr [esp + 0Ch]</span><br>  <span class="hljs-comment">// 08 89542408         mov     dword ptr [esp + 8], edx</span><br>  <span class="hljs-comment">// 0c c744240c0012407c mov     dword ptr [esp + 0Ch], 7C401200h</span><br>  <span class="hljs-comment">// 14 c744240403020140 mov     dword ptr [esp + 4], 40010203h</span><br>  <span class="hljs-comment">// 1c 5a               pop     edx</span><br>  <span class="hljs-comment">// 1d c3               ret</span><br>  <span class="hljs-built_in">InternalThunk</span>() &#123;<br>    opcodes_1 = <span class="hljs-number">0x5208ec83</span>;<br>    opcodes_2 = <span class="hljs-number">0x0c24548b</span>;<br>    opcodes_3 = <span class="hljs-number">0x08245489</span>;<br>    opcodes_4 = <span class="hljs-number">0x0c2444c7</span>; <br>    opcodes_5 = <span class="hljs-number">0x042444c7</span>;<br>    opcodes_6 = <span class="hljs-number">0xc35a</span>;<br>    extra_argument = <span class="hljs-number">0</span>;<br>    interceptor_function = <span class="hljs-number">0</span>;<br>  &#125;;<br>  ULONG opcodes_1;  <span class="hljs-comment">// = 0x5208ec83</span><br>  ULONG opcodes_2;  <span class="hljs-comment">// = 0x0c24548b</span><br>  ULONG opcodes_3;  <span class="hljs-comment">// = 0x08245489</span><br>  ULONG opcodes_4;  <span class="hljs-comment">// = 0x0c2444c7</span><br>  ULONG extra_argument;<br>  ULONG opcodes_5;  <span class="hljs-comment">// = 0x042444c7</span><br>  ULONG interceptor_function;<br>  USHORT opcodes_6;  <span class="hljs-comment">// = 0xc35a</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(pop)</span><br></code></pre></td></tr></table></figure>
<p>关于它的作用，一图胜千言：</p>
<p><img src="/images/internal_thunk.png" srcset="/img/loading.gif" lazyload /></p>
<p>通过这一thunk，就实现了先调用interceptor，interceptor返回后再回到ret
addr，interceptor调用期间，多了一个参数，这个参数实际上就是original
function。</p>
<p><code>extra_argument</code>和<code>interceptor_function</code>是外部传入的，在构造<code>InternalThunk</code>对象时，填充即可。此时<code>InternalThunk</code>的payload就正确了。典型的把Data看成Code的范例。</p>
<p><code>InternalThunk</code>对象在<code>SetInternalThunk</code>中使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ResolverThunk::SetInternalThunk</span><span class="hljs-params">(<span class="hljs-type">void</span>* storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* original_function,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor)</span> </span>&#123;<br>  <span class="hljs-comment">// 存储thunk的空间是否放得下InternalThunk</span><br>  <span class="hljs-keyword">if</span> (storage_bytes &lt; <span class="hljs-built_in">sizeof</span>(InternalThunk))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 在thunk buffer上部署InternalThunk</span><br>  InternalThunk* thunk = <span class="hljs-built_in">new</span> (storage) InternalThunk;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(push)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(disable : 4311)</span><br>  <span class="hljs-comment">// These casts generate warnings because they are 32 bit specific.</span><br>  <span class="hljs-comment">// 这两个一填充，就达成了interceptor(original_function, xxx) -&gt; ret addr的效果</span><br>  <span class="hljs-comment">// 那么关键的就在于interceptor内部要如何处理这个extra参数了</span><br>  thunk-&gt;interceptor_function = <span class="hljs-built_in">reinterpret_cast</span>&lt;ULONG&gt;(interceptor);<br>  thunk-&gt;extra_argument = <span class="hljs-built_in">reinterpret_cast</span>&lt;ULONG&gt;(original_function);<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(pop)</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其他接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ResolverThunk::GetInternalThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(InternalThunk);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="x64-internalthunk">x64: <code>InternalThunk</code></h3>
<p>x64因为全盘使用的<code>g_originals</code>而非将original
function地址作为hook的第一个参数，所以要简单得多。只需要把interceptor地址传入即可，thunk所做的仅仅是jmp到该地址，至于interceptor
function如何处理original function，那就是interceptor的事儿了。</p>
<p>这里的thunk没有动调用栈帧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InternalThunk</span> &#123;<br>  <span class="hljs-comment">// This struct contains roughly the following code:</span><br>  <span class="hljs-comment">// 01 48b8f0debc9a78563412  mov   rax,123456789ABCDEF0h</span><br>  <span class="hljs-comment">// ff e0                    jmp   rax</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The code modifies rax, but that&#x27;s fine for x64 ABI.</span><br><br>  <span class="hljs-built_in">InternalThunk</span>() &#123;<br>    mov_rax = kMovRax;<br>    jmp_rax = kJmpRax;<br>    interceptor_function = <span class="hljs-number">0</span>;<br>  &#125;;<br>  USHORT mov_rax;  <span class="hljs-comment">// = 48 B8</span><br>  ULONG_PTR interceptor_function;<br>  USHORT jmp_rax;  <span class="hljs-comment">// = ff e0</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>与x86接口一致：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ResolverThunk::SetInternalThunk</span><span class="hljs-params">(<span class="hljs-type">void</span>* storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* original_function,	<span class="hljs-comment">// 没有用到</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (storage_bytes &lt; <span class="hljs-built_in">sizeof</span>(InternalThunk))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 在thunk buffer处部署了payload，关联interceptor</span><br>  InternalThunk* thunk = <span class="hljs-built_in">new</span> (storage) InternalThunk;<br>  thunk-&gt;interceptor_function = <span class="hljs-built_in">reinterpret_cast</span>&lt;ULONG_PTR&gt;(interceptor);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ResolverThunk::GetInternalThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(InternalThunk);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有趣的是x64的<code>ResolveTarget</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">ResolverThunk::ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">void</span>** address)</span> </span>&#123;<br>  <span class="hljs-comment">// We don&#x27;t support sidestep &amp; co.</span><br>  <span class="hljs-comment">// 看起来基类的这个函数会被sidestep类型的interception用到，而x64不支持这种类型，所以也就不实现</span><br>  <span class="hljs-comment">// 那么其他类型呢，x64总有Eat类型吧。可能Eat类型有自己的ResolveTarget override。</span><br>  <span class="hljs-keyword">return</span> STATUS_NOT_IMPLEMENTED;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到此，基类相关的内容都已经过了一遍，想要把Interception和Resolver挂钩，还需要逐个分析各种类型的派生类。</p>
<h2 id="eatresolverthunk"><code>EatResolverThunk</code></h2>
<p>此前我们在<code>InterceptionAgent::PatchDll</code>中看到了resolver的使用，根据前面的分析，我们知道<code>PatchDll</code>是在target进程加载感兴趣dll的时候执行的，执行期间，会根据broker传过来的<code>DllPatchInfo</code>，对该dll的所有感兴趣的function进行处理，而此时借助的就是对应类型的resolver来处理，通过Setup方法传入了相关的<code>FunctionInfo</code>信息和thunk
data在dll上的buffer（实际上就是<code>base_address</code>）。</p>
<p>待加载dll的<code>base_address</code>处布置了一个<code>DllInterceptionData</code>对象，它内部的<code>ThunkData</code>数组即对应所有感兴趣的函数的thunk
data，而data的实装应该是由<code>xxxResolver::Setup</code>来完成的。</p>
<p>我们暂且假定target要加载一个感兴趣的dll，这个dll中的感兴趣的函数既有eat类型，也有sidestep类型（target端不会有service
call类型，这个在broker中处理）。</p>
<p>我们先分析Eat类型的执行流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is the concrete resolver used to perform exports table interceptions.</span><br><span class="hljs-comment">// Eat类型是指对导出表函数的拦截？看来此前的猜想有误。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EatResolverThunk</span> : <span class="hljs-keyword">public</span> ResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">EatResolverThunk</span>() : <span class="hljs-built_in">eat_entry_</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>  ~<span class="hljs-built_in">EatResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br>  <span class="hljs-comment">// Implementation of Resolver::Setup.</span><br>  <span class="hljs-comment">// 纯虚函数的override，父类显然不清楚子类是如何把控thunk和相关info的</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span>* storage_used)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// Implementation of Resolver::ResolveTarget.</span><br>  <span class="hljs-comment">// eat类型需要这个函数，这里还要override父类函数</span><br>  <span class="hljs-comment">// 我们已经知道了父类的这个函数实际上是间接调用ResolveInterceptor</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">void</span>** address)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// Implementation of Resolver::GetThunkSize.</span><br>  <span class="hljs-comment">// 父类的这个函数是纯虚函数，这说明不同类型的interception，其thunk尺寸的计算各不相同</span><br>  <span class="hljs-comment">// 父类本身是不可能知道派生类对thunk的设计需求的，同Setup</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// The entry to patch.</span><br>  DWORD* eat_entry_;	<span class="hljs-comment">// patch入口</span><br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(EatResolverThunk);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><code>eat_entry_</code>是唯一的一个扩展成员，我们在下面要盯住它的使用。</p>
<h3 id="setup"><code>Setup</code></h3>
<p>看看最为关键的Setup：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">EatResolverThunk::Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">size_t</span>* storage_used)</span> </span>&#123;<br>  <span class="hljs-comment">// 先进行Init，调用父类的方法</span><br>  <span class="hljs-comment">// 回忆一下父类的流程，先是判断ThunkData这个64字节的坑够不够放下thunk data</span><br>  <span class="hljs-comment">// 对于Eat类型来说，它所需要的thunk size，对于x86就是GetInternalThunkSize()</span><br>  <span class="hljs-comment">// x64要乘2（尽管乘2也比x86小），为什么需要两次jmp呢？我们继续往下看。</span><br>  <span class="hljs-comment">// 而InternalThunk我们已经很清楚了，就是那段payload，它作为eat类型的thunk data</span><br>  <span class="hljs-comment">// 在Init内部，对Eat类型来说，ThunkData[i]这个坑位显然放得下，于是Init会继续解析出</span><br>  <span class="hljs-comment">// Interceptor的地址（如果传入的是名称的话）和Target的地址</span><br>  <span class="hljs-comment">// Interceptor没什么好说的，Eat类型的ResolveTarget做了override，使用的是导出表的那套机制</span><br>  NTSTATUS ret =<br>      <span class="hljs-built_in">Init</span>(target_module, interceptor_module, target_name, interceptor_name,<br>           interceptor_entry_point, thunk_storage, storage_bytes);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-keyword">if</span> (!eat_entry_)<br>    <span class="hljs-keyword">return</span> STATUS_INVALID_PARAMETER;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64)</span><br>  <span class="hljs-comment">// We have two thunks, in order: the return path and the forward path.</span><br>  <span class="hljs-comment">// x64有两个thunk，一来一回</span><br>  <span class="hljs-comment">// x64用不到第三个参数，在x86的设计中它表示original地址</span><br>  <span class="hljs-comment">// 这里在ThunkData[i]处先放置了第一个跳转到original地址的thunk data</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetInternalThunk</span>(thunk_storage, storage_bytes, <span class="hljs-literal">nullptr</span>, target_))<br>    <span class="hljs-keyword">return</span> STATUS_BUFFER_TOO_SMALL;<br><br>  <span class="hljs-comment">// thunk_storage向后挪动，指向需要部署第二个InternalThunk的位置</span><br>  <span class="hljs-type">size_t</span> thunk_bytes = <span class="hljs-built_in">GetInternalThunkSize</span>();<br>  storage_bytes -= thunk_bytes;<br>  thunk_storage = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(thunk_storage) + thunk_bytes;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">// 对x86来说，这里实现了interceptor_(target_, xxx)替换target(xxx)的效果</span><br>  <span class="hljs-comment">// 当外部call ThunkData[i]位置的时候，通过执行InternalThunk的指令，最后会调用interceptor_(target_, xxx)</span><br>  <span class="hljs-comment">// 当然这种机制依赖两个外部条件：</span><br>  <span class="hljs-comment">// 1. interceptor要外部提供，利用上origin参数</span><br>  <span class="hljs-comment">// 2. 在调用一个函数时，不直接call target而是call ThunkData[i]</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// 对x64来说，这里相当于第二次设置，第三个参数是没意义的，仅仅是把jmp interceptor_放在了</span><br>  <span class="hljs-comment">// 第一个InternalThunk(jmp original)的正后方</span><br>  <span class="hljs-comment">// 这样看来x64的thunk比较奇怪，应该是call ThunkData[i]+sizeof(InternalThunk)去调用</span><br>  <span class="hljs-comment">// interceptor，interceptor内部再去call ThunkData[i]来调用original</span><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetInternalThunk</span>(thunk_storage, storage_bytes, target_, interceptor_))<br>    <span class="hljs-keyword">return</span> STATUS_BUFFER_TOO_SMALL;<br><br>  AutoProtectMemory memory;<br>  ret = memory.<span class="hljs-built_in">ChangeProtection</span>(eat_entry_, <span class="hljs-built_in">sizeof</span>(DWORD), PAGE_READWRITE);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// Perform the patch.</span><br>  <span class="hljs-comment">// 看到这里就明白了为什么x64要把jmp original放在前面</span><br>  <span class="hljs-comment">// 无论是x64还是x86，此时eat_entry是original函数的导出表地址，我们只需要把这个导出表地址</span><br>  <span class="hljs-comment">// 替换成Interceptor的地址就行了。</span><br>  <span class="hljs-comment">// 这里就解决了上面的一个外部条件的达成：调用dll导出表函数时，此后不会call target，而是</span><br>  <span class="hljs-comment">// call ThunkData[i]，此外之所以要减去基地址是因为导出表存的是RVA</span><br>  *eat_entry_ = <span class="hljs-built_in">static_cast</span>&lt;DWORD&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(thunk_storage)) -<br>                <span class="hljs-built_in">static_cast</span>&lt;DWORD&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(target_module));<br><br>  <span class="hljs-comment">// OUT型参数回置使用的thunk data大小</span><br>  <span class="hljs-keyword">if</span> (storage_used)<br>    *storage_used = <span class="hljs-built_in">GetThunkSize</span>();<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="resolvetarget"><code>ResolveTarget</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">EatResolverThunk::ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         <span class="hljs-type">void</span>** address)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_NT</span>(address);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">module</span>)<br>    <span class="hljs-keyword">return</span> STATUS_INVALID_PARAMETER;<br><br>  base::<span class="hljs-function">win::PEImage <span class="hljs-title">pe</span><span class="hljs-params">(<span class="hljs-keyword">module</span>)</span></span>;<br>  <span class="hljs-keyword">if</span> (!pe.<span class="hljs-built_in">VerifyMagic</span>())<br>    <span class="hljs-keyword">return</span> STATUS_INVALID_IMAGE_FORMAT;<br><br>  <span class="hljs-comment">// 直接从导出表拿了，所以eat_entry是导出表中的地址，是个RVA</span><br>  <span class="hljs-comment">// 而该函数是在Init时调用的，这说明eat_entry_已经有值了</span><br>  eat_entry_ = pe.<span class="hljs-built_in">GetExportEntry</span>(function_name);<br><br>  <span class="hljs-keyword">if</span> (!eat_entry_)<br>    <span class="hljs-keyword">return</span> STATUS_PROCEDURE_NOT_FOUND;<br><br>  <span class="hljs-comment">// RVA到addr，给回address，实际上address就是original函数地址</span><br>  *address = pe.<span class="hljs-built_in">RVAToAddr</span>(*eat_entry_);<br><br>  <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>所以，我们此前对Eat类型的猜想是错误的。Eat类型实际上是用于处理Dll导出表函数的resolver，它的做法是用<code>InternalThunk</code>来部署<code>interceptor</code>，并且把它的地址RVA替换导出表的函数地址，以实现interception。</strong></p>
<h2 id="sidestepresolverthunk"><code>SidestepResolverThunk</code></h2>
<p>在target中，x86还会用到两种Resolver，分别是<code>SidestepResolverThunk</code>和<code>SmartSidestepResolverThunk</code>。</p>
<p>先看一下头：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is the concrete resolver used to perform sidestep interceptions.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SidestepResolverThunk</span> : <span class="hljs-keyword">public</span> ResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">SidestepResolverThunk</span>() &#123;&#125;<br>  ~<span class="hljs-built_in">SidestepResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br>  <span class="hljs-comment">// Setup和GetThunkSize作为两大核心接口，是子类必须override的纯虚函数</span><br>  <span class="hljs-comment">// Implementation of Resolver::Setup.</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span>* storage_used)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// Implementation of Resolver::GetThunkSize.</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(SidestepResolverThunk);<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="getthunksize"><code>GetThunkSize</code></h3>
<p>在分析之前，我们还是得先看看sidestep使用的Thunk是什么。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">SidestepResolverThunk::GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-comment">// 除了InternalThunk以外，还有一个额外的kSizeOfSidestepStub，这个值是32</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetInternalThunkSize</span>() + kSizeOfSidestepStub;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么额外的32个字节是用来干什么的呢？根据注释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Maximum size of the preamble stub. We overwrite at least the first 5</span><br><span class="hljs-comment">// bytes of the function. Considering the worst case scenario, we need 4</span><br><span class="hljs-comment">// bytes + the max instruction size + 5 more bytes for our jump back to</span><br><span class="hljs-comment">// the original code. With that in mind, 32 is a good number :)</span><br><span class="hljs-comment">// 所以看起来sidestep是inline hook，它会覆盖original头至少5个字节。</span><br><span class="hljs-comment">// 最坏的情况下，我们需要4个字节 + 最大指令长度 + 用于跳回到original代码的5个额外字节</span><br><span class="hljs-comment">// 为了对齐就用了32.</span><br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kMaxPreambleStubSize = <span class="hljs-number">32</span>;<br></code></pre></td></tr></table></figure>
<h3 id="setup-1"><code>Setup</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">SidestepResolverThunk::Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">size_t</span>* storage_used)</span> </span>&#123;<br>  <span class="hljs-comment">// 常规init，注意sidestep类型没有自己override ResolveTarget，使用的是父类的函数</span><br>  <span class="hljs-comment">// 而这个函数和ResolveInterception是一样的，通过GetProcAddress取得</span><br>  NTSTATUS ret =<br>      <span class="hljs-built_in">Init</span>(target_module, interceptor_module, target_name, interceptor_name,<br>           interceptor_entry_point, thunk_storage, storage_bytes);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// sidestep类型的resolver，把传入的ThunkData[i]存储空间看成SidestepThunk</span><br>  <span class="hljs-comment">// 为什么要设计个类型呢？从GetThunkSize中我们就可以看到，sidestep的ThunkData由两部分构成</span><br>  <span class="hljs-comment">// 前32个字节是inline stub，ThunkData[i]的32个字节之后存储InternalThunk</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  	struct SidestepThunk &#123;</span><br><span class="hljs-comment">      char sidestep[kSizeOfSidestepStub];  // Storage for the sidestep stub.</span><br><span class="hljs-comment">      int internal_thunk;  // Dummy member to the beginning of the internal thunk.</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">  */</span><br>  SidestepThunk* thunk = <span class="hljs-built_in">reinterpret_cast</span>&lt;SidestepThunk*&gt;(thunk_storage);<br><br>  <span class="hljs-type">size_t</span> internal_bytes = storage_bytes - kSizeOfSidestepStub;<br>  <span class="hljs-comment">// 别担心，SetInternalThunk内部会检查剩余的空间够不够存放InternalThunk，这里64-32=32是够放的</span><br>  <span class="hljs-comment">// 调用后，32个字节之后的InternalThunk就安排好了</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetInternalThunk</span>(&amp;thunk-&gt;internal_thunk, internal_bytes, thunk_storage,<br>                        interceptor_))<br>    <span class="hljs-keyword">return</span> STATUS_BUFFER_TOO_SMALL;<br><br>  AutoProtectMemory memory;<br>  ret = memory.<span class="hljs-built_in">ChangeProtection</span>(target_, kSizeOfSidestepStub, PAGE_READWRITE);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// 前面32个字节的处理借助了PreamblePatcher这个对象的Patch方法</span><br>  <span class="hljs-comment">// 我们下面展开来看他的用途</span><br>  sidestep::SideStepError rv = sidestep::PreamblePatcher::<span class="hljs-built_in">Patch</span>(<br>      target_, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;thunk-&gt;internal_thunk), thunk_storage,<br>      kSizeOfSidestepStub);<br><br>  <span class="hljs-keyword">if</span> (sidestep::SIDESTEP_INSUFFICIENT_BUFFER == rv)<br>    <span class="hljs-keyword">return</span> STATUS_BUFFER_TOO_SMALL;<br><br>  <span class="hljs-keyword">if</span> (sidestep::SIDESTEP_SUCCESS != rv)<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br><br>  <span class="hljs-keyword">if</span> (storage_used)<br>    *storage_used = <span class="hljs-built_in">GetThunkSize</span>();<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="preamblepatcher"><code>PreamblePatcher</code></h3>
<p>命名空间是<code>sidestep</code>，很明显是供sidestep
resolver自身使用的helper接口。先看一下头部定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Implements a patching mechanism that overwrites the first few bytes of</span><br><span class="hljs-comment">// a function preamble with a jump to our hook function, which is then</span><br><span class="hljs-comment">// able to call the original function via a specially-made preamble-stub</span><br><span class="hljs-comment">// that imitates the action of the original preamble.</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// inline hook的局限性与危险性说明：</span><br><span class="hljs-comment">// Note that there are a number of ways that this method of patching can</span><br><span class="hljs-comment">// fail.  The most common are:</span><br><span class="hljs-comment">//    - If there is a jump (jxx) instruction in the first 5 bytes of</span><br><span class="hljs-comment">//    the function being patched, we cannot patch it because in the</span><br><span class="hljs-comment">//    current implementation we do not know how to rewrite relative</span><br><span class="hljs-comment">//    jumps after relocating them to the preamble-stub.  Note that</span><br><span class="hljs-comment">//    if you really really need to patch a function like this, it</span><br><span class="hljs-comment">//    would be possible to add this functionality (but at some cost).</span><br><span class="hljs-comment">//    - If there is a return (ret) instruction in the first 5 bytes</span><br><span class="hljs-comment">//    we cannot patch the function because it may not be long enough</span><br><span class="hljs-comment">//    for the jmp instruction we use to inject our patch.</span><br><span class="hljs-comment">//    - If there is another thread currently executing within the bytes</span><br><span class="hljs-comment">//    that are copied to the preamble stub, it will crash in an undefined</span><br><span class="hljs-comment">//    way.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If you get any other error than the above, you&#x27;re either pointing the</span><br><span class="hljs-comment">// patcher at an invalid instruction (e.g. into the middle of a multi-</span><br><span class="hljs-comment">// byte instruction, or not at memory containing executable instructions)</span><br><span class="hljs-comment">// or, there may be a bug in the disassembler we use to find</span><br><span class="hljs-comment">// instruction boundaries.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PreamblePatcher</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Patches target_function to point to replacement_function using a provided</span><br>  <span class="hljs-comment">// preamble_stub of stub_size bytes.</span><br>  <span class="hljs-comment">// Returns An error code indicating the result of patching.</span><br>  <span class="hljs-comment">// 函数模板，其实target_function和replacement_function都设void *应该就可以</span><br>  <span class="hljs-comment">// 我没有get到为什么要设一个模板在这里，为了便于扩展？</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>  <span class="hljs-function"><span class="hljs-type">static</span> SideStepError <span class="hljs-title">Patch</span><span class="hljs-params">(T target_function,</span></span><br><span class="hljs-params"><span class="hljs-function">                             T replacement_function,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">void</span>* preamble_stub,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">size_t</span> stub_size)</span> </span>&#123;<br>    <span class="hljs-comment">// 而且这个函数不是模板，是明确的参数void *</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">RawPatchWithStub</span>(target_function, replacement_function,<br>                            <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(preamble_stub),<br>                            stub_size, <span class="hljs-literal">nullptr</span>);<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Patches a function by overwriting its first few bytes with</span><br>  <span class="hljs-comment">// a jump to a different function.  This is similar to the RawPatch</span><br>  <span class="hljs-comment">// function except that it uses the stub allocated by the caller</span><br>  <span class="hljs-comment">// instead of allocating it.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// To use this function, you first have to call VirtualProtect to make the</span><br>  <span class="hljs-comment">// target function writable at least for the duration of the call.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// target_function: A pointer to the function that should be</span><br>  <span class="hljs-comment">// patched.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// replacement_function: A pointer to the function that should</span><br>  <span class="hljs-comment">// replace the target function.  The replacement function must have</span><br>  <span class="hljs-comment">// exactly the same calling convention and parameters as the original</span><br>  <span class="hljs-comment">// function.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// preamble_stub: A pointer to a buffer where the preamble stub</span><br>  <span class="hljs-comment">// should be copied. The size of the buffer should be sufficient to</span><br>  <span class="hljs-comment">// hold the preamble bytes.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// stub_size: Size in bytes of the buffer allocated for the</span><br>  <span class="hljs-comment">// preamble_stub</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// bytes_needed: Pointer to a variable that receives the minimum</span><br>  <span class="hljs-comment">// number of bytes required for the stub.  Can be set to nullptr if you&#x27;re</span><br>  <span class="hljs-comment">// not interested.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Returns An error code indicating the result of patching.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> SideStepError <span class="hljs-title">RawPatchWithStub</span><span class="hljs-params">(<span class="hljs-type">void</span>* target_function,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* replacement_function,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* preamble_stub,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">size_t</span> stub_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">size_t</span>* bytes_needed)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>展开看看<code>RawPatchWithStub</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SideStepError <span class="hljs-title">PreamblePatcher::RawPatchWithStub</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span>* target_function,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span>* replacement_function,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* preamble_stub,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">size_t</span> stub_size,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">size_t</span>* bytes_needed)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-literal">NULL</span> == target_function) ||<br>      (<span class="hljs-literal">NULL</span> == replacement_function) ||<br>      (<span class="hljs-literal">NULL</span> == preamble_stub)) &#123;<br>    <span class="hljs-built_in">ASSERT</span>(<span class="hljs-literal">false</span>, (<span class="hljs-string">L&quot;Invalid parameters - either pTargetFunction or &quot;</span><br>                   <span class="hljs-string">L&quot;pReplacementFunction or pPreambleStub were NULL.&quot;</span>));<br>    <span class="hljs-keyword">return</span> SIDESTEP_INVALID_PARAMETER;<br>  &#125;<br><br>  <span class="hljs-comment">// TODO(V7:joi) Siggi and I just had a discussion and decided that both</span><br>  <span class="hljs-comment">// patching and unpatching are actually unsafe.  We also discussed a</span><br>  <span class="hljs-comment">// method of making it safe, which is to freeze all other threads in the</span><br>  <span class="hljs-comment">// process, check their thread context to see if their eip is currently</span><br>  <span class="hljs-comment">// inside the block of instructions we need to copy to the stub, and if so</span><br>  <span class="hljs-comment">// wait a bit and try again, then unfreeze all threads once we&#x27;ve patched.</span><br>  <span class="hljs-comment">// Not implementing this for now since we&#x27;re only using SideStep for unit</span><br>  <span class="hljs-comment">// testing, but if we ever use it for production code this is what we</span><br>  <span class="hljs-comment">// should do.</span><br>  <span class="hljs-comment">// 这个sidestep目前还没有投入到产品，所以线程的安全性处理还没做，开发者还是很谨小慎微的</span><br>  <span class="hljs-comment">// 说不定这个东西问世的时候会带来安全隐患</span><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Stoyan suggests we can write 8 or even 10 bytes atomically using</span><br>  <span class="hljs-comment">// FPU instructions, and on newer processors we could use cmpxchg8b or</span><br>  <span class="hljs-comment">// cmpxchg16b. So it might be possible to do the patching/unpatching</span><br>  <span class="hljs-comment">// atomically and avoid having to freeze other threads.  Note though, that</span><br>  <span class="hljs-comment">// doing it atomically does not help if one of the other threads happens</span><br>  <span class="hljs-comment">// to have its eip in the middle of the bytes you change while you change</span><br>  <span class="hljs-comment">// them.</span><br>  <span class="hljs-comment">// original函数地址</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* target = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(target_function);<br><br>  <span class="hljs-comment">// Let&#x27;s disassemble the preamble of the target function to see if we can</span><br>  <span class="hljs-comment">// patch, and to see how much of the preamble we need to take.  We need 5</span><br>  <span class="hljs-comment">// bytes for our jmp instruction, so let&#x27;s find the minimum number of</span><br>  <span class="hljs-comment">// instructions to get 5 bytes.</span><br>  <span class="hljs-comment">// 通过反汇编original函数来看看是否能够patch，需要patch多少个字节。</span><br>  <span class="hljs-comment">// 注意jmp指令需要5个字节</span><br>  MiniDisassembler disassembler;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> preamble_bytes = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (preamble_bytes &lt; <span class="hljs-number">5</span>) &#123;<br>    InstructionType instruction_type =<br>      disassembler.<span class="hljs-built_in">Disassemble</span>(target + preamble_bytes, &amp;preamble_bytes);<br>    <span class="hljs-keyword">if</span> (IT_JUMP == instruction_type) &#123;<br>      <span class="hljs-comment">// 如果前5个字节有jmp系列指令，是没办法hook的</span><br>      <span class="hljs-built_in">ASSERT</span>(<span class="hljs-literal">false</span>, (<span class="hljs-string">L&quot;Unable to patch because there is a jump instruction &quot;</span><br>                     <span class="hljs-string">L&quot;in the first 5 bytes.&quot;</span>));<br>      <span class="hljs-keyword">return</span> SIDESTEP_JUMP_INSTRUCTION;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (IT_RETURN == instruction_type) &#123;<br>      <span class="hljs-comment">// 如果前5个字节有ret系列指令，那么函数太短了，不够patch一个jmp</span><br>      <span class="hljs-built_in">ASSERT</span>(<span class="hljs-literal">false</span>, (<span class="hljs-string">L&quot;Unable to patch because function is too short&quot;</span>));<br>      <span class="hljs-keyword">return</span> SIDESTEP_FUNCTION_TOO_SMALL;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (IT_GENERIC != instruction_type) &#123;<br>      <span class="hljs-comment">// 这种是异端的情况，指令不认识。。。</span><br>      <span class="hljs-built_in">ASSERT</span>(<span class="hljs-literal">false</span>, (<span class="hljs-string">L&quot;Disassembler encountered unsupported instruction &quot;</span><br>                     <span class="hljs-string">L&quot;(either unused or unknown&quot;</span>));<br>      <span class="hljs-keyword">return</span> SIDESTEP_UNSUPPORTED_INSTRUCTION;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 这个作为OUT型参数返回需要用到的字节数，5表示额外的jmp指令字节数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != bytes_needed)<br>    *bytes_needed = preamble_bytes + <span class="hljs-number">5</span>;<br><br>  <span class="hljs-comment">// Inv: preamble_bytes is the number of bytes (at least 5) that we need to</span><br>  <span class="hljs-comment">// take from the preamble to have whole instructions that are 5 bytes or more</span><br>  <span class="hljs-comment">// in size total. The size of the stub required is cbPreamble + size of</span><br>  <span class="hljs-comment">// jmp (5)</span><br>  <span class="hljs-keyword">if</span> (preamble_bytes + <span class="hljs-number">5</span> &gt; stub_size) &#123;<br>    <span class="hljs-built_in">NOTREACHED_NT</span>();<br>    <span class="hljs-keyword">return</span> SIDESTEP_INSUFFICIENT_BUFFER;<br>  &#125;<br><br>  <span class="hljs-comment">// First, copy the preamble that we will overwrite.</span><br>  <span class="hljs-comment">// 把要被覆盖的首字节序列copy出来，这个RawMemcpy是逐字节copy，没有用crt</span><br>  <span class="hljs-built_in">RawMemcpy</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(preamble_stub),<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(target), preamble_bytes);<br><br>  <span class="hljs-comment">// Now, make a jmp instruction to the rest of the target function (minus the</span><br>  <span class="hljs-comment">// preamble bytes we moved into the stub) and copy it into our preamble-stub.</span><br>  <span class="hljs-comment">// find address to jump to, relative to next address after jmp instruction</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(push)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(disable:4244)</span><br>  <span class="hljs-comment">// This assignment generates a warning because it is 32 bit specific.</span><br>  <span class="hljs-comment">// 计算original剩下的指令相对preamble_stub+preamble_bytes+5的偏移</span><br>  <span class="hljs-type">int</span> relative_offset_to_target_rest<br>    = ((<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(target) + preamble_bytes) -<br>        (preamble_stub + preamble_bytes + <span class="hljs-number">5</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(pop)</span><br>  <span class="hljs-comment">// jmp (Jump near, relative, displacement relative to next instruction)</span><br>  <span class="hljs-comment">// 这里放上jmp</span><br>  preamble_stub[preamble_bytes] = ASM_JMP32REL;<br>  <span class="hljs-comment">// copy the address</span><br>  <span class="hljs-comment">// jmp后跟上4个字节的相对跳转地址，此时jmp就跳到了overwrite之后的rest code</span><br>  <span class="hljs-built_in">RawMemcpy</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(preamble_stub + preamble_bytes + <span class="hljs-number">1</span>),<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;relative_offset_to_target_rest), <span class="hljs-number">4</span>);<br><br>  <span class="hljs-comment">// Inv: preamble_stub points to assembly code that will execute the</span><br>  <span class="hljs-comment">// original function by first executing the first cbPreamble bytes of the</span><br>  <span class="hljs-comment">// preamble, then jumping to the rest of the function.</span><br><br>  <span class="hljs-comment">// Overwrite the first 5 bytes of the target function with a jump to our</span><br>  <span class="hljs-comment">// replacement function.</span><br>  <span class="hljs-comment">// (Jump near, relative, displacement relative to next instruction)</span><br>  <span class="hljs-comment">// 修改original起始地址，做出一个jmp</span><br>  target[<span class="hljs-number">0</span>] = ASM_JMP32REL;<br><br>  <span class="hljs-comment">// Find offset from instruction after jmp, to the replacement function.</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(push)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(disable:4244)</span><br>  <span class="hljs-type">int</span> offset_to_replacement_function =<br>    <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(replacement_function) -<br>    <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(target) - <span class="hljs-number">5</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(pop)</span><br>  <span class="hljs-comment">// complete the jmp instruction</span><br>  <span class="hljs-built_in">RawMemcpy</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(target + <span class="hljs-number">1</span>),<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;offset_to_replacement_function), <span class="hljs-number">4</span>);<br>  <span class="hljs-comment">// 此时original的入口就变成了jmp到InternalThunk处</span><br>  <span class="hljs-comment">// Set any remaining bytes that were moved to the preamble-stub to INT3 so</span><br>  <span class="hljs-comment">// as not to cause confusion (otherwise you might see some strange</span><br>  <span class="hljs-comment">// instructions if you look at the disassembly, or even invalid</span><br>  <span class="hljs-comment">// instructions). Also, by doing this, we will break into the debugger if</span><br>  <span class="hljs-comment">// some code calls into this portion of the code.  If this happens, it</span><br>  <span class="hljs-comment">// means that this function cannot be patched using this patcher without</span><br>  <span class="hljs-comment">// further thought.</span><br>  <span class="hljs-comment">// 如果overwrite的字节数比5要多，就用0xcc填充剩下的部分</span><br>  <span class="hljs-keyword">if</span> (preamble_bytes &gt; <span class="hljs-number">5</span>) &#123;<br>    <span class="hljs-built_in">RawMemset</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(target + <span class="hljs-number">5</span>), ASM_INT3,<br>              preamble_bytes - <span class="hljs-number">5</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Inv: The memory pointed to by target_function now points to a relative</span><br>  <span class="hljs-comment">// jump instruction that jumps over to the preamble_stub.  The preamble</span><br>  <span class="hljs-comment">// stub contains the first stub_size bytes of the original target</span><br>  <span class="hljs-comment">// function&#x27;s preamble code, followed by a relative jump back to the next</span><br>  <span class="hljs-comment">// instruction after the first cbPreamble bytes.</span><br><br>  <span class="hljs-keyword">return</span> SIDESTEP_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>至于<code>MiniDisassembler</code>就不展开分析了，起始看到这里，已经明白了这个sidestep类型的resolver是如何patch的了。实际上，就是对原始的函数进行了inline
hook，此后，当call
original时，会jmp到<code>InternalThunk</code>，而<code>InternalThunk</code>中的<code>extra_argument</code>实际上是<code>ThunkData[i]</code>前面的32个字节，也就是copy出来的<code>preamble_stub</code>+<code>jmp original_rest</code>，当<code>interceptor_</code>执行完毕后再调用original时，就会找到这里执行copy出来的original原本的首指令序列并jmp到rest部分。</p>
<p>可以看出这个sidestep实现的inline hook非常的复杂。</p>
<h2
id="smartsidestepresolverthunk"><code>SmartSidestepResolverThunk</code></h2>
<p>还有个以sidestep类型为基础的smart_sidestep类型。我们一并看了吧，找找不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is the concrete resolver used to perform smart sidestep interceptions.</span><br><span class="hljs-comment">// This means basically a sidestep interception that skips the interceptor when</span><br><span class="hljs-comment">// the caller resides on the same dll being intercepted. It is intended as</span><br><span class="hljs-comment">// a helper only, because that determination is not infallible.</span><br><span class="hljs-comment">// SidestepResolverThunk的派生类</span><br><span class="hljs-comment">// 看起来是当call的发起者与被拦截的dll是同一个时，会跳过interceptor的执行</span><br><span class="hljs-comment">// 也就是说dll本体上的调用不会触发hook</span><br><span class="hljs-comment">// 好吧，我们此前猜测的完全不对。。。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartSidestepResolverThunk</span> : <span class="hljs-keyword">public</span> SidestepResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">SmartSidestepResolverThunk</span>() &#123;&#125;<br>  ~<span class="hljs-built_in">SmartSidestepResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br>  <span class="hljs-comment">// Implementation of Resolver::Setup.</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span>* storage_used)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// Implementation of Resolver::GetThunkSize.</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Performs the actual call to the interceptor if the conditions are correct</span><br>  <span class="hljs-comment">// (as determined by IsInternalCall).</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SmartStub</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Returns true if return_address is inside the module loaded at base.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">IsInternalCall</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* base, <span class="hljs-type">void</span>* return_address)</span></span>;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(SmartSidestepResolverThunk);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>可以看出来这个类多了两个private函数用于判断caller是内部还是外部以及stub的处理。</p>
<p>先看看两个private：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SmartSidestepResolverThunk::IsInternalCall</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* base,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">void</span>* return_address)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_NT</span>(base);<br>  <span class="hljs-built_in">DCHECK_NT</span>(return_address);<br><br>  <span class="hljs-comment">// 其实很简单，找找address是否在该PE上就知道了</span><br>  base::<span class="hljs-function">win::PEImage <span class="hljs-title">pe</span><span class="hljs-params">(base)</span></span>;<br>  <span class="hljs-keyword">if</span> (pe.<span class="hljs-built_in">GetImageSectionFromAddr</span>(return_address))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// This code must basically either call the intended interceptor or skip the</span><br><span class="hljs-comment">// call and invoke instead the original function. In any case, we are saving</span><br><span class="hljs-comment">// the registers that may be trashed by our c++ code.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function is called with a first parameter inserted by us, that points</span><br><span class="hljs-comment">// to our SmartThunk. When we call the interceptor we have to replace this</span><br><span class="hljs-comment">// parameter with the one expected by that function (stored inside our</span><br><span class="hljs-comment">// structure); on the other hand, when we skip the interceptor we have to remove</span><br><span class="hljs-comment">// that extra argument before calling the original function.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// When we skip the interceptor, the transformation of the stack looks like:</span><br><span class="hljs-comment">//  On Entry:                         On Use:                     On Exit:</span><br><span class="hljs-comment">//  [param 2] = first real argument   [param 2] (esp+1c)          [param 2]</span><br><span class="hljs-comment">//  [param 1] = our SmartThunk        [param 1] (esp+18)          [ret address]</span><br><span class="hljs-comment">//  [ret address] = real caller       [ret address] (esp+14)      [xxx]</span><br><span class="hljs-comment">//  [xxx]                             [addr to jump to] (esp+10)  [xxx]</span><br><span class="hljs-comment">//  [xxx]                             [saved eax]                 [xxx]</span><br><span class="hljs-comment">//  [xxx]                             [saved ebx]                 [xxx]</span><br><span class="hljs-comment">//  [xxx]                             [saved ecx]                 [xxx]</span><br><span class="hljs-comment">//  [xxx]                             [saved edx]                 [xxx]</span><br>__declspec(naked)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SmartSidestepResolverThunk::SmartStub</span><span class="hljs-params">()</span> </span>&#123;<br>  __asm &#123;<br>    push eax                  <span class="hljs-comment">// Space for the jump.</span><br>    push eax                  <span class="hljs-comment">// Save registers.</span><br>    push ebx<br>    push ecx<br>    push edx<br>    mov ebx, [esp + <span class="hljs-number">0x18</span>]     <span class="hljs-comment">// First parameter = SmartThunk.</span><br>    mov edx, [esp + <span class="hljs-number">0x14</span>]     <span class="hljs-comment">// Get the return address.</span><br>    mov eax, [ebx]SmartThunk.module_base<br>    push edx<br>    push eax<br>    call SmartSidestepResolverThunk::IsInternalCall	<span class="hljs-comment">// 这里判断一下是否是internal</span><br>    add esp, <span class="hljs-number">8</span><br><br>    test eax, eax					  <span class="hljs-comment">// 如果是的话，就直接call original就行了</span><br>    lea edx, [ebx]SmartThunk.sidestep   <span class="hljs-comment">// The original function. 盯住这个edx</span><br>    jz call_interceptor				   <span class="hljs-comment">// 如果不是internal，就得部署interceptor</span><br><br>    <span class="hljs-comment">// Skip this call</span><br>    mov ecx, [esp + <span class="hljs-number">0x14</span>]               <span class="hljs-comment">// Return address.</span><br>    mov [esp + <span class="hljs-number">0x18</span>], ecx               <span class="hljs-comment">// Remove first parameter.</span><br>    mov [esp + <span class="hljs-number">0x10</span>], edx			   <span class="hljs-comment">// edx是original function，这个位置作为ret时的返回地址</span><br>    pop edx                             <span class="hljs-comment">// Restore registers.</span><br>    pop ecx<br>    pop ebx<br>    pop eax<br>    ret <span class="hljs-number">4</span>                               <span class="hljs-comment">// Jump to original function.</span><br><br>  call_interceptor:<br>    mov ecx, [ebx]SmartThunk.interceptor<br>    mov [esp + <span class="hljs-number">0x18</span>], edx               <span class="hljs-comment">// Replace first parameter. orignal地址成了第一个参数</span><br>    mov [esp + <span class="hljs-number">0x10</span>], ecx				<span class="hljs-comment">// interceptor地址变成了ret addr</span><br>    pop edx                             <span class="hljs-comment">// Restore registers.</span><br>    pop ecx<br>    pop ebx<br>    pop eax<br>    ret                                 <span class="hljs-comment">// Jump to original function. 这个理应是jmp interceptor</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实看了这些就基本理清了，展开<code>GetThunkSize</code>和<code>Setup</code>印证一下想法：</p>
<h3 id="getthunksize-1"><code>GetThunkSize</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">SmartSidestepResolverThunk::GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetInternalThunkSize</span>() + kSizeOfSidestepStub +<br>         <span class="hljs-built_in">offsetof</span>(SmartThunk, sidestep);<span class="hljs-comment">// SmartThunk包含了SidestepThunk</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SmartThunk</span> &#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* module_base;  <span class="hljs-comment">// Target module&#x27;s base.</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor;  <span class="hljs-comment">// Real interceptor.</span><br>  SidestepThunk sidestep;   <span class="hljs-comment">// Standard sidestep thunk.</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="setup-2"><code>Setup</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is basically a wrapper around the normal sidestep patch that extends</span><br><span class="hljs-comment">// the thunk to use a chained interceptor. It uses the fact that</span><br><span class="hljs-comment">// SetInternalThunk generates the code to pass as the first parameter whatever</span><br><span class="hljs-comment">// it receives as original_function; we let SidestepResolverThunk set this value</span><br><span class="hljs-comment">// to its saved code, and then we change it to our thunk data.</span><br><span class="hljs-function">NTSTATUS <span class="hljs-title">SmartSidestepResolverThunk::Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">size_t</span>* storage_used)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (storage_bytes &lt; <span class="hljs-built_in">GetThunkSize</span>())<br>    <span class="hljs-keyword">return</span> STATUS_BUFFER_TOO_SMALL;<br><br>  <span class="hljs-comment">// 看出SmartThunk，填充module_base，SmartStub中会用到</span><br>  SmartThunk* thunk = <span class="hljs-built_in">reinterpret_cast</span>&lt;SmartThunk*&gt;(thunk_storage);<br>  thunk-&gt;module_base = target_module;<br><br>  NTSTATUS ret;<br>  <span class="hljs-comment">// 填充interceptor，SmartStub中会用到</span><br>  <span class="hljs-keyword">if</span> (interceptor_entry_point) &#123;<br>    thunk-&gt;interceptor = interceptor_entry_point;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ret = <span class="hljs-built_in">ResolveInterceptor</span>(interceptor_module, interceptor_name,<br>                             &amp;thunk-&gt;interceptor);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>      <span class="hljs-keyword">return</span> ret;<br>  &#125;<br><br>  <span class="hljs-comment">// Perform a standard sidestep patch on the last part of the thunk, but point</span><br>  <span class="hljs-comment">// to our internal smart interceptor.</span><br>  <span class="hljs-type">size_t</span> standard_bytes = storage_bytes - <span class="hljs-built_in">offsetof</span>(SmartThunk, sidestep);<br>  <span class="hljs-comment">// SmartThunk的SodestepThunk的填充和基类SidestepResolverThunk一致</span><br>  <span class="hljs-comment">// 但注意interceptor_entry_point此时不再是interceptor的地址，而是SmartStub地址</span><br>  <span class="hljs-comment">// 相当于在interceptor的基础上用SmartStub又拦了一次，而SmartStub会根据internal caller</span><br>  <span class="hljs-comment">// 的判断跳转到interceptor的分支或original分支，interceptor在thunk_storage中记录了</span><br>  ret = SidestepResolverThunk::<span class="hljs-built_in">Setup</span>(target_module, interceptor_module,<br>                                     target_name, <span class="hljs-literal">nullptr</span>,<br>                                     <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;SmartStub),<br>                                     &amp;thunk-&gt;sidestep, standard_bytes, <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-comment">// Fix the internal thunk to pass the whole buffer to the interceptor.</span><br>  <span class="hljs-comment">// 这里SmartStub地址作为了拦截器，而原本的一大坨thunk_storage作为original，它相当于一个代理</span><br>  <span class="hljs-built_in">SetInternalThunk</span>(&amp;thunk-&gt;sidestep.internal_thunk, <span class="hljs-built_in">GetInternalThunkSize</span>(),<br>                   thunk_storage, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;SmartStub));<br><br>  <span class="hljs-keyword">if</span> (storage_used)<br>    *storage_used = <span class="hljs-built_in">GetThunkSize</span>();<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="serviceresolverthunk"><code>ServiceResolverThunk</code></h2>
<p>我们分析过了三种target进程使用的Resolver，还有一种broker使用的Resolver类型——系统调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is the concrete resolver used to perform service-call type functions</span><br><span class="hljs-comment">// inside ntdll.dll.</span><br><span class="hljs-comment">// 用于执行ntdll中的系统调用类型函数的拦截</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceResolverThunk</span> : <span class="hljs-keyword">public</span> ResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// The service resolver needs a child process to write to.</span><br>  <span class="hljs-built_in">ServiceResolverThunk</span>(HANDLE process, <span class="hljs-type">bool</span> relaxed)<br>      : <span class="hljs-built_in">ntdll_base_</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">process_</span>(process),<br>        <span class="hljs-built_in">relaxed_</span>(relaxed),<br>        <span class="hljs-built_in">relative_jump_</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>  ~<span class="hljs-built_in">ServiceResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br>  <span class="hljs-comment">// Implementation of Resolver::Setup.</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">size_t</span>* storage_used)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// 可以看到两个resolve都override了</span><br>  <span class="hljs-comment">// Implementation of Resolver::ResolveInterceptor.</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">ResolveInterceptor</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> <span class="hljs-type">void</span>** address)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// Implementation of Resolver::ResolveTarget.</span><br>  <span class="hljs-function">NTSTATUS <span class="hljs-title">ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">void</span>** address)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// Implementation of Resolver::GetThunkSize.</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">// 这几个居然还是virtual，看来还有派生类</span><br>  <span class="hljs-comment">// Call this to set up ntdll_base_ which will allow for local patches.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">AllowLocalPatches</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Verifies that the function specified by |target_name| in |target_module| is</span><br>  <span class="hljs-comment">// a service and copies the data from that function into |thunk_storage|. If</span><br>  <span class="hljs-comment">// |storage_bytes| is too small, then the method fails.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> NTSTATUS <span class="hljs-title">CopyThunk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             BYTE* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">size_t</span>* storage_used)</span></span>;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// The unit test will use this member to allow local patch on a buffer.</span><br>  HMODULE ntdll_base_;<br><br>  <span class="hljs-comment">// Handle of the child process.</span><br>  HANDLE process_;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Returns true if the code pointer by target_ corresponds to the expected</span><br>  <span class="hljs-comment">// type of function. Saves that code on the first part of the thunk pointed</span><br>  <span class="hljs-comment">// by local_thunk (should be directly accessible from the parent).</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">IsFunctionAService</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Performs the actual patch of target_.</span><br>  <span class="hljs-comment">// local_thunk must be already fully initialized, and the first part must</span><br>  <span class="hljs-comment">// contain the original code. The real type of this buffer is ServiceFullThunk</span><br>  <span class="hljs-comment">// (yes, private). remote_thunk (real type ServiceFullThunk), must be</span><br>  <span class="hljs-comment">// allocated on the child, and will contain the thunk data, after this call.</span><br>  <span class="hljs-comment">// Returns the apropriate status code.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> NTSTATUS <span class="hljs-title">PerformPatch</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk, <span class="hljs-type">void</span>* remote_thunk)</span></span>;<br><br>  <span class="hljs-comment">// Provides basically the same functionality as IsFunctionAService but it</span><br>  <span class="hljs-comment">// continues even if it does not recognize the function code. remote_thunk</span><br>  <span class="hljs-comment">// is the address of our memory on the child.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SaveOriginalFunction</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk, <span class="hljs-type">void</span>* remote_thunk)</span></span>;<br><br>  <span class="hljs-comment">// true if we are allowed to patch already-patched functions.</span><br>  <span class="hljs-type">bool</span> relaxed_;<br>  ULONG relative_jump_;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(ServiceResolverThunk);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>显然，和前面分析的3个resolver不是一套体系的，这个要复杂得多。</p>
<p>service_resolver.h中也可以看到根据不同系统，以及位数进行了分类，定义了<code>ServiceResolverThunk</code>的众多子类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is the concrete resolver used to perform service-call type functions</span><br><span class="hljs-comment">// inside ntdll.dll on WOW64 (32 bit ntdll on 64 bit Vista).</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wow64ResolverThunk</span> : <span class="hljs-keyword">public</span> ServiceResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// The service resolver needs a child process to write to.</span><br>  <span class="hljs-built_in">Wow64ResolverThunk</span>(HANDLE process, <span class="hljs-type">bool</span> relaxed)<br>      : <span class="hljs-built_in">ServiceResolverThunk</span>(process, relaxed) &#123;&#125;<br>  ~<span class="hljs-built_in">Wow64ResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFunctionAService</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(Wow64ResolverThunk);<br>&#125;;<br><br><span class="hljs-comment">// This is the concrete resolver used to perform service-call type functions</span><br><span class="hljs-comment">// inside ntdll.dll on WOW64 for Windows 8.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wow64W8ResolverThunk</span> : <span class="hljs-keyword">public</span> ServiceResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// The service resolver needs a child process to write to.</span><br>  <span class="hljs-built_in">Wow64W8ResolverThunk</span>(HANDLE process, <span class="hljs-type">bool</span> relaxed)<br>      : <span class="hljs-built_in">ServiceResolverThunk</span>(process, relaxed) &#123;&#125;<br>  ~<span class="hljs-built_in">Wow64W8ResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFunctionAService</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(Wow64W8ResolverThunk);<br>&#125;;<br><br><span class="hljs-comment">// This is the concrete resolver used to perform service-call type functions</span><br><span class="hljs-comment">// inside ntdll.dll on Windows 8.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Win8ResolverThunk</span> : <span class="hljs-keyword">public</span> ServiceResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// The service resolver needs a child process to write to.</span><br>  <span class="hljs-built_in">Win8ResolverThunk</span>(HANDLE process, <span class="hljs-type">bool</span> relaxed)<br>      : <span class="hljs-built_in">ServiceResolverThunk</span>(process, relaxed) &#123;&#125;<br>  ~<span class="hljs-built_in">Win8ResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFunctionAService</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(Win8ResolverThunk);<br>&#125;;<br><br><span class="hljs-comment">// This is the concrete resolver used to perform service-call type functions</span><br><span class="hljs-comment">// inside ntdll.dll on WOW64 for Windows 10.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wow64W10ResolverThunk</span> : <span class="hljs-keyword">public</span> ServiceResolverThunk &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// The service resolver needs a child process to write to.</span><br>  <span class="hljs-built_in">Wow64W10ResolverThunk</span>(HANDLE process, <span class="hljs-type">bool</span> relaxed)<br>      : <span class="hljs-built_in">ServiceResolverThunk</span>(process, relaxed) &#123;&#125;<br>  ~<span class="hljs-built_in">Wow64W10ResolverThunk</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFunctionAService</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(Wow64W10ResolverThunk);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这些子类都override了<code>IsFunctionAService</code>，这是因为不同系统版本位数对系统调用的判断条件是不同的。</p>
<p>但是父类的另外几个虚函数，没有找到身影。</p>
<h3 id="两个resolve">两个resolve</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">ServiceResolverThunk::ResolveInterceptor</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">void</span>** address)</span> </span>&#123;<br>  <span class="hljs-comment">// After all, we are using a locally mapped version of the exe, so the</span><br>  <span class="hljs-comment">// action is the same as for a target function.</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ResolveTarget</span>(interceptor_module, interceptor_name,<br>                       <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">void</span>**&gt;(address));<br>&#125;<br><br><span class="hljs-comment">// In this case all the work is done from the parent, so resolve is</span><br><span class="hljs-comment">// just a simple GetProcAddress.</span><br><span class="hljs-function">NTSTATUS <span class="hljs-title">ServiceResolverThunk::ResolveTarget</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">module</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">void</span>** address)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">module</span>)<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br><br>  <span class="hljs-comment">// 还是老套路，没啥好说的</span><br>  base::<span class="hljs-function">win::PEImage <span class="hljs-title">module_image</span><span class="hljs-params">(<span class="hljs-keyword">module</span>)</span></span>;<br>  *address =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(module_image.<span class="hljs-built_in">GetProcAddress</span>(function_name));<br><br>  <span class="hljs-keyword">if</span> (!*address) &#123;<br>    <span class="hljs-built_in">NOTREACHED_NT</span>();<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>跟基类的原理是一样的，但这里和基类的两个resolve却是反过来的，基类是target-&gt;interceptor，而这里却是interceptor-&gt;target。</p>
<p>不太清楚是否有什么禁忌在其中。</p>
<h3 id="x86-servicefullthunk"><code>x86 ServiceFullThunk</code></h3>
<p>在研究<code>Setup</code>之前，还是按照惯例先研究Thunk：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceFullThunk</span> &#123;<br>  <span class="hljs-keyword">union</span> &#123;<br>    ServiceEntry original;<br>    ServiceEntryW8 original_w8;<br>    Wow64Entry wow_64;<br>    Wow64EntryW8 wow_64_w8;<br>  &#125;;<br>  <span class="hljs-type">int</span> internal_thunk;  <span class="hljs-comment">// Dummy member to the beginning of the internal thunk.</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>内部是个union，说明有4种不同的Thunk，对应到不同的系统版本和位数。我们先研究一下各版本的Entry。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Service code for 32 bit systems.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> on win2003 &quot;call dword ptr [edx]&quot; is &quot;call edx&quot;.</span><br><span class="hljs-comment">// 这个是32位系统调用样例</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceEntry</span> &#123;<br>  <span class="hljs-comment">// This struct contains roughly the following code:</span><br>  <span class="hljs-comment">// 00 mov     eax,25h</span><br>  <span class="hljs-comment">// 05 mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)</span><br>  <span class="hljs-comment">// 0a call    dword ptr [edx]</span><br>  <span class="hljs-comment">// 0c ret     2Ch</span><br>  <span class="hljs-comment">// 0f nop</span><br>  BYTE mov_eax;         <span class="hljs-comment">// = B8</span><br>  ULONG service_id;<br>  BYTE mov_edx;         <span class="hljs-comment">// = BA</span><br>  ULONG stub;<br>  USHORT call_ptr_edx;  <span class="hljs-comment">// = FF 12</span><br>  BYTE ret;             <span class="hljs-comment">// = C2</span><br>  USHORT num_params;<br>  BYTE nop;<br>&#125;;<br><br><span class="hljs-comment">// Service code for 32 bit Windows 8.</span><br><span class="hljs-comment">// 32位win8的service code入口</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceEntryW8</span> &#123;<br>  <span class="hljs-comment">// This struct contains the following code:</span><br>  <span class="hljs-comment">// 00 b825000000      mov     eax,25h</span><br>  <span class="hljs-comment">// 05 e803000000      call    eip+3</span><br>  <span class="hljs-comment">// 0a c22c00          ret     2Ch</span><br>  <span class="hljs-comment">// 0d 8bd4            mov     edx,esp</span><br>  <span class="hljs-comment">// 0f 0f34            sysenter</span><br>  <span class="hljs-comment">// 11 c3              ret</span><br>  <span class="hljs-comment">// 12 8bff            mov     edi,edi</span><br>  BYTE mov_eax;         <span class="hljs-comment">// = B8</span><br>  ULONG service_id;<br>  BYTE call_eip;        <span class="hljs-comment">// = E8</span><br>  ULONG call_offset;<br>  BYTE ret_p;           <span class="hljs-comment">// = C2</span><br>  USHORT num_params;<br>  USHORT mov_edx_esp;   <span class="hljs-comment">// = BD D4</span><br>  USHORT sysenter;      <span class="hljs-comment">// = 0F 34</span><br>  BYTE ret;             <span class="hljs-comment">// = C3</span><br>  USHORT nop;<br>&#125;;<br><br><span class="hljs-comment">// Service code for a 32 bit process running on a 64 bit os.</span><br><span class="hljs-comment">// 32位进程在64位os上运行的service code</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wow64Entry</span> &#123;<br>  <span class="hljs-comment">// This struct may contain one of two versions of code:</span><br>  <span class="hljs-comment">// 1. For XP, Vista and 2K3:</span><br>  <span class="hljs-comment">// 00 b825000000      mov     eax, 25h</span><br>  <span class="hljs-comment">// 05 33c9            xor     ecx, ecx</span><br>  <span class="hljs-comment">// 07 8d542404        lea     edx, [esp + 4]</span><br>  <span class="hljs-comment">// 0b 64ff15c0000000  call    dword ptr fs:[0C0h]</span><br>  <span class="hljs-comment">// 12 c22c00          ret     2Ch</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// 2. For Windows 7:</span><br>  <span class="hljs-comment">// 00 b825000000      mov     eax, 25h</span><br>  <span class="hljs-comment">// 05 33c9            xor     ecx, ecx</span><br>  <span class="hljs-comment">// 07 8d542404        lea     edx, [esp + 4]</span><br>  <span class="hljs-comment">// 0b 64ff15c0000000  call    dword ptr fs:[0C0h]</span><br>  <span class="hljs-comment">// 12 83c404          add     esp, 4</span><br>  <span class="hljs-comment">// 15 c22c00          ret     2Ch</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// So we base the structure on the bigger one:</span><br>  BYTE mov_eax;         <span class="hljs-comment">// = B8</span><br>  ULONG service_id;<br>  USHORT xor_ecx;       <span class="hljs-comment">// = 33 C9</span><br>  ULONG lea_edx;        <span class="hljs-comment">// = 8D 54 24 04</span><br>  ULONG call_fs1;       <span class="hljs-comment">// = 64 FF 15 C0</span><br>  USHORT call_fs2;      <span class="hljs-comment">// = 00 00</span><br>  BYTE call_fs3;        <span class="hljs-comment">// = 00</span><br>  BYTE add_esp1;        <span class="hljs-comment">// = 83             or ret</span><br>  USHORT add_esp2;      <span class="hljs-comment">// = C4 04          or num_params</span><br>  BYTE ret;             <span class="hljs-comment">// = C2</span><br>  USHORT num_params;	<span class="hljs-comment">// 这个得算，根据当前是哪种情况</span><br>&#125;;<br><br><span class="hljs-comment">// Service code for a 32 bit process running on 64 bit Windows 8.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wow64EntryW8</span> &#123;<br>  <span class="hljs-comment">// 00 b825000000      mov     eax, 25h</span><br>  <span class="hljs-comment">// 05 64ff15c0000000  call    dword ptr fs:[0C0h]</span><br>  <span class="hljs-comment">// 0b c22c00          ret     2Ch</span><br>  <span class="hljs-comment">// 0f 90              nop</span><br>  BYTE mov_eax;         <span class="hljs-comment">// = B8</span><br>  ULONG service_id;<br>  ULONG call_fs1;       <span class="hljs-comment">// = 64 FF 15 C0</span><br>  USHORT call_fs2;      <span class="hljs-comment">// = 00 00</span><br>  BYTE call_fs3;        <span class="hljs-comment">// = 00</span><br>  BYTE ret;             <span class="hljs-comment">// = C2</span><br>  USHORT num_params;<br>  BYTE nop;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="x64-servicefullthunk"><code>x64 ServiceFullThunk</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// We don&#x27;t have an internal thunk for x64.</span><br><span class="hljs-comment">// x64看来不需要internal thunk</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceFullThunk</span> &#123;<br>  <span class="hljs-keyword">union</span> &#123;<br>    ServiceEntry original;<br>    ServiceEntryW8 original_w8;<br>    ServiceEntryWithInt2E original_int2e_fallback;<br>  &#125;;<br>&#125;;<br><br><span class="hljs-comment">// Service code for 64 bit systems.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceEntry</span> &#123;<br>  <span class="hljs-comment">// This struct contains roughly the following code:</span><br>  <span class="hljs-comment">// 00 mov     r10,rcx</span><br>  <span class="hljs-comment">// 03 mov     eax,52h</span><br>  <span class="hljs-comment">// 08 syscall</span><br>  <span class="hljs-comment">// 0a ret</span><br>  <span class="hljs-comment">// 0b xchg    ax,ax</span><br>  <span class="hljs-comment">// 0e xchg    ax,ax</span><br><br>  ULONG mov_r10_rcx_mov_eax;  <span class="hljs-comment">// = 4C 8B D1 B8</span><br>  ULONG service_id;<br>  USHORT syscall;             <span class="hljs-comment">// = 0F 05</span><br>  BYTE ret;                   <span class="hljs-comment">// = C3</span><br>  BYTE pad;                   <span class="hljs-comment">// = 66</span><br>  USHORT xchg_ax_ax1;         <span class="hljs-comment">// = 66 90</span><br>  USHORT xchg_ax_ax2;         <span class="hljs-comment">// = 66 90</span><br>&#125;;<br><br><span class="hljs-comment">// Service code for 64 bit Windows 8.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceEntryW8</span> &#123;<br>  <span class="hljs-comment">// This struct contains the following code:</span><br>  <span class="hljs-comment">// 00 48894c2408      mov     [rsp+8], rcx</span><br>  <span class="hljs-comment">// 05 4889542410      mov     [rsp+10], rdx</span><br>  <span class="hljs-comment">// 0a 4c89442418      mov     [rsp+18], r8</span><br>  <span class="hljs-comment">// 0f 4c894c2420      mov     [rsp+20], r9</span><br>  <span class="hljs-comment">// 14 4c8bd1          mov     r10,rcx</span><br>  <span class="hljs-comment">// 17 b825000000      mov     eax,25h</span><br>  <span class="hljs-comment">// 1c 0f05            syscall</span><br>  <span class="hljs-comment">// 1e c3              ret</span><br>  <span class="hljs-comment">// 1f 90              nop</span><br><br>  ULONG64 mov_1;              <span class="hljs-comment">// = 48 89 4C 24 08 48 89 54</span><br>  ULONG64 mov_2;              <span class="hljs-comment">// = 24 10 4C 89 44 24 18 4C</span><br>  ULONG mov_3;                <span class="hljs-comment">// = 89 4C 24 20</span><br>  ULONG mov_r10_rcx_mov_eax;  <span class="hljs-comment">// = 4C 8B D1 B8</span><br>  ULONG service_id;<br>  USHORT syscall;             <span class="hljs-comment">// = 0F 05</span><br>  BYTE ret;                   <span class="hljs-comment">// = C3</span><br>  BYTE nop;                   <span class="hljs-comment">// = 90</span><br>&#125;;<br><br><span class="hljs-comment">// Service code for 64 bit systems with int 2e fallback.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceEntryWithInt2E</span> &#123;<br>  <span class="hljs-comment">// This struct contains roughly the following code:</span><br>  <span class="hljs-comment">// 00 4c8bd1           mov     r10,rcx</span><br>  <span class="hljs-comment">// 03 b855000000       mov     eax,52h</span><br>  <span class="hljs-comment">// 08 f604250803fe7f01 test byte ptr SharedUserData!308, 1</span><br>  <span class="hljs-comment">// 10 7503             jne [over syscall]</span><br>  <span class="hljs-comment">// 12 0f05             syscall</span><br>  <span class="hljs-comment">// 14 c3               ret</span><br>  <span class="hljs-comment">// 15 cd2e             int 2e</span><br>  <span class="hljs-comment">// 17 c3               ret</span><br><br>  ULONG mov_r10_rcx_mov_eax;  <span class="hljs-comment">// = 4C 8B D1 B8</span><br>  ULONG service_id;<br>  USHORT test_byte;           <span class="hljs-comment">// = F6 04</span><br>  BYTE ptr;                   <span class="hljs-comment">// = 25</span><br>  ULONG user_shared_data_ptr;<br>  BYTE one;                   <span class="hljs-comment">// = 01</span><br>  USHORT jne_over_syscall;    <span class="hljs-comment">// = 75 03</span><br>  USHORT syscall;             <span class="hljs-comment">// = 0F 05</span><br>  BYTE ret;                   <span class="hljs-comment">// = C3</span><br>  USHORT int2e;               <span class="hljs-comment">// = CD 2E</span><br>  BYTE ret2;                  <span class="hljs-comment">// = C3</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="getthunksize-2"><code>GetThunkSize</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// x86的结构是ServiceFullThunk接一个InternalThunk</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ServiceResolverThunk::GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">offsetof</span>(ServiceFullThunk, internal_thunk) + <span class="hljs-built_in">GetInternalThunkSize</span>();<br>&#125;<br><br><span class="hljs-comment">// x64结构只有一个ServiceFullThunk，没用InternalThunk</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ServiceResolverThunk::GetThunkSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(ServiceFullThunk);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="x86-setup"><code>x86 Setup</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// x86的Setup</span><br><span class="hljs-function">NTSTATUS <span class="hljs-title">ServiceResolverThunk::Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">size_t</span>* storage_used)</span> </span>&#123;<br>  NTSTATUS ret =<br>      <span class="hljs-built_in">Init</span>(target_module, interceptor_module, target_name, interceptor_name,<br>           interceptor_entry_point, thunk_storage, storage_bytes);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  relative_jump_ = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">size_t</span> thunk_bytes = <span class="hljs-built_in">GetThunkSize</span>();<br>  <span class="hljs-comment">// thunk buffer是内部new出来的</span><br>  <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">char</span>[]&gt; <span class="hljs-title">thunk_buffer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[thunk_bytes])</span></span>;<br>  <span class="hljs-comment">// 部署成ServiceFullThunk结构</span><br>  ServiceFullThunk* thunk =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;ServiceFullThunk*&gt;(thunk_buffer.<span class="hljs-built_in">get</span>());<br><br>  <span class="hljs-comment">// 检查一下想要被hook的函数是否是系统调用</span><br>  <span class="hljs-comment">// SaveOriginalFunction是什么？暂时不清楚</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsFunctionAService</span>(&amp;thunk-&gt;original) &amp;&amp;<br>      (!relaxed_ || !<span class="hljs-built_in">SaveOriginalFunction</span>(&amp;thunk-&gt;original, thunk_storage))) &#123;<br>    <span class="hljs-keyword">return</span> STATUS_OBJECT_NAME_COLLISION;<br>  &#125;<br><br>  <span class="hljs-comment">// 关键call，这里进行了patch实装</span><br>  ret = <span class="hljs-built_in">PerformPatch</span>(thunk, thunk_storage);<br><br>  <span class="hljs-keyword">if</span> (storage_used)<br>    *storage_used = thunk_bytes;<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>IsFunctionAService</code>顾名思义，就是读取target进程的original函数的字节码与<code>ServiceEntry</code>进行比较（对于<code>ServiceResolverThunk</code>来说用的是<code>ServiceEntry</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ServiceResolverThunk::IsFunctionAService</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk)</span> <span class="hljs-type">const</span> </span>&#123;<br>  ServiceEntry function_code;<br>  SIZE_T read;<br>  <span class="hljs-comment">// 读取target进程上的original函数字节码，长度为ServiceEntry的尺寸</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">ReadProcessMemory</span>(process_, target_, &amp;function_code,<br>                           <span class="hljs-built_in">sizeof</span>(function_code), &amp;read)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(function_code) != read)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 开始逐字节比较，固定的几处字节码如果有误的话，说明不是一个系统调用</span><br>  <span class="hljs-keyword">if</span> (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||<br>      (kCallPtrEdx != function_code.call_ptr_edx &amp;&amp;	<span class="hljs-comment">// 这里的&amp;&amp;是因为win2003上是call edx</span><br>       kCallEdx != function_code.call_ptr_edx) ||<br>      kRet != function_code.ret) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Find the system call pointer if we don&#x27;t already have it.</span><br>  <span class="hljs-comment">// 如果是call dword ptr [edx]的话，要读取出[edx]</span><br>  <span class="hljs-keyword">if</span> (kCallEdx != function_code.call_ptr_edx) &#123;<br>    DWORD ki_system_call;<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">ReadProcessMemory</span>(process_,<br>                             <span class="hljs-built_in">bit_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>*&gt;(function_code.stub),<br>                             &amp;ki_system_call, <span class="hljs-built_in">sizeof</span>(ki_system_call), &amp;read)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(ki_system_call) != read)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    HMODULE module_1, module_2;<br>    <span class="hljs-comment">// 检查一下读取到的ki_system_call的module和original函数的module是否一致</span><br>    <span class="hljs-comment">// last check, call_stub should point to a KiXXSystemCall function on ntdll</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetModuleHandleEx</span>(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |<br>                               GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,<br>                           <span class="hljs-built_in">bit_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt;(ki_system_call),<br>                           &amp;module_1)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ntdll_base_) &#123;<br>      <span class="hljs-comment">// This path is only taken when running the unit tests. We want to be</span><br>      <span class="hljs-comment">// able to patch a buffer in memory, so target_ is not inside ntdll.</span><br>      module_2 = ntdll_base_;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetModuleHandleEx</span>(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |<br>                                 GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,<br>                             <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt;(target_),<br>                             &amp;module_2))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (module_1 != module_2)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Save the verified code</span><br>  <span class="hljs-comment">// 此时Setup中的ServiceFullThunk的ServiceEntry成员就正确填充了</span><br>  <span class="hljs-built_in">memcpy</span>(local_thunk, &amp;function_code, <span class="hljs-built_in">sizeof</span>(function_code));<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到<code>IsFunctionAService</code>不仅判断了是否是service
call，还拷贝了original
function的字节码给了Setup传递进来的<code>ServiceEntry</code>。继续展开<code>SaveOriginalFunction</code>看看本地填充好的<code>ServiceEntry</code>是如何与外部传进来的<code>thunk_storage</code>建立联系的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ServiceResolverThunk::SaveOriginalFunction</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">void</span>* remote_thunk)</span> </span>&#123;<br>  ServiceEntry function_code;<br>  SIZE_T read;<br>  <span class="hljs-comment">// 又去读了一遍</span><br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">ReadProcessMemory</span>(process_, target_, &amp;function_code,<br>                           <span class="hljs-built_in">sizeof</span>(function_code), &amp;read)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(function_code) != read)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 进到这个函数就表示，Resolver是允许repatch的，那么第一次patch之后其后再次的patch</span><br>  <span class="hljs-comment">// 首字节就不再是mov eax,xx而是jmp xxx了</span><br>  <span class="hljs-keyword">if</span> (kJmp32 == function_code.mov_eax) &#123;<br>    <span class="hljs-comment">// Plain old entry point patch. The relative jump address follows it.</span><br>    <span class="hljs-comment">// 读出来上一次patch的jmp到的地址</span><br>    ULONG relative = function_code.service_id;<br><br>    <span class="hljs-comment">// First, fix our copy of their patch.</span><br>    <span class="hljs-comment">// 修正地址</span><br>    relative += <span class="hljs-built_in">bit_cast</span>&lt;ULONG&gt;(target_) - <span class="hljs-built_in">bit_cast</span>&lt;ULONG&gt;(remote_thunk);<br><br>    function_code.service_id = relative;<br><br>    <span class="hljs-comment">// And now, remember how to re-patch it.</span><br>    <span class="hljs-comment">// 这里处理repatch，remote_thunk是个ServiceFullThunk结构</span><br>    ServiceFullThunk* full_thunk =<br>        <span class="hljs-built_in">reinterpret_cast</span>&lt;ServiceFullThunk*&gt;(remote_thunk);<br><br>    <span class="hljs-type">const</span> ULONG kJmp32Size = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">// internal_thunk指向的是InternalThunk，它的地址减去original的地址再扣除5个jmp的尺寸</span><br>    <span class="hljs-comment">// 就是最终的跳转的地址偏移量，更新对象的成员relative_jump_，它用于从InternalThunk调用</span><br>    <span class="hljs-comment">// original时跳转到original</span><br>    relative_jump_ = <span class="hljs-built_in">bit_cast</span>&lt;ULONG&gt;(&amp;full_thunk-&gt;internal_thunk) -<br>                     <span class="hljs-built_in">bit_cast</span>&lt;ULONG&gt;(target_) - kJmp32Size;<br>  &#125;<br><br>  <span class="hljs-comment">// Save the verified code</span><br>  <span class="hljs-comment">// 如果不是首次进入，就把更新了jmp地址的ServiceEntry拷贝给local_thunk</span><br>  <span class="hljs-comment">// 如果是首次的话，实际上是copy出了original的字节码</span><br>  <span class="hljs-built_in">memcpy</span>(local_thunk, &amp;function_code, <span class="hljs-built_in">sizeof</span>(function_code));<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后是最后的patch实装：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">ServiceResolverThunk::PerformPatch</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">void</span>* remote_thunk)</span> </span>&#123;<br>  ServiceEntry intercepted_code;<br>  <span class="hljs-type">size_t</span> bytes_to_write = <span class="hljs-built_in">sizeof</span>(intercepted_code);<br>  ServiceFullThunk* full_local_thunk =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;ServiceFullThunk*&gt;(local_thunk);<br>  ServiceFullThunk* full_remote_thunk =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;ServiceFullThunk*&gt;(remote_thunk);<br><br>  <span class="hljs-comment">// patch the original code</span><br>  <span class="hljs-comment">// original字节码拷贝给local buffer</span><br>  <span class="hljs-built_in">memcpy</span>(&amp;intercepted_code, &amp;full_local_thunk-&gt;original,<br>         <span class="hljs-built_in">sizeof</span>(intercepted_code));<br>  intercepted_code.mov_eax = kMovEax;<br>  intercepted_code.service_id = full_local_thunk-&gt;original.service_id;<br>  intercepted_code.mov_edx = kMovEdx;<br>  intercepted_code.stub = <span class="hljs-built_in">bit_cast</span>&lt;ULONG&gt;(&amp;full_remote_thunk-&gt;internal_thunk);<br>  intercepted_code.call_ptr_edx = kJmpEdx;<br>  bytes_to_write = kMinServiceSize;<br><br>  <span class="hljs-comment">// 如果relative_jump_有效，说明不是首次patch的实装，此时就要修正local buffer中的字节码为正确</span><br>  <span class="hljs-comment">// 的jmp relative_jump_，这个偏移量是remote buffer中InternalThunk的地址减去original函数的地址</span><br>  <span class="hljs-comment">// 再扣除5个字节的jmp</span><br>  <span class="hljs-keyword">if</span> (relative_jump_) &#123;<br>    intercepted_code.mov_eax = kJmp32;<br>    intercepted_code.service_id = relative_jump_;<br>    bytes_to_write = <span class="hljs-built_in">offsetof</span>(ServiceEntry, mov_edx);<br>  &#125;<br><br>  <span class="hljs-comment">// setup the thunk</span><br>  <span class="hljs-comment">// 部署InternalThunk，InternalThunk的效果是interceptor_(remote_thunk,xxx)</span><br>  <span class="hljs-comment">// 也就是跳到remote_thunk的起始ServiceEntry处，而不是original</span><br>  <span class="hljs-built_in">SetInternalThunk</span>(&amp;full_local_thunk-&gt;internal_thunk, <span class="hljs-built_in">GetInternalThunkSize</span>(),<br>                   remote_thunk, interceptor_);<br><br>  <span class="hljs-type">size_t</span> thunk_size = <span class="hljs-built_in">GetThunkSize</span>();<br><br>  <span class="hljs-comment">// copy the local thunk buffer to the child</span><br>  <span class="hljs-comment">// local buffer给了remote_thunk的ServiceEntry</span><br>  <span class="hljs-comment">// 所以当interceptor_跳到这里时会执行jmp xxx（存在repatch）或者执行original原本的代码序列（没有repatch）</span><br>  SIZE_T written;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">WriteProcessMemory</span>(process_, remote_thunk, local_thunk, thunk_size,<br>                            &amp;written)) &#123;<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (thunk_size != written)<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br><br>  <span class="hljs-comment">// and now change the function to intercept, on the child</span><br>  <span class="hljs-comment">// 现在要处理的就是把原本的original函数开头的那一段内容修改成interceptor_</span><br>  <span class="hljs-comment">// 实现call original时实际上是call interceptor_，以此完成了整个hook链</span><br>  <span class="hljs-keyword">if</span> (ntdll_base_) &#123;<br>    <span class="hljs-comment">// running a unit test</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">WriteProcessMemory</span>(process_, target_, &amp;intercepted_code,<br>                              bytes_to_write, &amp;written))<br>      <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WriteProtectedChildMemory</span>(process_, target_, &amp;intercepted_code,<br>                                   bytes_to_write))<br>      <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="x64-setup"><code>x64 Setup</code></h3>
<p>至于x64就比较简单了，因为它的设计并不是interceptor_(original,xxx)，所以也就没有这么复杂的Thunk实装过程，它的<code>InternalThunk</code>仅仅是:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InternalThunk</span> &#123;<br>  <span class="hljs-comment">// This struct contains roughly the following code:</span><br>  <span class="hljs-comment">// 01 48b8f0debc9a78563412  mov   rax,123456789ABCDEF0h</span><br>  <span class="hljs-comment">// ff e0                    jmp   rax</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The code modifies rax, but that&#x27;s fine for x64 ABI.</span><br><br>  <span class="hljs-built_in">InternalThunk</span>() &#123;<br>    mov_rax = kMovRax;<br>    jmp_rax = kJmpRax;<br>    interceptor_function = <span class="hljs-number">0</span>;<br>  &#125;;<br>  USHORT mov_rax;  <span class="hljs-comment">// = 48 B8</span><br>  ULONG_PTR interceptor_function;<br>  USHORT jmp_rax;  <span class="hljs-comment">// = ff e0</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>也是通过<code>WriteChildProcessMemory</code>把original的入口改写成Thunk的地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">NTSTATUS <span class="hljs-title">ServiceResolverThunk::Setup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* target_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_module,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">char</span>* target_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_entry_point,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">void</span>* thunk_storage,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">size_t</span> storage_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">size_t</span>* storage_used)</span> </span>&#123;<br>  NTSTATUS ret =<br>      <span class="hljs-built_in">Init</span>(target_module, interceptor_module, target_name, interceptor_name,<br>           interceptor_entry_point, thunk_storage, storage_bytes);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret))<br>    <span class="hljs-keyword">return</span> ret;<br><br>  <span class="hljs-type">size_t</span> thunk_bytes = <span class="hljs-built_in">GetThunkSize</span>();<br>  <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">char</span>[]&gt; <span class="hljs-title">thunk_buffer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[thunk_bytes])</span></span>;<br>  ServiceFullThunk* thunk =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;ServiceFullThunk*&gt;(thunk_buffer.<span class="hljs-built_in">get</span>());<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsFunctionAService</span>(&amp;thunk-&gt;original))<br>    <span class="hljs-keyword">return</span> STATUS_OBJECT_NAME_COLLISION;<br><br>  ret = <span class="hljs-built_in">PerformPatch</span>(thunk, thunk_storage);<br><br>  <span class="hljs-keyword">if</span> (storage_used)<br>    *storage_used = thunk_bytes;<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function">NTSTATUS <span class="hljs-title">ServiceResolverThunk::PerformPatch</span><span class="hljs-params">(<span class="hljs-type">void</span>* local_thunk,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">void</span>* remote_thunk)</span> </span>&#123;<br>  <span class="hljs-comment">// Patch the original code.</span><br>  ServiceEntry local_service;<br>  <span class="hljs-built_in">DCHECK_NT</span>(<span class="hljs-built_in">GetInternalThunkSize</span>() &lt;= <span class="hljs-built_in">sizeof</span>(local_service));<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetInternalThunk</span>(&amp;local_service, <span class="hljs-built_in">sizeof</span>(local_service), <span class="hljs-literal">nullptr</span>,<br>                        interceptor_))<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br><br>  <span class="hljs-comment">// Copy the local thunk buffer to the child.</span><br>  <span class="hljs-comment">// local thunk buffer存储的是original函数原本的指令序列，拷贝到了远端的remote_thunk</span><br>  SIZE_T actual;<br>  <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">WriteProcessMemory</span>(process_, remote_thunk, local_thunk,<br>                            <span class="hljs-built_in">sizeof</span>(ServiceFullThunk), &amp;actual))<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(ServiceFullThunk) != actual)<br>    <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br><br>  <span class="hljs-comment">// And now change the function to intercept, on the child.</span><br>  <span class="hljs-keyword">if</span> (ntdll_base_) &#123;<br>    <span class="hljs-comment">// Running a unit test.</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">WriteProcessMemory</span>(process_, target_, &amp;local_service,<br>                              <span class="hljs-built_in">sizeof</span>(local_service), &amp;actual))<br>      <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 此时original函数面目全非，变成了InternalThunk的mov rax,interceptor;jmp rax;</span><br>    <span class="hljs-comment">// 至于如何从interceptor内部跳回remote_thunk，那就是interceptor的事了（g_orignal）</span><br>    <span class="hljs-comment">// 还记得InterceptionManager::PatchClientFunctions吗？</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WriteProtectedChildMemory</span>(process_, target_, &amp;local_service,<br>                                   <span class="hljs-built_in">sizeof</span>(local_service)))<br>      <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到此，我们终于可以明白<code>InterceptionManager::PatchClientFunctions</code>的意义了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">InterceptionManager::PatchClientFunctions</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    DllInterceptionData* thunks,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">size_t</span> thunk_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">    DllInterceptionData* dll_data)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(thunks);<br>  <span class="hljs-built_in">DCHECK</span>(dll_data);<br><br>  HMODULE ntdll_base = ::<span class="hljs-built_in">GetModuleHandle</span>(kNtdllName);<br>  <span class="hljs-keyword">if</span> (!ntdll_base)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_NO_HANDLE;<br><br>  <span class="hljs-type">char</span>* interceptor_base = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(SANDBOX_EXPORTS)</span><br>  interceptor_base = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(child_-&gt;<span class="hljs-built_in">MainModule</span>());<br>  <span class="hljs-function">base::ScopedNativeLibrary <span class="hljs-title">local_interceptor</span><span class="hljs-params">(::LoadLibrary(child_-&gt;Name()))</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// defined(SANDBOX_EXPORTS)</span></span><br><br>  std::unique_ptr&lt;ServiceResolverThunk&gt; thunk;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64)</span><br>  thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ServiceResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  base::win::OSInfo* os_info = base::win::OSInfo::<span class="hljs-built_in">GetInstance</span>();<br>  <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">wow64_status</span>() == base::win::OSInfo::WOW64_ENABLED) &#123;<br>    <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">version</span>() &gt;= base::win::VERSION_WIN10)<br>      thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Wow64W10ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">version</span>() &gt;= base::win::VERSION_WIN8)<br>      thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Wow64W8ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>    <span class="hljs-keyword">else</span><br>      thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Wow64ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">version</span>() &gt;= base::win::VERSION_WIN8) &#123;<br>    thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Win8ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ServiceResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> interception : interceptions_) &#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> base::string16 <span class="hljs-title">ntdll</span><span class="hljs-params">(kNtdllName)</span></span>;<br>    <span class="hljs-keyword">if</span> (interception.dll != ntdll)<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br>    <span class="hljs-keyword">if</span> (INTERCEPTION_SERVICE_CALL != interception.type)<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br>    <span class="hljs-comment">// 对每个service call类型的ntdll的拦截函数进行处理</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(SANDBOX_EXPORTS)</span><br>    <span class="hljs-comment">// We may be trying to patch by function name.</span><br>    <span class="hljs-keyword">if</span> (!interception.interceptor_address) &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* address;<br>      NTSTATUS ret = thunk-&gt;<span class="hljs-built_in">ResolveInterceptor</span>(<br>          local_interceptor.<span class="hljs-built_in">get</span>(), interception.interceptor.<span class="hljs-built_in">c_str</span>(),<br>          <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>**&gt;(&amp;address));<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret)) &#123;<br>        ::<span class="hljs-built_in">SetLastError</span>(<span class="hljs-built_in">GetLastErrorFromNtStatus</span>(ret));<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_RESOLVE_INTERCEPTION_THUNK;<br>      &#125;<br><br>      <span class="hljs-comment">// Translate the local address to an address on the child.</span><br>      interception.interceptor_address =<br>          interceptor_base +<br>          (address - <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(local_interceptor.<span class="hljs-built_in">get</span>()));<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// defined(SANDBOX_EXPORTS)</span></span><br>    <span class="hljs-comment">// 这里对&amp;thunks-&gt;thunks[dll_data-&gt;num_thunks]进行了实装</span><br>    <span class="hljs-comment">// 它是broker在target进程中开辟的内存空间，空间起始是DllInterceptionData</span><br>    <span class="hljs-comment">// 这里是某一个拦截函数的ThunkData</span><br>    NTSTATUS ret = thunk-&gt;<span class="hljs-built_in">Setup</span>(<br>        ntdll_base, interceptor_base, interception.function.<span class="hljs-built_in">c_str</span>(),<br>        interception.interceptor.<span class="hljs-built_in">c_str</span>(), interception.interceptor_address,<br>        &amp;thunks-&gt;thunks[dll_data-&gt;num_thunks],<br>        thunk_bytes - dll_data-&gt;used_bytes, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret)) &#123;<br>      ::<span class="hljs-built_in">SetLastError</span>(<span class="hljs-built_in">GetLastErrorFromNtStatus</span>(ret));<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_SETUP_INTERCEPTION_THUNK;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里更新了g_originals，使某个类型的interception指向正确的remote端内存地址</span><br>    <span class="hljs-comment">// 另一方面，g_originals的设计也暴露出来了拦截的函数实际上是固定的那些，凡是</span><br>    <span class="hljs-comment">// 使用到的拦截函数，在InterceptorId这个enum结构中都对应一个值</span><br>    <span class="hljs-built_in">DCHECK</span>(!g_originals[interception.id]);<br>    g_originals[interception.id] = &amp;thunks-&gt;thunks[dll_data-&gt;num_thunks];<br><br>    dll_data-&gt;num_thunks++;<br>    dll_data-&gt;used_bytes += <span class="hljs-built_in">sizeof</span>(ThunkData);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Interception和Resolver是目前分析sandbox中最为复杂的部分，尽管一路上磕磕绊绊，但总算是缕清了分分毫毫。</p>
<p>子系统的三大组件中，我们已经分析过了用于分发IPC请求的dispatcher，也分析过了安装Hook的Interception和Resolver，下一节我们分析最后一个——Policy。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="category-chain-item">源码剖析</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/chromium/" class="print-no-link">#chromium</a>
      
        <a href="/tags/chromium-sandbox/" class="print-no-link">#chromium-sandbox</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Chromium-sandbox-Resolver-analysis</div>
      <div>https://r00tk1ts.github.io/2018/05/26/chromium-sandbox-Resolver-analysis/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>r00tk1t</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2018年5月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/05/26/chromium-sandbox-PolicyEngine-analysis/" title="Chromium-sandbox-PolicyEngine-analysis">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Chromium-sandbox-PolicyEngine-analysis</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/05/26/chromium-sandbox-Interception/" title="Chromium-sandbox-Interception-analysis">
                        <span class="hidden-mobile">Chromium-sandbox-Interception-analysis</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/diy/yinghua.js"></script>
<script src="/js/diy/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
