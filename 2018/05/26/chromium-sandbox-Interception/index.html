

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="r00tk1t">
  <meta name="keywords" content="">
  
    <meta name="description" content="本篇是sandbox源码剖析的第十篇，主要分析了windows平台下，Chromium sandbox中子系统三大组件构成中的第二大组件——Interception。阅读本篇前，请先阅读前四篇。 想要流程的阅读本系列你需要以下几个条件： 1. 较高水平的C++编码能力（至少通读C++ Primer 5th，刷过课后题，有一定编码量）。 2. 熟悉Windows API编程，尤其是安全相关的内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="Chromium-sandbox-Interception-analysis">
<meta property="og:url" content="https://r00tk1ts.github.io/2018/05/26/chromium-sandbox-Interception/index.html">
<meta property="og:site_name" content="玉涵的技能书">
<meta property="og:description" content="本篇是sandbox源码剖析的第十篇，主要分析了windows平台下，Chromium sandbox中子系统三大组件构成中的第二大组件——Interception。阅读本篇前，请先阅读前四篇。 想要流程的阅读本系列你需要以下几个条件： 1. 较高水平的C++编码能力（至少通读C++ Primer 5th，刷过课后题，有一定编码量）。 2. 熟悉Windows API编程，尤其是安全相关的内容。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-05-26T02:25:11.000Z">
<meta property="article:modified_time" content="2024-04-22T03:34:00.165Z">
<meta property="article:author" content="r00tk1t">
<meta property="article:tag" content="chromium">
<meta property="article:tag" content="chromium-sandbox">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Chromium-sandbox-Interception-analysis - 玉涵的技能书</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"r00tk1ts.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>玉涵的技能书</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/doc/">
                <i class="iconfont icon-books"></i>
                <span>藏经阁</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Chromium-sandbox-Interception-analysis"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2018-05-26 10:25" pubdate>
          2018年5月26日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          40k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          337 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Chromium-sandbox-Interception-analysis</h1>
            
            
              <div class="markdown-body">
                
                <p>本篇是sandbox源码剖析的第十篇，主要分析了windows平台下，Chromium
sandbox中子系统三大组件构成中的第二大组件——Interception。阅读本篇前，请先阅读前四篇。</p>
<p>想要流程的阅读本系列你需要以下几个条件： 1.
较高水平的C++编码能力（至少通读C++ Primer
5th，刷过课后题，有一定编码量）。 2. 熟悉Windows
API编程，尤其是安全相关的内容。 3.
对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p>
<span id="more"></span>
<h1
id="chromium-sandbox-interception-analysis">chromium-sandbox-Interception-analysis</h1>
<p>此前已经看过了子系统的第一大组件<code>Dispatcher</code>，<code>Dispatcher</code>把IPC请求联系了起来，broker使用<code>TopLevelDispatcher</code>来分发给子系统具体的<code>xxxDispatcher</code>，然后进行server端处理的那些事儿。</p>
<p>今天来分析子系统三大组件中第二个——<code>Interception</code>。我们已经不止一次的在前面的分析之旅中见过<code>InterceptionManager</code>这个用来管理<code>Interception</code>的类了。</p>
<h2 id="interceptionmanager"><code>InterceptionManager</code></h2>
<p><code>InterceptionManager</code>类负责沙盒进程（target）各种拦截器的安装。</p>
<p>看一下类头定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The InterceptionManager executes on the parent application, and it is in</span><br><span class="hljs-comment">// charge of setting up the desired interceptions, and placing the Interception</span><br><span class="hljs-comment">// Agent into the child application.</span><br><span class="hljs-comment">// 这是个泛用说法，对应chrome，parent就是broker，child主要是renderer(target)。</span><br><span class="hljs-comment">// broker上运行的InterceptionManager实例负责安装Interception Agent到renderer上</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The exposed API consists of two methods: AddToPatchedFunctions to set up a</span><br><span class="hljs-comment">// particular interception, and InitializeInterceptions to actually go ahead and</span><br><span class="hljs-comment">// perform all interceptions and transfer data to the child application.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The typical usage is something like this:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// InterceptionManager interception_manager(child);</span><br><span class="hljs-comment">// if (!interception_manager.AddToPatchedFunctions(</span><br><span class="hljs-comment">//         L&quot;ntdll.dll&quot;, &quot;NtCreateFile&quot;,</span><br><span class="hljs-comment">//         sandbox::INTERCEPTION_SERVICE_CALL, &amp;MyNtCreateFile, MY_ID_1))</span><br><span class="hljs-comment">//   return false;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// if (!interception_manager.AddToPatchedFunctions(</span><br><span class="hljs-comment">//         L&quot;kernel32.dll&quot;, &quot;CreateDirectoryW&quot;,</span><br><span class="hljs-comment">//         sandbox::INTERCEPTION_EAT, L&quot;MyCreateDirectoryW@12&quot;, MY_ID_2))</span><br><span class="hljs-comment">//   return false;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// sandbox::ResultCode rc = interception_manager.InitializeInterceptions();</span><br><span class="hljs-comment">// if (rc != sandbox::SBOX_ALL_OK) &#123;</span><br><span class="hljs-comment">//   DWORD error = ::GetLastError();</span><br><span class="hljs-comment">//   return rc;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// Add-&gt;Add-&gt;Add-&gt;...-&gt;Init一波流</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Any required syncronization must be performed outside this class. Also, it is</span><br><span class="hljs-comment">// not possible to perform further interceptions after InitializeInterceptions</span><br><span class="hljs-comment">// is called.</span><br><span class="hljs-comment">// 一旦InitializeInterceptions后，就不能再添加interceptions了</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptionManager</span> &#123;<br>  <span class="hljs-comment">// The unit test will access private members.</span><br>  <span class="hljs-comment">// Allow tests to be marked DISABLED_. Note that FLAKY_ and FAILS_ prefixes</span><br>  <span class="hljs-comment">// do not work with sandbox tests.</span><br>  <span class="hljs-comment">// 单元测试的批量友元类，为了访问private，常见套路，这里不关心</span><br>  <span class="hljs-built_in">FRIEND_TEST_ALL_PREFIXES</span>(InterceptionManagerTest, BufferLayout1);<br>  <span class="hljs-built_in">FRIEND_TEST_ALL_PREFIXES</span>(InterceptionManagerTest, BufferLayout2);<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// An interception manager performs interceptions on a given child process.</span><br>  <span class="hljs-comment">// If we are allowed to intercept functions that have been patched by somebody</span><br>  <span class="hljs-comment">// else, relaxed should be set to true.</span><br>  <span class="hljs-comment">// Note: We increase the child&#x27;s reference count internally.</span><br>  <span class="hljs-comment">// 构造器关联了TargetProcess对象</span><br>  <span class="hljs-comment">// 如果relaxed置true则表示可以覆盖别人的patch</span><br>  <span class="hljs-built_in">InterceptionManager</span>(TargetProcess* child_process, <span class="hljs-type">bool</span> relaxed);<br>  ~<span class="hljs-built_in">InterceptionManager</span>();<br><br>  <span class="hljs-comment">// Patches function_name inside dll_name to point to replacement_code_address.</span><br>  <span class="hljs-comment">// function_name has to be an exported symbol of dll_name.</span><br>  <span class="hljs-comment">// Returns true on success.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The new function should match the prototype and calling convention of the</span><br>  <span class="hljs-comment">// function to intercept except for one extra argument (the first one) that</span><br>  <span class="hljs-comment">// contains a pointer to the original function, to simplify the development</span><br>  <span class="hljs-comment">// of interceptors (for IA32). In x64, there is no extra argument to the</span><br>  <span class="hljs-comment">// interceptor, so the provided InterceptorId is used to keep a table of</span><br>  <span class="hljs-comment">// intercepted functions so that the interceptor can index that table to get</span><br>  <span class="hljs-comment">// the pointer that would have been the first argument (g_originals[id]).</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// For example, to intercept NtClose, the following code could be used:</span><br>  <span class="hljs-comment">// x86和x64对hook函数的不同处理</span><br>  <span class="hljs-comment">// 下面给了一个对NtCloseFunction进行hook的方式，增加了一个原始函数指针的参数</span><br>  <span class="hljs-comment">// typedef NTSTATUS (WINAPI *NtCloseFunction) (IN HANDLE Handle);</span><br>  <span class="hljs-comment">// NTSTATUS WINAPI MyNtCose(IN NtCloseFunction OriginalClose,</span><br>  <span class="hljs-comment">//                          IN HANDLE Handle) &#123;</span><br>  <span class="hljs-comment">//   // do something</span><br>  <span class="hljs-comment">//   // call the original function</span><br>  <span class="hljs-comment">//   return OriginalClose(Handle);</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// And in x64:</span><br>  <span class="hljs-comment">// x64没有传参，而是使用了g_originals全局函数指针表</span><br>  <span class="hljs-comment">// typedef NTSTATUS (WINAPI *NtCloseFunction) (IN HANDLE Handle);</span><br>  <span class="hljs-comment">// NTSTATUS WINAPI MyNtCose64(IN HANDLE Handle) &#123;</span><br>  <span class="hljs-comment">//   // do something</span><br>  <span class="hljs-comment">//   // call the original function</span><br>  <span class="hljs-comment">//   NtCloseFunction OriginalClose = g_originals[NT_CLOSE_ID];</span><br>  <span class="hljs-comment">//   return OriginalClose(Handle);</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-comment">// add方法的几种重载</span><br>  <span class="hljs-comment">// 这个是把function_name的函数指针替换成replacement_code_address起始的地址</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AddToPatchedFunctions</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             InterceptionType interception_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">void</span>* replacement_code_address,</span></span><br><span class="hljs-params"><span class="hljs-function">                             InterceptorId id)</span></span>;<br><br>  <span class="hljs-comment">// Patches function_name inside dll_name to point to</span><br>  <span class="hljs-comment">// replacement_function_name.</span><br>  <span class="hljs-comment">// 用replacement_function_name来替换function_name</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AddToPatchedFunctions</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             InterceptionType interception_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span>* replacement_function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">                             InterceptorId id)</span></span>;<br><br>  <span class="hljs-comment">// The interception agent will unload the dll with dll_name.</span><br>  <span class="hljs-comment">// unload dll</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AddToUnloadModules</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name)</span></span>;<br><br>  <span class="hljs-comment">// Initializes all interceptions on the client.</span><br>  <span class="hljs-comment">// Returns SBOX_ALL_OK on success, or an appropriate error code.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The child process must be created suspended, and cannot be resumed until</span><br>  <span class="hljs-comment">// after this method returns. In addition, no action should be performed on</span><br>  <span class="hljs-comment">// the child that may cause it to resume momentarily, such as injecting</span><br>  <span class="hljs-comment">// threads or APCs.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// This function must be called only once, after all interceptions have been</span><br>  <span class="hljs-comment">// set up using AddToPatchedFunctions.</span><br>  <span class="hljs-comment">// 这个就是最后的fire</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">InitializeInterceptions</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Used to store the interception information until the actual set-up.</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">InterceptionData</span> &#123;<br>    <span class="hljs-built_in">InterceptionData</span>();<br>    <span class="hljs-built_in">InterceptionData</span>(<span class="hljs-type">const</span> InterceptionData&amp; other);<br>    ~<span class="hljs-built_in">InterceptionData</span>();<br><br>    <span class="hljs-comment">//这两个都是枚举量，id主要是用于划分给不同Dispatcher，type是某一种拦截类型</span><br>    <span class="hljs-comment">//这个结构体把所有有用的信息都封装好了</span><br>    InterceptionType type;            <span class="hljs-comment">// Interception type.</span><br>    InterceptorId id;                 <span class="hljs-comment">// Interceptor id.</span><br>    base::string16 dll;               <span class="hljs-comment">// Name of dll to intercept.</span><br>    std::string function;             <span class="hljs-comment">// Name of function to intercept.</span><br>    std::string interceptor;          <span class="hljs-comment">// Name of interceptor function.</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_address;  <span class="hljs-comment">// Interceptor&#x27;s entry point.</span><br>  &#125;;<br><br>  <span class="hljs-comment">// 计算config buffer的尺寸，InterceptionManager也需要一个buffer，这个buffer用于</span><br>  <span class="hljs-comment">// 承载安装的Interception，然后发给InterceptionAgent</span><br>  <span class="hljs-comment">// Calculates the size of the required configuration buffer.</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetBufferSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Rounds up the size of a given buffer, considering alignment (padding).</span><br>  <span class="hljs-comment">// value is the current size of the buffer, and alignment is specified in</span><br>  <span class="hljs-comment">// bytes.</span><br>  <span class="hljs-comment">// 向上对齐</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">RoundUpToMultiple</span><span class="hljs-params">(<span class="hljs-type">size_t</span> value, <span class="hljs-type">size_t</span> alignment)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((value + alignment - <span class="hljs-number">1</span>) / alignment) * alignment;<br>  &#125;<br><br>  <span class="hljs-comment">// Sets up a given buffer with all the information that has to be transfered</span><br>  <span class="hljs-comment">// to the child.</span><br>  <span class="hljs-comment">// Returns true on success.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// The buffer size should be at least the value returned by GetBufferSize</span><br>  <span class="hljs-comment">// 部署config buffer</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetupConfigBuffer</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer, <span class="hljs-type">size_t</span> buffer_bytes)</span></span>;<br><br>  <span class="hljs-comment">// Fills up the part of the transfer buffer that corresponds to information</span><br>  <span class="hljs-comment">// about one dll to patch.</span><br>  <span class="hljs-comment">// data is the first recorded interception for this dll.</span><br>  <span class="hljs-comment">// Returns true on success.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// On successful return, buffer will be advanced from it&#x27;s current position</span><br>  <span class="hljs-comment">// to the point where the next block of configuration data should be written</span><br>  <span class="hljs-comment">// (the actual interception info), and the current size of the buffer will</span><br>  <span class="hljs-comment">// decrease to account the space used by this method.</span><br>  <span class="hljs-comment">// 部署某个被patch的dll的信息到buffer中，这里可以看出buffer中实际上是InterceptionData</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetupDllInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> InterceptionData&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">void</span>** buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">size_t</span>* buffer_bytes)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Fills up the part of the transfer buffer that corresponds to a single</span><br>  <span class="hljs-comment">// function to patch.</span><br>  <span class="hljs-comment">// dll_info points to the dll being updated with the interception stored on</span><br>  <span class="hljs-comment">// data. The buffer pointer and remaining size are updated by this call.</span><br>  <span class="hljs-comment">// Returns true on success.</span><br>  <span class="hljs-comment">// 部署某个单一函数patch的信息到buffer</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SetupInterceptionInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> InterceptionData&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">void</span>** buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">size_t</span>* buffer_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                             DllPatchInfo* dll_info)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Returns true if this interception is to be performed by the child</span><br>  <span class="hljs-comment">// as opposed to from the parent.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInterceptionPerformedByChild</span><span class="hljs-params">(<span class="hljs-type">const</span> InterceptionData&amp; data)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Allocates a buffer on the child&#x27;s address space (returned on</span><br>  <span class="hljs-comment">// remote_buffer), and fills it with the contents of a local buffer.</span><br>  <span class="hljs-comment">// Returns SBOX_ALL_OK on success.</span><br>  <span class="hljs-comment">// 这个应该就是跨进程写数据的素质3连</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">CopyDataToChild</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* local_buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">size_t</span> buffer_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">void</span>** remote_buffer)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Performs the cold patch (from the parent) of ntdll.</span><br>  <span class="hljs-comment">// Returns SBOX_ALL_OK on success.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// This method will insert additional interceptions to launch the interceptor</span><br>  <span class="hljs-comment">// agent on the child process, if there are additional interceptions to do.</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">PatchNtdll</span><span class="hljs-params">(<span class="hljs-type">bool</span> hot_patch_needed)</span></span>;<br><br>  <span class="hljs-comment">// Peforms the actual interceptions on ntdll.</span><br>  <span class="hljs-comment">// thunks is the memory to store all the thunks for this dll (on the child),</span><br>  <span class="hljs-comment">// and dll_data is a local buffer to hold global dll interception info.</span><br>  <span class="hljs-comment">// Returns SBOX_ALL_OK on success.</span><br>  <span class="hljs-function">ResultCode <span class="hljs-title">PatchClientFunctions</span><span class="hljs-params">(DllInterceptionData* thunks,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">size_t</span> thunk_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  DllInterceptionData* dll_data)</span></span>;<br><br>  <span class="hljs-comment">// The process to intercept.</span><br>  <span class="hljs-comment">// 看起来一个Manager管理一个target进程</span><br>  TargetProcess* child_;<br>  <span class="hljs-comment">// Holds all interception info until the call to initialize (perform the</span><br>  <span class="hljs-comment">// actual patch).</span><br>  <span class="hljs-comment">// target进程所有待安装的拦截器</span><br>  std::list&lt;InterceptionData&gt; interceptions_;<br><br>  <span class="hljs-comment">// Keep track of patches added by name.</span><br>  <span class="hljs-type">bool</span> names_used_;<br><br>  <span class="hljs-comment">// true if we are allowed to patch already-patched functions.</span><br>  <span class="hljs-type">bool</span> relaxed_;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(InterceptionManager);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>### 构造/析构器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">InterceptionManager::<span class="hljs-built_in">InterceptionManager</span>(TargetProcess* child_process,<br>                                         <span class="hljs-type">bool</span> relaxed)<br>    : <span class="hljs-built_in">child_</span>(child_process), <span class="hljs-built_in">names_used_</span>(<span class="hljs-literal">false</span>), <span class="hljs-built_in">relaxed_</span>(relaxed) &#123;<br>  child_-&gt;<span class="hljs-built_in">AddRef</span>();	<span class="hljs-comment">// 引用计数增加，因为InterceptionManager用到了TargetProcess对象</span><br>&#125;<br><br>InterceptionManager::~<span class="hljs-built_in">InterceptionManager</span>() &#123;<br>  child_-&gt;<span class="hljs-built_in">Release</span>();	<span class="hljs-comment">// 引用计数减少</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="addtopatchedfunctions"><code>AddToPatchedFunctions</code></h3>
<p>构造和析构毫无营养，我们来看几个重要的接口，先看看重载的两个<code>AddToPatchedFunctions</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::AddToPatchedFunctions</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">    InterceptionType interception_type,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">void</span>* replacement_code_address,</span></span><br><span class="hljs-params"><span class="hljs-function">    InterceptorId id)</span> </span>&#123;<br>  <span class="hljs-comment">// 只是单纯的填充InterceptionData，注意interceptions_中存的不是指针，是InterceptionData对象</span><br>  InterceptionData function;<br>  function.type = interception_type;<br>  function.id = id;<br>  function.dll = dll_name;<br>  function.function = function_name;<br>  function.interceptor_address = replacement_code_address;<br>	<br>  <span class="hljs-comment">// 唯独没有填充interceptor，即拦截函数的名称，实际上也用不到</span><br>  interceptions_.<span class="hljs-built_in">push_back</span>(function);	<span class="hljs-comment">//填充然后push back</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::AddToPatchedFunctions</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">    InterceptionType interception_type,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* replacement_function_name,</span></span><br><span class="hljs-params"><span class="hljs-function">    InterceptorId id)</span> </span>&#123;<br>  InterceptionData function;<br>  function.type = interception_type;<br>  function.id = id;<br>  function.dll = dll_name;<br>  function.function = function_name;<br>  <span class="hljs-comment">// 这里赋值了拦截函数名称，而interceptor_address置为了nullptr</span><br>  function.interceptor = replacement_function_name;<br>  function.interceptor_address = <span class="hljs-literal">nullptr</span>;<br><br>  interceptions_.<span class="hljs-built_in">push_back</span>(function);<br>  names_used_ = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// unload实际上也是一种interception，它的type为固定的INTERCEPTION_UNLOAD_MODULE</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::AddToUnloadModules</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* dll_name)</span> </span>&#123;<br>  InterceptionData module_to_unload;<br>  module_to_unload.type = INTERCEPTION_UNLOAD_MODULE;<br>  module_to_unload.dll = dll_name;<br>  <span class="hljs-comment">// The next two are dummy values that make the structures regular, instead</span><br>  <span class="hljs-comment">// of having special cases. They should not be used.</span><br>  <span class="hljs-comment">// 这两个成员对于该对象来说没有实际意义，填充dummy数据</span><br>  module_to_unload.function = kUnloadDLLDummyFunction;<br>  module_to_unload.interceptor_address = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(<span class="hljs-number">1</span>);<br><br>  interceptions_.<span class="hljs-built_in">push_back</span>(module_to_unload);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先看看都有哪几种type：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">InterceptionType</span> &#123;<br>  INTERCEPTION_INVALID = <span class="hljs-number">0</span>,<br>  INTERCEPTION_SERVICE_CALL,  <span class="hljs-comment">// Trampoline of an NT native call</span><br>  INTERCEPTION_EAT,<br>  INTERCEPTION_SIDESTEP,        <span class="hljs-comment">// Preamble patch</span><br>  INTERCEPTION_SMART_SIDESTEP,  <span class="hljs-comment">// Preamble patch but bypass internal calls</span><br>  INTERCEPTION_UNLOAD_MODULE,   <span class="hljs-comment">// Unload the module (don&#x27;t patch)</span><br>  INTERCEPTION_LAST             <span class="hljs-comment">// Placeholder for last item in the enumeration</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>暂时只有<code>INTERCEPTION_UNLOAD_MODULE</code>的意义是明确的。</p>
<p>其他的几个我们给个猜想：</p>
<ol type="1">
<li>SERVICE_CALL是对系统调用的hook，为什么说成是蹦床，暂不清楚。</li>
<li>EAT应该是取代本体</li>
<li>SIDESTEP应该是inline hook，执行序列后最终会跳回原始地址</li>
<li>SMART_SIDESTEP也是inline hook，但不会跳回</li>
</ol>
<p>根据以往对hook的理解，暂时给出这些猜想。</p>
<p>再看看id的分类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">InterceptorId</span> &#123;<br>  <span class="hljs-comment">// Internal use:</span><br>  MAP_VIEW_OF_SECTION_ID = <span class="hljs-number">0</span>,<br>  UNMAP_VIEW_OF_SECTION_ID,<br>  <span class="hljs-comment">// Policy broker:</span><br>  SET_INFORMATION_THREAD_ID,<br>  OPEN_THREAD_TOKEN_ID,<br>  OPEN_THREAD_TOKEN_EX_ID,<br>  OPEN_THREAD_ID,<br>  OPEN_PROCESS_ID,<br>  OPEN_PROCESS_TOKEN_ID,<br>  OPEN_PROCESS_TOKEN_EX_ID,<br>  <span class="hljs-comment">// Filesystem dispatcher:</span><br>  CREATE_FILE_ID,<br>  OPEN_FILE_ID,<br>  QUERY_ATTRIB_FILE_ID,<br>  QUERY_FULL_ATTRIB_FILE_ID,<br>  SET_INFO_FILE_ID,<br>  <span class="hljs-comment">// Named pipe dispatcher:</span><br>  CREATE_NAMED_PIPE_ID,<br>  <span class="hljs-comment">// Process-thread dispatcher:</span><br>  CREATE_PROCESSW_ID,<br>  CREATE_PROCESSA_ID,<br>  CREATE_THREAD_ID,<br>  <span class="hljs-comment">// Registry dispatcher:</span><br>  CREATE_KEY_ID,<br>  OPEN_KEY_ID,<br>  OPEN_KEY_EX_ID,<br>  <span class="hljs-comment">// Sync dispatcher:</span><br>  CREATE_EVENT_ID,<br>  OPEN_EVENT_ID,<br>  <span class="hljs-comment">// Process mitigations Win32k dispatcher:</span><br>  GDIINITIALIZE_ID,<br>  GETSTOCKOBJECT_ID,<br>  REGISTERCLASSW_ID,<br>  ENUMDISPLAYMONITORS_ID,<br>  ENUMDISPLAYDEVICESA_ID,<br>  GETMONITORINFOA_ID,<br>  GETMONITORINFOW_ID,<br>  CREATEOPMPROTECTEDOUTPUTS_ID,<br>  GETCERTIFICATE_ID,<br>  GETCERTIFICATESIZE_ID,<br>  GETCERTIFICATEBYHANDLE_ID,<br>  GETCERTIFICATESIZEBYHANDLE_ID,<br>  DESTROYOPMPROTECTEDOUTPUT_ID,<br>  CONFIGUREOPMPROTECTEDOUTPUT_ID,<br>  GETOPMINFORMATION_ID,<br>  GETOPMRANDOMNUMBER_ID,<br>  GETSUGGESTEDOPMPROTECTEDOUTPUTARRAYSIZE_ID,<br>  SETOPMSIGNINGKEYANDSEQUENCENUMBERS_ID,<br>  INTERCEPTOR_MAX_ID<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>可以看出来是给每个子系统分派的。</p>
<h3
id="initializeinterceptions"><code>InitializeInterceptions</code></h3>
<p>这个就是fire函数了，broker会把target自己需要按照的interceptions发过去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">InterceptionManager::InitializeInterceptions</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 如果没有拦截器，什么都不用做</span><br>  <span class="hljs-keyword">if</span> (interceptions_.<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span> SBOX_ALL_OK;  <span class="hljs-comment">// Nothing to do here</span><br><br>  <span class="hljs-comment">// 老套路，用GetBufferSize计算尺寸，new出一片天</span><br>  <span class="hljs-type">size_t</span> buffer_bytes = <span class="hljs-built_in">GetBufferSize</span>();<br>  <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">char</span>[]&gt; <span class="hljs-title">local_buffer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[buffer_bytes])</span></span>;<br><br>  <span class="hljs-comment">// 部署buffer</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetupConfigBuffer</span>(local_buffer.<span class="hljs-built_in">get</span>(), buffer_bytes))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_SETUP_INTERCEPTION_CONFIG_BUFFER;<br><br>  <span class="hljs-type">void</span>* remote_buffer;<br>  <span class="hljs-comment">// 关键Call，buffer是如何通过broker发给target进程的呢？</span><br>  <span class="hljs-comment">// 应该还是那个老套路，VirtualAlloc+WriteProcessMemory</span><br>  <span class="hljs-comment">// 然后接全局变量的TransferVariable为target索引内存空间</span><br>  ResultCode rc =<br>      <span class="hljs-built_in">CopyDataToChild</span>(local_buffer.<span class="hljs-built_in">get</span>(), buffer_bytes, &amp;remote_buffer);<br><br>  <span class="hljs-keyword">if</span> (rc != SBOX_ALL_OK)<br>    <span class="hljs-keyword">return</span> rc;<br><br>  <span class="hljs-comment">// 如果buffer不为空，就要打Ntdll 热补丁，这个函数暂时不清楚意义何在</span><br>  <span class="hljs-type">bool</span> hot_patch_needed = (<span class="hljs-number">0</span> != buffer_bytes);<br>  rc = <span class="hljs-built_in">PatchNtdll</span>(hot_patch_needed);<br><br>  <span class="hljs-keyword">if</span> (rc != SBOX_ALL_OK)<br>    <span class="hljs-keyword">return</span> rc;<br><br>  <span class="hljs-comment">// 果然有全局变量的值传递</span><br>  g_interceptions = <span class="hljs-built_in">reinterpret_cast</span>&lt;SharedMemory*&gt;(remote_buffer);<br>  rc = child_-&gt;<span class="hljs-built_in">TransferVariable</span>(<span class="hljs-string">&quot;g_interceptions&quot;</span>, &amp;g_interceptions,<br>                                <span class="hljs-built_in">sizeof</span>(g_interceptions));<br>  <span class="hljs-keyword">return</span> rc;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数内部实际上是各种其他成员函数的组合技，逐一审视：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">InterceptionManager::GetBufferSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  std::set&lt;base::string16&gt; dlls;<br>  <span class="hljs-type">size_t</span> buffer_bytes = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 迭代interception，interceptions_实际上是std::list&lt;InterceptionData&gt;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; interception : interceptions_) &#123;<br>    <span class="hljs-comment">// skip interceptions that are performed from the parent</span><br>    <span class="hljs-comment">// 设计上拦截器分两种，一种由broker来给target执行，另一种由target自己执行</span><br>    <span class="hljs-comment">// 前者就不需要传递给target进程了，所以这里做了skip</span><br>    <span class="hljs-comment">// 那么怎么分类呢？实际上是根据type来判定</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsInterceptionPerformedByChild</span>(interception))<br>      <span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-comment">// 如果本次interception的dll没有出现过，就把该dll的名称插入到dlls</span><br>    <span class="hljs-comment">// 同一个dll尽管出现多次，也只有一个DllPatchInfo结构</span><br>    <span class="hljs-keyword">if</span> (!dlls.<span class="hljs-built_in">count</span>(interception.dll)) &#123;<br>      <span class="hljs-comment">// NULL terminate the dll name on the structure</span><br>      <span class="hljs-type">size_t</span> dll_name_bytes = (interception.dll.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>);<br><br>      <span class="hljs-comment">// include the dll related size</span><br>      <span class="hljs-comment">// dll_name是DLLPatchInfo的最后一个成员，是个flexible数组，这里是计算出整个结构体真实的长度，且单位要对齐</span><br>      <span class="hljs-comment">// 我们mark一下DllPatchInfo结构体</span><br>      buffer_bytes += <span class="hljs-built_in">RoundUpToMultiple</span>(<br>          <span class="hljs-built_in">offsetof</span>(DllPatchInfo, dll_name) + dll_name_bytes, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>));<br>      dlls.<span class="hljs-built_in">insert</span>(interception.dll);<br>    &#125;<br><br>    <span class="hljs-comment">// we have to NULL terminate the strings on the structure</span><br>    <span class="hljs-comment">// 被拦截函数的名称尺寸以及拦截函数的尺寸，2表示两个终结符</span><br>    <span class="hljs-comment">// 但有个疑问在于我们观察两个重载的Add方法时，发现其中一个并没有设置interceptor</span><br>    <span class="hljs-comment">// 如果interceptor在这种情况下为空串，那么还好，但Add时并没有设置，所以可能存在隐患</span><br>    <span class="hljs-type">size_t</span> strings_chars =<br>        interception.function.<span class="hljs-built_in">size</span>() + interception.interceptor.<span class="hljs-built_in">size</span>() + <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// a new FunctionInfo is required per function</span><br>    <span class="hljs-comment">// FunctionInfo也类似DllPatchInfo，function是最后一个flexible数组成员，这个function是两个字符串，一个function，一个interception</span><br>    <span class="hljs-type">size_t</span> record_bytes = <span class="hljs-built_in">offsetof</span>(FunctionInfo, function) + strings_chars;<br>    record_bytes = <span class="hljs-built_in">RoundUpToMultiple</span>(record_bytes, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>));<br>    buffer_bytes += record_bytes;<br>  &#125;<br><br>  <span class="hljs-comment">// SharedMemory也是个类似的结构体，dll_list是最后一个DllPatchInfo flexible数组成员</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != buffer_bytes)<br>    <span class="hljs-comment">// add the part of SharedMemory that we have not counted yet</span><br>    buffer_bytes += <span class="hljs-built_in">offsetof</span>(SharedMemory, dll_list);<br><br>  <span class="hljs-keyword">return</span> buffer_bytes;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以到此可以看出，整个buffer的组成实际上是<code>SharedMemory</code>结构体起始，它的末尾会有多个<code>DllPatchInfo</code>，而每个<code>DllPatchInfo</code>的末尾都有一个<code>dll_name</code>接不定个数的<code>FunctionInfo</code>，每个<code>FunctionInfo</code>的末尾function由两个函数名称字符串组成。</p>
<p>每一个上层结构都有成员来维护不定个数的下层结构，这和我们之前看到的<code>HandleCloser</code>结构很相似。</p>
<p>我们看一下这几个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// All interceptions:</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SharedMemory</span> &#123;<br>  <span class="hljs-type">int</span> num_intercepted_dlls;<br>  <span class="hljs-type">void</span>* interceptor_base;<br>  DllPatchInfo dll_list[<span class="hljs-number">1</span>];  <span class="hljs-comment">// placeholder for the list of dlls</span><br>&#125;;<br><br><span class="hljs-comment">// A single dll:</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DllPatchInfo</span> &#123;<br>  <span class="hljs-type">size_t</span> record_bytes;  <span class="hljs-comment">// rounded to sizeof(size_t) bytes</span><br>  <span class="hljs-type">size_t</span> offset_to_functions;<br>  <span class="hljs-type">int</span> num_functions;<br>  <span class="hljs-type">bool</span> unload_module;<br>  <span class="hljs-type">wchar_t</span> dll_name[<span class="hljs-number">1</span>];  <span class="hljs-comment">// placeholder for null terminated name</span><br>  <span class="hljs-comment">// FunctionInfo function_info[] // followed by the functions to intercept</span><br>&#125;;<br><br><span class="hljs-comment">// Structures for the shared memory that contains patching information</span><br><span class="hljs-comment">// for the InterceptionAgent.</span><br><span class="hljs-comment">// A single interception:</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FunctionInfo</span> &#123;<br>  <span class="hljs-type">size_t</span> record_bytes;  <span class="hljs-comment">// rounded to sizeof(size_t) bytes</span><br>  InterceptionType type;<br>  InterceptorId id;<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* interceptor_address;<br>  <span class="hljs-type">char</span> function[<span class="hljs-number">1</span>];  <span class="hljs-comment">// placeholder for null terminated name</span><br>  <span class="hljs-comment">// char interceptor[]           // followed by the interceptor function</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>成员里的两个注释成员也是很有灵性，注意他们对语法是不可见的。</p>
<p>计算出长度以后，在<code>InitializeInterceptions</code>的内部new出了这个buffer，此后进入到<code>SetupConfigBuffer</code>部署：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Basically, walk the list of interceptions moving them to the config buffer,</span><br><span class="hljs-comment">// but keeping together all interceptions that belong to the same dll.</span><br><span class="hljs-comment">// The config buffer is a local buffer, not the one allocated on the child.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::SetupConfigBuffer</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer, <span class="hljs-type">size_t</span> buffer_bytes)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == buffer_bytes)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-built_in">DCHECK</span>(buffer_bytes &gt; <span class="hljs-built_in">sizeof</span>(SharedMemory));<br><br>  <span class="hljs-comment">// 开始逐一解构</span><br>  SharedMemory* shared_memory = <span class="hljs-built_in">reinterpret_cast</span>&lt;SharedMemory*&gt;(buffer);<br>  DllPatchInfo* dll_info = shared_memory-&gt;dll_list;<br>  <span class="hljs-type">int</span> num_dlls = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 如果names_used_为真，就把target进程的入口地址作为拦截器的基址</span><br>  shared_memory-&gt;interceptor_base =<br>      names_used_ ? child_-&gt;<span class="hljs-built_in">MainModule</span>() : <span class="hljs-literal">nullptr</span>;<br><br>  buffer_bytes -= <span class="hljs-built_in">offsetof</span>(SharedMemory, dll_list);<br>  buffer = dll_info;<br><br>  <span class="hljs-comment">//开始了，抽离出每个dll，SetupDllInfo</span><br>  std::list&lt;InterceptionData&gt;::iterator it = interceptions_.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">for</span> (; it != interceptions_.<span class="hljs-built_in">end</span>();) &#123;<br>    <span class="hljs-comment">// skip interceptions that are performed from the parent</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsInterceptionPerformedByChild</span>(*it)) &#123;<br>      ++it;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 部署本次的dll</span><br>    <span class="hljs-type">const</span> base::string16 dll = it-&gt;dll;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetupDllInfo</span>(*it, &amp;buffer, &amp;buffer_bytes))<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// walk the interceptions from this point, saving the ones that are</span><br>    <span class="hljs-comment">// performed on this dll, and removing the entry from the list.</span><br>    <span class="hljs-comment">// advance the iterator before removing the element from the list</span><br>    <span class="hljs-comment">// 找到后面相同dll的interception，一并处理然后移除</span><br>    std::list&lt;InterceptionData&gt;::iterator rest = it;<br>    <span class="hljs-keyword">for</span> (; rest != interceptions_.<span class="hljs-built_in">end</span>();) &#123;<br>      <span class="hljs-keyword">if</span> (rest-&gt;dll == dll) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetupInterceptionInfo</span>(*rest, &amp;buffer, &amp;buffer_bytes, dll_info))<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (it == rest)<br>          ++it;<br>        rest = interceptions_.<span class="hljs-built_in">erase</span>(rest);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        ++rest;<br>      &#125;<br>    &#125;<br>    dll_info = <span class="hljs-built_in">reinterpret_cast</span>&lt;DllPatchInfo*&gt;(buffer);<br>    ++num_dlls;<br>  &#125;<br><br>  shared_memory-&gt;num_intercepted_dlls = num_dlls;	<span class="hljs-comment">//此时信息就修正了</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到<code>SetupConfigBuffer</code>旨在修正buffer中的各个成员。对<code>DllPatchInfo</code>的处理由两个函数协助完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Fills up just the part that depends on the dll, not the info that depends on</span><br><span class="hljs-comment">// the actual interception.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::SetupDllInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> InterceptionData&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">void</span>** buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">size_t</span>* buffer_bytes)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(buffer_bytes);<br>  <span class="hljs-built_in">DCHECK</span>(buffer);<br>  <span class="hljs-built_in">DCHECK</span>(*buffer);<br><br>  DllPatchInfo* dll_info = <span class="hljs-built_in">reinterpret_cast</span>&lt;DllPatchInfo*&gt;(*buffer);<br><br>  <span class="hljs-comment">// the strings have to be zero terminated</span><br>  <span class="hljs-type">size_t</span> required = <span class="hljs-built_in">offsetof</span>(DllPatchInfo, dll_name) +<br>                    (data.dll.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>);<br>  required = <span class="hljs-built_in">RoundUpToMultiple</span>(required, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>));<br>  <span class="hljs-keyword">if</span> (*buffer_bytes &lt; required)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  *buffer_bytes -= required;<br>  *buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(*buffer) + required;<br><br>  <span class="hljs-comment">// set up the dll info to be what we know about it at this time</span><br>  <span class="hljs-comment">// 首次处理一个dll时，仅仅填充了dll相关的信息，FunctionInfo还没有拉进来</span><br>  dll_info-&gt;unload_module = (data.type == INTERCEPTION_UNLOAD_MODULE);	<span class="hljs-comment">// 是不是要unload的dll</span><br>  dll_info-&gt;record_bytes = required;<br>  dll_info-&gt;offset_to_functions = required;<br>  dll_info-&gt;num_functions = <span class="hljs-number">0</span>;<br>  data.dll.<span class="hljs-built_in">copy</span>(dll_info-&gt;dll_name, data.dll.<span class="hljs-built_in">size</span>());<br>  dll_info-&gt;dll_name[data.dll.<span class="hljs-built_in">size</span>()] = <span class="hljs-string">L&#x27;\0&#x27;</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::SetupInterceptionInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> InterceptionData&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">void</span>** buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">size_t</span>* buffer_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                DllPatchInfo* dll_info)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(buffer_bytes);<br>  <span class="hljs-built_in">DCHECK</span>(buffer);<br>  <span class="hljs-built_in">DCHECK</span>(*buffer);<br><br>  <span class="hljs-comment">// 都要卸载了，还patch个毛，检查一下有没有这种矛盾的情况</span><br>  <span class="hljs-keyword">if</span> ((dll_info-&gt;unload_module) &amp;&amp; (data.function != kUnloadDLLDummyFunction)) &#123;<br>    <span class="hljs-comment">// Can&#x27;t specify a dll for both patch and unload.</span><br>    <span class="hljs-built_in">NOTREACHED</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 常规操作，把InterceptorData的信息全部倒出来，给FunctionInfo</span><br>  FunctionInfo* function = <span class="hljs-built_in">reinterpret_cast</span>&lt;FunctionInfo*&gt;(*buffer);<br><br>  <span class="hljs-type">size_t</span> name_bytes = data.function.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-type">size_t</span> interceptor_bytes = data.interceptor.<span class="hljs-built_in">size</span>();<br><br>  <span class="hljs-comment">// the strings at the end of the structure are zero terminated</span><br>  <span class="hljs-type">size_t</span> required =<br>      <span class="hljs-built_in">offsetof</span>(FunctionInfo, function) + name_bytes + interceptor_bytes + <span class="hljs-number">2</span>;<br>  required = <span class="hljs-built_in">RoundUpToMultiple</span>(required, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>));<br>  <span class="hljs-keyword">if</span> (*buffer_bytes &lt; required)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// update the caller&#x27;s values</span><br>  *buffer_bytes -= required;<br>  *buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(*buffer) + required;<br><br>  function-&gt;record_bytes = required;<br>  function-&gt;type = data.type;<br>  function-&gt;id = data.id;<br>  <span class="hljs-comment">// FunctionInfo实际上有interceptor_address</span><br>  function-&gt;interceptor_address = data.interceptor_address;<br>  <span class="hljs-type">char</span>* names = function-&gt;function;<br><br>  data.function.<span class="hljs-built_in">copy</span>(names, name_bytes);<br>  names += name_bytes;<br>  *names++ = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>  <span class="hljs-comment">// interceptor follows the function_name</span><br>  <span class="hljs-comment">// 所以对于第一种Add方法，这个interceptor_bytes应该就是0</span><br>  data.interceptor.<span class="hljs-built_in">copy</span>(names, interceptor_bytes);<br>  names += interceptor_bytes;<br>  *names++ = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>  <span class="hljs-comment">// update the dll table</span><br>  <span class="hljs-comment">// 这两个结构才是最为重要的，有他们才能正确定位尾随的FunctionInfo</span><br>  dll_info-&gt;num_functions++;		<br>  dll_info-&gt;record_bytes += required;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此后，buffer拷贝给child:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">InterceptionManager::CopyDataToChild</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* local_buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">size_t</span> buffer_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">void</span>** remote_buffer)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(remote_buffer);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == buffer_bytes) &#123;<br>    *remote_buffer = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>  &#125;<br><br>  <span class="hljs-comment">// 借助TargetProcess拿到target进程的句柄</span><br>  HANDLE child = child_-&gt;<span class="hljs-built_in">Process</span>();<br><br>  <span class="hljs-comment">// Allocate memory on the target process without specifying the address</span><br>  <span class="hljs-comment">// 经典的素质二连：VirtualAllocEx + WriteProcessMemory</span><br>  <span class="hljs-type">void</span>* remote_data = ::<span class="hljs-built_in">VirtualAllocEx</span>(child, <span class="hljs-literal">nullptr</span>, buffer_bytes, MEM_COMMIT,<br>                                       PAGE_READWRITE);<br>  <span class="hljs-keyword">if</span> (!remote_data)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_NO_SPACE;<br><br>  SIZE_T bytes_written;<br>  <span class="hljs-type">bool</span> success = ::<span class="hljs-built_in">WriteProcessMemory</span>(child, remote_data, local_buffer,<br>                                      buffer_bytes, &amp;bytes_written);<br>  <span class="hljs-keyword">if</span> (!success || bytes_written != buffer_bytes) &#123;<br>    ::<span class="hljs-built_in">VirtualFreeEx</span>(child, remote_data, <span class="hljs-number">0</span>, MEM_RELEASE);<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_COPY_DATA_TO_CHILD;<br>  &#125;<br><br>  <span class="hljs-comment">//注意remote_buffer参数是个二级指针，如此通过OUT型参数返回了分配地址</span><br>  *remote_buffer = remote_data;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此后<code>g_interceptions</code>值也传递（<code>TransferVariable</code>）过去，target就可以用它来索引这块<code>remote_buffer</code>。</p>
<p>分析至此，剩余三个疑点：</p>
<ol type="1">
<li>某个Interception是由target自己执行还是由broker执行，判断的具体条件是什么？</li>
<li>broker的fire函数仅仅只是把target自己要执行的Interceptions传递了过去，但具体是怎么使用的？broker端执行的Interceptions又是怎样使用的？</li>
<li><code>PatchNtdll</code>究竟是什么鬼？</li>
</ol>
<p>第一个问题实际上很简单，我们展开看看判断函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Only return true if the child should be able to perform this interception.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionManager::IsInterceptionPerformedByChild</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> InterceptionData&amp; data)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-comment">// 心智健全？</span><br>  <span class="hljs-keyword">if</span> (INTERCEPTION_INVALID == data.type)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 系统调用类型的Interception不能由target自己执行，要broker去执行</span><br>  <span class="hljs-keyword">if</span> (INTERCEPTION_SERVICE_CALL == data.type)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 心智健全？</span><br>  <span class="hljs-keyword">if</span> (data.type &gt;= INTERCEPTION_LAST)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// ntdll相关的Interception，都只能由broker执行</span><br>  <span class="hljs-function">base::string16 <span class="hljs-title">ntdll</span><span class="hljs-params">(kNtdllName)</span></span>;<br>  <span class="hljs-keyword">if</span> (ntdll == data.dll)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// ntdll has to be intercepted from the parent</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第二个问题涉及到了target进程使用的Agent对端，很快就会看到。</p>
<p>第三个我们展开<code>PatchNtdll</code>看看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">InterceptionManager::PatchNtdll</span><span class="hljs-params">(<span class="hljs-type">bool</span> hot_patch_needed)</span> </span>&#123;<br>  <span class="hljs-comment">// Maybe there is nothing to do</span><br>  <span class="hljs-comment">// 如果不需要热补丁且interception空空如也，就什么都不用做</span><br>  <span class="hljs-keyword">if</span> (!hot_patch_needed &amp;&amp; interceptions_.<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br><br>  <span class="hljs-comment">// 如果需要热补丁</span><br>  <span class="hljs-keyword">if</span> (hot_patch_needed) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(SANDBOX_EXPORTS)</span><br><span class="hljs-comment">// Make sure the functions are not excluded by the linker.</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/include:TargetNtMapViewOfSection64&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/include:TargetNtUnmapViewOfSection64&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/include:_TargetNtMapViewOfSection@44&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/include:_TargetNtUnmapViewOfSection@12&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// defined(SANDBOX_EXPORTS)</span></span><br>    <span class="hljs-comment">// 这个宏有点意思，第二个参数的两个InterceptorId是内部使用的前两个成员</span><br>    <span class="hljs-built_in">ADD_NT_INTERCEPTION</span>(NtMapViewOfSection, MAP_VIEW_OF_SECTION_ID, <span class="hljs-number">44</span>);<br>    <span class="hljs-built_in">ADD_NT_INTERCEPTION</span>(NtUnmapViewOfSection, UNMAP_VIEW_OF_SECTION_ID, <span class="hljs-number">12</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Reserve a full 64k memory range in the child process.</span><br>  <span class="hljs-comment">// 在target进程中储备一个64k大小的内存</span><br>  HANDLE child = child_-&gt;<span class="hljs-built_in">Process</span>();<br>  BYTE* thunk_base = <span class="hljs-built_in">reinterpret_cast</span>&lt;BYTE*&gt;(::<span class="hljs-built_in">VirtualAllocEx</span>(<br>      child, <span class="hljs-literal">nullptr</span>, kAllocGranularity, MEM_RESERVE, PAGE_NOACCESS));<br><br>  <span class="hljs-comment">// Find an aligned, random location within the reserved range.</span><br>  <span class="hljs-comment">// 每一个interceptions都占用一个ThunkData，ThunkData实际上是个char[64]包装</span><br>  <span class="hljs-comment">// DllInterceptionData是ThunkData flexible数组的头部</span><br>  <span class="hljs-type">size_t</span> thunk_bytes =<br>      interceptions_.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(ThunkData) + <span class="hljs-built_in">sizeof</span>(DllInterceptionData);<br>  <span class="hljs-comment">// 在64k内存中找到一个随机的偏移起始，当然偏移必须要合适，即64k-offset的尺寸比thunk_bytes大</span><br>  <span class="hljs-type">size_t</span> thunk_offset = internal::<span class="hljs-built_in">GetGranularAlignedRandomOffset</span>(thunk_bytes);<br><br>  <span class="hljs-comment">// Split the base and offset along page boundaries.</span><br>  thunk_base += thunk_offset &amp; ~(kPageSize - <span class="hljs-number">1</span>);<br>  thunk_offset &amp;= kPageSize - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// Make an aligned, padded allocation, and move the pointer to our chunk.</span><br>  <span class="hljs-type">size_t</span> thunk_bytes_padded = (thunk_bytes + kPageSize - <span class="hljs-number">1</span>) &amp; ~(kPageSize - <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 分配padded部分内存空间</span><br>  thunk_base = <span class="hljs-built_in">reinterpret_cast</span>&lt;BYTE*&gt;(<br>      ::<span class="hljs-built_in">VirtualAllocEx</span>(child, thunk_base, thunk_bytes_padded, MEM_COMMIT,<br>                       PAGE_EXECUTE_READWRITE));<br>  <span class="hljs-built_in">CHECK</span>(thunk_base);  <span class="hljs-comment">// If this fails we&#x27;d crash anyway on an invalid access.</span><br>  <span class="hljs-comment">// 找到存储DllInterceptionData的起始位置</span><br>  DllInterceptionData* thunks =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;DllInterceptionData*&gt;(thunk_base + thunk_offset);<br><br>  DllInterceptionData dll_data;<br>  dll_data.data_bytes = thunk_bytes;<br>  dll_data.num_thunks = <span class="hljs-number">0</span>;<br>  dll_data.used_bytes = <span class="hljs-built_in">offsetof</span>(DllInterceptionData, thunks);<br><br>  <span class="hljs-comment">// Reset all helpers for a new child.</span><br>  <span class="hljs-comment">// 清空g_originals全局函数指针数组</span><br>  <span class="hljs-built_in">memset</span>(g_originals, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(g_originals));<br><br>  <span class="hljs-comment">// this should write all the individual thunks to the child&#x27;s memory</span><br>  <span class="hljs-comment">// 对target进程的内存空间写入数据，这个函数看起来很关键</span><br>  ResultCode rc = <span class="hljs-built_in">PatchClientFunctions</span>(thunks, thunk_bytes, &amp;dll_data);<br><br>  <span class="hljs-keyword">if</span> (rc != SBOX_ALL_OK)<br>    <span class="hljs-keyword">return</span> rc;<br><br>  <span class="hljs-comment">// and now write the first part of the table to the child&#x27;s memory</span><br>  <span class="hljs-comment">// 这里向target进程的内存空间写入了DllInterceptionData头部数据</span><br>  <span class="hljs-comment">// 看起来PatchClientFunctions写的是ThunkData[]，并更新了dll_data的成员</span><br>  SIZE_T written;<br>  <span class="hljs-type">bool</span> ok =<br>      !!::<span class="hljs-built_in">WriteProcessMemory</span>(child, thunks, &amp;dll_data,<br>                             <span class="hljs-built_in">offsetof</span>(DllInterceptionData, thunks), &amp;written);<br><br>  <span class="hljs-keyword">if</span> (!ok || (<span class="hljs-built_in">offsetof</span>(DllInterceptionData, thunks) != written))<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_WRITE_INTERCEPTION_THUNK;<br><br>  <span class="hljs-comment">// Attempt to protect all the thunks, but ignore failure</span><br>  <span class="hljs-comment">// 对target进程这段空间设置为只读，不允许更改</span><br>  DWORD old_protection;<br>  ::<span class="hljs-built_in">VirtualProtectEx</span>(child, thunks, thunk_bytes, PAGE_EXECUTE_READ,<br>                     &amp;old_protection);<br><br>  <span class="hljs-comment">// 这里传过去了g_originals全局变量，显然这货肯定在PatchClientFunctions中调整了值</span><br>  ResultCode ret =<br>      child_-&gt;<span class="hljs-built_in">TransferVariable</span>(<span class="hljs-string">&quot;g_originals&quot;</span>, g_originals, <span class="hljs-built_in">sizeof</span>(g_originals));<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看看<code>ADD_NT_INTERCEPTION</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD_NT_INTERCEPTION(service, id, num_params)        \</span><br><span class="hljs-meta">  AddToPatchedFunctions(kNtdllName, #service,               \</span><br><span class="hljs-meta">                        sandbox::INTERCEPTION_SERVICE_CALL, \</span><br><span class="hljs-meta">                        MAKE_SERVICE_NAME(service, num_params), id)</span><br><br><span class="hljs-comment">// This macro simply calls interception_manager.AddToPatchedFunctions with</span><br><span class="hljs-comment">// the given service to intercept (INTERCEPTION_SERVICE_CALL), and assumes that</span><br><span class="hljs-comment">// the interceptor is called &quot;TargetXXX&quot;, where XXX is the name of the service.</span><br><span class="hljs-comment">// Note that num_params is the number of bytes to pop out of the stack for</span><br><span class="hljs-comment">// the exported interceptor, following the calling convention of a service call</span><br><span class="hljs-comment">// (WINAPI = with the &quot;C&quot; underscore).</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SANDBOX_EXPORTS</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_SERVICE_NAME(service, params) <span class="hljs-string">&quot;Target&quot;</span> #service <span class="hljs-string">&quot;64&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_SERVICE_NAME(service, params) <span class="hljs-string">&quot;_Target&quot;</span> #service <span class="hljs-string">&quot;@&quot;</span> #params</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>其实就是拦截ntdll中的某个系统调用，拦截的函数x64上叫TargetXXX64，x86叫_TargetXXX@YYY。</p>
<p>XXX是系统调用名称，YYY是拦截器在栈上所用的字节数。有个问题在于，这个拦截函数是在哪儿定义的呢？</p>
<p>再看关键Call：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ResultCode <span class="hljs-title">InterceptionManager::PatchClientFunctions</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    DllInterceptionData* thunks,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">size_t</span> thunk_bytes,</span></span><br><span class="hljs-params"><span class="hljs-function">    DllInterceptionData* dll_data)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(thunks);<br>  <span class="hljs-built_in">DCHECK</span>(dll_data);<br><br>  <span class="hljs-comment">// 拿到ntdll基址</span><br>  HMODULE ntdll_base = ::<span class="hljs-built_in">GetModuleHandle</span>(kNtdllName);<br>  <span class="hljs-keyword">if</span> (!ntdll_base)<br>    <span class="hljs-keyword">return</span> SBOX_ERROR_NO_HANDLE;<br><br>  <span class="hljs-type">char</span>* interceptor_base = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(SANDBOX_EXPORTS)</span><br>  interceptor_base = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(child_-&gt;<span class="hljs-built_in">MainModule</span>());<br>  <span class="hljs-function">base::ScopedNativeLibrary <span class="hljs-title">local_interceptor</span><span class="hljs-params">(::LoadLibrary(child_-&gt;Name()))</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// defined(SANDBOX_EXPORTS)</span></span><br><br>  <span class="hljs-comment">// 这个ServiceResolverThunk是个什么东西？</span><br>  std::unique_ptr&lt;ServiceResolverThunk&gt; thunk;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64)</span><br>  thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ServiceResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  base::win::OSInfo* os_info = base::win::OSInfo::<span class="hljs-built_in">GetInstance</span>();<br>  <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">wow64_status</span>() == base::win::OSInfo::WOW64_ENABLED) &#123;<br>    <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">version</span>() &gt;= base::win::VERSION_WIN10)<br>      thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Wow64W10ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">version</span>() &gt;= base::win::VERSION_WIN8)<br>      thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Wow64W8ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>    <span class="hljs-keyword">else</span><br>      thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Wow64ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (os_info-&gt;<span class="hljs-built_in">version</span>() &gt;= base::win::VERSION_WIN8) &#123;<br>    thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Win8ResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    thunk.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ServiceResolverThunk</span>(child_-&gt;<span class="hljs-built_in">Process</span>(), relaxed_));<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> interception : interceptions_) &#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> base::string16 <span class="hljs-title">ntdll</span><span class="hljs-params">(kNtdllName)</span></span>;<br>    <span class="hljs-comment">// 必须的是ntdll的系统调用类型拦截器</span><br>    <span class="hljs-keyword">if</span> (interception.dll != ntdll)<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br>    <span class="hljs-keyword">if</span> (INTERCEPTION_SERVICE_CALL != interception.type)<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_BAD_PARAMS;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(SANDBOX_EXPORTS)</span><br>    <span class="hljs-comment">// We may be trying to patch by function name.</span><br>    <span class="hljs-keyword">if</span> (!interception.interceptor_address) &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* address;<br>      NTSTATUS ret = thunk-&gt;<span class="hljs-built_in">ResolveInterceptor</span>(<br>          local_interceptor.<span class="hljs-built_in">get</span>(), interception.interceptor.<span class="hljs-built_in">c_str</span>(),<br>          <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">void</span>**&gt;(&amp;address));<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret)) &#123;<br>        ::<span class="hljs-built_in">SetLastError</span>(<span class="hljs-built_in">GetLastErrorFromNtStatus</span>(ret));<br>        <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_RESOLVE_INTERCEPTION_THUNK;<br>      &#125;<br><br>      <span class="hljs-comment">// Translate the local address to an address on the child.</span><br>      interception.interceptor_address =<br>          interceptor_base +<br>          (address - <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(local_interceptor.<span class="hljs-built_in">get</span>()));<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// defined(SANDBOX_EXPORTS)</span></span><br>    NTSTATUS ret = thunk-&gt;<span class="hljs-built_in">Setup</span>(<br>        ntdll_base, interceptor_base, interception.function.<span class="hljs-built_in">c_str</span>(),<br>        interception.interceptor.<span class="hljs-built_in">c_str</span>(), interception.interceptor_address,<br>        &amp;thunks-&gt;thunks[dll_data-&gt;num_thunks],	<span class="hljs-comment">// 这里把thunk发在了thunks中，thunks实际上是child的内存空间</span><br>        thunk_bytes - dll_data-&gt;used_bytes, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret)) &#123;<br>      ::<span class="hljs-built_in">SetLastError</span>(<span class="hljs-built_in">GetLastErrorFromNtStatus</span>(ret));<br>      <span class="hljs-keyword">return</span> SBOX_ERROR_CANNOT_SETUP_INTERCEPTION_THUNK;<br>    &#125;<br><br>    <span class="hljs-comment">// 看起来都是围绕着ServiceResolverThunk对象的操作，暂时不关心他具体做了什么</span><br>    <span class="hljs-comment">// 但这里可以看到g_originals的ntdll service call的id索引到了正确的thunks</span><br>    <span class="hljs-comment">// 实际上就是Interceptor id中第一个类别：internal</span><br>    <span class="hljs-built_in">DCHECK</span>(!g_originals[interception.id]);<br>    g_originals[interception.id] = &amp;thunks-&gt;thunks[dll_data-&gt;num_thunks];<br><br>    dll_data-&gt;num_thunks++;<br>    dll_data-&gt;used_bytes += <span class="hljs-built_in">sizeof</span>(ThunkData);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> SBOX_ALL_OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>PatchNtdll</code>看得云里雾里，看起来<code>InterceptionManager</code>确实是个名副其实的管理者，负责的工作有限，我们到此还没有看到完整的功能拼图。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Dummy single thunk:</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThunkData</span> &#123;<br>  <span class="hljs-type">char</span> data[kMaxThunkDataBytes];<br>&#125;;<br><br><span class="hljs-comment">// In-memory representation of the interceptions for a given dll:</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DllInterceptionData</span> &#123;<br>  <span class="hljs-type">size_t</span> data_bytes;<br>  <span class="hljs-type">size_t</span> used_bytes;<br>  <span class="hljs-type">void</span>* base;<br>  <span class="hljs-type">int</span> num_thunks;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN64)</span><br>  <span class="hljs-type">int</span> dummy;  <span class="hljs-comment">// Improve alignment.</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  ThunkData thunks[<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="interceptionagent"><code>InterceptionAgent</code></h2>
<p>暂时不理<code>ServiceResolverThunk</code>，去看看target进程的收端Agent：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// of setting up the desired interceptions or indicating what module needs to</span><br><span class="hljs-comment">// be unloaded.</span><br><span class="hljs-comment">// target进程上部署具体的拦截器，broker的manager把interceptions发了过来</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// The exposed API consists of three methods: GetInterceptionAgent to retrieve</span><br><span class="hljs-comment">// the single class instance, OnDllLoad and OnDllUnload to process a dll being</span><br><span class="hljs-comment">// loaded and unloaded respectively.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This class assumes that it will get called for every dll being loaded,</span><br><span class="hljs-comment">// starting with kernel32, so the singleton will be instantiated from within the</span><br><span class="hljs-comment">// loader lock.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptionAgent</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Returns the single InterceptionAgent object for this process.</span><br>  <span class="hljs-comment">// InterceptionAgent是单例模式</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> InterceptionAgent* <span class="hljs-title">GetInterceptionAgent</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// This method should be invoked whenever a new dll is loaded to perform the</span><br>  <span class="hljs-comment">// required patches. If the return value is false, this dll should not be</span><br>  <span class="hljs-comment">// allowed to load.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// full_path is the (optional) full name of the module being loaded and name</span><br>  <span class="hljs-comment">// is the internal module name. If full_path is provided, it will be used</span><br>  <span class="hljs-comment">// before the internal name to determine if we care about this dll.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OnDllLoad</span><span class="hljs-params">(<span class="hljs-type">const</span> UNICODE_STRING* full_path, <span class="hljs-type">const</span> UNICODE_STRING* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">void</span>* base_address)</span></span>;<br><br>  <span class="hljs-comment">// Performs cleanup when a dll is unloaded.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnDllUnload</span><span class="hljs-params">(<span class="hljs-type">void</span>* base_address)</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  ~<span class="hljs-built_in">InterceptionAgent</span>() &#123;&#125;	<span class="hljs-comment">// 限定到static成员使用</span><br><br>  <span class="hljs-comment">// Performs initialization of the singleton.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Init</span><span class="hljs-params">(SharedMemory* shared_memory)</span></span>;<br><br>  <span class="hljs-comment">// Returns true if we are interested on this dll. dll_info is an entry of the</span><br>  <span class="hljs-comment">// list of intercepted dlls.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DllMatch</span><span class="hljs-params">(<span class="hljs-type">const</span> UNICODE_STRING* full_path, <span class="hljs-type">const</span> UNICODE_STRING* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> DllPatchInfo* dll_info)</span></span>;<br><br>  <span class="hljs-comment">// Performs the patching of the dll loaded at base_address.</span><br>  <span class="hljs-comment">// The patches to perform are described on dll_info, and thunks is the thunk</span><br>  <span class="hljs-comment">// storage for the whole dll.</span><br>  <span class="hljs-comment">// Returns true on success.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PatchDll</span><span class="hljs-params">(<span class="hljs-type">const</span> DllPatchInfo* dll_info, DllInterceptionData* thunks)</span></span>;<br><br>  <span class="hljs-comment">// 这里又出现了一个ResolverThunk</span><br>  <span class="hljs-comment">// Returns a resolver for a given interception type.</span><br>  <span class="hljs-function">ResolverThunk* <span class="hljs-title">GetResolver</span><span class="hljs-params">(InterceptionType type)</span></span>;<br><br>  <span class="hljs-comment">// 这个是SharedMemory结构</span><br>  <span class="hljs-comment">// 里面描述了有哪些dll，每个dll的哪些函数被hook了</span><br>  <span class="hljs-comment">// Shared memory containing the list of functions to intercept.</span><br>  SharedMemory* interceptions_;<br><br>  <span class="hljs-comment">// Array of thunk data buffers for the intercepted dlls. This object singleton</span><br>  <span class="hljs-comment">// is allocated with a placement new with enough space to hold the complete</span><br>  <span class="hljs-comment">// array of pointers, not just the first element.</span><br>  <span class="hljs-comment">// 这个是DllInterceptionData flexible数组结构，每个dll对应一个成员，这里面承载的是thunk数据</span><br>  DllInterceptionData* dlls_[<span class="hljs-number">1</span>];<br><br>  <span class="hljs-built_in">DISALLOW_IMPLICIT_CONSTRUCTORS</span>(InterceptionAgent);<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="getinterceptionagent"><code>GetInterceptionAgent</code></h3>
<p>先看看单例模式的静态Get方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Memory buffer mapped from the parent, with the list of interceptions.</span><br><span class="hljs-comment">// 这个已经认识了，存储数据的内存空间由broker开辟，g_interceptions会指向那段空间</span><br>SANDBOX_INTERCEPT SharedMemory* g_interceptions = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function">InterceptionAgent* <span class="hljs-title">InterceptionAgent::GetInterceptionAgent</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">static</span> InterceptionAgent* s_singleton = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (!s_singleton) &#123;<br>    <span class="hljs-keyword">if</span> (!g_interceptions)	<span class="hljs-comment">// broker得把信息发过来先</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// 注意这里并不是直接new InterceptionAgent对象，而是附加了array_bytes尺寸</span><br>    <span class="hljs-comment">// 附加的尺寸实际上就是flexible成员dlls_这个DllInterceptionData指针数组的尺寸</span><br>    <span class="hljs-comment">// 每有一个dll，就分配一个DllInterceptionData指针出来</span><br>    <span class="hljs-type">size_t</span> array_bytes = g_interceptions-&gt;num_intercepted_dlls * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*);<br>    s_singleton = <span class="hljs-built_in">reinterpret_cast</span>&lt;InterceptionAgent*&gt;(<br>        <span class="hljs-built_in">new</span> (NT_ALLOC) <span class="hljs-type">char</span>[array_bytes + <span class="hljs-built_in">sizeof</span>(InterceptionAgent)]);<br><br>    <span class="hljs-comment">// 实际上是个“零化”函数，全局g_interceptions会在broker中设置，然后调整interceptions_成员</span><br>    <span class="hljs-comment">// 指向这片内存空间，此外，所有的dlls_[i]（每个对应一个DllInterceptionData结构）先指向null</span><br>    <span class="hljs-type">bool</span> success = s_singleton-&gt;<span class="hljs-built_in">Init</span>(g_interceptions);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>      <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(s_singleton, NT_ALLOC)</span></span>;<br>      s_singleton = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s_singleton;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="ondllload"><code>OnDllLoad</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionAgent::OnDllLoad</span><span class="hljs-params">(<span class="hljs-type">const</span> UNICODE_STRING* full_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">const</span> UNICODE_STRING* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">void</span>* base_address)</span> </span>&#123;<br>  <span class="hljs-comment">// 解包，拿到DllPatchInfo结构</span><br>  DllPatchInfo* dll_info = interceptions_-&gt;dll_list;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 当dll加载时，先看看想要加载的这个dll是否在拦截列表里</span><br>  <span class="hljs-keyword">for</span> (; i &lt; interceptions_-&gt;num_intercepted_dlls; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">DllMatch</span>(full_path, name, dll_info))<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 定位下一个DllPatchInfo</span><br>    dll_info = <span class="hljs-built_in">reinterpret_cast</span>&lt;DllPatchInfo*&gt;(<br>        <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(dll_info) + dll_info-&gt;record_bytes);<br>  &#125;<br><br>  <span class="hljs-comment">// Return now if the dll is not in our list of interest.</span><br>  <span class="hljs-comment">// 如果不在，说明拦截器对它没兴趣，那么直接load就行了</span><br>  <span class="hljs-keyword">if</span> (i == interceptions_-&gt;num_intercepted_dlls)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// The dll must be unloaded.</span><br>  <span class="hljs-comment">// 到此说明拦截器有这个dll，如果它unload_module的true，那么就表示不允许load</span><br>  <span class="hljs-keyword">if</span> (dll_info-&gt;unload_module)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// Purify causes this condition to trigger.</span><br>  <span class="hljs-comment">// 看看是否已经部署了Dll的DllInterceptionData，也就是拦截器已实装。如果已经实装了，就let it go</span><br>  <span class="hljs-keyword">if</span> (dlls_[i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// 还没有的话就要new出来这个dlls_[i]</span><br>  <span class="hljs-comment">// 每个拦截的函数都有一个ThunkData，为这个拦截dll分配出DllInterceptionData</span><br>  <span class="hljs-comment">// 在dll加载的base_address处分配，这个base_address是参数，究竟把这些thunk data写到了哪里呢？</span><br>  <span class="hljs-type">size_t</span> buffer_bytes = <span class="hljs-built_in">offsetof</span>(DllInterceptionData, thunks) +<br>                        dll_info-&gt;num_functions * <span class="hljs-built_in">sizeof</span>(ThunkData);<br>  dlls_[i] = <span class="hljs-built_in">reinterpret_cast</span>&lt;DllInterceptionData*&gt;(<br>      <span class="hljs-built_in">new</span> (NT_PAGE, base_address) <span class="hljs-type">char</span>[buffer_bytes]);<br><br>  <span class="hljs-built_in">DCHECK_NT</span>(dlls_[i]);<br>  <span class="hljs-comment">// 这种情况居然返回true？我很好奇如何fall through</span><br>  <span class="hljs-keyword">if</span> (!dlls_[i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// 这个时候还仅仅只是一片初始化的空间，ThunkData未填充，num_thunks待更新</span><br>  dlls_[i]-&gt;data_bytes = buffer_bytes;<br>  dlls_[i]-&gt;num_thunks = <span class="hljs-number">0</span>;<br>  dlls_[i]-&gt;base = base_address;<br>  dlls_[i]-&gt;used_bytes = <span class="hljs-built_in">offsetof</span>(DllInterceptionData, thunks);<br><br>  <span class="hljs-comment">// 这个PatchDll看起来很关键，从传入的两个参数就能看出来，应该是真正的thunk实装</span><br>  <span class="hljs-built_in">VERIFY</span>(<span class="hljs-built_in">PatchDll</span>(dll_info, dlls_[i]));<br><br>  <span class="hljs-comment">// dlls_[i]指向的这段内存标记为RE，防止Write</span><br>  ULONG old_protect;<br>  SIZE_T real_size = buffer_bytes;<br>  <span class="hljs-type">void</span>* to_protect = dlls_[i];<br>  <span class="hljs-built_in">VERIFY_SUCCESS</span>(g_nt.<span class="hljs-built_in">ProtectVirtualMemory</span>(NtCurrentProcess, &amp;to_protect,<br>                                           &amp;real_size, PAGE_EXECUTE_READ,<br>                                           &amp;old_protect));<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键的<code>PatchDll</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TODO(rvargas): We have to deal with prebinded dlls. I see two options: change</span><br><span class="hljs-comment">// the timestamp of the patched dll, or modify the info on the prebinded dll.</span><br><span class="hljs-comment">// the first approach messes matching of debug symbols, the second one is more</span><br><span class="hljs-comment">// complicated.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InterceptionAgent::PatchDll</span><span class="hljs-params">(<span class="hljs-type">const</span> DllPatchInfo* dll_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 DllInterceptionData* thunks)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_NT</span>(thunks);<br>  <span class="hljs-built_in">DCHECK_NT</span>(dll_info);<br><br>  <span class="hljs-comment">// 定位到DllPatchInfo中的第一个FunctionInfo</span><br>  <span class="hljs-type">const</span> FunctionInfo* function = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> FunctionInfo*&gt;(<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(dll_info) + dll_info-&gt;offset_to_functions);<br><br>  <span class="hljs-comment">// 对每个需要interception的函数进行处理</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dll_info-&gt;num_functions; i++) &#123;<br>    <span class="hljs-comment">// 尺寸校验</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsWithinRange</span>(dll_info, dll_info-&gt;record_bytes, function-&gt;function)) &#123;<br>      <span class="hljs-built_in">NOTREACHED_NT</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里用到了resolver，function-&gt;type指定了这是哪一类别的interception，所以就找到具体的resolver</span><br>    <span class="hljs-comment">// 怎么看resolver都是个父类指针指向子类对象，而猜测每一种type的interception都会有一个resolver</span><br>    ResolverThunk* resolver = <span class="hljs-built_in">GetResolver</span>(function-&gt;type);<br>    <span class="hljs-keyword">if</span> (!resolver)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// interceptor的名称紧随function的名称其后</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* interceptor =<br>        function-&gt;function + g_nt.<span class="hljs-built_in">strlen</span>(function-&gt;function) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsWithinRange</span>(function, function-&gt;record_bytes, interceptor) ||<br>        !<span class="hljs-built_in">IsWithinRange</span>(dll_info, dll_info-&gt;record_bytes, interceptor)) &#123;<br>      <span class="hljs-built_in">NOTREACHED_NT</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>	<span class="hljs-comment">// resolver的Setup方法看起来很关键，thunk data和DllPatchInfo的关联就在此处</span><br>    NTSTATUS ret = resolver-&gt;<span class="hljs-built_in">Setup</span>(<br>        thunks-&gt;base, interceptions_-&gt;interceptor_base, function-&gt;function,<br>        interceptor, function-&gt;interceptor_address, &amp;thunks-&gt;thunks[i],<br>        <span class="hljs-built_in">sizeof</span>(ThunkData), <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NT_SUCCESS</span>(ret)) &#123;<br>      <span class="hljs-built_in">NOTREACHED_NT</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">DCHECK_NT</span>(!g_originals[function-&gt;id]);<br>    <span class="hljs-comment">// 这里调整了g_originals的数组成员，根据被拦截函数的id，索引指针指向正确的thunk data</span><br>    <span class="hljs-comment">// 看起来DllPatchInfo中的FunctionInfo和DllInterceptionData中的ThunkData一一对应</span><br>    <span class="hljs-comment">// FunctionInfo[i]-&gt;ThunkData[i]</span><br>    g_originals[function-&gt;id] = &amp;thunks-&gt;thunks[i];<br><br>    <span class="hljs-comment">// 更新DllInterceptionData的数据成员</span><br>    thunks-&gt;num_thunks++;<br>    thunks-&gt;used_bytes += <span class="hljs-built_in">sizeof</span>(ThunkData);<br><br>    <span class="hljs-comment">// 但FunctionInfo毕竟是不定长的，不能用FunctionInfo[i]，所以要通过record_bytes来step</span><br>    function = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> FunctionInfo*&gt;(<br>        <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(function) + function-&gt;record_bytes);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>具体resolver是如何利用的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This method is called from within the loader lock</span><br><span class="hljs-function">ResolverThunk* <span class="hljs-title">InterceptionAgent::GetResolver</span><span class="hljs-params">(InterceptionType type)</span> </span>&#123;<br>  <span class="hljs-comment">// 这几个都是ResolverThunk的派生类，根据名称可以发现和type息息相关</span><br>  <span class="hljs-comment">// 看起来此前的推断是正确的</span><br>  <span class="hljs-type">static</span> EatResolverThunk* eat_resolver = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-type">static</span> SidestepResolverThunk* sidestep_resolver = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-type">static</span> SmartSidestepResolverThunk* smart_sidestep_resolver = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-comment">// static成员，在第一次进入时new出单例</span><br>  <span class="hljs-keyword">if</span> (!eat_resolver)<br>    eat_resolver = <span class="hljs-built_in">new</span> (NT_ALLOC) EatResolverThunk;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(_WIN64)</span><br>  <span class="hljs-comment">// Sidestep is not supported for x64.</span><br>  <span class="hljs-comment">// sidestep和smart_sidestep不能在x64上使用</span><br>  <span class="hljs-keyword">if</span> (!sidestep_resolver)<br>    sidestep_resolver = <span class="hljs-built_in">new</span> (NT_ALLOC) SidestepResolverThunk;<br><br>  <span class="hljs-keyword">if</span> (!smart_sidestep_resolver)<br>    smart_sidestep_resolver = <span class="hljs-built_in">new</span> (NT_ALLOC) SmartSidestepResolverThunk;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">// 根据type返回对应type的resolver</span><br>  <span class="hljs-comment">// 注意到实际上只有3种类型，少了service call和unload module</span><br>  <span class="hljs-comment">// unload module可以理解，毕竟不涉及到function的interception，但service call为什么用不到呢？</span><br>  <span class="hljs-comment">// 根据此前对两种interception的了解，service call应该都是由broker来执行的，target并不会用到</span><br>  <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> INTERCEPTION_EAT:<br>      <span class="hljs-keyword">return</span> eat_resolver;<br>    <span class="hljs-keyword">case</span> INTERCEPTION_SIDESTEP:<br>      <span class="hljs-keyword">return</span> sidestep_resolver;<br>    <span class="hljs-keyword">case</span> INTERCEPTION_SMART_SIDESTEP:<br>      <span class="hljs-keyword">return</span> smart_sidestep_resolver;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-built_in">NOTREACHED_NT</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>另一个最为关键的就是<code>Resolver</code>的<code>Setup</code>方法了，是他把<code>ThunkData</code>和<code>FunctionInfo</code>关联了起来，实装了补丁，那么具体是如何操纵的呢？我们下一篇抽离<code>Resolver</code>相关内容单独分析。</p>
<h3 id="ondllunload"><code>OnDllUnload</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InterceptionAgent::OnDllUnload</span><span class="hljs-params">(<span class="hljs-type">void</span>* base_address)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; interceptions_-&gt;num_intercepted_dlls; i++) &#123;<br>    <span class="hljs-comment">// 这种逻辑处理方式，如果有两个感兴趣的dll在load的时候，base_address一致怎么办？</span><br>    <span class="hljs-comment">// 这样就可能在unload时找错了目标。</span><br>    <span class="hljs-comment">// 但仔细想想，如果base_address是dll加载基址的话，不同dll也不可能具有相同的base_address</span><br>    <span class="hljs-comment">// 所以这个base_address的意义就很重要了</span><br>    <span class="hljs-keyword">if</span> (dlls_[i] &amp;&amp; dlls_[i]-&gt;base == base_address) &#123;<br>      <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(dlls_[i], NT_PAGE)</span></span>;<br>      dlls_[i] = <span class="hljs-literal">nullptr</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个就相当简单了，此前安装的dll如果部署了interception，那就需要delete掉在<code>base_address</code>分配的内存空间。这部分内存空间此前用来承载thunk
data。</p>
<p>到此，<code>Interception</code>相关的Manager和Agent就分析完了，显然缺少了<code>Resolver</code>的介入，我们对整个流程还是不甚清楚，下一节我们分析<code>Resolver</code>，直捣黄龙。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="category-chain-item">源码剖析</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/chromium/" class="print-no-link">#chromium</a>
      
        <a href="/tags/chromium-sandbox/" class="print-no-link">#chromium-sandbox</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Chromium-sandbox-Interception-analysis</div>
      <div>https://r00tk1ts.github.io/2018/05/26/chromium-sandbox-Interception/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>r00tk1t</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2018年5月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/05/26/chromium-sandbox-Resolver-analysis/" title="Chromium-sandbox-Resolver-analysis">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Chromium-sandbox-Resolver-analysis</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/05/21/chromium-sandbox-HandleCloser-analysis/" title="Chromium-sandbox-HandleCloser-analysis">
                        <span class="hidden-mobile">Chromium-sandbox-HandleCloser-analysis</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/diy/yinghua.js"></script>
<script src="/js/diy/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
