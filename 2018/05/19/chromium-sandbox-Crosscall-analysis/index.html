

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="r00tk1t">
  <meta name="keywords" content="">
  
    <meta name="description" content="本篇是sandbox源码剖析的第七篇，主要分析了windows平台下，Chromium sandbox IPC通信中参数返回值的封装以及IPC Channel Buffer的结构设计。本篇相对独立，可以直接阅读。 想要流程的阅读本系列你需要以下几个条件： 1. 较高水平的C++编码能力（至少通读C++ Primer 5th，刷过课后题，有一定编码量）。 2. 熟悉Windows API编程，尤其是">
<meta property="og:type" content="article">
<meta property="og:title" content="Chromium-sandbox-crosscall-analysis">
<meta property="og:url" content="https://r00tk1ts.github.io/2018/05/19/chromium-sandbox-Crosscall-analysis/index.html">
<meta property="og:site_name" content="玉涵的技能书">
<meta property="og:description" content="本篇是sandbox源码剖析的第七篇，主要分析了windows平台下，Chromium sandbox IPC通信中参数返回值的封装以及IPC Channel Buffer的结构设计。本篇相对独立，可以直接阅读。 想要流程的阅读本系列你需要以下几个条件： 1. 较高水平的C++编码能力（至少通读C++ Primer 5th，刷过课后题，有一定编码量）。 2. 熟悉Windows API编程，尤其是">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-05-19T02:31:11.000Z">
<meta property="article:modified_time" content="2024-04-22T03:34:00.165Z">
<meta property="article:author" content="r00tk1t">
<meta property="article:tag" content="chromium">
<meta property="article:tag" content="chromium-sandbox">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Chromium-sandbox-crosscall-analysis - 玉涵的技能书</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"r00tk1ts.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>玉涵的技能书</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/doc/">
                <i class="iconfont icon-books"></i>
                <span>藏经阁</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Chromium-sandbox-crosscall-analysis"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2018-05-19 10:31" pubdate>
          2018年5月19日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          40k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          333 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Chromium-sandbox-crosscall-analysis</h1>
            
            
              <div class="markdown-body">
                
                <p>本篇是sandbox源码剖析的第七篇，主要分析了windows平台下，Chromium
sandbox IPC通信中参数返回值的封装以及IPC Channel
Buffer的结构设计。本篇相对独立，可以直接阅读。</p>
<p>想要流程的阅读本系列你需要以下几个条件： 1.
较高水平的C++编码能力（至少通读C++ Primer
5th，刷过课后题，有一定编码量）。 2. 熟悉Windows
API编程，尤其是安全相关的内容。 3.
对二进制安全有一定了解，熟悉各类型安全漏洞成因、漏洞缓解措施及bypass手法。</p>
<span id="more"></span>
<h1
id="chromium-sandbox-crosscall-analysis">chromium-sandbox-crosscall-analysis</h1>
<h2 id="common-gargets">Common gargets</h2>
<p>CrossCall是沙盒IPC实现的灵魂。想要了解CrossCall代码，势必先了解它的设计。从crosscall_params.h的注释头可以获取大量的有用信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This header is part of CrossCall: the sandbox inter-process communication.</span><br><span class="hljs-comment">// This header defines the basic types used both in the client IPC and in the</span><br><span class="hljs-comment">// server IPC code. CrossCallParams and ActualCallParams model the input</span><br><span class="hljs-comment">// parameters of an IPC call and CrossCallReturn models the output params and</span><br><span class="hljs-comment">// the return value.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// An IPC call is defined by its &#x27;tag&#x27; which is a (uint32_t) unique identifier</span><br><span class="hljs-comment">// that is used to route the IPC call to the proper server. Every tag implies</span><br><span class="hljs-comment">// a complete call signature including the order and type of each parameter.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Like most IPC systems. CrossCall is designed to take as inputs &#x27;simple&#x27;</span><br><span class="hljs-comment">// types such as integers and strings. Classes, generic arrays or pointers to</span><br><span class="hljs-comment">// them are not supported.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Another limitation of CrossCall is that the return value and output</span><br><span class="hljs-comment">// parameters can only be uint32_t integers. Returning complex structures or</span><br><span class="hljs-comment">// strings is not supported.</span><br></code></pre></td></tr></table></figure>
<p>简单梳理一下：</p>
<ol type="1">
<li>client和server端通过IPC通信，其中<code>CrossCallParams</code>和<code>ActualCallParams</code>封装了client端发起IPC调用的输入型参数，而<code>CrossCallReturn</code>封装了输出型参数和返回值。</li>
<li>每种IPC调用都以它的tag区分，tag是个<code>uint32_t</code>类型值，不同的值对应不同的IPC调用。tag用以将IPC调用转发给正确的server处理，每种tag类型暗示了一套完整的调用签名，这包括参数的类型和顺序。</li>
<li>CrossCall的输入参数只能使用整型、字符串等简单类型。类、数组或指针是不行的。</li>
<li>CrossCall的另一个限制在于返回值和输出参数只能是<code>uint32_t</code>类型，不能返回复杂的结构体或字符串。</li>
</ol>
<blockquote>
<p>其实<code>uint32_t</code>已经绰绰有余了，x86平台指针也是32位的，可以做类型转换。</p>
</blockquote>
<h3 id="infrastructure">Infrastructure</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// max number of extended return parameters. See CrossCallReturn</span><br><span class="hljs-comment">// 输出型参数最多只能有8个，不清楚是否包括返回值，等到看CrossCallReturn时再说</span><br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kExtendedReturnCount = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">// Union of multiple types to be used as extended results</span><br><span class="hljs-comment">// in the CrossCallReturn.</span><br><span class="hljs-comment">// 前面已经看到了，返回值和输出型参数只能是uint32_t</span><br><span class="hljs-comment">// 实际上这种说法不严谨，编码意义上的本质在于只能使用32位的值。</span><br><span class="hljs-comment">// 32位的值可以表示一个任意类型x86指针，可以表示句柄等等。</span><br><span class="hljs-comment">// 下面的union就整理了CrossCallReturn可能会用到的几种类型</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">MultiType</span> &#123;<br>  <span class="hljs-type">uint32_t</span> unsigned_int;<br>  <span class="hljs-type">void</span>* pointer;<br>  HANDLE handle;<br>  ULONG_PTR ulong_ptr;<br>&#125;;<br><br><span class="hljs-comment">// Maximum number of IPC parameters currently supported.</span><br><span class="hljs-comment">// To increase this value, we have to:</span><br><span class="hljs-comment">//  - Add another Callback typedef to Dispatcher.</span><br><span class="hljs-comment">//  - Add another case to the switch on SharedMemIPCServer::InvokeCallback.</span><br><span class="hljs-comment">//  - Add another case to the switch in GetActualAndMaxBufferSize</span><br><span class="hljs-comment">// 这个应该是IPC参数的最大数量</span><br><span class="hljs-comment">// 看起来如果扩展参数数量会相当麻烦：</span><br><span class="hljs-comment">//		- Dispatcher的Callback需要增加</span><br><span class="hljs-comment">//		- SharedMemIPCServer::InvokeCallback的switch需要加个case</span><br><span class="hljs-comment">//		- GetActualAndMaxBufferSize的switch需要加个case</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kMaxIpcParams = <span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure>
<p>再看IPC buffer的info封装：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Contains the information about a parameter in the ipc buffer.</span><br><span class="hljs-comment">// IPC通信无论如何折腾，最本质的client用buffer承载数据，将其发给server</span><br><span class="hljs-comment">// ParamInfo则抽象了buffer中的某个参数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ParamInfo</span> &#123;<br>  ArgType type_;	<span class="hljs-comment">// 看下面</span><br>  <span class="hljs-type">uint32_t</span> offset_;	<span class="hljs-comment">// 真实数据偏移</span><br>  <span class="hljs-type">uint32_t</span> size_;	<span class="hljs-comment">// 真实数据尺寸</span><br>&#125;;<br><span class="hljs-comment">// 这种offset+size的组合通常来说都是真实数据游离于ParamInfo结构之外</span><br><span class="hljs-comment">// 而真实数据append到ParamInfo后面的某个地址处，offset和size用于定位真实数据的起始</span><br><br><span class="hljs-comment">// Defines the supported C++ types encoding to numeric id. Like a simplified</span><br><span class="hljs-comment">// RTTI. Note that true C++ RTTI will not work because the types are not</span><br><span class="hljs-comment">// polymorphic anyway.</span><br><span class="hljs-comment">// 这个就表示参数（上面提到的真实数据）是哪一种C++类型，用枚举来表示</span><br><span class="hljs-comment">// 这就很像一个简化的RTTI（runtime type identify），当然了这些类型没有多态所以RTTI是没戏的。</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ArgType</span> &#123;<br>  INVALID_TYPE = <span class="hljs-number">0</span>,<br>  WCHAR_TYPE,<br>  UINT32_TYPE,<br>  UNISTR_TYPE,<br>  VOIDPTR_TYPE,<br>  INPTR_TYPE,<br>  INOUTPTR_TYPE,<br>  LAST_TYPE<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="crosscallreturn"><code>CrossCallReturn</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Models the return value and the return parameters of an IPC call</span><br><span class="hljs-comment">// currently limited to one status code and eight generic return values</span><br><span class="hljs-comment">// which cannot be pointers to other data. For x64 ports this structure</span><br><span class="hljs-comment">// might have to use other integer types.</span><br><span class="hljs-comment">// 封装了IPC调用的输出型参数和返回值</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CrossCallReturn</span> &#123;<br>  <span class="hljs-comment">// the IPC tag. It should match the original IPC tag.</span><br>  <span class="hljs-type">uint32_t</span> tag;	<span class="hljs-comment">// 每种IPC调用独有的tag</span><br>  <span class="hljs-comment">// The result of the IPC operation itself.</span><br>  ResultCode call_outcome;	<span class="hljs-comment">// 保存IPC操作本身的状态码结果</span><br>  <span class="hljs-comment">// the result of the IPC call as executed in the server. The interpretation</span><br>  <span class="hljs-comment">// of this value depends on the specific service.</span><br>  <span class="hljs-comment">// 这个就是server上处理IPC call的结果状态值，具体意义取决于特定的服务</span><br>  <span class="hljs-keyword">union</span> &#123;<br>    NTSTATUS nt_status;<br>    DWORD win32_result;<br>  &#125;;<br>  <span class="hljs-comment">// Number of extended return values.</span><br>  <span class="hljs-type">uint32_t</span> extended_count;	<span class="hljs-comment">// 应该是输出型参数的个数，暂不清楚是否包含返回值</span><br>  <span class="hljs-comment">// for calls that should return a windows handle. It is found here.</span><br>  HANDLE handle;	<span class="hljs-comment">// 如果有需要返回windows句柄的，可以存在这里</span><br>  <span class="hljs-comment">// The array of extended values.</span><br>  <span class="hljs-comment">// extended values数组，每一种都是MultiType这个union</span><br>  MultiType extended[kExtendedReturnCount];<span class="hljs-comment">//kExtendedReturnCount是8</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><code>CrossCallReturn</code>看起来的确封装了输出参数和返回值，在client发起IPC调用时，应该是直接或者间接通过某种结构嵌套传到server，而server在把结果和输出参数填充好，client再读出来。</p>
<h3 id="crosscallparams"><code>CrossCallParams</code></h3>
<p>再看看输入型参数的封装结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CrossCallParams base class that models the input params all packed in a</span><br><span class="hljs-comment">// single compact memory blob. The representation can vary but in general a</span><br><span class="hljs-comment">// given child of this class is meant to represent all input parameters</span><br><span class="hljs-comment">// necessary to make a IPC call.</span><br><span class="hljs-comment">// 把输入型参数紧凑的捏成一团，用于发起IPC调用</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// This class cannot have virtual members because its assumed the IPC</span><br><span class="hljs-comment">// parameters start from the &#x27;this&#x27; pointer to the end, which is defined by</span><br><span class="hljs-comment">// one of the subclasses</span><br><span class="hljs-comment">// 该类无法拥有虚成员函数，因为设计上会假定从this指针起始到结尾（并不是对象内存空间尾）这部分内存空间</span><br><span class="hljs-comment">// 要作为IPC参数的buffer，这由它的子类定义</span><br><span class="hljs-comment">//（含有虚函数的对象会有虚表，虚表在this处即对象头部位置）</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// Objects of this class cannot be constructed directly. Only derived</span><br><span class="hljs-comment">// classes have the proper knowledge to construct it.</span><br><span class="hljs-comment">// 限于这种复杂的使用方式，该类不能简单的直接构造，而是必须通过子类以特殊方式构造。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossCallParams</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Returns the tag (ipc unique id) associated with this IPC.</span><br>  <span class="hljs-comment">// 获取该IPC调用的tag，实际上存储在tag_成员</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetTag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> tag_; &#125;<br><br>  <span class="hljs-comment">// Returns the beggining of the buffer where the IPC params can be stored.</span><br>  <span class="hljs-comment">// prior to an IPC call</span><br>  <span class="hljs-comment">// 这里就看出类头注释的意义了，该对象实体的整个内存空间都是IPC参数存储的buffer</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetBuffer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br><br>  <span class="hljs-comment">// Returns how many parameter this IPC call should have.</span><br>  <span class="hljs-comment">// 返回该IPC call有多少个参数</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetParamsCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> params_count_; &#125;<br><br>  <span class="hljs-comment">// Returns a pointer to the CrossCallReturn structure.</span><br>  <span class="hljs-comment">// 返回CrossCallReturn结构指针，这里可以看出该对象内部封装了一个用于承载返回值和</span><br>  <span class="hljs-comment">// 输出型参数的结构</span><br>  <span class="hljs-function">CrossCallReturn* <span class="hljs-title">GetCallReturn</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;call_return; &#125;<br><br>  <span class="hljs-comment">// Returns true if this call contains InOut parameters.</span><br>  <span class="hljs-comment">// 是否有InOut型即输入输出型参数</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> == is_in_out_); &#125;<br><br>  <span class="hljs-comment">// Tells the CrossCall object if it contains InOut parameters.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetIsInOut</span><span class="hljs-params">(<span class="hljs-type">bool</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (value)<br>      is_in_out_ = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>      is_in_out_ = <span class="hljs-number">0</span>;<br>  &#125;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// constructs the IPC call params. Called only from the derived classes</span><br>  <span class="hljs-comment">// 构造器是protected，表明该对象的实例化需要借助派生类。</span><br>  <span class="hljs-built_in">CrossCallParams</span>(<span class="hljs-type">uint32_t</span> tag, <span class="hljs-type">uint32_t</span> params_count)<br>      : <span class="hljs-built_in">tag_</span>(tag), <span class="hljs-built_in">is_in_out_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">params_count_</span>(params_count) &#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">uint32_t</span> tag_;<br>  <span class="hljs-type">uint32_t</span> is_in_out_;<br>  CrossCallReturn call_return;<br>  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> params_count_;	<br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(CrossCallParams);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>能够嗅到一点设计上熟悉的味道，下一步就是找到它的派生类，看看整个buffer到底是什么，<code>CrossCallParams</code>内存空间后又贴了哪些数据。</p>
<h3 id="actualcallparams"><code>ActualCallParams</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ActualCallParams models an specific IPC call parameters with respect to the</span><br><span class="hljs-comment">// storage allocation that the packed parameters should need.</span><br><span class="hljs-comment">// NUMBER_PARAMS: the number of parameters, valid from 1 to N</span><br><span class="hljs-comment">// BLOCK_SIZE: the total storage that the NUMBER_PARAMS parameters can take,</span><br><span class="hljs-comment">// typically the block size is defined by the channel size of the underlying</span><br><span class="hljs-comment">// ipc mechanism.</span><br><span class="hljs-comment">// In practice this class is used to levergage C++ capacity to properly</span><br><span class="hljs-comment">// calculate sizes and displacements given the possibility of the packed params</span><br><span class="hljs-comment">// blob to be complex.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// As is, this class assumes that the layout of the blob is as follows. Assume</span><br><span class="hljs-comment">// that NUMBER_PARAMS = 2 and a 32-bit build:</span><br><span class="hljs-comment">// 这就是关键之处了，刻画了2个参数情形下的buffer布局</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// [ tag                4 bytes]</span><br><span class="hljs-comment">// [ IsOnOut            4 bytes]	// 这个应该是IsInOut吧。。.</span><br><span class="hljs-comment">// [ call return       52 bytes]</span><br><span class="hljs-comment">// [ params count       4 bytes]	// 上面这些就是父类CrossCallParam的64B内存空间</span><br><span class="hljs-comment">// [ parameter 0 type   4 bytes]	// 三元组就是struct ParamInfo，2表示有3个</span><br><span class="hljs-comment">// [ parameter 0 offset 4 bytes] ---delta to ---\</span><br><span class="hljs-comment">// [ parameter 0 size   4 bytes]                |</span><br><span class="hljs-comment">// [ parameter 1 type   4 bytes]                |</span><br><span class="hljs-comment">// [ parameter 1 offset 4 bytes] ---------------|--\</span><br><span class="hljs-comment">// [ parameter 1 size   4 bytes]                |  |</span><br><span class="hljs-comment">// [ parameter 2 type   4 bytes]                |  |</span><br><span class="hljs-comment">// [ parameter 2 offset 4 bytes] ----------------------\</span><br><span class="hljs-comment">// [ parameter 2 size   4 bytes]                |  |   |</span><br><span class="hljs-comment">// |---------------------------|                |  |   |</span><br><span class="hljs-comment">// | value 0     (x bytes)     | &lt;--------------/  |   |// 这部分对应真实数据</span><br><span class="hljs-comment">// | value 1     (y bytes)     | &lt;-----------------/   |</span><br><span class="hljs-comment">// |                           |                       |</span><br><span class="hljs-comment">// | end of buffer             | &lt;---------------------/// 最后一个offset表示结尾</span><br><span class="hljs-comment">// |---------------------------|</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Note that the actual number of params is NUMBER_PARAMS + 1</span><br><span class="hljs-comment">// so that the size of each actual param can be computed from the difference</span><br><span class="hljs-comment">// between one parameter and the next down. The offset of the last param</span><br><span class="hljs-comment">// points to the end of the buffer and the type and size are undefined.</span><br><span class="hljs-comment">// 描述了最后一个ParamInfo的说明</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 类模板，常数型，用以在定义ActualCallParams&lt;xxx,xxx&gt;类时指定参数个数与buffer尺寸</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">size_t</span> NUMBER_PARAMS, <span class="hljs-type">size_t</span> BLOCK_SIZE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ActualCallParams</span> : <span class="hljs-keyword">public</span> CrossCallParams &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// constructor. Pass the ipc unique tag as input</span><br>  <span class="hljs-comment">// 以传入的tag和模板常量NUMBER_PARAMS调用父类构造器</span><br>  <span class="hljs-comment">// 像这种单基本型参数的构造器都要声明explicit，防止编译器自作聪明的在某些情况把uint32_t自动转化成ActualCallParams&lt;xxx,xxx&gt;对象</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ActualCallParams</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> tag)</span></span><br><span class="hljs-function">      : CrossCallParams(tag, NUMBER_PARAMS) &#123;</span><br>    <span class="hljs-comment">// 第一个ParamInfo的offset是已知的</span><br>    <span class="hljs-comment">// parameters_数组存储真实参数，它的首地址减去param_info_数组地址就是param_info_[0]的offset</span><br>    param_info_[<span class="hljs-number">0</span>].offset_ =<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(parameters_ - <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-keyword">this</span>));<br>  &#125;<br><br>  <span class="hljs-comment">// Testing-only constructor. Allows setting the |number_params| to a</span><br>  <span class="hljs-comment">// wrong value.</span><br>  <span class="hljs-comment">// 测试用的构造器，这里没有用模板常量而是使用了传入的参数个数</span><br>  <span class="hljs-built_in">ActualCallParams</span>(<span class="hljs-type">uint32_t</span> tag, <span class="hljs-type">uint32_t</span> number_params)<br>      : <span class="hljs-built_in">CrossCallParams</span>(tag, number_params) &#123;<br>    param_info_[<span class="hljs-number">0</span>].offset_ =<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(parameters_ - <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-keyword">this</span>));<br>  &#125;<br><br>  <span class="hljs-comment">// Testing-only method. Allows setting the apparent size to a wrong value.</span><br>  <span class="hljs-comment">// returns the previous size.</span><br>  <span class="hljs-comment">// 测试用，修改一个param_info_[someone]的offset</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">OverrideSize</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> new_size)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> previous_size = param_info_[NUMBER_PARAMS].offset_;<br>    param_info_[NUMBER_PARAMS].offset_ = new_size;<br>    <span class="hljs-keyword">return</span> previous_size;<br>  &#125;<br><br>  <span class="hljs-comment">// Copies each paramter into the internal buffer. For each you must supply:</span><br>  <span class="hljs-comment">// index: 0 for the first param, 1 for the next an so on</span><br>  <span class="hljs-comment">// 把参数拷贝到正确的buffer位置，index表示第几个参数</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CopyParamIn</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">const</span> <span class="hljs-type">void</span>* parameter_address,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">uint32_t</span> size,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">bool</span> is_in_out,</span></span><br><span class="hljs-params"><span class="hljs-function">                   ArgType type)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= NUMBER_PARAMS) &#123;	<span class="hljs-comment">// sanity check</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (UINT32_MAX == size) &#123;<br>      <span class="hljs-comment">// Memory error while getting the size.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (size &amp;&amp; !parameter_address) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((size &gt; <span class="hljs-built_in">sizeof</span>(*<span class="hljs-keyword">this</span>)) ||<br>        (param_info_[index].offset_ &gt; (<span class="hljs-built_in">sizeof</span>(*<span class="hljs-keyword">this</span>) - size))) &#123;<br>      <span class="hljs-comment">// It does not fit, abort copy.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>	<span class="hljs-comment">// 安检通过，找到坑位</span><br>    <span class="hljs-type">char</span>* dest = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-keyword">this</span>) + param_info_[index].offset_;<br><br>    <span class="hljs-comment">// We might be touching user memory, this has to be done from inside a try</span><br>    <span class="hljs-comment">// except.</span><br>    <span class="hljs-comment">// copy参数过去</span><br>    __try &#123;<br>      <span class="hljs-built_in">memcpy</span>(dest, parameter_address, size);<br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Set the flag to tell the broker to update the buffer once the call is</span><br>    <span class="hljs-comment">// made.</span><br>    <span class="hljs-comment">// 如果这个参数是输入输出型参数，enable is_in_out_</span><br>    <span class="hljs-keyword">if</span> (is_in_out)<br>      <span class="hljs-built_in">SetIsInOut</span>(<span class="hljs-literal">true</span>);<br><br>	<span class="hljs-comment">// 常规offset计算与type,size填充</span><br>    param_info_[index + <span class="hljs-number">1</span>].offset_ = <span class="hljs-built_in">Align</span>(param_info_[index].offset_ + size);<br>    param_info_[index].size_ = size;<br>    param_info_[index].type_ = type;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns a pointer to a parameter in the memory section.</span><br>  <span class="hljs-comment">// get特定参数，返回的是buffer中真实参数的指针</span><br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">GetParamPtr</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-keyword">this</span>) + param_info_[index].offset_;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns the total size of the buffer. Only valid once all the paramters</span><br>  <span class="hljs-comment">// have been copied in with CopyParamIn.</span><br>  <span class="hljs-comment">// 只有当所有参数都通过CopyParamIn拷贝过来后，这个函数返回的才是正确的值。</span><br>  <span class="hljs-comment">// 所以如果我并不copy NUMBER_PARAMS个参数的话，是否会引入某些漏洞？</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> param_info_[NUMBER_PARAMS].offset_; &#125;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// tag为0的构造，这货是protected，对外隐藏</span><br>  <span class="hljs-built_in">ActualCallParams</span>() : <span class="hljs-built_in">CrossCallParams</span>(<span class="hljs-number">0</span>, NUMBER_PARAMS) &#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  ParamInfo param_info_[NUMBER_PARAMS + <span class="hljs-number">1</span>];<span class="hljs-comment">//这个+1说明最后一个边界块不占用参数个数</span><br>  <span class="hljs-type">char</span> parameters_[BLOCK_SIZE - <span class="hljs-built_in">sizeof</span>(CrossCallParams) -<br>                   <span class="hljs-built_in">sizeof</span>(ParamInfo) * (NUMBER_PARAMS + <span class="hljs-number">1</span>)];<br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(ActualCallParams);	<span class="hljs-comment">//用不到就禁了，以绝后患</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>到此，IPC调用传输所用的IN/OUT参数、返回值是如何被安排在buffer上，已经非常清楚了。下面就是对Client和Server两端驱动者的分析。</p>
<h2 id="client">Client</h2>
<p>老规矩先看看crosscall_client.h头注释的说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This header defines the CrossCall(..) family of templated functions</span><br><span class="hljs-comment">// Their purpose is to simulate the syntax of regular call but to generate</span><br><span class="hljs-comment">// and IPC from the client-side.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The basic pattern is to</span><br><span class="hljs-comment">//   1) use template argument deduction to compute the size of each</span><br><span class="hljs-comment">//      parameter and the appropriate copy method</span><br><span class="hljs-comment">//   2) pack the parameters in the appropriate ActualCallParams&lt; &gt; object</span><br><span class="hljs-comment">//   3) call the IPC interface IPCProvider::DoCall( )</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The general interface of CrossCall is:</span><br><span class="hljs-comment">//  ResultCode CrossCall(IPCProvider&amp; ipc_provider,</span><br><span class="hljs-comment">//                       uint32_t tag,</span><br><span class="hljs-comment">//                       const Par1&amp; p1, const Par2&amp; p2,...pn</span><br><span class="hljs-comment">//                       CrossCallReturn* answer)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  where:</span><br><span class="hljs-comment">//    ipc_provider: is a specific implementation of the ipc transport see</span><br><span class="hljs-comment">//                  sharedmem_ipc_server.h for an example.</span><br><span class="hljs-comment">//    tag : is the unique id for this IPC call. Is used to route the call to</span><br><span class="hljs-comment">//          the appropriate service.</span><br><span class="hljs-comment">//    p1, p2,.. pn : The input parameters of the IPC. Use only simple types</span><br><span class="hljs-comment">//                   and wide strings (can add support for others).</span><br><span class="hljs-comment">//    answer : If the IPC was successful. The server-side answer is here. The</span><br><span class="hljs-comment">//             interpretation of the answer is private to client and server.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The return value is ALL_OK if the IPC was delivered to the server, other</span><br><span class="hljs-comment">// return codes indicate that the IPC transport failed to deliver it.</span><br></code></pre></td></tr></table></figure>
<p>归纳一下大概就是：</p>
<ol type="1">
<li>定义了一套<code>CrossCall</code>函数模板，每一个函数模板都对应不同个数的参数。</li>
<li><code>CrossCall</code>的使用方式:
<ol type="1">
<li>利用模板参数来推断每个参数尺寸的计算以及合适的copy方法</li>
<li>把参数打包到<code>ActualCallParams&lt; &gt;</code>对象</li>
<li>发起IPC调用<code>IPCProvider::DoCall()</code></li>
</ol></li>
</ol>
<h3 id="crosscall"><code>CrossCall</code></h3>
<p>可以说是安排的明明白白，那么我们先看一下<code>CrossCall</code>全家桶。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CrossCall template with one input parameter</span><br><span class="hljs-comment">// 一个参数的CrossCall模板</span><br><span class="hljs-comment">// 模板参数IPCProvider实际上才是IPC机制真正的操纵者，至于它是什么，sandbox用的是哪个Provider，以后再说</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IPCProvider, <span class="hljs-keyword">typename</span> Par1&gt;<br><span class="hljs-function">ResultCode <span class="hljs-title">CrossCall</span><span class="hljs-params">(IPCProvider&amp; ipc_provider,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">uint32_t</span> tag,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par1&amp; p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                     CrossCallReturn* answer)</span> </span>&#123;<br>  <span class="hljs-comment">// 这两个宏有点复杂，一会儿展开</span><br>  <span class="hljs-comment">// 相当于</span><br>  <span class="hljs-comment">// ActualCallParams&lt;1,1024&gt;* call_params = new (ipc_provider.GetBuffer())ActualCallParams&lt;1,1024&gt;(tag);</span><br>  <span class="hljs-comment">// ActualCallParams&lt;&gt;对象是buffer上的抽象，负责具体的参数布局</span><br>  <span class="hljs-comment">// 但buffer内存空间的来源是ipc_provider提供的</span><br>  <span class="hljs-built_in">XCALL_GEN_PARAMS_OBJ</span>(<span class="hljs-number">1</span>, call_params);<br>  <span class="hljs-comment">// 相当于</span><br>  <span class="hljs-comment">// CopyHelper&lt;Par1&gt; ch1(p1); </span><br>  <span class="hljs-comment">// call_params-&gt;CopyParamIn(0,ch1.GetStart(),ch1.GetSize(),ch1.IsInOut(),ch1.GetType())</span><br>  <span class="hljs-comment">// 至于CopyHelper是什么，一会儿再分析，功能上推测是个控制参数拷贝的类模板</span><br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">1</span>, call_params);<br><br>  <span class="hljs-comment">// 实际上还是借用了ipc_provider的DoCall，call_params是个ActualCallParam没问题</span><br>  <span class="hljs-comment">// ActualCallParam已经包含了一个CrossCallReturn，这里又传入了一个CrossCallReturn</span><br>  <span class="hljs-comment">// 是传参的answer，call_params在new的时候并没有对内部的CrossCallReturn做什么</span><br>  <span class="hljs-comment">// 所以answer和call_params中的CrossCallReturn的关系现在还不明朗</span><br>  ResultCode result = ipc_provider.<span class="hljs-built_in">DoCall</span>(call_params, answer);<br><br>  <span class="hljs-keyword">if</span> (SBOX_ERROR_CHANNEL_ERROR != result) &#123;<br>    <span class="hljs-comment">// if(!ch1.Update(call_params-&gt;GetParamPtr(num - 1)))</span><br>    <span class="hljs-comment">// &#123;ipc_provider.FreeBuffer(ipc_provider.GetBuffer());&#125;</span><br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">1</span>, call_params);<br>    <span class="hljs-comment">// ipc_provider.FreeBuffer(ipc_provider.GetBuffer());</span><br>    <span class="hljs-built_in">XCALL_GEN_FREE_CHANNEL</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这几个宏的展开：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> XCALL_GEN_PARAMS_OBJ(num, params)                      \</span><br><span class="hljs-meta">  typedef ActualCallParams<span class="hljs-string">&lt;num, kIPCChannelSize&gt;</span> ActualParams; \</span><br><span class="hljs-meta">  void* raw_mem = ipc_provider.GetBuffer();                    \</span><br><span class="hljs-meta">  <span class="hljs-keyword">if</span> (!raw_mem)                                                \</span><br><span class="hljs-meta">    return SBOX_ERROR_NO_SPACE;                                \</span><br><span class="hljs-meta">  ActualParams* params = new (raw_mem) ActualParams(tag);</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XCALL_GEN_COPY_PARAM(num, params)                                  \</span><br><span class="hljs-meta">  static_assert(kMaxIpcParams &gt;= num, <span class="hljs-string">&quot;too many parameters&quot;</span>);              \</span><br><span class="hljs-meta">  CopyHelper<span class="hljs-string">&lt;Par##num&gt;</span> ch##num(p##num);                                    \</span><br><span class="hljs-meta">  <span class="hljs-keyword">if</span> (!params-&gt;CopyParamIn(num - 1, ch##num.GetStart(), ch##num.GetSize(), \</span><br><span class="hljs-meta">                           ch##num.IsInOut(), ch##num.GetType()))          \</span><br><span class="hljs-meta">    return SBOX_ERROR_NO_SPACE;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XCALL_GEN_UPDATE_PARAM(num, params)            \</span><br><span class="hljs-meta">  <span class="hljs-keyword">if</span> (!ch##num.Update(params-&gt;GetParamPtr(num - 1))) &#123; \</span><br><span class="hljs-meta">    ipc_provider.FreeBuffer(raw_mem);                  \</span><br><span class="hljs-meta">    return SBOX_ERROR_BAD_PARAMS;                      \</span><br><span class="hljs-meta">  &#125;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XCALL_GEN_FREE_CHANNEL() ipc_provider.FreeBuffer(raw_mem);</span><br></code></pre></td></tr></table></figure>
<p>到此，一个参数的<code>CrossCall</code>类模板就清楚了，那么按照<code>static_assert(kMaxIpcParams &gt;= num, "too many parameters");</code>的指示，应该还有2个参数到9个参数的版本。</p>
<p>但观察了一下crosscall_client.h的定义，只发现了2到7个参数的模板，我也不清楚为何定义和最大值常量有出入。</p>
<p>展开看看7个参数的版本吧，实际上只是简单的叠加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CrossCall template with seven input parameters.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IPCProvider,<br>          <span class="hljs-keyword">typename</span> Par1,<br>          <span class="hljs-keyword">typename</span> Par2,<br>          <span class="hljs-keyword">typename</span> Par3,<br>          <span class="hljs-keyword">typename</span> Par4,<br>          <span class="hljs-keyword">typename</span> Par5,<br>          <span class="hljs-keyword">typename</span> Par6,<br>          <span class="hljs-keyword">typename</span> Par7&gt;<br><span class="hljs-function">ResultCode <span class="hljs-title">CrossCall</span><span class="hljs-params">(IPCProvider&amp; ipc_provider,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">uint32_t</span> tag,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par1&amp; p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par2&amp; p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par3&amp; p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par4&amp; p4,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par5&amp; p5,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par6&amp; p6,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> Par7&amp; p7,</span></span><br><span class="hljs-params"><span class="hljs-function">                     CrossCallReturn* answer)</span> </span>&#123;<br>  <span class="hljs-built_in">XCALL_GEN_PARAMS_OBJ</span>(<span class="hljs-number">7</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">1</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">2</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">3</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">4</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">5</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">6</span>, call_params);<br>  <span class="hljs-built_in">XCALL_GEN_COPY_PARAM</span>(<span class="hljs-number">7</span>, call_params);<br><br>  ResultCode result = ipc_provider.<span class="hljs-built_in">DoCall</span>(call_params, answer);<br><br>  <span class="hljs-keyword">if</span> (SBOX_ERROR_CHANNEL_ERROR != result) &#123;<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">1</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">2</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">3</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">4</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">5</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">6</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_UPDATE_PARAM</span>(<span class="hljs-number">7</span>, call_params);<br>    <span class="hljs-built_in">XCALL_GEN_FREE_CHANNEL</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="copyhelper"><code>CopyHelper</code></h3>
<p>一个类模板，用以推断合适的copy函数来把输入参数拷贝到buffer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The copy helper uses templates to deduce the appropriate copy function to</span><br><span class="hljs-comment">// copy the input parameters in the buffer that is going to be send across the</span><br><span class="hljs-comment">// IPC. These template facility can be made more sophisticated as need arises.</span><br><br><span class="hljs-comment">// The default copy helper. It catches the general case where no other</span><br><span class="hljs-comment">// specialized template matches better. We set the type to UINT32_TYPE, so this</span><br><span class="hljs-comment">// only works with objects whose size is 32 bits.</span><br><span class="hljs-comment">// 这个是default模板，除了下面对明确类型的模板类定义以外，其他的都匹配到这里</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyHelper</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CopyHelper</span>(<span class="hljs-type">const</span> T&amp; t) : <span class="hljs-built_in">t_</span>(t) &#123;&#125;<br><br>  <span class="hljs-comment">// Returns the pointer to the start of the input.</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetStart</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;t_; &#125;<br><br>  <span class="hljs-comment">// Update the stored value with the value in the buffer. This is not</span><br>  <span class="hljs-comment">// supported for this type.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span> </span>&#123;<br>    <span class="hljs-comment">// Not supported;</span><br>    <span class="hljs-comment">// 这个显然对未知类型很危险，不能瞎j8赋值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns the size of the input in bytes.</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(T); &#125;<br><br>  <span class="hljs-comment">// Returns true if the current type is used as an In or InOut parameter.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><br>  <span class="hljs-comment">// Returns this object&#x27;s type.</span><br>  <span class="hljs-comment">// 这里的处理强制了UINT32_TYPE</span><br>  <span class="hljs-function">ArgType <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(T) == <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>), <span class="hljs-string">&quot;specialization needed&quot;</span>);<br>    <span class="hljs-keyword">return</span> UINT32_TYPE;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">const</span> T&amp; t_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>再看几个具体的包装（实际上就是对<code>ArgType</code>的每种类型都包装一个），这些才是有实际实用意义的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This copy helper template specialization if for the void pointer</span><br><span class="hljs-comment">// case both 32 and 64 bit.</span><br><span class="hljs-comment">// 这个是T为void*的情景，实际上没做什么实际内容</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyHelper</span>&lt;<span class="hljs-type">void</span>*&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CopyHelper</span>(<span class="hljs-type">void</span>* t) : <span class="hljs-built_in">t_</span>(t) &#123;&#125;<br><br>  <span class="hljs-comment">// Returns the pointer to the start of the input.</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetStart</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;t_; &#125;<br><br>  <span class="hljs-comment">// Update the stored value with the value in the buffer. This is not</span><br>  <span class="hljs-comment">// supported for this type.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span> </span>&#123;<br>    <span class="hljs-comment">// Not supported;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns the size of the input in bytes.</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(t_); &#125;<br><br>  <span class="hljs-comment">// Returns true if the current type is used as an In or InOut parameter.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><br>  <span class="hljs-comment">// Returns this object&#x27;s type.</span><br>  <span class="hljs-function">ArgType <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> VOIDPTR_TYPE; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* t_;<br>&#125;;<br><br><span class="hljs-comment">// This copy helper template specialization catches the cases where the</span><br><span class="hljs-comment">// parameter is a pointer to a string.</span><br><span class="hljs-comment">// 这个是const宽字符指针，实际上是字符串</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyHelper</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CopyHelper</span>(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* t) : <span class="hljs-built_in">t_</span>(t) &#123;&#125;<br><br>  <span class="hljs-comment">// Returns the pointer to the start of the string.</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetStart</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> t_; &#125;<br><br>  <span class="hljs-comment">// Update the stored value with the value in the buffer. This is not</span><br>  <span class="hljs-comment">// supported for this type.</span><br>  <span class="hljs-comment">// 都const了，改个毛线</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span> </span>&#123;<br>    <span class="hljs-comment">// Not supported;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns the size of the string in bytes. We define a nullptr string to</span><br>  <span class="hljs-comment">// be of zero length.</span><br>  <span class="hljs-comment">// 获取尺寸，这里并不是类型的尺寸，而是宽字符串的整体大小</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    __try &#123;<br>      <span class="hljs-keyword">return</span> (!t_) ? <span class="hljs-number">0</span><br>                   : <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(<span class="hljs-built_in">StringLength</span>(t_) * <span class="hljs-built_in">sizeof</span>(t_[<span class="hljs-number">0</span>]));<br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>      <span class="hljs-keyword">return</span> UINT32_MAX;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns true if the current type is used as an In or InOut parameter.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><br>  <span class="hljs-function">ArgType <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> WCHAR_TYPE; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// We provide our not very optimized version of wcslen(), since we don&#x27;t</span><br>  <span class="hljs-comment">// want to risk having the linker use the version in the CRT since the CRT</span><br>  <span class="hljs-comment">// might not be present when we do an early IPC call.</span><br>  <span class="hljs-comment">// 起始就是简单的count，\0结束，包含了\0</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> __cdecl <span class="hljs-title">StringLength</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* wcs)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* eos = wcs;<br>    <span class="hljs-keyword">while</span> (*eos++)<br>      ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(eos - wcs - <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* t_;<br>&#125;;<br><br><span class="hljs-comment">// Specialization for non-const strings. We just reuse the implementation of the</span><br><span class="hljs-comment">// const string specialization.</span><br><span class="hljs-comment">// 这个是non-const字符串</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyHelper</span>&lt;<span class="hljs-type">wchar_t</span>*&gt; : <span class="hljs-keyword">public</span> CopyHelper&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">typedef</span> CopyHelper&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt; Base;<span class="hljs-comment">//定义这货是怕编译器混淆，用了自生成类模板类吗？</span><br>  <span class="hljs-built_in">CopyHelper</span>(<span class="hljs-type">wchar_t</span>* t) : <span class="hljs-built_in">Base</span>(t) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetStart</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">GetStart</span>(); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">Update</span>(buffer); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">GetSize</span>(); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">IsInOut</span>(); &#125;<br><br>  <span class="hljs-function">ArgType <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">GetType</span>(); &#125;<br>&#125;;<br><br><span class="hljs-comment">// Specialization for wchar_t arrays strings. We just reuse the implementation</span><br><span class="hljs-comment">// of the const string specialization.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">size_t</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyHelper</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>[n]&gt; : <span class="hljs-keyword">public</span> CopyHelper&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> array[n];<br>  <span class="hljs-keyword">typedef</span> CopyHelper&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>*&gt; Base;<br>  <span class="hljs-built_in">CopyHelper</span>(array t) : <span class="hljs-built_in">Base</span>(t) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetStart</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">GetStart</span>(); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">Update</span>(buffer); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">GetSize</span>(); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">IsInOut</span>(); &#125;<br><br>  <span class="hljs-function">ArgType <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Base::<span class="hljs-built_in">GetType</span>(); &#125;<br>&#125;;<br><br><span class="hljs-comment">// This copy helper template specialization catches the cases where the</span><br><span class="hljs-comment">// parameter is a an input/output buffer.</span><br><span class="hljs-comment">// 输入输出型参数比较特殊，用InOutCountedBuffer结构，这个结构一会儿再分析</span><br><span class="hljs-comment">// 对应ArgType为INOUTPTR_TYPE</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyHelper</span>&lt;InOutCountedBuffer&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CopyHelper</span>(<span class="hljs-type">const</span> InOutCountedBuffer t) : <span class="hljs-built_in">t_</span>(t) &#123;&#125;<br><br>  <span class="hljs-comment">// Returns the pointer to the start of the string.</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* <span class="hljs-title">GetStart</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> t_.<span class="hljs-built_in">Buffer</span>(); &#125;<br><br>  <span class="hljs-comment">// Updates the buffer with the value from the new buffer in parameter.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer)</span> </span>&#123;<br>    <span class="hljs-comment">// We are touching user memory, this has to be done from inside a try</span><br>    <span class="hljs-comment">// except.</span><br>    __try &#123;<br>      <span class="hljs-built_in">memcpy</span>(t_.<span class="hljs-built_in">Buffer</span>(), buffer, t_.<span class="hljs-built_in">Size</span>());<br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Returns the size of the string in bytes. We define a nullptr string to</span><br>  <span class="hljs-comment">// be of zero length.</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> t_.<span class="hljs-built_in">Size</span>(); &#125;<br><br>  <span class="hljs-comment">// Returns true if the current type is used as an In or InOut parameter.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInOut</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><br>  <span class="hljs-function">ArgType <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> INOUTPTR_TYPE; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">const</span> InOutCountedBuffer t_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>展开<code>InOutCountedBuffer</code>，实际上是一个对指针的包装类，描述了指针和指向buffer的尺寸：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Generic encapsulation class containing a pointer to a buffer and the</span><br><span class="hljs-comment">// size of the buffer. It is used by the IPC to be able to pass in/out</span><br><span class="hljs-comment">// parameters.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InOutCountedBuffer</span> : <span class="hljs-keyword">public</span> CountedBuffer &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">InOutCountedBuffer</span>(<span class="hljs-type">void</span>* buffer, <span class="hljs-type">uint32_t</span> size)<br>      : <span class="hljs-built_in">CountedBuffer</span>(buffer, size) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// Encapsulates a pointer to a buffer and the size of the buffer.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CountedBuffer</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CountedBuffer</span>(<span class="hljs-type">void</span>* buffer, <span class="hljs-type">uint32_t</span> size) : <span class="hljs-built_in">size_</span>(size), <span class="hljs-built_in">buffer_</span>(buffer) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">Size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size_; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">Buffer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> buffer_; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">uint32_t</span> size_;<br>  <span class="hljs-type">void</span>* buffer_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="server">Server</h2>
<p>再看看server的描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This is the IPC server interface for CrossCall: The  IPC for the Sandbox</span><br><span class="hljs-comment">// On the server, CrossCall needs two things:</span><br><span class="hljs-comment">// 1) threads: Or better said, someone to provide them, that is what the</span><br><span class="hljs-comment">//             ThreadProvider interface is defined for. These thread(s) are</span><br><span class="hljs-comment">//             the ones that will actually execute the  IPC data retrieval.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 2) a dispatcher: This interface represents the way to route and process</span><br><span class="hljs-comment">//                  an  IPC call given the  IPC tag.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The other class included here CrossCallParamsEx is the server side version</span><br><span class="hljs-comment">// of the CrossCallParams class of /sandbox/crosscall_params.h The difference</span><br><span class="hljs-comment">// is that the sever version is paranoid about the correctness of the IPC</span><br><span class="hljs-comment">// message and will do all sorts of verifications.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A general diagram of the interaction is as follows:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//                                 ------------</span><br><span class="hljs-comment">//                                 |          |</span><br><span class="hljs-comment">//  ThreadProvider &lt;--(1)Register--|  IPC     |</span><br><span class="hljs-comment">//      |                          | Implemen |</span><br><span class="hljs-comment">//      |                          | -tation  |</span><br><span class="hljs-comment">//     (2)                         |          |  OnMessage</span><br><span class="hljs-comment">//     IPC fired --callback ------&gt;|          |--(3)---&gt; Dispatcher</span><br><span class="hljs-comment">//                                 |          |</span><br><span class="hljs-comment">//                                 ------------</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  The  IPC implementation sits as a middleman between the handling of the</span><br><span class="hljs-comment">//  specifics of scheduling a thread to service the  IPC and the multiple</span><br><span class="hljs-comment">//  entities that can potentially serve each particular IPC.</span><br></code></pre></td></tr></table></figure>
<p>大致梳理一下：</p>
<ol type="1">
<li>IPC的server端需要完成两件事：
<ol type="1">
<li>需要一个provide IPC调用的线程池，provider每次收到IPC
call就assign到一个thread来处理</li>
<li>一个分发器：基于IPC tag来引导、处理每一种IPC call</li>
</ol></li>
<li>图示已经描摹出了整个状态机，看起来Server借助了两个外部组件：”线程池供给者ThreadProvider“+"消息处理器Dispatcher"</li>
</ol>
<p>说白了就是每来一个消息就用一个线程来处理，实现并发性，而消息根据tag在Dispatcher的OnMessage中分门别类，找到它自己的回调处理Handler。</p>
<h3 id="threadprovider">ThreadProvider</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ThreadProvider models a thread factory. The idea is to decouple thread</span><br><span class="hljs-comment">// creation and lifetime from the inner guts of the IPC. The contract is</span><br><span class="hljs-comment">// simple:</span><br><span class="hljs-comment">//   - the IPC implementation calls RegisterWait with a waitable object that</span><br><span class="hljs-comment">//     becomes signaled when an IPC arrives and needs to be serviced.</span><br><span class="hljs-comment">//   - when the waitable object becomes signaled, the thread provider conjures</span><br><span class="hljs-comment">//     a thread that calls the callback (CrossCallIPCCallback) function</span><br><span class="hljs-comment">//   - the callback function tries its best not to block and return quickly</span><br><span class="hljs-comment">//     and should not assume that the next callback will use the same thread</span><br><span class="hljs-comment">//   - when the callback returns the ThreadProvider owns again the thread</span><br><span class="hljs-comment">//     and can destroy it or keep it around.</span><br><span class="hljs-comment">// simple已经描述的很清楚了，IPC实现体会利用RegisterWait来注册一个可等待对象，一旦IPC</span><br><span class="hljs-comment">// 请求到来，那么该对象signaled，ThreadProvider这个线程工厂会生成一个线程来调用CrossCallIPCCallback</span><br><span class="hljs-comment">// CrossCallIPCCallback很快回来，ThreadProvider再次控制该线程，可以销毁也可以保持</span><br><span class="hljs-comment">// 前后两次执行callback的不一定是同一个线程</span><br><span class="hljs-comment">// 那么CrossCallIPCCallback是个什么样的callback呢？实际上是个函数指针类型定义：</span><br><br><span class="hljs-comment">// This function signature is required as the callback when an  IPC call fires.</span><br><span class="hljs-comment">// context: a user-defined pointer that was set using  ThreadProvider</span><br><span class="hljs-comment">// reason: 0 if the callback was fired because of a timeout.</span><br><span class="hljs-comment">//         1 if the callback was fired because of an event.</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(__stdcall* CrossCallIPCCallback)</span><span class="hljs-params">(<span class="hljs-type">void</span>* context,</span></span><br><span class="hljs-params"><span class="hljs-function">                                              <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> reason)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadProvider</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Registers a waitable object with the thread provider.</span><br>  <span class="hljs-comment">// client: A number to associate with all the RegisterWait calls, typically</span><br>  <span class="hljs-comment">//         this is the address of the caller object. This parameter cannot</span><br>  <span class="hljs-comment">//         be zero.</span><br>  <span class="hljs-comment">// waitable_object : a kernel object that can be waited on</span><br>  <span class="hljs-comment">// callback: a function pointer which is the function that will be called</span><br>  <span class="hljs-comment">//           when the waitable object fires</span><br>  <span class="hljs-comment">// context: a user-provider pointer that is passed back to the callback</span><br>  <span class="hljs-comment">//          when its called</span><br>  <span class="hljs-comment">// client作为标志把waitable_object与callback绑定，当waitable_object signaled（IPC arrive），调用callback</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">RegisterWait</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* client,</span></span><br><span class="hljs-params"><span class="hljs-function">                            HANDLE waitable_object,</span></span><br><span class="hljs-params"><span class="hljs-function">                            CrossCallIPCCallback callback,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">void</span>* context)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Removes all the registrations done with the same cookie parameter.</span><br>  <span class="hljs-comment">// This frees internal thread pool resources.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">UnRegisterWaits</span><span class="hljs-params">(<span class="hljs-type">void</span>* cookie)</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ThreadProvider</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>但这只是个抽象基类，实际上windows应该是靠<code>Win2kThreadPool</code>这个内存池类来操作的。而线程池本身是个非常复杂的东西，本身也不属于sandbox的范畴，日后有空的时候再分析一下。</p>
<h3 id="crosscallparamsex"><code>CrossCallParamsEx</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Models the server-side of the original input parameters.</span><br><span class="hljs-comment">// Provides IPC buffer validation and it is capable of reading the parameters</span><br><span class="hljs-comment">// out of the IPC buffer.</span><br><span class="hljs-comment">// CrossCallParams的另一个子类，用在server</span><br><span class="hljs-comment">// 模拟server端原始输入参数的处理，提供了IPC buffer的检查并copy到另一个对象结构</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossCallParamsEx</span> : <span class="hljs-keyword">public</span> CrossCallParams &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Factory constructor. Pass an IPCbuffer (and buffer size) that contains a</span><br>  <span class="hljs-comment">// pending IPCcall. This constructor will:</span><br>  <span class="hljs-comment">// 1) validate the IPC buffer. returns nullptr is the IPCbuffer is malformed.</span><br>  <span class="hljs-comment">// 2) make a copy of the IPCbuffer (parameter capture)</span><br>  <span class="hljs-comment">// 颇为关键的static工厂方法，验证IPC buffer并拷贝参数</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> CrossCallParamsEx* <span class="hljs-title">CreateFromBuffer</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer_base,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">uint32_t</span> buffer_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">uint32_t</span>* output_size)</span></span>;<br><br>  <span class="hljs-comment">// Provides IPCinput parameter raw access:</span><br>  <span class="hljs-comment">// index : the parameter to read; 0 is the first parameter</span><br>  <span class="hljs-comment">// returns nullptr if the parameter is non-existent. If it exists it also</span><br>  <span class="hljs-comment">// returns the size in *size</span><br>  <span class="hljs-comment">// IPCinput参数的各种形态原生访问方法</span><br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">GetRawParameter</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index, <span class="hljs-type">uint32_t</span>* size, ArgType* type)</span></span>;<br><br>  <span class="hljs-comment">// Gets a parameter that is four bytes in size.</span><br>  <span class="hljs-comment">// Returns false if the parameter does not exist or is not 32 bits wide.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetParameter32</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index, <span class="hljs-type">uint32_t</span>* param)</span></span>;<br><br>  <span class="hljs-comment">// Gets a parameter that is void pointer in size.</span><br>  <span class="hljs-comment">// Returns false if the parameter does not exist or is not void pointer sized.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetParameterVoidPtr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index, <span class="hljs-type">void</span>** param)</span></span>;<br><br>  <span class="hljs-comment">// Gets a parameter that is a string. Returns false if the parameter does not</span><br>  <span class="hljs-comment">// exist.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetParameterStr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index, base::string16* string)</span></span>;<br><br>  <span class="hljs-comment">// Gets a parameter that is an in/out buffer. Returns false is the parameter</span><br>  <span class="hljs-comment">// does not exist or if the size of the actual parameter is not equal to the</span><br>  <span class="hljs-comment">// expected size.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetParameterPtr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index, <span class="hljs-type">uint32_t</span> expected_size, <span class="hljs-type">void</span>** pointer)</span></span>;<br><br>  <span class="hljs-comment">// Frees the memory associated with the IPC parameters.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* raw_memory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Only the factory method CreateFromBuffer can construct these objects.</span><br>  <span class="hljs-built_in">CrossCallParamsEx</span>();<span class="hljs-comment">//CrossCallParamsEx对象必须从static工厂方法中make</span><br><br>  ParamInfo param_info_[<span class="hljs-number">1</span>];	<span class="hljs-comment">//ParamInfo是通用的(type,offset,size)三元组，熟悉的味道</span><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_ASSIGN</span>(CrossCallParamsEx);<span class="hljs-comment">//用不到就禁了，防呆</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这个类就是解包client IPC请求的，工厂方法相当关键：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This function uses a SEH try block so cannot use C++ objects that</span><br><span class="hljs-comment">// have destructors or else you get Compiler Error C2712. So no DCHECKs</span><br><span class="hljs-comment">// inside this function.</span><br><span class="hljs-function">CrossCallParamsEx* <span class="hljs-title">CrossCallParamsEx::CreateFromBuffer</span><span class="hljs-params">(<span class="hljs-type">void</span>* buffer_base,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                       <span class="hljs-type">uint32_t</span> buffer_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                       <span class="hljs-type">uint32_t</span>* output_size)</span> </span>&#123;<br>  <span class="hljs-comment">// IMPORTANT: Everything inside buffer_base and derived from it such</span><br>  <span class="hljs-comment">// as param_count and declared_size is untrusted.</span><br>  <span class="hljs-comment">// 心智检查</span><br>  <span class="hljs-keyword">if</span> (!buffer_base)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (buffer_size &lt; <span class="hljs-built_in">sizeof</span>(CrossCallParams))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (buffer_size &gt; kMaxBufferSize)	<span class="hljs-comment">//就是1024，IPC Channel实现体目前的硬编码最大尺寸</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-type">char</span>* backing_mem = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-type">uint32_t</span> param_count = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">uint32_t</span> declared_size;<br>  <span class="hljs-type">uint32_t</span> min_declared_size;<br>  CrossCallParamsEx* copied_params = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-comment">// Touching the untrusted buffer is done under a SEH try block. This</span><br>  <span class="hljs-comment">// will catch memory access violations so we don&#x27;t crash.</span><br>  __try &#123;<br>    CrossCallParams* call_params =<br>        <span class="hljs-built_in">reinterpret_cast</span>&lt;CrossCallParams*&gt;(buffer_base);<br>    <span class="hljs-comment">//传入的应该是client的ActualCallParams，call_params父类指针指向子类对象</span><br><br>    <span class="hljs-comment">// 过安检，CrossCallParams+((param_count + 1) * sizeof(ParamInfo))是除了真实参数数据以外至少需要的空间</span><br>    <span class="hljs-comment">// Check against the minimum size given the number of stated params</span><br>    <span class="hljs-comment">// if too small we bail out.</span><br>    param_count = call_params-&gt;<span class="hljs-built_in">GetParamsCount</span>();<br>    min_declared_size =<br>        <span class="hljs-built_in">sizeof</span>(CrossCallParams) + ((param_count + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(ParamInfo));<br><br>    <span class="hljs-comment">// Initial check for the buffer being big enough to determine the actual</span><br>    <span class="hljs-comment">// buffer size.</span><br>    <span class="hljs-comment">// 如果buffer_size比min_declared_size还小，说明这段数据是有问题的，显然不能继续解析了</span><br>    <span class="hljs-keyword">if</span> (buffer_size &lt; min_declared_size)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// Retrieve the declared size which if it fails returns 0.</span><br>    <span class="hljs-comment">// 不管参数个数有几个，参数总尺寸是可以计算的</span><br>    <span class="hljs-comment">// 参数总尺寸的计算其实就是ParamInfo[]的parser，一会儿展开看</span><br>    declared_size = <span class="hljs-built_in">GetActualBufferSize</span>(param_count, buffer_base);<br><br>    <span class="hljs-comment">// 判断一下buffer_size，buffer_size理应&gt;=declared_size而declared_size理应&gt;=min_declared_size</span><br>    <span class="hljs-comment">// 这个函数很简单</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsSizeWithinRange</span>(buffer_size, min_declared_size, declared_size))<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// 这里就进行解包了，移花接木给copied_params，CrossCallParamsEx对象是在这里new的</span><br>    <span class="hljs-comment">// Now we copy the actual amount of the message.</span><br>    *output_size = declared_size;<br>    backing_mem = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[declared_size];<br>    <span class="hljs-comment">// 依然是这种间接new操作，因为buffer尺寸是已知的，但CrossCallParamsEx并没有包含所有的</span><br>    <span class="hljs-comment">// buffer数据（真实数据由ParamInfo定位，附加在类的正后方），所以要用间接的方式把这段</span><br>    <span class="hljs-comment">// 内存空间看成CrossCallParamsEx + 额外的真实参数数据</span><br>    copied_params = <span class="hljs-built_in">reinterpret_cast</span>&lt;CrossCallParamsEx*&gt;(backing_mem);<br>    <span class="hljs-comment">// 这个memcpy实际上非常讲究，把ActualCallParams + 额外真实参数数据直接copy到了另外</span><br>    <span class="hljs-comment">// 一个对象CrossCallParamsEx+额外真实参数数据</span><br>    <span class="hljs-comment">// 这意味着CrossCallParamsEx和ActualCallParams有着相同的内存布局，事实上也确实如此</span><br>    <span class="hljs-comment">// 都是CrossCallParams基类+ParamInfo[] flexible数据的结构</span><br>    <span class="hljs-comment">// 在server和client各封装这样一个成员变量布局相同的类，主要是因为布局理应相同，但</span><br>    <span class="hljs-comment">// 要用到的接口函数是互逆的</span><br>    <span class="hljs-built_in">memcpy</span>(backing_mem, call_params, declared_size);<br><br>    <span class="hljs-comment">// Avoid compiler optimizations across this point. Any value stored in</span><br>    <span class="hljs-comment">// memory should be stored for real, and values previously read from memory</span><br>    <span class="hljs-comment">// should be actually read.</span><br>    <span class="hljs-comment">// 内存屏障，防止此处的编译优化，所有内存的值必须用存储的真实值，此前从memory中读出的高速缓存不能在寄存器中直接复用</span><br>    base::subtle::<span class="hljs-built_in">MemoryBarrier</span>();<br><br>    <span class="hljs-comment">// 内存屏障是为这一句准备的我懂，但我不明白为啥要重算</span><br>    <span class="hljs-comment">// 有大神了解的话还请解惑</span><br>    min_declared_size =<br>        <span class="hljs-built_in">sizeof</span>(CrossCallParams) + ((param_count + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(ParamInfo));<br><br>    <span class="hljs-comment">// Check that the copied buffer is still valid.</span><br>    <span class="hljs-comment">// 可以看出server对input param的检查近乎严苛</span><br>    <span class="hljs-comment">// 还要检查copy过去后buffer是否符合预期</span><br>    <span class="hljs-keyword">if</span> (copied_params-&gt;<span class="hljs-built_in">GetParamsCount</span>() != param_count ||<br>        <span class="hljs-built_in">GetActualBufferSize</span>(param_count, backing_mem) != declared_size ||<br>        !<span class="hljs-built_in">IsSizeWithinRange</span>(buffer_size, min_declared_size, declared_size)) &#123;<br>      <span class="hljs-keyword">delete</span>[] backing_mem;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>  &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>    <span class="hljs-comment">// In case of a windows exception we know it occurred while touching the</span><br>    <span class="hljs-comment">// untrusted buffer so we bail out as is.</span><br>    <span class="hljs-keyword">delete</span>[] backing_mem;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125; <span class="hljs-comment">// 内存的访问很可能因畸形或恶意构造IPCInput出现access violations，这里套上了try块，windows对应SEH</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* last_byte = &amp;backing_mem[declared_size];<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* first_byte = &amp;backing_mem[min_declared_size];<br><br>  <span class="hljs-comment">// last_byte和first_byte之间就是真实参数数据区间了</span><br>  <span class="hljs-comment">// Verify here that all and each parameters make sense. This is done in the</span><br>  <span class="hljs-comment">// local copy.</span><br>  <span class="hljs-comment">// 检查每个parameter都有意义，可以说是相当的严格</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> ix = <span class="hljs-number">0</span>; ix != param_count; ++ix) &#123;<br>    <span class="hljs-type">uint32_t</span> size = <span class="hljs-number">0</span>;<br>    ArgType type;<br>    <span class="hljs-type">char</span>* address = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<br>        <span class="hljs-comment">//一会儿展开看这货</span><br>        copied_params-&gt;<span class="hljs-built_in">GetRawParameter</span>(ix, &amp;size, &amp;type));<br>    <span class="hljs-keyword">if</span> ((!address) ||                                     <span class="hljs-comment">// No null params.</span><br>        (INVALID_TYPE &gt;= type) || (LAST_TYPE &lt;= type) ||  <span class="hljs-comment">// Unknown type.</span><br>        (address &lt; backing_mem) ||         <span class="hljs-comment">// Start cannot point before buffer.</span><br>        (address &lt; first_byte) ||          <span class="hljs-comment">// Start cannot point too low.</span><br>        (address &gt; last_byte) ||           <span class="hljs-comment">// Start cannot point past buffer.</span><br>        ((address + size) &lt; address) ||    <span class="hljs-comment">// Invalid size.</span><br>        ((address + size) &gt; last_byte)) &#123;  <span class="hljs-comment">// End cannot point past buffer.</span><br>      <span class="hljs-comment">// Malformed.</span><br>      <span class="hljs-keyword">delete</span>[] backing_mem;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// The parameter buffer looks good.</span><br>  <span class="hljs-keyword">return</span> copied_params;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>工厂只是做了移花接木的操作。</p>
<p>看看几个关键的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Returns the actual size for the parameters in an IPC buffer. Returns</span><br><span class="hljs-comment">// zero if the |param_count| is zero or too big.</span><br><span class="hljs-comment">// 又见呆逼操作，不定参数个数的匹配处理在这里完成，不管是几个参数，返回的就是参数总尺寸</span><br><span class="hljs-comment">// 这里又变成1-9个了，怕是client端少写了两个，然后一直用不到？</span><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetActualBufferSize</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> param_count, <span class="hljs-type">void</span>* buffer_base)</span> </span>&#123;<br>  <span class="hljs-comment">// The template types are used to calculate the maximum expected size.</span><br>  <span class="hljs-comment">// kMaxBufferSize是硬编码的sandbox::kIPCChannelSize，也就是1024</span><br>  <span class="hljs-comment">// 把9种模板类都做一下typedef</span><br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">1</span>, kMaxBufferSize&gt; ActualCP1;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">2</span>, kMaxBufferSize&gt; ActualCP2;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">3</span>, kMaxBufferSize&gt; ActualCP3;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">4</span>, kMaxBufferSize&gt; ActualCP4;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">5</span>, kMaxBufferSize&gt; ActualCP5;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">6</span>, kMaxBufferSize&gt; ActualCP6;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">7</span>, kMaxBufferSize&gt; ActualCP7;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">8</span>, kMaxBufferSize&gt; ActualCP8;<br>  <span class="hljs-keyword">typedef</span> ActualCallParams&lt;<span class="hljs-number">9</span>, kMaxBufferSize&gt; ActualCP9;<br><br>  <span class="hljs-comment">// Retrieve the actual size and the maximum size of the params buffer.</span><br>  <span class="hljs-comment">// 根据参数个数，可以判断出是哪一个模板类</span><br>  <span class="hljs-keyword">switch</span> (param_count) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP1*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP2*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP3*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP4*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP5*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP6*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP7*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP8*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;ActualCP9*&gt;(buffer_base)-&gt;<span class="hljs-built_in">GetSize</span>();<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>GetSize</code>实际上就是client端<code>ActualCallParams&lt;&gt;</code>的接口，我们再次看一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> param_info_[NUMBER_PARAMS].offset_; &#125;<br><span class="hljs-comment">// 所以想要计算尺寸，只需要获取最后一个ParamInfo的offset即可，这个就是最后一个end struct</span><br></code></pre></td></tr></table></figure>
<p>再看简单的值范围检查：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Verifies that the declared sizes of an IPC buffer are within range.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsSizeWithinRange</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> buffer_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">uint32_t</span> min_declared_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">uint32_t</span> declared_size)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> ((buffer_size &lt; min_declared_size) ||<br>      (<span class="hljs-built_in">sizeof</span>(CrossCallParamsEx) &gt; min_declared_size)) &#123;<br>    <span class="hljs-comment">// Minimal computed size bigger than existing buffer or param_count</span><br>    <span class="hljs-comment">// integer overflow.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ((declared_size &gt; buffer_size) || (declared_size &lt; min_declared_size)) &#123;<br>    <span class="hljs-comment">// Declared size is bigger than buffer or smaller than computed size</span><br>    <span class="hljs-comment">// or param_count is equal to 0 or bigger than 9.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后一个关键的<code>GetRawParameter</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Accessors to the parameters in the raw buffer.</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">CrossCallParamsEx::GetRawParameter</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> index,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         <span class="hljs-type">uint32_t</span>* size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         ArgType* type)</span> </span>&#123;<br>  <span class="hljs-comment">// 不能越界</span><br>  <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-built_in">GetParamsCount</span>())<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// The size is always computed from the parameter minus the next</span><br>  <span class="hljs-comment">// parameter, this works because the message has an extra parameter slot</span><br>  <span class="hljs-comment">// 拿到该参数的尺寸和类型</span><br>  *size = param_info_[index].size_;<br>  *type = param_info_[index].type_;<br><br>  <span class="hljs-comment">// 返回该参数的真实数据所在的位置</span><br>  <span class="hljs-keyword">return</span> param_info_[index].offset_ + <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>也是非常简单的函数。</p>
<h3 id="diapatcher"><code>Diapatcher</code></h3>
<p><code>CrossCallParamsEx</code>不过是个承载buffer的容器，真正的驱动者另有其人。在crosscall_server.h中可以找到<code>Dispatcher</code>类，根据头的注释可以知道它时IPC消息的操纵者。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Models an entity that can process an IPC message or it can route to another</span><br><span class="hljs-comment">// one that could handle it. When an IPC arrives the IPC implementation will:</span><br><span class="hljs-comment">// 1) call OnMessageReady() with the tag of the pending IPC. If the dispatcher</span><br><span class="hljs-comment">//    returns nullptr it means that it cannot handle this IPC but if it returns</span><br><span class="hljs-comment">//    non-null, it must be the pointer to a dispatcher that can handle it.</span><br><span class="hljs-comment">// 2) When the  IPC finally obtains a valid Dispatcher the IPC</span><br><span class="hljs-comment">//    implementation creates a CrossCallParamsEx from the raw IPC buffer.</span><br><span class="hljs-comment">// 3) It calls the returned callback, with the IPC info and arguments.</span><br><span class="hljs-comment">// 所以IPC请求给到IPC实现体时，会先使用tag调用Dispatcher::OnMessageReady()。</span><br><span class="hljs-comment">// Dispatcher维护了一组callback，如果该IPC与其中某一个匹配的话，就表示该Dispatcher</span><br><span class="hljs-comment">// 可以处理该IPC调用</span><br><span class="hljs-comment">// 找到以后，IPC实现体会创建一个CrossCallParamsEx，从buffer拷贝数据</span><br><span class="hljs-comment">// 然后，以IPC info和args调用对应的callback</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dispatcher</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Called from the  IPC implementation to handle a specific IPC message.</span><br>  <span class="hljs-comment">// 又是这种笨拙的函数指针定义，根据参数个数的多少，定义callback多种形态</span><br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*CallbackGeneric)</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback0)</span><span class="hljs-params">(IPCInfo* ipc)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback1)</span><span class="hljs-params">(IPCInfo* ipc, <span class="hljs-type">void</span>* p1)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback2)</span><span class="hljs-params">(IPCInfo* ipc, <span class="hljs-type">void</span>* p1, <span class="hljs-type">void</span>* p2)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback3)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback4)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p4)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback5)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p4,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p5)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback6)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p4,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p5,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p6)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback7)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p4,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p5,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p6,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p7)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback8)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p4,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p5,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p6,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p7,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p8)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(Dispatcher::*Callback9)</span><span class="hljs-params">(IPCInfo* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p1,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p2,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p3,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p4,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p5,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p6,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p7,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p8,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">void</span>* p9)</span></span>;<br><br>  <span class="hljs-comment">// Called from the  IPC implementation when an  IPC message is ready override</span><br>  <span class="hljs-comment">// on a derived class to handle a set of  IPC messages. Return nullptr if your</span><br>  <span class="hljs-comment">// subclass does not handle the message or return the pointer to the subclass</span><br>  <span class="hljs-comment">// that can handle it.</span><br>  <span class="hljs-comment">// IPC消息到来时，IPC实现体先调用这个MessageReady事件响应，看看是否有能力handle</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> Dispatcher* <span class="hljs-title">OnMessageReady</span><span class="hljs-params">(IPCParams* ipc, CallbackGeneric* callback)</span></span>;<br><br>  <span class="hljs-comment">// Called when a target proces is created, to setup the interceptions related</span><br>  <span class="hljs-comment">// with the given service (IPC).</span><br>  <span class="hljs-comment">// 当target进程创建时，部署与给定服务（IPC）相关的interceptions</span><br>  <span class="hljs-comment">// 这个暂时不关心，涉及到它的上层组件Interception机制</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">SetupService</span><span class="hljs-params">(InterceptionManager* manager, <span class="hljs-type">int</span> service)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-built_in">Dispatcher</span>();<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Dispatcher</span>();<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// Structure that defines an IPC Call with all the parameters and the handler.</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IPCCall</span> &#123;<br>    IPCParams params;<br>    CallbackGeneric callback;<br>  &#125;;<br><br>  <span class="hljs-comment">// List of IPC Calls supported by the class.</span><br>  <span class="hljs-comment">// 一个Dispatcher所支持的IPC调用列表，这个结构在内部定义使用</span><br>  <span class="hljs-comment">// 封装了IPCParams和CallbackGeneric</span><br>  std::vector&lt;IPCCall&gt; ipc_calls_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>看看这几个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Represents the client process that initiated the IPC which boils down to the</span><br><span class="hljs-comment">// process handle and the job object handle that contains the client process.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ClientInfo</span> &#123;<br>  HANDLE process;<br>  DWORD process_id;<br>&#125;;<br><br><span class="hljs-comment">// All IPC-related information to be passed to the IPC handler.</span><br><span class="hljs-comment">// 一组callback的第一个参数，分组了tag，进程相关信息以及一个CrossCallReturn</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IPCInfo</span> &#123;<br>  <span class="hljs-type">int</span> ipc_tag;<br>  <span class="hljs-type">const</span> ClientInfo* client_info;<br>  CrossCallReturn return_info;<br>&#125;;<br><br><span class="hljs-comment">// This structure identifies IPC signatures.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IPCParams</span> &#123;<br>  <span class="hljs-type">int</span> ipc_tag;<br>  ArgType args[kMaxIpcParams];<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Matches</span><span class="hljs-params">(IPCParams* other)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">memcmp</span>(<span class="hljs-keyword">this</span>, other, <span class="hljs-built_in">sizeof</span>(*other));<span class="hljs-comment">//这个IPCParams的对比有点粗暴</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>看一下<code>OnMessageReady</code>的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Dispatcher* <span class="hljs-title">Dispatcher::OnMessageReady</span><span class="hljs-params">(IPCParams* ipc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       CallbackGeneric* callback)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(callback);<br>  std::vector&lt;IPCCall&gt;::iterator it = ipc_calls_.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">for</span> (; it != ipc_calls_.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    <span class="hljs-comment">//IPCCall的第一个成员是IPCParams，所以可以直接调用IPCParams的Matches</span><br>    <span class="hljs-keyword">if</span> (it-&gt;params.<span class="hljs-built_in">Matches</span>(ipc)) &#123;<br>      *callback = it-&gt;callback;	<span class="hljs-comment">//如果可以处理该ipc，就填充callback，这种callback是个CallbackGeneric类型</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很明显，<code>Dispatcher</code>也只是个基类。<code>ipc_calls_</code>应该是派生的子类中某个setup方法中填充的，而父类的构造和析构都是空函数。除此之外，基类定义的不过是一组typedef，原材料都已准备好了，但依然找不到使用者。</p>
<p>显然<code>Dispatcher</code>也不过是架在<code>CrossCallParamsEx</code>之上的adapter。那么<code>Dispatcher</code>又是由谁来操纵呢？我们下回继续求索。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="category-chain-item">源码剖析</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/chromium/" class="print-no-link">#chromium</a>
      
        <a href="/tags/chromium-sandbox/" class="print-no-link">#chromium-sandbox</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Chromium-sandbox-crosscall-analysis</div>
      <div>https://r00tk1ts.github.io/2018/05/19/chromium-sandbox-Crosscall-analysis/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>r00tk1t</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2018年5月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/05/20/chromium-sandbox-SharedMemIPC/" title="Chromium-sandbox-SharedMemIPC-analysis">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Chromium-sandbox-SharedMemIPC-analysis</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/05/19/chromium-sandbox-AlternateDesktop-analysis/" title="Chromium-sandbox-AlternateDesktop-analysis">
                        <span class="hidden-mobile">Chromium-sandbox-AlternateDesktop-analysis</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/diy/yinghua.js"></script>
<script src="/js/diy/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
